(() => {
  var __webpack_modules__ = {
    8520: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const net = __nccwpck_require__(1808);
      const tls = __nccwpck_require__(4404);
      const { once } = __nccwpck_require__(2361);
      const timers = __nccwpck_require__(8670);
      const { normalizeOptions, cacheOptions } = __nccwpck_require__(1709);
      const { getProxy, getProxyAgent, proxyCache } = __nccwpck_require__(8443);
      const Errors = __nccwpck_require__(4724);
      const { Agent: AgentBase } = __nccwpck_require__(694);
      module.exports = class Agent extends AgentBase {
        #options;
        #timeouts;
        #proxy;
        #noProxy;
        #ProxyAgent;
        constructor(options = {}) {
          const { timeouts, proxy, noProxy, ...normalizedOptions } =
            normalizeOptions(options);
          super(normalizedOptions);
          this.#options = normalizedOptions;
          this.#timeouts = timeouts;
          if (proxy) {
            this.#proxy = new URL(proxy);
            this.#noProxy = noProxy;
            this.#ProxyAgent = getProxyAgent(proxy);
          }
        }
        get proxy() {
          return this.#proxy ? { url: this.#proxy } : {};
        }
        #getProxy(options) {
          if (!this.#proxy) {
            return;
          }
          const proxy = getProxy(
            `${options.protocol}//${options.host}:${options.port}`,
            { proxy: this.#proxy, noProxy: this.#noProxy },
          );
          if (!proxy) {
            return;
          }
          const cacheKey = cacheOptions({
            ...options,
            ...this.#options,
            timeouts: this.#timeouts,
            proxy,
          });
          if (proxyCache.has(cacheKey)) {
            return proxyCache.get(cacheKey);
          }
          let ProxyAgent = this.#ProxyAgent;
          if (Array.isArray(ProxyAgent)) {
            ProxyAgent = this.isSecureEndpoint(options)
              ? ProxyAgent[1]
              : ProxyAgent[0];
          }
          const proxyAgent = new ProxyAgent(proxy, {
            ...this.#options,
            socketOptions: { family: this.#options.family },
          });
          proxyCache.set(cacheKey, proxyAgent);
          return proxyAgent;
        }
        async #timeoutConnection(
          { promises, options, timeout },
          ac = new AbortController(),
        ) {
          if (timeout) {
            const connectionTimeout = timers
              .setTimeout(timeout, null, { signal: ac.signal })
              .then(() => {
                throw new Errors.ConnectionTimeoutError(
                  `${options.host}:${options.port}`,
                );
              })
              .catch((err) => {
                if (err.name === "AbortError") {
                  return;
                }
                throw err;
              });
            promises.push(connectionTimeout);
          }
          let result;
          try {
            result = await Promise.race(promises);
            ac.abort();
          } catch (err) {
            ac.abort();
            throw err;
          }
          return result;
        }
        async connect(request, options) {
          options.lookup ??= this.#options.lookup;
          let socket;
          let timeout = this.#timeouts.connection;
          const isSecureEndpoint = this.isSecureEndpoint(options);
          const proxy = this.#getProxy(options);
          if (proxy) {
            const start = Date.now();
            socket = await this.#timeoutConnection({
              options,
              timeout,
              promises: [proxy.connect(request, options)],
            });
            if (timeout) {
              timeout = timeout - (Date.now() - start);
            }
          } else {
            socket = (isSecureEndpoint ? tls : net).connect(options);
          }
          socket.setKeepAlive(this.keepAlive, this.keepAliveMsecs);
          socket.setNoDelay(this.keepAlive);
          const abortController = new AbortController();
          const { signal } = abortController;
          const connectPromise = socket[
            isSecureEndpoint ? "secureConnecting" : "connecting"
          ]
            ? once(socket, isSecureEndpoint ? "secureConnect" : "connect", {
                signal,
              })
            : Promise.resolve();
          await this.#timeoutConnection(
            {
              options,
              timeout,
              promises: [
                connectPromise,
                once(socket, "error", { signal }).then((err) => {
                  throw err[0];
                }),
              ],
            },
            abortController,
          );
          if (this.#timeouts.idle) {
            socket.setTimeout(this.#timeouts.idle, () => {
              socket.destroy(
                new Errors.IdleTimeoutError(`${options.host}:${options.port}`),
              );
            });
          }
          return socket;
        }
        addRequest(request, options) {
          const proxy = this.#getProxy(options);
          if (proxy?.setRequestProps) {
            proxy.setRequestProps(request, options);
          }
          request.setHeader(
            "connection",
            this.keepAlive ? "keep-alive" : "close",
          );
          if (this.#timeouts.response) {
            let responseTimeout;
            request.once("finish", () => {
              setTimeout(() => {
                request.destroy(
                  new Errors.ResponseTimeoutError(request, this.#proxy),
                );
              }, this.#timeouts.response);
            });
            request.once("response", () => {
              clearTimeout(responseTimeout);
            });
          }
          if (this.#timeouts.transfer) {
            let transferTimeout;
            request.once("response", (res) => {
              setTimeout(() => {
                res.destroy(
                  new Errors.TransferTimeoutError(request, this.#proxy),
                );
              }, this.#timeouts.transfer);
              res.once("close", () => {
                clearTimeout(transferTimeout);
              });
            });
          }
          return super.addRequest(request, options);
        }
      };
    },
    2292: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { LRUCache } = __nccwpck_require__(3866);
      const dns = __nccwpck_require__(7578);
      const cache = new LRUCache({ max: 50 });
      const getOptions = ({
        family = 0,
        hints = dns.ADDRCONFIG,
        all = false,
        verbatim = undefined,
        ttl = 5 * 60 * 1e3,
        lookup = dns.lookup,
      }) => ({
        hints,
        lookup: (hostname, ...args) => {
          const callback = args.pop();
          const lookupOptions = args[0] ?? {};
          const options = {
            family,
            hints,
            all,
            verbatim,
            ...(typeof lookupOptions === "number"
              ? { family: lookupOptions }
              : lookupOptions),
          };
          const key = JSON.stringify({ hostname, ...options });
          if (cache.has(key)) {
            const cached = cache.get(key);
            return process.nextTick(callback, null, ...cached);
          }
          lookup(hostname, options, (err, ...result) => {
            if (err) {
              return callback(err);
            }
            cache.set(key, result, { ttl });
            return callback(null, ...result);
          });
        },
      });
      module.exports = { cache, getOptions };
    },
    4724: (module) => {
      "use strict";
      class InvalidProxyProtocolError extends Error {
        constructor(url) {
          super(
            `Invalid protocol \`${url.protocol}\` connecting to proxy \`${url.host}\``,
          );
          this.code = "EINVALIDPROXY";
          this.proxy = url;
        }
      }
      class ConnectionTimeoutError extends Error {
        constructor(host) {
          super(`Timeout connecting to host \`${host}\``);
          this.code = "ECONNECTIONTIMEOUT";
          this.host = host;
        }
      }
      class IdleTimeoutError extends Error {
        constructor(host) {
          super(`Idle timeout reached for host \`${host}\``);
          this.code = "EIDLETIMEOUT";
          this.host = host;
        }
      }
      class ResponseTimeoutError extends Error {
        constructor(request, proxy) {
          let msg = "Response timeout ";
          if (proxy) {
            msg += `from proxy \`${proxy.host}\` `;
          }
          msg += `connecting to host \`${request.host}\``;
          super(msg);
          this.code = "ERESPONSETIMEOUT";
          this.proxy = proxy;
          this.request = request;
        }
      }
      class TransferTimeoutError extends Error {
        constructor(request, proxy) {
          let msg = "Transfer timeout ";
          if (proxy) {
            msg += `from proxy \`${proxy.host}\` `;
          }
          msg += `for \`${request.host}\``;
          super(msg);
          this.code = "ETRANSFERTIMEOUT";
          this.proxy = proxy;
          this.request = request;
        }
      }
      module.exports = {
        InvalidProxyProtocolError,
        ConnectionTimeoutError,
        IdleTimeoutError,
        ResponseTimeoutError,
        TransferTimeoutError,
      };
    },
    9907: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { LRUCache } = __nccwpck_require__(3866);
      const { normalizeOptions, cacheOptions } = __nccwpck_require__(1709);
      const { getProxy, proxyCache } = __nccwpck_require__(8443);
      const dns = __nccwpck_require__(2292);
      const Agent = __nccwpck_require__(8520);
      const agentCache = new LRUCache({ max: 20 });
      const getAgent = (url, { agent, proxy, noProxy, ...options } = {}) => {
        if (agent != null) {
          return agent;
        }
        url = new URL(url);
        const proxyForUrl = getProxy(url, { proxy, noProxy });
        const normalizedOptions = {
          ...normalizeOptions(options),
          proxy: proxyForUrl,
        };
        const cacheKey = cacheOptions({
          ...normalizedOptions,
          secureEndpoint: url.protocol === "https:",
        });
        if (agentCache.has(cacheKey)) {
          return agentCache.get(cacheKey);
        }
        const newAgent = new Agent(normalizedOptions);
        agentCache.set(cacheKey, newAgent);
        return newAgent;
      };
      module.exports = {
        getAgent,
        Agent,
        HttpAgent: Agent,
        HttpsAgent: Agent,
        cache: {
          proxy: proxyCache,
          agent: agentCache,
          dns: dns.cache,
          clear: () => {
            proxyCache.clear();
            agentCache.clear();
            dns.cache.clear();
          },
        },
      };
    },
    1709: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const dns = __nccwpck_require__(2292);
      const normalizeOptions = (opts) => {
        const family = parseInt(opts.family ?? "0", 10);
        const keepAlive = opts.keepAlive ?? true;
        const normalized = {
          keepAliveMsecs: keepAlive ? 1e3 : undefined,
          maxSockets: opts.maxSockets ?? 15,
          maxTotalSockets: Infinity,
          maxFreeSockets: keepAlive ? 256 : undefined,
          scheduling: "fifo",
          ...opts,
          family,
          keepAlive,
          timeouts: {
            idle: opts.timeout ?? 0,
            connection: 0,
            response: 0,
            transfer: 0,
            ...opts.timeouts,
          },
          ...dns.getOptions({ family, ...opts.dns }),
        };
        delete normalized.timeout;
        return normalized;
      };
      const createKey = (obj) => {
        let key = "";
        const sorted = Object.entries(obj).sort((a, b) => a[0] - b[0]);
        for (let [k, v] of sorted) {
          if (v == null) {
            v = "null";
          } else if (v instanceof URL) {
            v = v.toString();
          } else if (typeof v === "object") {
            v = createKey(v);
          }
          key += `${k}:${v}:`;
        }
        return key;
      };
      const cacheOptions = ({ secureEndpoint, ...options }) =>
        createKey({
          secureEndpoint: !!secureEndpoint,
          family: options.family,
          hints: options.hints,
          localAddress: options.localAddress,
          strictSsl: secureEndpoint ? !!options.rejectUnauthorized : false,
          ca: secureEndpoint ? options.ca : null,
          cert: secureEndpoint ? options.cert : null,
          key: secureEndpoint ? options.key : null,
          keepAlive: options.keepAlive,
          keepAliveMsecs: options.keepAliveMsecs,
          maxSockets: options.maxSockets,
          maxTotalSockets: options.maxTotalSockets,
          maxFreeSockets: options.maxFreeSockets,
          scheduling: options.scheduling,
          timeouts: options.timeouts,
          proxy: options.proxy,
        });
      module.exports = { normalizeOptions, cacheOptions };
    },
    8443: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { HttpProxyAgent } = __nccwpck_require__(3764);
      const { HttpsProxyAgent } = __nccwpck_require__(7219);
      const { SocksProxyAgent } = __nccwpck_require__(5038);
      const { LRUCache } = __nccwpck_require__(3866);
      const { InvalidProxyProtocolError } = __nccwpck_require__(4724);
      const PROXY_CACHE = new LRUCache({ max: 20 });
      const SOCKS_PROTOCOLS = new Set(SocksProxyAgent.protocols);
      const PROXY_ENV_KEYS = new Set([
        "https_proxy",
        "http_proxy",
        "proxy",
        "no_proxy",
      ]);
      const PROXY_ENV = Object.entries(process.env).reduce(
        (acc, [key, value]) => {
          key = key.toLowerCase();
          if (PROXY_ENV_KEYS.has(key)) {
            acc[key] = value;
          }
          return acc;
        },
        {},
      );
      const getProxyAgent = (url) => {
        url = new URL(url);
        const protocol = url.protocol.slice(0, -1);
        if (SOCKS_PROTOCOLS.has(protocol)) {
          return SocksProxyAgent;
        }
        if (protocol === "https" || protocol === "http") {
          return [HttpProxyAgent, HttpsProxyAgent];
        }
        throw new InvalidProxyProtocolError(url);
      };
      const isNoProxy = (url, noProxy) => {
        if (typeof noProxy === "string") {
          noProxy = noProxy
            .split(",")
            .map((p) => p.trim())
            .filter(Boolean);
        }
        if (!noProxy || !noProxy.length) {
          return false;
        }
        const hostSegments = url.hostname.split(".").reverse();
        return noProxy.some((no) => {
          const noSegments = no.split(".").filter(Boolean).reverse();
          if (!noSegments.length) {
            return false;
          }
          for (let i = 0; i < noSegments.length; i++) {
            if (hostSegments[i] !== noSegments[i]) {
              return false;
            }
          }
          return true;
        });
      };
      const getProxy = (url, { proxy, noProxy }) => {
        url = new URL(url);
        if (!proxy) {
          proxy =
            url.protocol === "https:"
              ? PROXY_ENV.https_proxy
              : PROXY_ENV.https_proxy ||
                PROXY_ENV.http_proxy ||
                PROXY_ENV.proxy;
        }
        if (!noProxy) {
          noProxy = PROXY_ENV.no_proxy;
        }
        if (!proxy || isNoProxy(url, noProxy)) {
          return null;
        }
        return new URL(proxy);
      };
      module.exports = { getProxyAgent, getProxy, proxyCache: PROXY_CACHE };
    },
    8217: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const matchers = __nccwpck_require__(5131);
      const { redactUrlPassword } = __nccwpck_require__(766);
      const REPLACE = "***";
      const redact = (value) => {
        if (typeof value !== "string" || !value) {
          return value;
        }
        return redactUrlPassword(value, REPLACE)
          .replace(matchers.NPM_SECRET.pattern, `npm_${REPLACE}`)
          .replace(matchers.UUID.pattern, REPLACE);
      };
      const splitAndRedact = (str) => {
        const splitChars = /[\s=]/g;
        let match = null;
        let result = "";
        let index = 0;
        while ((match = splitChars.exec(str))) {
          result += redact(str.slice(index, match.index)) + match[0];
          index = splitChars.lastIndex;
        }
        return result + redact(str.slice(index));
      };
      const redactLog = (arg) => {
        if (typeof arg === "string") {
          return splitAndRedact(arg);
        } else if (Array.isArray(arg)) {
          return arg.map((a) =>
            typeof a === "string" ? splitAndRedact(a) : a,
          );
        }
        return arg;
      };
      module.exports = { redact, redactLog };
    },
    5131: (module) => {
      const TYPE_REGEX = "regex";
      const TYPE_URL = "url";
      const TYPE_PATH = "path";
      const NPM_SECRET = {
        type: TYPE_REGEX,
        pattern: /\b(npms?_)[a-zA-Z0-9]{36,48}\b/gi,
        replacement: `[REDACTED_NPM_SECRET]`,
      };
      const AUTH_HEADER = {
        type: TYPE_REGEX,
        pattern: /\b(Basic\s+|Bearer\s+)[\w+=\-.]+\b/gi,
        replacement: `[REDACTED_AUTH_HEADER]`,
      };
      const JSON_WEB_TOKEN = {
        type: TYPE_REGEX,
        pattern:
          /\b[A-Za-z0-9-_]{10,}(?!\.\d+\.)\.[A-Za-z0-9-_]{3,}\.[A-Za-z0-9-_]{20,}\b/gi,
        replacement: `[REDACTED_JSON_WEB_TOKEN]`,
      };
      const UUID = {
        type: TYPE_REGEX,
        pattern:
          /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi,
        replacement: `[REDACTED_UUID]`,
      };
      const URL_MATCHER = {
        type: TYPE_REGEX,
        pattern: /(?:https?|ftp):\/\/[^\s/"$.?#].[^\s"]*/gi,
        replacement: "[REDACTED_URL]",
      };
      const DEEP_HEADER_AUTHORIZATION = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".headers.authorization"),
        replacement: "[REDACTED_HEADER_AUTHORIZATION]",
      };
      const DEEP_HEADER_SET_COOKIE = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".headers.set-cookie"),
        replacement: "[REDACTED_HEADER_SET_COOKIE]",
      };
      const REWRITE_REQUEST = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".request"),
        replacement: (input) => ({
          method: input?.method,
          path: input?.path,
          headers: input?.headers,
          url: input?.url,
        }),
      };
      const REWRITE_RESPONSE = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".response"),
        replacement: (input) => ({
          data: input?.data,
          status: input?.status,
          headers: input?.headers,
        }),
      };
      module.exports = {
        TYPE_REGEX,
        TYPE_URL,
        TYPE_PATH,
        NPM_SECRET,
        AUTH_HEADER,
        JSON_WEB_TOKEN,
        UUID,
        URL_MATCHER,
        DEEP_HEADER_AUTHORIZATION,
        DEEP_HEADER_SET_COOKIE,
        REWRITE_REQUEST,
        REWRITE_RESPONSE,
      };
    },
    766: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { URL_MATCHER, TYPE_URL, TYPE_REGEX, TYPE_PATH } =
        __nccwpck_require__(5131);
      const asterisk = (length = 0) => {
        length = typeof length === "string" ? length.length : length;
        if (length < 8) {
          return "*".repeat(8);
        }
        return "*".repeat(length);
      };
      const escapeRegExp = (text) =>
        text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, `\\$&`);
      const urlEncodeRegexGroup = (value) => {
        const decoded = decodeURIComponent(value);
        const encoded = encodeURIComponent(value);
        const union = [...new Set([encoded, decoded, value])]
          .map(escapeRegExp)
          .join("|");
        return union;
      };
      const urlEncodeRegexTag = (strings, ...values) => {
        let pattern = "";
        for (let i = 0; i < values.length; i++) {
          pattern += strings[i] + `(${urlEncodeRegexGroup(values[i])})`;
        }
        pattern += strings[strings.length - 1];
        return new RegExp(pattern);
      };
      const redactUrlHostnameMatcher = ({ hostname, replacement } = {}) => ({
        type: TYPE_URL,
        predicate: ({ url }) => url.hostname === hostname,
        pattern: ({ url }) =>
          urlEncodeRegexTag`(^${url.protocol}//${url.username}:.+@)?${url.hostname}`,
        replacement: `$1${replacement || asterisk()}`,
      });
      const redactUrlSearchParamsMatcher = ({ param, replacement } = {}) => ({
        type: TYPE_URL,
        predicate: ({ url }) => url.searchParams.has(param),
        pattern: ({ url }) =>
          urlEncodeRegexTag`(${param}=)${url.searchParams.get(param)}`,
        replacement: `$1${replacement || asterisk()}`,
      });
      const redactUrlPasswordMatcher = ({ replacement } = {}) => ({
        type: TYPE_URL,
        predicate: ({ url }) => url.password,
        pattern: ({ url }) =>
          urlEncodeRegexTag`(^${url.protocol}//${url.username}:)${url.password}`,
        replacement: `$1${replacement || asterisk()}`,
      });
      const redactUrlReplacement =
        (...matchers) =>
        (subValue) => {
          try {
            const url = new URL(subValue);
            return redactMatchers(...matchers)(subValue, { url });
          } catch (err) {
            return subValue;
          }
        };
      const redactUrlMatcher = (...matchers) => ({
        ...URL_MATCHER,
        replacement: redactUrlReplacement(...matchers),
      });
      const matcherFunctions = {
        [TYPE_REGEX]: (matcher) => (value) => {
          if (typeof value === "string") {
            value = value.replace(matcher.pattern, matcher.replacement);
          }
          return value;
        },
        [TYPE_URL]: (matcher) => (value, ctx) => {
          if (typeof value === "string") {
            try {
              const url = ctx?.url || new URL(value);
              const { predicate, pattern } = matcher;
              const predicateValue = predicate({ url });
              if (predicateValue) {
                value = value.replace(pattern({ url }), matcher.replacement);
              }
            } catch (_e) {
              return value;
            }
          }
          return value;
        },
        [TYPE_PATH]: (matcher) => (value, ctx) => {
          const rawPath = ctx?.path;
          const path = rawPath.join(".").toLowerCase();
          const { predicate, replacement } = matcher;
          const replace =
            typeof replacement === "function" ? replacement : () => replacement;
          const shouldRun = predicate({ rawPath, path });
          if (shouldRun) {
            value = replace(value, { rawPath, path });
          }
          return value;
        },
      };
      const redactMatcher = (matcher) =>
        matcherFunctions[matcher.type](matcher);
      const redactMatchers =
        (...matchers) =>
        (value, ctx) => {
          const flatMatchers = matchers.flat();
          return flatMatchers.reduce((result, matcher) => {
            const fn =
              typeof matcher === "function" ? matcher : redactMatcher(matcher);
            return fn(result, ctx);
          }, value);
        };
      const redactDynamicReplacement = () => (value, start) => {
        if (typeof start === "number") {
          return asterisk(value);
        }
        return start + asterisk(value.substring(start.length).length);
      };
      const redactFixedReplacement = (length) => (_value, start) => {
        if (typeof start === "number") {
          return asterisk(length);
        }
        return start + asterisk(length);
      };
      const redactUrlPassword = (value, replacement) =>
        redactMatchers(redactUrlPasswordMatcher({ replacement }))(value);
      module.exports = {
        asterisk,
        escapeRegExp,
        urlEncodeRegexGroup,
        urlEncodeRegexTag,
        redactUrlHostnameMatcher,
        redactUrlSearchParamsMatcher,
        redactUrlPasswordMatcher,
        redactUrlMatcher,
        redactUrlReplacement,
        redactDynamicReplacement,
        redactFixedReplacement,
        redactMatchers,
        redactUrlPassword,
      };
    },
    6833: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toDSSEBundle = exports.toMessageSignatureBundle = void 0;
      const protobuf_specs_1 = __nccwpck_require__(530);
      const bundle_1 = __nccwpck_require__(2712);
      function toMessageSignatureBundle(options) {
        return {
          mediaType: options.singleCertificate
            ? bundle_1.BUNDLE_V03_MEDIA_TYPE
            : bundle_1.BUNDLE_V02_MEDIA_TYPE,
          content: {
            $case: "messageSignature",
            messageSignature: {
              messageDigest: {
                algorithm: protobuf_specs_1.HashAlgorithm.SHA2_256,
                digest: options.digest,
              },
              signature: options.signature,
            },
          },
          verificationMaterial: toVerificationMaterial(options),
        };
      }
      exports.toMessageSignatureBundle = toMessageSignatureBundle;
      function toDSSEBundle(options) {
        return {
          mediaType: options.singleCertificate
            ? bundle_1.BUNDLE_V03_MEDIA_TYPE
            : bundle_1.BUNDLE_V02_MEDIA_TYPE,
          content: { $case: "dsseEnvelope", dsseEnvelope: toEnvelope(options) },
          verificationMaterial: toVerificationMaterial(options),
        };
      }
      exports.toDSSEBundle = toDSSEBundle;
      function toEnvelope(options) {
        return {
          payloadType: options.artifactType,
          payload: options.artifact,
          signatures: [toSignature(options)],
        };
      }
      function toSignature(options) {
        return { keyid: options.keyHint || "", sig: options.signature };
      }
      function toVerificationMaterial(options) {
        return {
          content: toKeyContent(options),
          tlogEntries: [],
          timestampVerificationData: { rfc3161Timestamps: [] },
        };
      }
      function toKeyContent(options) {
        if (options.certificate) {
          if (options.singleCertificate) {
            return {
              $case: "certificate",
              certificate: { rawBytes: options.certificate },
            };
          } else {
            return {
              $case: "x509CertificateChain",
              x509CertificateChain: {
                certificates: [{ rawBytes: options.certificate }],
              },
            };
          }
        } else {
          return {
            $case: "publicKey",
            publicKey: { hint: options.keyHint || "" },
          };
        }
      }
    },
    2712: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBundleWithDsseEnvelope =
        exports.isBundleWithMessageSignature =
        exports.isBundleWithPublicKey =
        exports.isBundleWithCertificateChain =
        exports.BUNDLE_V03_MEDIA_TYPE =
        exports.BUNDLE_V03_LEGACY_MEDIA_TYPE =
        exports.BUNDLE_V02_MEDIA_TYPE =
        exports.BUNDLE_V01_MEDIA_TYPE =
          void 0;
      exports.BUNDLE_V01_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle+json;version=0.1";
      exports.BUNDLE_V02_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle+json;version=0.2";
      exports.BUNDLE_V03_LEGACY_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle+json;version=0.3";
      exports.BUNDLE_V03_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle.v0.3+json";
      function isBundleWithCertificateChain(b) {
        return b.verificationMaterial.content.$case === "x509CertificateChain";
      }
      exports.isBundleWithCertificateChain = isBundleWithCertificateChain;
      function isBundleWithPublicKey(b) {
        return b.verificationMaterial.content.$case === "publicKey";
      }
      exports.isBundleWithPublicKey = isBundleWithPublicKey;
      function isBundleWithMessageSignature(b) {
        return b.content.$case === "messageSignature";
      }
      exports.isBundleWithMessageSignature = isBundleWithMessageSignature;
      function isBundleWithDsseEnvelope(b) {
        return b.content.$case === "dsseEnvelope";
      }
      exports.isBundleWithDsseEnvelope = isBundleWithDsseEnvelope;
    },
    3802: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValidationError = void 0;
      class ValidationError extends Error {
        constructor(message, fields) {
          super(message);
          this.fields = fields;
        }
      }
      exports.ValidationError = ValidationError;
    },
    9715: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBundleV01 =
        exports.assertBundleV02 =
        exports.assertBundleV01 =
        exports.assertBundleLatest =
        exports.assertBundle =
        exports.envelopeToJSON =
        exports.envelopeFromJSON =
        exports.bundleToJSON =
        exports.bundleFromJSON =
        exports.ValidationError =
        exports.isBundleWithPublicKey =
        exports.isBundleWithMessageSignature =
        exports.isBundleWithDsseEnvelope =
        exports.isBundleWithCertificateChain =
        exports.BUNDLE_V03_MEDIA_TYPE =
        exports.BUNDLE_V03_LEGACY_MEDIA_TYPE =
        exports.BUNDLE_V02_MEDIA_TYPE =
        exports.BUNDLE_V01_MEDIA_TYPE =
        exports.toMessageSignatureBundle =
        exports.toDSSEBundle =
          void 0;
      var build_1 = __nccwpck_require__(6833);
      Object.defineProperty(exports, "toDSSEBundle", {
        enumerable: true,
        get: function () {
          return build_1.toDSSEBundle;
        },
      });
      Object.defineProperty(exports, "toMessageSignatureBundle", {
        enumerable: true,
        get: function () {
          return build_1.toMessageSignatureBundle;
        },
      });
      var bundle_1 = __nccwpck_require__(2712);
      Object.defineProperty(exports, "BUNDLE_V01_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V01_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "BUNDLE_V02_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V02_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "BUNDLE_V03_LEGACY_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V03_LEGACY_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "BUNDLE_V03_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V03_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "isBundleWithCertificateChain", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithCertificateChain;
        },
      });
      Object.defineProperty(exports, "isBundleWithDsseEnvelope", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithDsseEnvelope;
        },
      });
      Object.defineProperty(exports, "isBundleWithMessageSignature", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithMessageSignature;
        },
      });
      Object.defineProperty(exports, "isBundleWithPublicKey", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithPublicKey;
        },
      });
      var error_1 = __nccwpck_require__(3802);
      Object.defineProperty(exports, "ValidationError", {
        enumerable: true,
        get: function () {
          return error_1.ValidationError;
        },
      });
      var serialized_1 = __nccwpck_require__(9875);
      Object.defineProperty(exports, "bundleFromJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.bundleFromJSON;
        },
      });
      Object.defineProperty(exports, "bundleToJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.bundleToJSON;
        },
      });
      Object.defineProperty(exports, "envelopeFromJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.envelopeFromJSON;
        },
      });
      Object.defineProperty(exports, "envelopeToJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.envelopeToJSON;
        },
      });
      var validate_1 = __nccwpck_require__(9599);
      Object.defineProperty(exports, "assertBundle", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundle;
        },
      });
      Object.defineProperty(exports, "assertBundleLatest", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundleLatest;
        },
      });
      Object.defineProperty(exports, "assertBundleV01", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundleV01;
        },
      });
      Object.defineProperty(exports, "assertBundleV02", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundleV02;
        },
      });
      Object.defineProperty(exports, "isBundleV01", {
        enumerable: true,
        get: function () {
          return validate_1.isBundleV01;
        },
      });
    },
    9875: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.envelopeToJSON =
        exports.envelopeFromJSON =
        exports.bundleToJSON =
        exports.bundleFromJSON =
          void 0;
      const protobuf_specs_1 = __nccwpck_require__(530);
      const bundle_1 = __nccwpck_require__(2712);
      const validate_1 = __nccwpck_require__(9599);
      const bundleFromJSON = (obj) => {
        const bundle = protobuf_specs_1.Bundle.fromJSON(obj);
        switch (bundle.mediaType) {
          case bundle_1.BUNDLE_V01_MEDIA_TYPE:
            (0, validate_1.assertBundleV01)(bundle);
            break;
          case bundle_1.BUNDLE_V02_MEDIA_TYPE:
            (0, validate_1.assertBundleV02)(bundle);
            break;
          default:
            (0, validate_1.assertBundleLatest)(bundle);
            break;
        }
        return bundle;
      };
      exports.bundleFromJSON = bundleFromJSON;
      const bundleToJSON = (bundle) => protobuf_specs_1.Bundle.toJSON(bundle);
      exports.bundleToJSON = bundleToJSON;
      const envelopeFromJSON = (obj) => protobuf_specs_1.Envelope.fromJSON(obj);
      exports.envelopeFromJSON = envelopeFromJSON;
      const envelopeToJSON = (envelope) =>
        protobuf_specs_1.Envelope.toJSON(envelope);
      exports.envelopeToJSON = envelopeToJSON;
    },
    9599: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assertBundleLatest =
        exports.assertBundleV02 =
        exports.isBundleV01 =
        exports.assertBundleV01 =
        exports.assertBundle =
          void 0;
      const error_1 = __nccwpck_require__(3802);
      function assertBundle(b) {
        const invalidValues = validateBundleBase(b);
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError("invalid bundle", invalidValues);
        }
      }
      exports.assertBundle = assertBundle;
      function assertBundleV01(b) {
        const invalidValues = [];
        invalidValues.push(...validateBundleBase(b));
        invalidValues.push(...validateInclusionPromise(b));
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError(
            "invalid v0.1 bundle",
            invalidValues,
          );
        }
      }
      exports.assertBundleV01 = assertBundleV01;
      function isBundleV01(b) {
        try {
          assertBundleV01(b);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isBundleV01 = isBundleV01;
      function assertBundleV02(b) {
        const invalidValues = [];
        invalidValues.push(...validateBundleBase(b));
        invalidValues.push(...validateInclusionProof(b));
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError(
            "invalid v0.2 bundle",
            invalidValues,
          );
        }
      }
      exports.assertBundleV02 = assertBundleV02;
      function assertBundleLatest(b) {
        const invalidValues = [];
        invalidValues.push(...validateBundleBase(b));
        invalidValues.push(...validateInclusionProof(b));
        invalidValues.push(...validateNoCertificateChain(b));
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError("invalid bundle", invalidValues);
        }
      }
      exports.assertBundleLatest = assertBundleLatest;
      function validateBundleBase(b) {
        const invalidValues = [];
        if (
          b.mediaType === undefined ||
          (!b.mediaType.match(
            /^application\/vnd\.dev\.sigstore\.bundle\+json;version=\d\.\d/,
          ) &&
            !b.mediaType.match(
              /^application\/vnd\.dev\.sigstore\.bundle\.v\d\.\d\+json/,
            ))
        ) {
          invalidValues.push("mediaType");
        }
        if (b.content === undefined) {
          invalidValues.push("content");
        } else {
          switch (b.content.$case) {
            case "messageSignature":
              if (b.content.messageSignature.messageDigest === undefined) {
                invalidValues.push("content.messageSignature.messageDigest");
              } else {
                if (
                  b.content.messageSignature.messageDigest.digest.length === 0
                ) {
                  invalidValues.push(
                    "content.messageSignature.messageDigest.digest",
                  );
                }
              }
              if (b.content.messageSignature.signature.length === 0) {
                invalidValues.push("content.messageSignature.signature");
              }
              break;
            case "dsseEnvelope":
              if (b.content.dsseEnvelope.payload.length === 0) {
                invalidValues.push("content.dsseEnvelope.payload");
              }
              if (b.content.dsseEnvelope.signatures.length !== 1) {
                invalidValues.push("content.dsseEnvelope.signatures");
              } else {
                if (b.content.dsseEnvelope.signatures[0].sig.length === 0) {
                  invalidValues.push("content.dsseEnvelope.signatures[0].sig");
                }
              }
              break;
          }
        }
        if (b.verificationMaterial === undefined) {
          invalidValues.push("verificationMaterial");
        } else {
          if (b.verificationMaterial.content === undefined) {
            invalidValues.push("verificationMaterial.content");
          } else {
            switch (b.verificationMaterial.content.$case) {
              case "x509CertificateChain":
                if (
                  b.verificationMaterial.content.x509CertificateChain
                    .certificates.length === 0
                ) {
                  invalidValues.push(
                    "verificationMaterial.content.x509CertificateChain.certificates",
                  );
                }
                b.verificationMaterial.content.x509CertificateChain.certificates.forEach(
                  (cert, i) => {
                    if (cert.rawBytes.length === 0) {
                      invalidValues.push(
                        `verificationMaterial.content.x509CertificateChain.certificates[${i}].rawBytes`,
                      );
                    }
                  },
                );
                break;
              case "certificate":
                if (
                  b.verificationMaterial.content.certificate.rawBytes.length ===
                  0
                ) {
                  invalidValues.push(
                    "verificationMaterial.content.certificate.rawBytes",
                  );
                }
                break;
            }
          }
          if (b.verificationMaterial.tlogEntries === undefined) {
            invalidValues.push("verificationMaterial.tlogEntries");
          } else {
            if (b.verificationMaterial.tlogEntries.length > 0) {
              b.verificationMaterial.tlogEntries.forEach((entry, i) => {
                if (entry.logId === undefined) {
                  invalidValues.push(
                    `verificationMaterial.tlogEntries[${i}].logId`,
                  );
                }
                if (entry.kindVersion === undefined) {
                  invalidValues.push(
                    `verificationMaterial.tlogEntries[${i}].kindVersion`,
                  );
                }
              });
            }
          }
        }
        return invalidValues;
      }
      function validateInclusionPromise(b) {
        const invalidValues = [];
        if (
          b.verificationMaterial &&
          b.verificationMaterial.tlogEntries?.length > 0
        ) {
          b.verificationMaterial.tlogEntries.forEach((entry, i) => {
            if (entry.inclusionPromise === undefined) {
              invalidValues.push(
                `verificationMaterial.tlogEntries[${i}].inclusionPromise`,
              );
            }
          });
        }
        return invalidValues;
      }
      function validateInclusionProof(b) {
        const invalidValues = [];
        if (
          b.verificationMaterial &&
          b.verificationMaterial.tlogEntries?.length > 0
        ) {
          b.verificationMaterial.tlogEntries.forEach((entry, i) => {
            if (entry.inclusionProof === undefined) {
              invalidValues.push(
                `verificationMaterial.tlogEntries[${i}].inclusionProof`,
              );
            } else {
              if (entry.inclusionProof.checkpoint === undefined) {
                invalidValues.push(
                  `verificationMaterial.tlogEntries[${i}].inclusionProof.checkpoint`,
                );
              }
            }
          });
        }
        return invalidValues;
      }
      function validateNoCertificateChain(b) {
        const invalidValues = [];
        if (b.verificationMaterial?.content?.$case === "x509CertificateChain") {
          invalidValues.push("verificationMaterial.content.$case");
        }
        return invalidValues;
      }
    },
    6136: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1TypeError = exports.ASN1ParseError = void 0;
      class ASN1ParseError extends Error {}
      exports.ASN1ParseError = ASN1ParseError;
      class ASN1TypeError extends Error {}
      exports.ASN1TypeError = ASN1TypeError;
    },
    4095: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1Obj = void 0;
      var obj_1 = __nccwpck_require__(2988);
      Object.defineProperty(exports, "ASN1Obj", {
        enumerable: true,
        get: function () {
          return obj_1.ASN1Obj;
        },
      });
    },
    5088: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeLength = exports.decodeLength = void 0;
      const error_1 = __nccwpck_require__(6136);
      function decodeLength(stream) {
        const buf = stream.getUint8();
        if ((buf & 128) === 0) {
          return buf;
        }
        const byteCount = buf & 127;
        if (byteCount > 6) {
          throw new error_1.ASN1ParseError("length exceeds 6 byte limit");
        }
        let len = 0;
        for (let i = 0; i < byteCount; i++) {
          len = len * 256 + stream.getUint8();
        }
        if (len === 0) {
          throw new error_1.ASN1ParseError(
            "indefinite length encoding not supported",
          );
        }
        return len;
      }
      exports.decodeLength = decodeLength;
      function encodeLength(len) {
        if (len < 128) {
          return Buffer.from([len]);
        }
        let val = BigInt(len);
        const bytes = [];
        while (val > 0n) {
          bytes.unshift(Number(val & 255n));
          val = val >> 8n;
        }
        return Buffer.from([128 | bytes.length, ...bytes]);
      }
      exports.encodeLength = encodeLength;
    },
    2988: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1Obj = void 0;
      const stream_1 = __nccwpck_require__(2283);
      const error_1 = __nccwpck_require__(6136);
      const length_1 = __nccwpck_require__(5088);
      const parse_1 = __nccwpck_require__(3947);
      const tag_1 = __nccwpck_require__(3725);
      class ASN1Obj {
        constructor(tag, value, subs) {
          this.tag = tag;
          this.value = value;
          this.subs = subs;
        }
        static parseBuffer(buf) {
          return parseStream(new stream_1.ByteStream(buf));
        }
        toDER() {
          const valueStream = new stream_1.ByteStream();
          if (this.subs.length > 0) {
            for (const sub of this.subs) {
              valueStream.appendView(sub.toDER());
            }
          } else {
            valueStream.appendView(this.value);
          }
          const value = valueStream.buffer;
          const obj = new stream_1.ByteStream();
          obj.appendChar(this.tag.toDER());
          obj.appendView((0, length_1.encodeLength)(value.length));
          obj.appendView(value);
          return obj.buffer;
        }
        toBoolean() {
          if (!this.tag.isBoolean()) {
            throw new error_1.ASN1TypeError("not a boolean");
          }
          return (0, parse_1.parseBoolean)(this.value);
        }
        toInteger() {
          if (!this.tag.isInteger()) {
            throw new error_1.ASN1TypeError("not an integer");
          }
          return (0, parse_1.parseInteger)(this.value);
        }
        toOID() {
          if (!this.tag.isOID()) {
            throw new error_1.ASN1TypeError("not an OID");
          }
          return (0, parse_1.parseOID)(this.value);
        }
        toDate() {
          switch (true) {
            case this.tag.isUTCTime():
              return (0, parse_1.parseTime)(this.value, true);
            case this.tag.isGeneralizedTime():
              return (0, parse_1.parseTime)(this.value, false);
            default:
              throw new error_1.ASN1TypeError("not a date");
          }
        }
        toBitString() {
          if (!this.tag.isBitString()) {
            throw new error_1.ASN1TypeError("not a bit string");
          }
          return (0, parse_1.parseBitString)(this.value);
        }
      }
      exports.ASN1Obj = ASN1Obj;
      function parseStream(stream) {
        const tag = new tag_1.ASN1Tag(stream.getUint8());
        const len = (0, length_1.decodeLength)(stream);
        const value = stream.slice(stream.position, len);
        const start = stream.position;
        let subs = [];
        if (tag.constructed) {
          subs = collectSubs(stream, len);
        } else if (tag.isOctetString()) {
          try {
            subs = collectSubs(stream, len);
          } catch (e) {}
        }
        if (subs.length === 0) {
          stream.seek(start + len);
        }
        return new ASN1Obj(tag, value, subs);
      }
      function collectSubs(stream, len) {
        const end = stream.position + len;
        if (end > stream.length) {
          throw new error_1.ASN1ParseError("invalid length");
        }
        const subs = [];
        while (stream.position < end) {
          subs.push(parseStream(stream));
        }
        if (stream.position !== end) {
          throw new error_1.ASN1ParseError("invalid length");
        }
        return subs;
      }
    },
    3947: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseBitString =
        exports.parseBoolean =
        exports.parseOID =
        exports.parseTime =
        exports.parseStringASCII =
        exports.parseInteger =
          void 0;
      const RE_TIME_SHORT_YEAR =
        /^(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d{3})?Z$/;
      const RE_TIME_LONG_YEAR =
        /^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d{3})?Z$/;
      function parseInteger(buf) {
        let pos = 0;
        const end = buf.length;
        let val = buf[pos];
        const neg = val > 127;
        const pad = neg ? 255 : 0;
        while (val == pad && ++pos < end) {
          val = buf[pos];
        }
        const len = end - pos;
        if (len === 0) return BigInt(neg ? -1 : 0);
        val = neg ? val - 256 : val;
        let n = BigInt(val);
        for (let i = pos + 1; i < end; ++i) {
          n = n * BigInt(256) + BigInt(buf[i]);
        }
        return n;
      }
      exports.parseInteger = parseInteger;
      function parseStringASCII(buf) {
        return buf.toString("ascii");
      }
      exports.parseStringASCII = parseStringASCII;
      function parseTime(buf, shortYear) {
        const timeStr = parseStringASCII(buf);
        const m = shortYear
          ? RE_TIME_SHORT_YEAR.exec(timeStr)
          : RE_TIME_LONG_YEAR.exec(timeStr);
        if (!m) {
          throw new Error("invalid time");
        }
        if (shortYear) {
          let year = Number(m[1]);
          year += year >= 50 ? 1900 : 2e3;
          m[1] = year.toString();
        }
        return new Date(`${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}Z`);
      }
      exports.parseTime = parseTime;
      function parseOID(buf) {
        let pos = 0;
        const end = buf.length;
        let n = buf[pos++];
        const first = Math.floor(n / 40);
        const second = n % 40;
        let oid = `${first}.${second}`;
        let val = 0;
        for (; pos < end; ++pos) {
          n = buf[pos];
          val = (val << 7) + (n & 127);
          if ((n & 128) === 0) {
            oid += `.${val}`;
            val = 0;
          }
        }
        return oid;
      }
      exports.parseOID = parseOID;
      function parseBoolean(buf) {
        return buf[0] !== 0;
      }
      exports.parseBoolean = parseBoolean;
      function parseBitString(buf) {
        const unused = buf[0];
        const start = 1;
        const end = buf.length;
        const bits = [];
        for (let i = start; i < end; ++i) {
          const byte = buf[i];
          const skip = i === end - 1 ? unused : 0;
          for (let j = 7; j >= skip; --j) {
            bits.push((byte >> j) & 1);
          }
        }
        return bits;
      }
      exports.parseBitString = parseBitString;
    },
    3725: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1Tag = void 0;
      const error_1 = __nccwpck_require__(6136);
      const UNIVERSAL_TAG = {
        BOOLEAN: 1,
        INTEGER: 2,
        BIT_STRING: 3,
        OCTET_STRING: 4,
        OBJECT_IDENTIFIER: 6,
        SEQUENCE: 16,
        SET: 17,
        PRINTABLE_STRING: 19,
        UTC_TIME: 23,
        GENERALIZED_TIME: 24,
      };
      const TAG_CLASS = {
        UNIVERSAL: 0,
        APPLICATION: 1,
        CONTEXT_SPECIFIC: 2,
        PRIVATE: 3,
      };
      class ASN1Tag {
        constructor(enc) {
          this.number = enc & 31;
          this.constructed = (enc & 32) === 32;
          this.class = enc >> 6;
          if (this.number === 31) {
            throw new error_1.ASN1ParseError("long form tags not supported");
          }
          if (this.class === TAG_CLASS.UNIVERSAL && this.number === 0) {
            throw new error_1.ASN1ParseError("unsupported tag 0x00");
          }
        }
        isUniversal() {
          return this.class === TAG_CLASS.UNIVERSAL;
        }
        isContextSpecific(num) {
          const res = this.class === TAG_CLASS.CONTEXT_SPECIFIC;
          return num !== undefined ? res && this.number === num : res;
        }
        isBoolean() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.BOOLEAN;
        }
        isInteger() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.INTEGER;
        }
        isBitString() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.BIT_STRING;
        }
        isOctetString() {
          return (
            this.isUniversal() && this.number === UNIVERSAL_TAG.OCTET_STRING
          );
        }
        isOID() {
          return (
            this.isUniversal() &&
            this.number === UNIVERSAL_TAG.OBJECT_IDENTIFIER
          );
        }
        isUTCTime() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.UTC_TIME;
        }
        isGeneralizedTime() {
          return (
            this.isUniversal() && this.number === UNIVERSAL_TAG.GENERALIZED_TIME
          );
        }
        toDER() {
          return this.number | (this.constructed ? 32 : 0) | (this.class << 6);
        }
      }
      exports.ASN1Tag = ASN1Tag;
    },
    3914: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferEqual =
        exports.verify =
        exports.hash =
        exports.digest =
        exports.createPublicKey =
          void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const SHA256_ALGORITHM = "sha256";
      function createPublicKey(key, type = "spki") {
        if (typeof key === "string") {
          return crypto_1.default.createPublicKey(key);
        } else {
          return crypto_1.default.createPublicKey({ key, format: "der", type });
        }
      }
      exports.createPublicKey = createPublicKey;
      function digest(algorithm, ...data) {
        const hash = crypto_1.default.createHash(algorithm);
        for (const d of data) {
          hash.update(d);
        }
        return hash.digest();
      }
      exports.digest = digest;
      function hash(...data) {
        const hash = crypto_1.default.createHash(SHA256_ALGORITHM);
        for (const d of data) {
          hash.update(d);
        }
        return hash.digest();
      }
      exports.hash = hash;
      function verify(data, key, signature, algorithm) {
        try {
          return crypto_1.default.verify(algorithm, data, key, signature);
        } catch (e) {
          return false;
        }
      }
      exports.verify = verify;
      function bufferEqual(a, b) {
        try {
          return crypto_1.default.timingSafeEqual(a, b);
        } catch {
          return false;
        }
      }
      exports.bufferEqual = bufferEqual;
    },
    9892: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.preAuthEncoding = void 0;
      const PAE_PREFIX = "DSSEv1";
      function preAuthEncoding(payloadType, payload) {
        const prefix = [
          PAE_PREFIX,
          payloadType.length,
          payloadType,
          payload.length,
          "",
        ].join(" ");
        return Buffer.concat([Buffer.from(prefix, "ascii"), payload]);
      }
      exports.preAuthEncoding = preAuthEncoding;
    },
    7496: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.base64Decode = exports.base64Encode = void 0;
      const BASE64_ENCODING = "base64";
      const UTF8_ENCODING = "utf-8";
      function base64Encode(str) {
        return Buffer.from(str, UTF8_ENCODING).toString(BASE64_ENCODING);
      }
      exports.base64Encode = base64Encode;
      function base64Decode(str) {
        return Buffer.from(str, BASE64_ENCODING).toString(UTF8_ENCODING);
      }
      exports.base64Decode = base64Decode;
    },
    3352: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509SCTExtension =
        exports.X509Certificate =
        exports.EXTENSION_OID_SCT =
        exports.ByteStream =
        exports.RFC3161Timestamp =
        exports.pem =
        exports.json =
        exports.encoding =
        exports.dsse =
        exports.crypto =
        exports.ASN1Obj =
          void 0;
      var asn1_1 = __nccwpck_require__(4095);
      Object.defineProperty(exports, "ASN1Obj", {
        enumerable: true,
        get: function () {
          return asn1_1.ASN1Obj;
        },
      });
      exports.crypto = __importStar(__nccwpck_require__(3914));
      exports.dsse = __importStar(__nccwpck_require__(9892));
      exports.encoding = __importStar(__nccwpck_require__(7496));
      exports.json = __importStar(__nccwpck_require__(9022));
      exports.pem = __importStar(__nccwpck_require__(5225));
      var rfc3161_1 = __nccwpck_require__(7411);
      Object.defineProperty(exports, "RFC3161Timestamp", {
        enumerable: true,
        get: function () {
          return rfc3161_1.RFC3161Timestamp;
        },
      });
      var stream_1 = __nccwpck_require__(2283);
      Object.defineProperty(exports, "ByteStream", {
        enumerable: true,
        get: function () {
          return stream_1.ByteStream;
        },
      });
      var x509_1 = __nccwpck_require__(5500);
      Object.defineProperty(exports, "EXTENSION_OID_SCT", {
        enumerable: true,
        get: function () {
          return x509_1.EXTENSION_OID_SCT;
        },
      });
      Object.defineProperty(exports, "X509Certificate", {
        enumerable: true,
        get: function () {
          return x509_1.X509Certificate;
        },
      });
      Object.defineProperty(exports, "X509SCTExtension", {
        enumerable: true,
        get: function () {
          return x509_1.X509SCTExtension;
        },
      });
    },
    9022: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.canonicalize = void 0;
      function canonicalize(object) {
        let buffer = "";
        if (
          object === null ||
          typeof object !== "object" ||
          object.toJSON != null
        ) {
          buffer += JSON.stringify(object);
        } else if (Array.isArray(object)) {
          buffer += "[";
          let first = true;
          object.forEach((element) => {
            if (!first) {
              buffer += ",";
            }
            first = false;
            buffer += canonicalize(element);
          });
          buffer += "]";
        } else {
          buffer += "{";
          let first = true;
          Object.keys(object)
            .sort()
            .forEach((property) => {
              if (!first) {
                buffer += ",";
              }
              first = false;
              buffer += JSON.stringify(property);
              buffer += ":";
              buffer += canonicalize(object[property]);
            });
          buffer += "}";
        }
        return buffer;
      }
      exports.canonicalize = canonicalize;
    },
    5960: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2_HASH_ALGOS = exports.ECDSA_SIGNATURE_ALGOS = void 0;
      exports.ECDSA_SIGNATURE_ALGOS = {
        "1.2.840.10045.4.3.1": "sha224",
        "1.2.840.10045.4.3.2": "sha256",
        "1.2.840.10045.4.3.3": "sha384",
        "1.2.840.10045.4.3.4": "sha512",
      };
      exports.SHA2_HASH_ALGOS = {
        "2.16.840.1.101.3.4.2.1": "sha256",
        "2.16.840.1.101.3.4.2.2": "sha384",
        "2.16.840.1.101.3.4.2.3": "sha512",
      };
    },
    5225: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromDER = exports.toDER = void 0;
      const PEM_HEADER = /-----BEGIN (.*)-----/;
      const PEM_FOOTER = /-----END (.*)-----/;
      function toDER(certificate) {
        let der = "";
        certificate.split("\n").forEach((line) => {
          if (line.match(PEM_HEADER) || line.match(PEM_FOOTER)) {
            return;
          }
          der += line;
        });
        return Buffer.from(der, "base64");
      }
      exports.toDER = toDER;
      function fromDER(certificate, type = "CERTIFICATE") {
        const der = certificate.toString("base64");
        const lines = der.match(/.{1,64}/g) || "";
        return [`-----BEGIN ${type}-----`, ...lines, `-----END ${type}-----`]
          .join("\n")
          .concat("\n");
      }
      exports.fromDER = fromDER;
    },
    4526: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RFC3161TimestampVerificationError = void 0;
      class RFC3161TimestampVerificationError extends Error {}
      exports.RFC3161TimestampVerificationError =
        RFC3161TimestampVerificationError;
    },
    7411: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RFC3161Timestamp = void 0;
      var timestamp_1 = __nccwpck_require__(9180);
      Object.defineProperty(exports, "RFC3161Timestamp", {
        enumerable: true,
        get: function () {
          return timestamp_1.RFC3161Timestamp;
        },
      });
    },
    9180: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RFC3161Timestamp = void 0;
      const asn1_1 = __nccwpck_require__(4095);
      const crypto = __importStar(__nccwpck_require__(3914));
      const oid_1 = __nccwpck_require__(5960);
      const error_1 = __nccwpck_require__(4526);
      const tstinfo_1 = __nccwpck_require__(852);
      const OID_PKCS9_CONTENT_TYPE_SIGNED_DATA = "1.2.840.113549.1.7.2";
      const OID_PKCS9_CONTENT_TYPE_TSTINFO = "1.2.840.113549.1.9.16.1.4";
      const OID_PKCS9_MESSAGE_DIGEST_KEY = "1.2.840.113549.1.9.4";
      class RFC3161Timestamp {
        constructor(asn1) {
          this.root = asn1;
        }
        static parse(der) {
          const asn1 = asn1_1.ASN1Obj.parseBuffer(der);
          return new RFC3161Timestamp(asn1);
        }
        get status() {
          return this.pkiStatusInfoObj.subs[0].toInteger();
        }
        get contentType() {
          return this.contentTypeObj.toOID();
        }
        get eContentType() {
          return this.eContentTypeObj.toOID();
        }
        get signingTime() {
          return this.tstInfo.genTime;
        }
        get signerIssuer() {
          return this.signerSidObj.subs[0].value;
        }
        get signerSerialNumber() {
          return this.signerSidObj.subs[1].value;
        }
        get signerDigestAlgorithm() {
          const oid = this.signerDigestAlgorithmObj.subs[0].toOID();
          return oid_1.SHA2_HASH_ALGOS[oid];
        }
        get signatureAlgorithm() {
          const oid = this.signatureAlgorithmObj.subs[0].toOID();
          return oid_1.ECDSA_SIGNATURE_ALGOS[oid];
        }
        get signatureValue() {
          return this.signatureValueObj.value;
        }
        get tstInfo() {
          return new tstinfo_1.TSTInfo(this.eContentObj.subs[0].subs[0]);
        }
        verify(data, publicKey) {
          if (!this.timeStampTokenObj) {
            throw new error_1.RFC3161TimestampVerificationError(
              "timeStampToken is missing",
            );
          }
          if (this.contentType !== OID_PKCS9_CONTENT_TYPE_SIGNED_DATA) {
            throw new error_1.RFC3161TimestampVerificationError(
              `incorrect content type: ${this.contentType}`,
            );
          }
          if (this.eContentType !== OID_PKCS9_CONTENT_TYPE_TSTINFO) {
            throw new error_1.RFC3161TimestampVerificationError(
              `incorrect encapsulated content type: ${this.eContentType}`,
            );
          }
          this.tstInfo.verify(data);
          this.verifyMessageDigest();
          this.verifySignature(publicKey);
        }
        verifyMessageDigest() {
          const tstInfoDigest = crypto.digest(
            this.signerDigestAlgorithm,
            this.tstInfo.raw,
          );
          const expectedDigest =
            this.messageDigestAttributeObj.subs[1].subs[0].value;
          if (!crypto.bufferEqual(tstInfoDigest, expectedDigest)) {
            throw new error_1.RFC3161TimestampVerificationError(
              "signed data does not match tstInfo",
            );
          }
        }
        verifySignature(key) {
          const signedAttrs = this.signedAttrsObj.toDER();
          signedAttrs[0] = 49;
          const verified = crypto.verify(
            signedAttrs,
            key,
            this.signatureValue,
            this.signatureAlgorithm,
          );
          if (!verified) {
            throw new error_1.RFC3161TimestampVerificationError(
              "signature verification failed",
            );
          }
        }
        get pkiStatusInfoObj() {
          return this.root.subs[0];
        }
        get timeStampTokenObj() {
          return this.root.subs[1];
        }
        get contentTypeObj() {
          return this.timeStampTokenObj.subs[0];
        }
        get signedDataObj() {
          const obj = this.timeStampTokenObj.subs.find((sub) =>
            sub.tag.isContextSpecific(0),
          );
          return obj.subs[0];
        }
        get encapContentInfoObj() {
          return this.signedDataObj.subs[2];
        }
        get signerInfosObj() {
          const sd = this.signedDataObj;
          return sd.subs[sd.subs.length - 1];
        }
        get signerInfoObj() {
          return this.signerInfosObj.subs[0];
        }
        get eContentTypeObj() {
          return this.encapContentInfoObj.subs[0];
        }
        get eContentObj() {
          return this.encapContentInfoObj.subs[1];
        }
        get signedAttrsObj() {
          const signedAttrs = this.signerInfoObj.subs.find((sub) =>
            sub.tag.isContextSpecific(0),
          );
          return signedAttrs;
        }
        get messageDigestAttributeObj() {
          const messageDigest = this.signedAttrsObj.subs.find(
            (sub) =>
              sub.subs[0].tag.isOID() &&
              sub.subs[0].toOID() === OID_PKCS9_MESSAGE_DIGEST_KEY,
          );
          return messageDigest;
        }
        get signerSidObj() {
          return this.signerInfoObj.subs[1];
        }
        get signerDigestAlgorithmObj() {
          return this.signerInfoObj.subs[2];
        }
        get signatureAlgorithmObj() {
          return this.signerInfoObj.subs[4];
        }
        get signatureValueObj() {
          return this.signerInfoObj.subs[5];
        }
      }
      exports.RFC3161Timestamp = RFC3161Timestamp;
    },
    852: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSTInfo = void 0;
      const crypto = __importStar(__nccwpck_require__(3914));
      const oid_1 = __nccwpck_require__(5960);
      const error_1 = __nccwpck_require__(4526);
      class TSTInfo {
        constructor(asn1) {
          this.root = asn1;
        }
        get version() {
          return this.root.subs[0].toInteger();
        }
        get genTime() {
          return this.root.subs[4].toDate();
        }
        get messageImprintHashAlgorithm() {
          const oid = this.messageImprintObj.subs[0].subs[0].toOID();
          return oid_1.SHA2_HASH_ALGOS[oid];
        }
        get messageImprintHashedMessage() {
          return this.messageImprintObj.subs[1].value;
        }
        get raw() {
          return this.root.toDER();
        }
        verify(data) {
          const digest = crypto.digest(this.messageImprintHashAlgorithm, data);
          if (!crypto.bufferEqual(digest, this.messageImprintHashedMessage)) {
            throw new error_1.RFC3161TimestampVerificationError(
              "message imprint does not match artifact",
            );
          }
        }
        get messageImprintObj() {
          return this.root.subs[2];
        }
      }
      exports.TSTInfo = TSTInfo;
    },
    2283: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ByteStream = void 0;
      class StreamError extends Error {}
      class ByteStream {
        constructor(buffer) {
          this.start = 0;
          if (buffer) {
            this.buf = buffer;
            this.view = Buffer.from(buffer);
          } else {
            this.buf = new ArrayBuffer(0);
            this.view = Buffer.from(this.buf);
          }
        }
        get buffer() {
          return this.view.subarray(0, this.start);
        }
        get length() {
          return this.view.byteLength;
        }
        get position() {
          return this.start;
        }
        seek(position) {
          this.start = position;
        }
        slice(start, len) {
          const end = start + len;
          if (end > this.length) {
            throw new StreamError("request past end of buffer");
          }
          return this.view.subarray(start, end);
        }
        appendChar(char) {
          this.ensureCapacity(1);
          this.view[this.start] = char;
          this.start += 1;
        }
        appendUint16(num) {
          this.ensureCapacity(2);
          const value = new Uint16Array([num]);
          const view = new Uint8Array(value.buffer);
          this.view[this.start] = view[1];
          this.view[this.start + 1] = view[0];
          this.start += 2;
        }
        appendUint24(num) {
          this.ensureCapacity(3);
          const value = new Uint32Array([num]);
          const view = new Uint8Array(value.buffer);
          this.view[this.start] = view[2];
          this.view[this.start + 1] = view[1];
          this.view[this.start + 2] = view[0];
          this.start += 3;
        }
        appendView(view) {
          this.ensureCapacity(view.length);
          this.view.set(view, this.start);
          this.start += view.length;
        }
        getBlock(size) {
          if (size <= 0) {
            return Buffer.alloc(0);
          }
          if (this.start + size > this.view.length) {
            throw new Error("request past end of buffer");
          }
          const result = this.view.subarray(this.start, this.start + size);
          this.start += size;
          return result;
        }
        getUint8() {
          return this.getBlock(1)[0];
        }
        getUint16() {
          const block = this.getBlock(2);
          return (block[0] << 8) | block[1];
        }
        ensureCapacity(size) {
          if (this.start + size > this.view.byteLength) {
            const blockSize =
              ByteStream.BLOCK_SIZE + (size > ByteStream.BLOCK_SIZE ? size : 0);
            this.realloc(this.view.byteLength + blockSize);
          }
        }
        realloc(size) {
          const newArray = new ArrayBuffer(size);
          const newView = Buffer.from(newArray);
          newView.set(this.view);
          this.buf = newArray;
          this.view = newView;
        }
      }
      exports.ByteStream = ByteStream;
      ByteStream.BLOCK_SIZE = 1024;
    },
    6381: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509Certificate = exports.EXTENSION_OID_SCT = void 0;
      const asn1_1 = __nccwpck_require__(4095);
      const crypto = __importStar(__nccwpck_require__(3914));
      const oid_1 = __nccwpck_require__(5960);
      const pem = __importStar(__nccwpck_require__(5225));
      const ext_1 = __nccwpck_require__(1292);
      const EXTENSION_OID_SUBJECT_KEY_ID = "2.5.29.14";
      const EXTENSION_OID_KEY_USAGE = "2.5.29.15";
      const EXTENSION_OID_SUBJECT_ALT_NAME = "2.5.29.17";
      const EXTENSION_OID_BASIC_CONSTRAINTS = "2.5.29.19";
      const EXTENSION_OID_AUTHORITY_KEY_ID = "2.5.29.35";
      exports.EXTENSION_OID_SCT = "1.3.6.1.4.1.11129.2.4.2";
      class X509Certificate {
        constructor(asn1) {
          this.root = asn1;
        }
        static parse(cert) {
          const der = typeof cert === "string" ? pem.toDER(cert) : cert;
          const asn1 = asn1_1.ASN1Obj.parseBuffer(der);
          return new X509Certificate(asn1);
        }
        get tbsCertificate() {
          return this.tbsCertificateObj;
        }
        get version() {
          const ver = this.versionObj.subs[0].toInteger();
          return `v${(ver + BigInt(1)).toString()}`;
        }
        get serialNumber() {
          return this.serialNumberObj.value;
        }
        get notBefore() {
          return this.validityObj.subs[0].toDate();
        }
        get notAfter() {
          return this.validityObj.subs[1].toDate();
        }
        get issuer() {
          return this.issuerObj.value;
        }
        get subject() {
          return this.subjectObj.value;
        }
        get publicKey() {
          return this.subjectPublicKeyInfoObj.toDER();
        }
        get signatureAlgorithm() {
          const oid = this.signatureAlgorithmObj.subs[0].toOID();
          return oid_1.ECDSA_SIGNATURE_ALGOS[oid];
        }
        get signatureValue() {
          return this.signatureValueObj.value.subarray(1);
        }
        get subjectAltName() {
          const ext = this.extSubjectAltName;
          return ext?.uri || ext?.rfc822Name;
        }
        get extensions() {
          const extSeq = this.extensionsObj?.subs[0];
          return extSeq?.subs || [];
        }
        get extKeyUsage() {
          const ext = this.findExtension(EXTENSION_OID_KEY_USAGE);
          return ext ? new ext_1.X509KeyUsageExtension(ext) : undefined;
        }
        get extBasicConstraints() {
          const ext = this.findExtension(EXTENSION_OID_BASIC_CONSTRAINTS);
          return ext ? new ext_1.X509BasicConstraintsExtension(ext) : undefined;
        }
        get extSubjectAltName() {
          const ext = this.findExtension(EXTENSION_OID_SUBJECT_ALT_NAME);
          return ext
            ? new ext_1.X509SubjectAlternativeNameExtension(ext)
            : undefined;
        }
        get extAuthorityKeyID() {
          const ext = this.findExtension(EXTENSION_OID_AUTHORITY_KEY_ID);
          return ext ? new ext_1.X509AuthorityKeyIDExtension(ext) : undefined;
        }
        get extSubjectKeyID() {
          const ext = this.findExtension(EXTENSION_OID_SUBJECT_KEY_ID);
          return ext ? new ext_1.X509SubjectKeyIDExtension(ext) : undefined;
        }
        get extSCT() {
          const ext = this.findExtension(exports.EXTENSION_OID_SCT);
          return ext ? new ext_1.X509SCTExtension(ext) : undefined;
        }
        get isCA() {
          const ca = this.extBasicConstraints?.isCA || false;
          if (this.extKeyUsage) {
            ca && this.extKeyUsage.keyCertSign;
          }
          return ca;
        }
        extension(oid) {
          const ext = this.findExtension(oid);
          return ext ? new ext_1.X509Extension(ext) : undefined;
        }
        verify(issuerCertificate) {
          const publicKey = issuerCertificate?.publicKey || this.publicKey;
          const key = crypto.createPublicKey(publicKey);
          return crypto.verify(
            this.tbsCertificate.toDER(),
            key,
            this.signatureValue,
            this.signatureAlgorithm,
          );
        }
        validForDate(date) {
          return this.notBefore <= date && date <= this.notAfter;
        }
        equals(other) {
          return this.root.toDER().equals(other.root.toDER());
        }
        clone() {
          const der = this.root.toDER();
          const clone = Buffer.alloc(der.length);
          der.copy(clone);
          return X509Certificate.parse(clone);
        }
        findExtension(oid) {
          return this.extensions.find((ext) => ext.subs[0].toOID() === oid);
        }
        get tbsCertificateObj() {
          return this.root.subs[0];
        }
        get signatureAlgorithmObj() {
          return this.root.subs[1];
        }
        get signatureValueObj() {
          return this.root.subs[2];
        }
        get versionObj() {
          return this.tbsCertificateObj.subs[0];
        }
        get serialNumberObj() {
          return this.tbsCertificateObj.subs[1];
        }
        get issuerObj() {
          return this.tbsCertificateObj.subs[3];
        }
        get validityObj() {
          return this.tbsCertificateObj.subs[4];
        }
        get subjectObj() {
          return this.tbsCertificateObj.subs[5];
        }
        get subjectPublicKeyInfoObj() {
          return this.tbsCertificateObj.subs[6];
        }
        get extensionsObj() {
          return this.tbsCertificateObj.subs.find((sub) =>
            sub.tag.isContextSpecific(3),
          );
        }
      }
      exports.X509Certificate = X509Certificate;
    },
    1292: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509SCTExtension =
        exports.X509SubjectKeyIDExtension =
        exports.X509AuthorityKeyIDExtension =
        exports.X509SubjectAlternativeNameExtension =
        exports.X509KeyUsageExtension =
        exports.X509BasicConstraintsExtension =
        exports.X509Extension =
          void 0;
      const stream_1 = __nccwpck_require__(2283);
      const sct_1 = __nccwpck_require__(454);
      class X509Extension {
        constructor(asn1) {
          this.root = asn1;
        }
        get oid() {
          return this.root.subs[0].toOID();
        }
        get critical() {
          return this.root.subs.length === 3
            ? this.root.subs[1].toBoolean()
            : false;
        }
        get value() {
          return this.extnValueObj.value;
        }
        get valueObj() {
          return this.extnValueObj;
        }
        get extnValueObj() {
          return this.root.subs[this.root.subs.length - 1];
        }
      }
      exports.X509Extension = X509Extension;
      class X509BasicConstraintsExtension extends X509Extension {
        get isCA() {
          return this.sequence.subs[0]?.toBoolean() ?? false;
        }
        get pathLenConstraint() {
          return this.sequence.subs.length > 1
            ? this.sequence.subs[1].toInteger()
            : undefined;
        }
        get sequence() {
          return this.extnValueObj.subs[0];
        }
      }
      exports.X509BasicConstraintsExtension = X509BasicConstraintsExtension;
      class X509KeyUsageExtension extends X509Extension {
        get digitalSignature() {
          return this.bitString[0] === 1;
        }
        get keyCertSign() {
          return this.bitString[5] === 1;
        }
        get crlSign() {
          return this.bitString[6] === 1;
        }
        get bitString() {
          return this.extnValueObj.subs[0].toBitString();
        }
      }
      exports.X509KeyUsageExtension = X509KeyUsageExtension;
      class X509SubjectAlternativeNameExtension extends X509Extension {
        get rfc822Name() {
          return this.findGeneralName(1)?.value.toString("ascii");
        }
        get uri() {
          return this.findGeneralName(6)?.value.toString("ascii");
        }
        otherName(oid) {
          const otherName = this.findGeneralName(0);
          if (otherName === undefined) {
            return undefined;
          }
          const otherNameOID = otherName.subs[0].toOID();
          if (otherNameOID !== oid) {
            return undefined;
          }
          const otherNameValue = otherName.subs[1];
          return otherNameValue.subs[0].value.toString("ascii");
        }
        findGeneralName(tag) {
          return this.generalNames.find((gn) => gn.tag.isContextSpecific(tag));
        }
        get generalNames() {
          return this.extnValueObj.subs[0].subs;
        }
      }
      exports.X509SubjectAlternativeNameExtension =
        X509SubjectAlternativeNameExtension;
      class X509AuthorityKeyIDExtension extends X509Extension {
        get keyIdentifier() {
          return this.findSequenceMember(0)?.value;
        }
        findSequenceMember(tag) {
          return this.sequence.subs.find((el) => el.tag.isContextSpecific(tag));
        }
        get sequence() {
          return this.extnValueObj.subs[0];
        }
      }
      exports.X509AuthorityKeyIDExtension = X509AuthorityKeyIDExtension;
      class X509SubjectKeyIDExtension extends X509Extension {
        get keyIdentifier() {
          return this.extnValueObj.subs[0].value;
        }
      }
      exports.X509SubjectKeyIDExtension = X509SubjectKeyIDExtension;
      class X509SCTExtension extends X509Extension {
        constructor(asn1) {
          super(asn1);
        }
        get signedCertificateTimestamps() {
          const buf = this.extnValueObj.subs[0].value;
          const stream = new stream_1.ByteStream(buf);
          const end = stream.getUint16() + 2;
          const sctList = [];
          while (stream.position < end) {
            const sctLength = stream.getUint16();
            const sct = stream.getBlock(sctLength);
            sctList.push(sct_1.SignedCertificateTimestamp.parse(sct));
          }
          if (stream.position !== end) {
            throw new Error("SCT list length does not match actual length");
          }
          return sctList;
        }
      }
      exports.X509SCTExtension = X509SCTExtension;
    },
    5500: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509SCTExtension =
        exports.X509Certificate =
        exports.EXTENSION_OID_SCT =
          void 0;
      var cert_1 = __nccwpck_require__(6381);
      Object.defineProperty(exports, "EXTENSION_OID_SCT", {
        enumerable: true,
        get: function () {
          return cert_1.EXTENSION_OID_SCT;
        },
      });
      Object.defineProperty(exports, "X509Certificate", {
        enumerable: true,
        get: function () {
          return cert_1.X509Certificate;
        },
      });
      var ext_1 = __nccwpck_require__(1292);
      Object.defineProperty(exports, "X509SCTExtension", {
        enumerable: true,
        get: function () {
          return ext_1.X509SCTExtension;
        },
      });
    },
    454: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SignedCertificateTimestamp = void 0;
      const crypto = __importStar(__nccwpck_require__(3914));
      const stream_1 = __nccwpck_require__(2283);
      class SignedCertificateTimestamp {
        constructor(options) {
          this.version = options.version;
          this.logID = options.logID;
          this.timestamp = options.timestamp;
          this.extensions = options.extensions;
          this.hashAlgorithm = options.hashAlgorithm;
          this.signatureAlgorithm = options.signatureAlgorithm;
          this.signature = options.signature;
        }
        get datetime() {
          return new Date(Number(this.timestamp.readBigInt64BE()));
        }
        get algorithm() {
          switch (this.hashAlgorithm) {
            case 0:
              return "none";
            case 1:
              return "md5";
            case 2:
              return "sha1";
            case 3:
              return "sha224";
            case 4:
              return "sha256";
            case 5:
              return "sha384";
            case 6:
              return "sha512";
            default:
              return "unknown";
          }
        }
        verify(preCert, key) {
          const stream = new stream_1.ByteStream();
          stream.appendChar(this.version);
          stream.appendChar(0);
          stream.appendView(this.timestamp);
          stream.appendUint16(1);
          stream.appendView(preCert);
          stream.appendUint16(this.extensions.byteLength);
          if (this.extensions.byteLength > 0) {
            stream.appendView(this.extensions);
          }
          return crypto.verify(
            stream.buffer,
            key,
            this.signature,
            this.algorithm,
          );
        }
        static parse(buf) {
          const stream = new stream_1.ByteStream(buf);
          const version = stream.getUint8();
          const logID = stream.getBlock(32);
          const timestamp = stream.getBlock(8);
          const extenstionLength = stream.getUint16();
          const extensions = stream.getBlock(extenstionLength);
          const hashAlgorithm = stream.getUint8();
          const signatureAlgorithm = stream.getUint8();
          const sigLength = stream.getUint16();
          const signature = stream.getBlock(sigLength);
          if (stream.position !== buf.length) {
            throw new Error("SCT buffer length mismatch");
          }
          return new SignedCertificateTimestamp({
            version,
            logID,
            timestamp,
            extensions,
            hashAlgorithm,
            signatureAlgorithm,
            signature,
          });
        }
      }
      exports.SignedCertificateTimestamp = SignedCertificateTimestamp;
    },
    714: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signature = exports.Envelope = void 0;
      function createBaseEnvelope() {
        return { payload: Buffer.alloc(0), payloadType: "", signatures: [] };
      }
      exports.Envelope = {
        fromJSON(object) {
          return {
            payload: isSet(object.payload)
              ? Buffer.from(bytesFromBase64(object.payload))
              : Buffer.alloc(0),
            payloadType: isSet(object.payloadType)
              ? String(object.payloadType)
              : "",
            signatures: Array.isArray(object?.signatures)
              ? object.signatures.map((e) => exports.Signature.fromJSON(e))
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.payload !== undefined &&
            (obj.payload = base64FromBytes(
              message.payload !== undefined ? message.payload : Buffer.alloc(0),
            ));
          message.payloadType !== undefined &&
            (obj.payloadType = message.payloadType);
          if (message.signatures) {
            obj.signatures = message.signatures.map((e) =>
              e ? exports.Signature.toJSON(e) : undefined,
            );
          } else {
            obj.signatures = [];
          }
          return obj;
        },
      };
      function createBaseSignature() {
        return { sig: Buffer.alloc(0), keyid: "" };
      }
      exports.Signature = {
        fromJSON(object) {
          return {
            sig: isSet(object.sig)
              ? Buffer.from(bytesFromBase64(object.sig))
              : Buffer.alloc(0),
            keyid: isSet(object.keyid) ? String(object.keyid) : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.sig !== undefined &&
            (obj.sig = base64FromBytes(
              message.sig !== undefined ? message.sig : Buffer.alloc(0),
            ));
          message.keyid !== undefined && (obj.keyid = message.keyid);
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    3027: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Timestamp = void 0;
      function createBaseTimestamp() {
        return { seconds: "0", nanos: 0 };
      }
      exports.Timestamp = {
        fromJSON(object) {
          return {
            seconds: isSet(object.seconds) ? String(object.seconds) : "0",
            nanos: isSet(object.nanos) ? Number(object.nanos) : 0,
          };
        },
        toJSON(message) {
          const obj = {};
          message.seconds !== undefined && (obj.seconds = message.seconds);
          message.nanos !== undefined &&
            (obj.nanos = Math.round(message.nanos));
          return obj;
        },
      };
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    8293: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Bundle =
        exports.VerificationMaterial =
        exports.TimestampVerificationData =
          void 0;
      const envelope_1 = __nccwpck_require__(714);
      const sigstore_common_1 = __nccwpck_require__(2193);
      const sigstore_rekor_1 = __nccwpck_require__(4951);
      function createBaseTimestampVerificationData() {
        return { rfc3161Timestamps: [] };
      }
      exports.TimestampVerificationData = {
        fromJSON(object) {
          return {
            rfc3161Timestamps: Array.isArray(object?.rfc3161Timestamps)
              ? object.rfc3161Timestamps.map((e) =>
                  sigstore_common_1.RFC3161SignedTimestamp.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.rfc3161Timestamps) {
            obj.rfc3161Timestamps = message.rfc3161Timestamps.map((e) =>
              e
                ? sigstore_common_1.RFC3161SignedTimestamp.toJSON(e)
                : undefined,
            );
          } else {
            obj.rfc3161Timestamps = [];
          }
          return obj;
        },
      };
      function createBaseVerificationMaterial() {
        return {
          content: undefined,
          tlogEntries: [],
          timestampVerificationData: undefined,
        };
      }
      exports.VerificationMaterial = {
        fromJSON(object) {
          return {
            content: isSet(object.publicKey)
              ? {
                  $case: "publicKey",
                  publicKey: sigstore_common_1.PublicKeyIdentifier.fromJSON(
                    object.publicKey,
                  ),
                }
              : isSet(object.x509CertificateChain)
                ? {
                    $case: "x509CertificateChain",
                    x509CertificateChain:
                      sigstore_common_1.X509CertificateChain.fromJSON(
                        object.x509CertificateChain,
                      ),
                  }
                : isSet(object.certificate)
                  ? {
                      $case: "certificate",
                      certificate: sigstore_common_1.X509Certificate.fromJSON(
                        object.certificate,
                      ),
                    }
                  : undefined,
            tlogEntries: Array.isArray(object?.tlogEntries)
              ? object.tlogEntries.map((e) =>
                  sigstore_rekor_1.TransparencyLogEntry.fromJSON(e),
                )
              : [],
            timestampVerificationData: isSet(object.timestampVerificationData)
              ? exports.TimestampVerificationData.fromJSON(
                  object.timestampVerificationData,
                )
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.content?.$case === "publicKey" &&
            (obj.publicKey = message.content?.publicKey
              ? sigstore_common_1.PublicKeyIdentifier.toJSON(
                  message.content?.publicKey,
                )
              : undefined);
          message.content?.$case === "x509CertificateChain" &&
            (obj.x509CertificateChain = message.content?.x509CertificateChain
              ? sigstore_common_1.X509CertificateChain.toJSON(
                  message.content?.x509CertificateChain,
                )
              : undefined);
          message.content?.$case === "certificate" &&
            (obj.certificate = message.content?.certificate
              ? sigstore_common_1.X509Certificate.toJSON(
                  message.content?.certificate,
                )
              : undefined);
          if (message.tlogEntries) {
            obj.tlogEntries = message.tlogEntries.map((e) =>
              e ? sigstore_rekor_1.TransparencyLogEntry.toJSON(e) : undefined,
            );
          } else {
            obj.tlogEntries = [];
          }
          message.timestampVerificationData !== undefined &&
            (obj.timestampVerificationData = message.timestampVerificationData
              ? exports.TimestampVerificationData.toJSON(
                  message.timestampVerificationData,
                )
              : undefined);
          return obj;
        },
      };
      function createBaseBundle() {
        return {
          mediaType: "",
          verificationMaterial: undefined,
          content: undefined,
        };
      }
      exports.Bundle = {
        fromJSON(object) {
          return {
            mediaType: isSet(object.mediaType) ? String(object.mediaType) : "",
            verificationMaterial: isSet(object.verificationMaterial)
              ? exports.VerificationMaterial.fromJSON(
                  object.verificationMaterial,
                )
              : undefined,
            content: isSet(object.messageSignature)
              ? {
                  $case: "messageSignature",
                  messageSignature: sigstore_common_1.MessageSignature.fromJSON(
                    object.messageSignature,
                  ),
                }
              : isSet(object.dsseEnvelope)
                ? {
                    $case: "dsseEnvelope",
                    dsseEnvelope: envelope_1.Envelope.fromJSON(
                      object.dsseEnvelope,
                    ),
                  }
                : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.mediaType !== undefined &&
            (obj.mediaType = message.mediaType);
          message.verificationMaterial !== undefined &&
            (obj.verificationMaterial = message.verificationMaterial
              ? exports.VerificationMaterial.toJSON(
                  message.verificationMaterial,
                )
              : undefined);
          message.content?.$case === "messageSignature" &&
            (obj.messageSignature = message.content?.messageSignature
              ? sigstore_common_1.MessageSignature.toJSON(
                  message.content?.messageSignature,
                )
              : undefined);
          message.content?.$case === "dsseEnvelope" &&
            (obj.dsseEnvelope = message.content?.dsseEnvelope
              ? envelope_1.Envelope.toJSON(message.content?.dsseEnvelope)
              : undefined);
          return obj;
        },
      };
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    2193: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TimeRange =
        exports.X509CertificateChain =
        exports.SubjectAlternativeName =
        exports.X509Certificate =
        exports.DistinguishedName =
        exports.ObjectIdentifierValuePair =
        exports.ObjectIdentifier =
        exports.PublicKeyIdentifier =
        exports.PublicKey =
        exports.RFC3161SignedTimestamp =
        exports.LogId =
        exports.MessageSignature =
        exports.HashOutput =
        exports.subjectAlternativeNameTypeToJSON =
        exports.subjectAlternativeNameTypeFromJSON =
        exports.SubjectAlternativeNameType =
        exports.publicKeyDetailsToJSON =
        exports.publicKeyDetailsFromJSON =
        exports.PublicKeyDetails =
        exports.hashAlgorithmToJSON =
        exports.hashAlgorithmFromJSON =
        exports.HashAlgorithm =
          void 0;
      const timestamp_1 = __nccwpck_require__(3027);
      var HashAlgorithm;
      (function (HashAlgorithm) {
        HashAlgorithm[(HashAlgorithm["HASH_ALGORITHM_UNSPECIFIED"] = 0)] =
          "HASH_ALGORITHM_UNSPECIFIED";
        HashAlgorithm[(HashAlgorithm["SHA2_256"] = 1)] = "SHA2_256";
        HashAlgorithm[(HashAlgorithm["SHA2_384"] = 2)] = "SHA2_384";
        HashAlgorithm[(HashAlgorithm["SHA2_512"] = 3)] = "SHA2_512";
        HashAlgorithm[(HashAlgorithm["SHA3_256"] = 4)] = "SHA3_256";
        HashAlgorithm[(HashAlgorithm["SHA3_384"] = 5)] = "SHA3_384";
      })(
        (HashAlgorithm = exports.HashAlgorithm || (exports.HashAlgorithm = {})),
      );
      function hashAlgorithmFromJSON(object) {
        switch (object) {
          case 0:
          case "HASH_ALGORITHM_UNSPECIFIED":
            return HashAlgorithm.HASH_ALGORITHM_UNSPECIFIED;
          case 1:
          case "SHA2_256":
            return HashAlgorithm.SHA2_256;
          case 2:
          case "SHA2_384":
            return HashAlgorithm.SHA2_384;
          case 3:
          case "SHA2_512":
            return HashAlgorithm.SHA2_512;
          case 4:
          case "SHA3_256":
            return HashAlgorithm.SHA3_256;
          case 5:
          case "SHA3_384":
            return HashAlgorithm.SHA3_384;
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " + object + " for enum HashAlgorithm",
            );
        }
      }
      exports.hashAlgorithmFromJSON = hashAlgorithmFromJSON;
      function hashAlgorithmToJSON(object) {
        switch (object) {
          case HashAlgorithm.HASH_ALGORITHM_UNSPECIFIED:
            return "HASH_ALGORITHM_UNSPECIFIED";
          case HashAlgorithm.SHA2_256:
            return "SHA2_256";
          case HashAlgorithm.SHA2_384:
            return "SHA2_384";
          case HashAlgorithm.SHA2_512:
            return "SHA2_512";
          case HashAlgorithm.SHA3_256:
            return "SHA3_256";
          case HashAlgorithm.SHA3_384:
            return "SHA3_384";
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " + object + " for enum HashAlgorithm",
            );
        }
      }
      exports.hashAlgorithmToJSON = hashAlgorithmToJSON;
      var PublicKeyDetails;
      (function (PublicKeyDetails) {
        PublicKeyDetails[
          (PublicKeyDetails["PUBLIC_KEY_DETAILS_UNSPECIFIED"] = 0)
        ] = "PUBLIC_KEY_DETAILS_UNSPECIFIED";
        PublicKeyDetails[(PublicKeyDetails["PKCS1_RSA_PKCS1V5"] = 1)] =
          "PKCS1_RSA_PKCS1V5";
        PublicKeyDetails[(PublicKeyDetails["PKCS1_RSA_PSS"] = 2)] =
          "PKCS1_RSA_PSS";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PKCS1V5"] = 3)] =
          "PKIX_RSA_PKCS1V5";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS"] = 4)] =
          "PKIX_RSA_PSS";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_RSA_PKCS1V15_2048_SHA256"] = 9)
        ] = "PKIX_RSA_PKCS1V15_2048_SHA256";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_RSA_PKCS1V15_3072_SHA256"] = 10)
        ] = "PKIX_RSA_PKCS1V15_3072_SHA256";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_RSA_PKCS1V15_4096_SHA256"] = 11)
        ] = "PKIX_RSA_PKCS1V15_4096_SHA256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS_2048_SHA256"] = 16)] =
          "PKIX_RSA_PSS_2048_SHA256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS_3072_SHA256"] = 17)] =
          "PKIX_RSA_PSS_3072_SHA256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS_4096_SHA256"] = 18)] =
          "PKIX_RSA_PSS_4096_SHA256";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_ECDSA_P256_HMAC_SHA_256"] = 6)
        ] = "PKIX_ECDSA_P256_HMAC_SHA_256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ECDSA_P256_SHA_256"] = 5)] =
          "PKIX_ECDSA_P256_SHA_256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ECDSA_P384_SHA_384"] = 12)] =
          "PKIX_ECDSA_P384_SHA_384";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ECDSA_P521_SHA_512"] = 13)] =
          "PKIX_ECDSA_P521_SHA_512";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ED25519"] = 7)] =
          "PKIX_ED25519";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ED25519_PH"] = 8)] =
          "PKIX_ED25519_PH";
        PublicKeyDetails[(PublicKeyDetails["LMS_SHA256"] = 14)] = "LMS_SHA256";
        PublicKeyDetails[(PublicKeyDetails["LMOTS_SHA256"] = 15)] =
          "LMOTS_SHA256";
      })(
        (PublicKeyDetails =
          exports.PublicKeyDetails || (exports.PublicKeyDetails = {})),
      );
      function publicKeyDetailsFromJSON(object) {
        switch (object) {
          case 0:
          case "PUBLIC_KEY_DETAILS_UNSPECIFIED":
            return PublicKeyDetails.PUBLIC_KEY_DETAILS_UNSPECIFIED;
          case 1:
          case "PKCS1_RSA_PKCS1V5":
            return PublicKeyDetails.PKCS1_RSA_PKCS1V5;
          case 2:
          case "PKCS1_RSA_PSS":
            return PublicKeyDetails.PKCS1_RSA_PSS;
          case 3:
          case "PKIX_RSA_PKCS1V5":
            return PublicKeyDetails.PKIX_RSA_PKCS1V5;
          case 4:
          case "PKIX_RSA_PSS":
            return PublicKeyDetails.PKIX_RSA_PSS;
          case 9:
          case "PKIX_RSA_PKCS1V15_2048_SHA256":
            return PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256;
          case 10:
          case "PKIX_RSA_PKCS1V15_3072_SHA256":
            return PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256;
          case 11:
          case "PKIX_RSA_PKCS1V15_4096_SHA256":
            return PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256;
          case 16:
          case "PKIX_RSA_PSS_2048_SHA256":
            return PublicKeyDetails.PKIX_RSA_PSS_2048_SHA256;
          case 17:
          case "PKIX_RSA_PSS_3072_SHA256":
            return PublicKeyDetails.PKIX_RSA_PSS_3072_SHA256;
          case 18:
          case "PKIX_RSA_PSS_4096_SHA256":
            return PublicKeyDetails.PKIX_RSA_PSS_4096_SHA256;
          case 6:
          case "PKIX_ECDSA_P256_HMAC_SHA_256":
            return PublicKeyDetails.PKIX_ECDSA_P256_HMAC_SHA_256;
          case 5:
          case "PKIX_ECDSA_P256_SHA_256":
            return PublicKeyDetails.PKIX_ECDSA_P256_SHA_256;
          case 12:
          case "PKIX_ECDSA_P384_SHA_384":
            return PublicKeyDetails.PKIX_ECDSA_P384_SHA_384;
          case 13:
          case "PKIX_ECDSA_P521_SHA_512":
            return PublicKeyDetails.PKIX_ECDSA_P521_SHA_512;
          case 7:
          case "PKIX_ED25519":
            return PublicKeyDetails.PKIX_ED25519;
          case 8:
          case "PKIX_ED25519_PH":
            return PublicKeyDetails.PKIX_ED25519_PH;
          case 14:
          case "LMS_SHA256":
            return PublicKeyDetails.LMS_SHA256;
          case 15:
          case "LMOTS_SHA256":
            return PublicKeyDetails.LMOTS_SHA256;
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum PublicKeyDetails",
            );
        }
      }
      exports.publicKeyDetailsFromJSON = publicKeyDetailsFromJSON;
      function publicKeyDetailsToJSON(object) {
        switch (object) {
          case PublicKeyDetails.PUBLIC_KEY_DETAILS_UNSPECIFIED:
            return "PUBLIC_KEY_DETAILS_UNSPECIFIED";
          case PublicKeyDetails.PKCS1_RSA_PKCS1V5:
            return "PKCS1_RSA_PKCS1V5";
          case PublicKeyDetails.PKCS1_RSA_PSS:
            return "PKCS1_RSA_PSS";
          case PublicKeyDetails.PKIX_RSA_PKCS1V5:
            return "PKIX_RSA_PKCS1V5";
          case PublicKeyDetails.PKIX_RSA_PSS:
            return "PKIX_RSA_PSS";
          case PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256:
            return "PKIX_RSA_PKCS1V15_2048_SHA256";
          case PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256:
            return "PKIX_RSA_PKCS1V15_3072_SHA256";
          case PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256:
            return "PKIX_RSA_PKCS1V15_4096_SHA256";
          case PublicKeyDetails.PKIX_RSA_PSS_2048_SHA256:
            return "PKIX_RSA_PSS_2048_SHA256";
          case PublicKeyDetails.PKIX_RSA_PSS_3072_SHA256:
            return "PKIX_RSA_PSS_3072_SHA256";
          case PublicKeyDetails.PKIX_RSA_PSS_4096_SHA256:
            return "PKIX_RSA_PSS_4096_SHA256";
          case PublicKeyDetails.PKIX_ECDSA_P256_HMAC_SHA_256:
            return "PKIX_ECDSA_P256_HMAC_SHA_256";
          case PublicKeyDetails.PKIX_ECDSA_P256_SHA_256:
            return "PKIX_ECDSA_P256_SHA_256";
          case PublicKeyDetails.PKIX_ECDSA_P384_SHA_384:
            return "PKIX_ECDSA_P384_SHA_384";
          case PublicKeyDetails.PKIX_ECDSA_P521_SHA_512:
            return "PKIX_ECDSA_P521_SHA_512";
          case PublicKeyDetails.PKIX_ED25519:
            return "PKIX_ED25519";
          case PublicKeyDetails.PKIX_ED25519_PH:
            return "PKIX_ED25519_PH";
          case PublicKeyDetails.LMS_SHA256:
            return "LMS_SHA256";
          case PublicKeyDetails.LMOTS_SHA256:
            return "LMOTS_SHA256";
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum PublicKeyDetails",
            );
        }
      }
      exports.publicKeyDetailsToJSON = publicKeyDetailsToJSON;
      var SubjectAlternativeNameType;
      (function (SubjectAlternativeNameType) {
        SubjectAlternativeNameType[
          (SubjectAlternativeNameType[
            "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED"
          ] = 0)
        ] = "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED";
        SubjectAlternativeNameType[(SubjectAlternativeNameType["EMAIL"] = 1)] =
          "EMAIL";
        SubjectAlternativeNameType[(SubjectAlternativeNameType["URI"] = 2)] =
          "URI";
        SubjectAlternativeNameType[
          (SubjectAlternativeNameType["OTHER_NAME"] = 3)
        ] = "OTHER_NAME";
      })(
        (SubjectAlternativeNameType =
          exports.SubjectAlternativeNameType ||
          (exports.SubjectAlternativeNameType = {})),
      );
      function subjectAlternativeNameTypeFromJSON(object) {
        switch (object) {
          case 0:
          case "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED":
            return SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED;
          case 1:
          case "EMAIL":
            return SubjectAlternativeNameType.EMAIL;
          case 2:
          case "URI":
            return SubjectAlternativeNameType.URI;
          case 3:
          case "OTHER_NAME":
            return SubjectAlternativeNameType.OTHER_NAME;
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum SubjectAlternativeNameType",
            );
        }
      }
      exports.subjectAlternativeNameTypeFromJSON =
        subjectAlternativeNameTypeFromJSON;
      function subjectAlternativeNameTypeToJSON(object) {
        switch (object) {
          case SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED:
            return "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED";
          case SubjectAlternativeNameType.EMAIL:
            return "EMAIL";
          case SubjectAlternativeNameType.URI:
            return "URI";
          case SubjectAlternativeNameType.OTHER_NAME:
            return "OTHER_NAME";
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum SubjectAlternativeNameType",
            );
        }
      }
      exports.subjectAlternativeNameTypeToJSON =
        subjectAlternativeNameTypeToJSON;
      function createBaseHashOutput() {
        return { algorithm: 0, digest: Buffer.alloc(0) };
      }
      exports.HashOutput = {
        fromJSON(object) {
          return {
            algorithm: isSet(object.algorithm)
              ? hashAlgorithmFromJSON(object.algorithm)
              : 0,
            digest: isSet(object.digest)
              ? Buffer.from(bytesFromBase64(object.digest))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.algorithm !== undefined &&
            (obj.algorithm = hashAlgorithmToJSON(message.algorithm));
          message.digest !== undefined &&
            (obj.digest = base64FromBytes(
              message.digest !== undefined ? message.digest : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseMessageSignature() {
        return { messageDigest: undefined, signature: Buffer.alloc(0) };
      }
      exports.MessageSignature = {
        fromJSON(object) {
          return {
            messageDigest: isSet(object.messageDigest)
              ? exports.HashOutput.fromJSON(object.messageDigest)
              : undefined,
            signature: isSet(object.signature)
              ? Buffer.from(bytesFromBase64(object.signature))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.messageDigest !== undefined &&
            (obj.messageDigest = message.messageDigest
              ? exports.HashOutput.toJSON(message.messageDigest)
              : undefined);
          message.signature !== undefined &&
            (obj.signature = base64FromBytes(
              message.signature !== undefined
                ? message.signature
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseLogId() {
        return { keyId: Buffer.alloc(0) };
      }
      exports.LogId = {
        fromJSON(object) {
          return {
            keyId: isSet(object.keyId)
              ? Buffer.from(bytesFromBase64(object.keyId))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.keyId !== undefined &&
            (obj.keyId = base64FromBytes(
              message.keyId !== undefined ? message.keyId : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseRFC3161SignedTimestamp() {
        return { signedTimestamp: Buffer.alloc(0) };
      }
      exports.RFC3161SignedTimestamp = {
        fromJSON(object) {
          return {
            signedTimestamp: isSet(object.signedTimestamp)
              ? Buffer.from(bytesFromBase64(object.signedTimestamp))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.signedTimestamp !== undefined &&
            (obj.signedTimestamp = base64FromBytes(
              message.signedTimestamp !== undefined
                ? message.signedTimestamp
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBasePublicKey() {
        return { rawBytes: undefined, keyDetails: 0, validFor: undefined };
      }
      exports.PublicKey = {
        fromJSON(object) {
          return {
            rawBytes: isSet(object.rawBytes)
              ? Buffer.from(bytesFromBase64(object.rawBytes))
              : undefined,
            keyDetails: isSet(object.keyDetails)
              ? publicKeyDetailsFromJSON(object.keyDetails)
              : 0,
            validFor: isSet(object.validFor)
              ? exports.TimeRange.fromJSON(object.validFor)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.rawBytes !== undefined &&
            (obj.rawBytes =
              message.rawBytes !== undefined
                ? base64FromBytes(message.rawBytes)
                : undefined);
          message.keyDetails !== undefined &&
            (obj.keyDetails = publicKeyDetailsToJSON(message.keyDetails));
          message.validFor !== undefined &&
            (obj.validFor = message.validFor
              ? exports.TimeRange.toJSON(message.validFor)
              : undefined);
          return obj;
        },
      };
      function createBasePublicKeyIdentifier() {
        return { hint: "" };
      }
      exports.PublicKeyIdentifier = {
        fromJSON(object) {
          return { hint: isSet(object.hint) ? String(object.hint) : "" };
        },
        toJSON(message) {
          const obj = {};
          message.hint !== undefined && (obj.hint = message.hint);
          return obj;
        },
      };
      function createBaseObjectIdentifier() {
        return { id: [] };
      }
      exports.ObjectIdentifier = {
        fromJSON(object) {
          return {
            id: Array.isArray(object?.id)
              ? object.id.map((e) => Number(e))
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.id) {
            obj.id = message.id.map((e) => Math.round(e));
          } else {
            obj.id = [];
          }
          return obj;
        },
      };
      function createBaseObjectIdentifierValuePair() {
        return { oid: undefined, value: Buffer.alloc(0) };
      }
      exports.ObjectIdentifierValuePair = {
        fromJSON(object) {
          return {
            oid: isSet(object.oid)
              ? exports.ObjectIdentifier.fromJSON(object.oid)
              : undefined,
            value: isSet(object.value)
              ? Buffer.from(bytesFromBase64(object.value))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.oid !== undefined &&
            (obj.oid = message.oid
              ? exports.ObjectIdentifier.toJSON(message.oid)
              : undefined);
          message.value !== undefined &&
            (obj.value = base64FromBytes(
              message.value !== undefined ? message.value : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseDistinguishedName() {
        return { organization: "", commonName: "" };
      }
      exports.DistinguishedName = {
        fromJSON(object) {
          return {
            organization: isSet(object.organization)
              ? String(object.organization)
              : "",
            commonName: isSet(object.commonName)
              ? String(object.commonName)
              : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.organization !== undefined &&
            (obj.organization = message.organization);
          message.commonName !== undefined &&
            (obj.commonName = message.commonName);
          return obj;
        },
      };
      function createBaseX509Certificate() {
        return { rawBytes: Buffer.alloc(0) };
      }
      exports.X509Certificate = {
        fromJSON(object) {
          return {
            rawBytes: isSet(object.rawBytes)
              ? Buffer.from(bytesFromBase64(object.rawBytes))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.rawBytes !== undefined &&
            (obj.rawBytes = base64FromBytes(
              message.rawBytes !== undefined
                ? message.rawBytes
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseSubjectAlternativeName() {
        return { type: 0, identity: undefined };
      }
      exports.SubjectAlternativeName = {
        fromJSON(object) {
          return {
            type: isSet(object.type)
              ? subjectAlternativeNameTypeFromJSON(object.type)
              : 0,
            identity: isSet(object.regexp)
              ? { $case: "regexp", regexp: String(object.regexp) }
              : isSet(object.value)
                ? { $case: "value", value: String(object.value) }
                : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.type !== undefined &&
            (obj.type = subjectAlternativeNameTypeToJSON(message.type));
          message.identity?.$case === "regexp" &&
            (obj.regexp = message.identity?.regexp);
          message.identity?.$case === "value" &&
            (obj.value = message.identity?.value);
          return obj;
        },
      };
      function createBaseX509CertificateChain() {
        return { certificates: [] };
      }
      exports.X509CertificateChain = {
        fromJSON(object) {
          return {
            certificates: Array.isArray(object?.certificates)
              ? object.certificates.map((e) =>
                  exports.X509Certificate.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.certificates) {
            obj.certificates = message.certificates.map((e) =>
              e ? exports.X509Certificate.toJSON(e) : undefined,
            );
          } else {
            obj.certificates = [];
          }
          return obj;
        },
      };
      function createBaseTimeRange() {
        return { start: undefined, end: undefined };
      }
      exports.TimeRange = {
        fromJSON(object) {
          return {
            start: isSet(object.start)
              ? fromJsonTimestamp(object.start)
              : undefined,
            end: isSet(object.end) ? fromJsonTimestamp(object.end) : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.start !== undefined &&
            (obj.start = message.start.toISOString());
          message.end !== undefined && (obj.end = message.end.toISOString());
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function fromTimestamp(t) {
        let millis = Number(t.seconds) * 1e3;
        millis += t.nanos / 1e6;
        return new Date(millis);
      }
      function fromJsonTimestamp(o) {
        if (o instanceof Date) {
          return o;
        } else if (typeof o === "string") {
          return new Date(o);
        } else {
          return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    4951: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TransparencyLogEntry =
        exports.InclusionPromise =
        exports.InclusionProof =
        exports.Checkpoint =
        exports.KindVersion =
          void 0;
      const sigstore_common_1 = __nccwpck_require__(2193);
      function createBaseKindVersion() {
        return { kind: "", version: "" };
      }
      exports.KindVersion = {
        fromJSON(object) {
          return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            version: isSet(object.version) ? String(object.version) : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.kind !== undefined && (obj.kind = message.kind);
          message.version !== undefined && (obj.version = message.version);
          return obj;
        },
      };
      function createBaseCheckpoint() {
        return { envelope: "" };
      }
      exports.Checkpoint = {
        fromJSON(object) {
          return {
            envelope: isSet(object.envelope) ? String(object.envelope) : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.envelope !== undefined && (obj.envelope = message.envelope);
          return obj;
        },
      };
      function createBaseInclusionProof() {
        return {
          logIndex: "0",
          rootHash: Buffer.alloc(0),
          treeSize: "0",
          hashes: [],
          checkpoint: undefined,
        };
      }
      exports.InclusionProof = {
        fromJSON(object) {
          return {
            logIndex: isSet(object.logIndex) ? String(object.logIndex) : "0",
            rootHash: isSet(object.rootHash)
              ? Buffer.from(bytesFromBase64(object.rootHash))
              : Buffer.alloc(0),
            treeSize: isSet(object.treeSize) ? String(object.treeSize) : "0",
            hashes: Array.isArray(object?.hashes)
              ? object.hashes.map((e) => Buffer.from(bytesFromBase64(e)))
              : [],
            checkpoint: isSet(object.checkpoint)
              ? exports.Checkpoint.fromJSON(object.checkpoint)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.logIndex !== undefined && (obj.logIndex = message.logIndex);
          message.rootHash !== undefined &&
            (obj.rootHash = base64FromBytes(
              message.rootHash !== undefined
                ? message.rootHash
                : Buffer.alloc(0),
            ));
          message.treeSize !== undefined && (obj.treeSize = message.treeSize);
          if (message.hashes) {
            obj.hashes = message.hashes.map((e) =>
              base64FromBytes(e !== undefined ? e : Buffer.alloc(0)),
            );
          } else {
            obj.hashes = [];
          }
          message.checkpoint !== undefined &&
            (obj.checkpoint = message.checkpoint
              ? exports.Checkpoint.toJSON(message.checkpoint)
              : undefined);
          return obj;
        },
      };
      function createBaseInclusionPromise() {
        return { signedEntryTimestamp: Buffer.alloc(0) };
      }
      exports.InclusionPromise = {
        fromJSON(object) {
          return {
            signedEntryTimestamp: isSet(object.signedEntryTimestamp)
              ? Buffer.from(bytesFromBase64(object.signedEntryTimestamp))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.signedEntryTimestamp !== undefined &&
            (obj.signedEntryTimestamp = base64FromBytes(
              message.signedEntryTimestamp !== undefined
                ? message.signedEntryTimestamp
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseTransparencyLogEntry() {
        return {
          logIndex: "0",
          logId: undefined,
          kindVersion: undefined,
          integratedTime: "0",
          inclusionPromise: undefined,
          inclusionProof: undefined,
          canonicalizedBody: Buffer.alloc(0),
        };
      }
      exports.TransparencyLogEntry = {
        fromJSON(object) {
          return {
            logIndex: isSet(object.logIndex) ? String(object.logIndex) : "0",
            logId: isSet(object.logId)
              ? sigstore_common_1.LogId.fromJSON(object.logId)
              : undefined,
            kindVersion: isSet(object.kindVersion)
              ? exports.KindVersion.fromJSON(object.kindVersion)
              : undefined,
            integratedTime: isSet(object.integratedTime)
              ? String(object.integratedTime)
              : "0",
            inclusionPromise: isSet(object.inclusionPromise)
              ? exports.InclusionPromise.fromJSON(object.inclusionPromise)
              : undefined,
            inclusionProof: isSet(object.inclusionProof)
              ? exports.InclusionProof.fromJSON(object.inclusionProof)
              : undefined,
            canonicalizedBody: isSet(object.canonicalizedBody)
              ? Buffer.from(bytesFromBase64(object.canonicalizedBody))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.logIndex !== undefined && (obj.logIndex = message.logIndex);
          message.logId !== undefined &&
            (obj.logId = message.logId
              ? sigstore_common_1.LogId.toJSON(message.logId)
              : undefined);
          message.kindVersion !== undefined &&
            (obj.kindVersion = message.kindVersion
              ? exports.KindVersion.toJSON(message.kindVersion)
              : undefined);
          message.integratedTime !== undefined &&
            (obj.integratedTime = message.integratedTime);
          message.inclusionPromise !== undefined &&
            (obj.inclusionPromise = message.inclusionPromise
              ? exports.InclusionPromise.toJSON(message.inclusionPromise)
              : undefined);
          message.inclusionProof !== undefined &&
            (obj.inclusionProof = message.inclusionProof
              ? exports.InclusionProof.toJSON(message.inclusionProof)
              : undefined);
          message.canonicalizedBody !== undefined &&
            (obj.canonicalizedBody = base64FromBytes(
              message.canonicalizedBody !== undefined
                ? message.canonicalizedBody
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    4012: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClientTrustConfig =
        exports.SigningConfig =
        exports.TrustedRoot =
        exports.CertificateAuthority =
        exports.TransparencyLogInstance =
          void 0;
      const sigstore_common_1 = __nccwpck_require__(2193);
      function createBaseTransparencyLogInstance() {
        return {
          baseUrl: "",
          hashAlgorithm: 0,
          publicKey: undefined,
          logId: undefined,
          checkpointKeyId: undefined,
        };
      }
      exports.TransparencyLogInstance = {
        fromJSON(object) {
          return {
            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : "",
            hashAlgorithm: isSet(object.hashAlgorithm)
              ? (0, sigstore_common_1.hashAlgorithmFromJSON)(
                  object.hashAlgorithm,
                )
              : 0,
            publicKey: isSet(object.publicKey)
              ? sigstore_common_1.PublicKey.fromJSON(object.publicKey)
              : undefined,
            logId: isSet(object.logId)
              ? sigstore_common_1.LogId.fromJSON(object.logId)
              : undefined,
            checkpointKeyId: isSet(object.checkpointKeyId)
              ? sigstore_common_1.LogId.fromJSON(object.checkpointKeyId)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);
          message.hashAlgorithm !== undefined &&
            (obj.hashAlgorithm = (0, sigstore_common_1.hashAlgorithmToJSON)(
              message.hashAlgorithm,
            ));
          message.publicKey !== undefined &&
            (obj.publicKey = message.publicKey
              ? sigstore_common_1.PublicKey.toJSON(message.publicKey)
              : undefined);
          message.logId !== undefined &&
            (obj.logId = message.logId
              ? sigstore_common_1.LogId.toJSON(message.logId)
              : undefined);
          message.checkpointKeyId !== undefined &&
            (obj.checkpointKeyId = message.checkpointKeyId
              ? sigstore_common_1.LogId.toJSON(message.checkpointKeyId)
              : undefined);
          return obj;
        },
      };
      function createBaseCertificateAuthority() {
        return {
          subject: undefined,
          uri: "",
          certChain: undefined,
          validFor: undefined,
        };
      }
      exports.CertificateAuthority = {
        fromJSON(object) {
          return {
            subject: isSet(object.subject)
              ? sigstore_common_1.DistinguishedName.fromJSON(object.subject)
              : undefined,
            uri: isSet(object.uri) ? String(object.uri) : "",
            certChain: isSet(object.certChain)
              ? sigstore_common_1.X509CertificateChain.fromJSON(
                  object.certChain,
                )
              : undefined,
            validFor: isSet(object.validFor)
              ? sigstore_common_1.TimeRange.fromJSON(object.validFor)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.subject !== undefined &&
            (obj.subject = message.subject
              ? sigstore_common_1.DistinguishedName.toJSON(message.subject)
              : undefined);
          message.uri !== undefined && (obj.uri = message.uri);
          message.certChain !== undefined &&
            (obj.certChain = message.certChain
              ? sigstore_common_1.X509CertificateChain.toJSON(message.certChain)
              : undefined);
          message.validFor !== undefined &&
            (obj.validFor = message.validFor
              ? sigstore_common_1.TimeRange.toJSON(message.validFor)
              : undefined);
          return obj;
        },
      };
      function createBaseTrustedRoot() {
        return {
          mediaType: "",
          tlogs: [],
          certificateAuthorities: [],
          ctlogs: [],
          timestampAuthorities: [],
        };
      }
      exports.TrustedRoot = {
        fromJSON(object) {
          return {
            mediaType: isSet(object.mediaType) ? String(object.mediaType) : "",
            tlogs: Array.isArray(object?.tlogs)
              ? object.tlogs.map((e) =>
                  exports.TransparencyLogInstance.fromJSON(e),
                )
              : [],
            certificateAuthorities: Array.isArray(
              object?.certificateAuthorities,
            )
              ? object.certificateAuthorities.map((e) =>
                  exports.CertificateAuthority.fromJSON(e),
                )
              : [],
            ctlogs: Array.isArray(object?.ctlogs)
              ? object.ctlogs.map((e) =>
                  exports.TransparencyLogInstance.fromJSON(e),
                )
              : [],
            timestampAuthorities: Array.isArray(object?.timestampAuthorities)
              ? object.timestampAuthorities.map((e) =>
                  exports.CertificateAuthority.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.mediaType !== undefined &&
            (obj.mediaType = message.mediaType);
          if (message.tlogs) {
            obj.tlogs = message.tlogs.map((e) =>
              e ? exports.TransparencyLogInstance.toJSON(e) : undefined,
            );
          } else {
            obj.tlogs = [];
          }
          if (message.certificateAuthorities) {
            obj.certificateAuthorities = message.certificateAuthorities.map(
              (e) => (e ? exports.CertificateAuthority.toJSON(e) : undefined),
            );
          } else {
            obj.certificateAuthorities = [];
          }
          if (message.ctlogs) {
            obj.ctlogs = message.ctlogs.map((e) =>
              e ? exports.TransparencyLogInstance.toJSON(e) : undefined,
            );
          } else {
            obj.ctlogs = [];
          }
          if (message.timestampAuthorities) {
            obj.timestampAuthorities = message.timestampAuthorities.map((e) =>
              e ? exports.CertificateAuthority.toJSON(e) : undefined,
            );
          } else {
            obj.timestampAuthorities = [];
          }
          return obj;
        },
      };
      function createBaseSigningConfig() {
        return { caUrl: "", oidcUrl: "", tlogUrls: [], tsaUrls: [] };
      }
      exports.SigningConfig = {
        fromJSON(object) {
          return {
            caUrl: isSet(object.caUrl) ? String(object.caUrl) : "",
            oidcUrl: isSet(object.oidcUrl) ? String(object.oidcUrl) : "",
            tlogUrls: Array.isArray(object?.tlogUrls)
              ? object.tlogUrls.map((e) => String(e))
              : [],
            tsaUrls: Array.isArray(object?.tsaUrls)
              ? object.tsaUrls.map((e) => String(e))
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.caUrl !== undefined && (obj.caUrl = message.caUrl);
          message.oidcUrl !== undefined && (obj.oidcUrl = message.oidcUrl);
          if (message.tlogUrls) {
            obj.tlogUrls = message.tlogUrls.map((e) => e);
          } else {
            obj.tlogUrls = [];
          }
          if (message.tsaUrls) {
            obj.tsaUrls = message.tsaUrls.map((e) => e);
          } else {
            obj.tsaUrls = [];
          }
          return obj;
        },
      };
      function createBaseClientTrustConfig() {
        return {
          mediaType: "",
          trustedRoot: undefined,
          signingConfig: undefined,
        };
      }
      exports.ClientTrustConfig = {
        fromJSON(object) {
          return {
            mediaType: isSet(object.mediaType) ? String(object.mediaType) : "",
            trustedRoot: isSet(object.trustedRoot)
              ? exports.TrustedRoot.fromJSON(object.trustedRoot)
              : undefined,
            signingConfig: isSet(object.signingConfig)
              ? exports.SigningConfig.fromJSON(object.signingConfig)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.mediaType !== undefined &&
            (obj.mediaType = message.mediaType);
          message.trustedRoot !== undefined &&
            (obj.trustedRoot = message.trustedRoot
              ? exports.TrustedRoot.toJSON(message.trustedRoot)
              : undefined);
          message.signingConfig !== undefined &&
            (obj.signingConfig = message.signingConfig
              ? exports.SigningConfig.toJSON(message.signingConfig)
              : undefined);
          return obj;
        },
      };
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    9980: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Input =
        exports.Artifact =
        exports.ArtifactVerificationOptions_ObserverTimestampOptions =
        exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions =
        exports.ArtifactVerificationOptions_TimestampAuthorityOptions =
        exports.ArtifactVerificationOptions_CtlogOptions =
        exports.ArtifactVerificationOptions_TlogOptions =
        exports.ArtifactVerificationOptions =
        exports.PublicKeyIdentities =
        exports.CertificateIdentities =
        exports.CertificateIdentity =
          void 0;
      const sigstore_bundle_1 = __nccwpck_require__(8293);
      const sigstore_common_1 = __nccwpck_require__(2193);
      const sigstore_trustroot_1 = __nccwpck_require__(4012);
      function createBaseCertificateIdentity() {
        return { issuer: "", san: undefined, oids: [] };
      }
      exports.CertificateIdentity = {
        fromJSON(object) {
          return {
            issuer: isSet(object.issuer) ? String(object.issuer) : "",
            san: isSet(object.san)
              ? sigstore_common_1.SubjectAlternativeName.fromJSON(object.san)
              : undefined,
            oids: Array.isArray(object?.oids)
              ? object.oids.map((e) =>
                  sigstore_common_1.ObjectIdentifierValuePair.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.issuer !== undefined && (obj.issuer = message.issuer);
          message.san !== undefined &&
            (obj.san = message.san
              ? sigstore_common_1.SubjectAlternativeName.toJSON(message.san)
              : undefined);
          if (message.oids) {
            obj.oids = message.oids.map((e) =>
              e
                ? sigstore_common_1.ObjectIdentifierValuePair.toJSON(e)
                : undefined,
            );
          } else {
            obj.oids = [];
          }
          return obj;
        },
      };
      function createBaseCertificateIdentities() {
        return { identities: [] };
      }
      exports.CertificateIdentities = {
        fromJSON(object) {
          return {
            identities: Array.isArray(object?.identities)
              ? object.identities.map((e) =>
                  exports.CertificateIdentity.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.identities) {
            obj.identities = message.identities.map((e) =>
              e ? exports.CertificateIdentity.toJSON(e) : undefined,
            );
          } else {
            obj.identities = [];
          }
          return obj;
        },
      };
      function createBasePublicKeyIdentities() {
        return { publicKeys: [] };
      }
      exports.PublicKeyIdentities = {
        fromJSON(object) {
          return {
            publicKeys: Array.isArray(object?.publicKeys)
              ? object.publicKeys.map((e) =>
                  sigstore_common_1.PublicKey.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.publicKeys) {
            obj.publicKeys = message.publicKeys.map((e) =>
              e ? sigstore_common_1.PublicKey.toJSON(e) : undefined,
            );
          } else {
            obj.publicKeys = [];
          }
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions() {
        return {
          signers: undefined,
          tlogOptions: undefined,
          ctlogOptions: undefined,
          tsaOptions: undefined,
          integratedTsOptions: undefined,
          observerOptions: undefined,
        };
      }
      exports.ArtifactVerificationOptions = {
        fromJSON(object) {
          return {
            signers: isSet(object.certificateIdentities)
              ? {
                  $case: "certificateIdentities",
                  certificateIdentities: exports.CertificateIdentities.fromJSON(
                    object.certificateIdentities,
                  ),
                }
              : isSet(object.publicKeys)
                ? {
                    $case: "publicKeys",
                    publicKeys: exports.PublicKeyIdentities.fromJSON(
                      object.publicKeys,
                    ),
                  }
                : undefined,
            tlogOptions: isSet(object.tlogOptions)
              ? exports.ArtifactVerificationOptions_TlogOptions.fromJSON(
                  object.tlogOptions,
                )
              : undefined,
            ctlogOptions: isSet(object.ctlogOptions)
              ? exports.ArtifactVerificationOptions_CtlogOptions.fromJSON(
                  object.ctlogOptions,
                )
              : undefined,
            tsaOptions: isSet(object.tsaOptions)
              ? exports.ArtifactVerificationOptions_TimestampAuthorityOptions.fromJSON(
                  object.tsaOptions,
                )
              : undefined,
            integratedTsOptions: isSet(object.integratedTsOptions)
              ? exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions.fromJSON(
                  object.integratedTsOptions,
                )
              : undefined,
            observerOptions: isSet(object.observerOptions)
              ? exports.ArtifactVerificationOptions_ObserverTimestampOptions.fromJSON(
                  object.observerOptions,
                )
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.signers?.$case === "certificateIdentities" &&
            (obj.certificateIdentities = message.signers?.certificateIdentities
              ? exports.CertificateIdentities.toJSON(
                  message.signers?.certificateIdentities,
                )
              : undefined);
          message.signers?.$case === "publicKeys" &&
            (obj.publicKeys = message.signers?.publicKeys
              ? exports.PublicKeyIdentities.toJSON(message.signers?.publicKeys)
              : undefined);
          message.tlogOptions !== undefined &&
            (obj.tlogOptions = message.tlogOptions
              ? exports.ArtifactVerificationOptions_TlogOptions.toJSON(
                  message.tlogOptions,
                )
              : undefined);
          message.ctlogOptions !== undefined &&
            (obj.ctlogOptions = message.ctlogOptions
              ? exports.ArtifactVerificationOptions_CtlogOptions.toJSON(
                  message.ctlogOptions,
                )
              : undefined);
          message.tsaOptions !== undefined &&
            (obj.tsaOptions = message.tsaOptions
              ? exports.ArtifactVerificationOptions_TimestampAuthorityOptions.toJSON(
                  message.tsaOptions,
                )
              : undefined);
          message.integratedTsOptions !== undefined &&
            (obj.integratedTsOptions = message.integratedTsOptions
              ? exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions.toJSON(
                  message.integratedTsOptions,
                )
              : undefined);
          message.observerOptions !== undefined &&
            (obj.observerOptions = message.observerOptions
              ? exports.ArtifactVerificationOptions_ObserverTimestampOptions.toJSON(
                  message.observerOptions,
                )
              : undefined);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_TlogOptions() {
        return {
          threshold: 0,
          performOnlineVerification: false,
          disable: false,
        };
      }
      exports.ArtifactVerificationOptions_TlogOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            performOnlineVerification: isSet(object.performOnlineVerification)
              ? Boolean(object.performOnlineVerification)
              : false,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.performOnlineVerification !== undefined &&
            (obj.performOnlineVerification = message.performOnlineVerification);
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_CtlogOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_CtlogOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_TimestampAuthorityOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_TimestampAuthorityOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_TlogIntegratedTimestampOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_ObserverTimestampOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_ObserverTimestampOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifact() {
        return { data: undefined };
      }
      exports.Artifact = {
        fromJSON(object) {
          return {
            data: isSet(object.artifactUri)
              ? {
                  $case: "artifactUri",
                  artifactUri: String(object.artifactUri),
                }
              : isSet(object.artifact)
                ? {
                    $case: "artifact",
                    artifact: Buffer.from(bytesFromBase64(object.artifact)),
                  }
                : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.data?.$case === "artifactUri" &&
            (obj.artifactUri = message.data?.artifactUri);
          message.data?.$case === "artifact" &&
            (obj.artifact =
              message.data?.artifact !== undefined
                ? base64FromBytes(message.data?.artifact)
                : undefined);
          return obj;
        },
      };
      function createBaseInput() {
        return {
          artifactTrustRoot: undefined,
          artifactVerificationOptions: undefined,
          bundle: undefined,
          artifact: undefined,
        };
      }
      exports.Input = {
        fromJSON(object) {
          return {
            artifactTrustRoot: isSet(object.artifactTrustRoot)
              ? sigstore_trustroot_1.TrustedRoot.fromJSON(
                  object.artifactTrustRoot,
                )
              : undefined,
            artifactVerificationOptions: isSet(
              object.artifactVerificationOptions,
            )
              ? exports.ArtifactVerificationOptions.fromJSON(
                  object.artifactVerificationOptions,
                )
              : undefined,
            bundle: isSet(object.bundle)
              ? sigstore_bundle_1.Bundle.fromJSON(object.bundle)
              : undefined,
            artifact: isSet(object.artifact)
              ? exports.Artifact.fromJSON(object.artifact)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.artifactTrustRoot !== undefined &&
            (obj.artifactTrustRoot = message.artifactTrustRoot
              ? sigstore_trustroot_1.TrustedRoot.toJSON(
                  message.artifactTrustRoot,
                )
              : undefined);
          message.artifactVerificationOptions !== undefined &&
            (obj.artifactVerificationOptions =
              message.artifactVerificationOptions
                ? exports.ArtifactVerificationOptions.toJSON(
                    message.artifactVerificationOptions,
                  )
                : undefined);
          message.bundle !== undefined &&
            (obj.bundle = message.bundle
              ? sigstore_bundle_1.Bundle.toJSON(message.bundle)
              : undefined);
          message.artifact !== undefined &&
            (obj.artifact = message.artifact
              ? exports.Artifact.toJSON(message.artifact)
              : undefined);
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    530: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(__nccwpck_require__(714), exports);
      __exportStar(__nccwpck_require__(8293), exports);
      __exportStar(__nccwpck_require__(2193), exports);
      __exportStar(__nccwpck_require__(4951), exports);
      __exportStar(__nccwpck_require__(4012), exports);
      __exportStar(__nccwpck_require__(9980), exports);
    },
    5: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseBundleBuilder = void 0;
      class BaseBundleBuilder {
        constructor(options) {
          this.signer = options.signer;
          this.witnesses = options.witnesses;
        }
        async create(artifact) {
          const signature = await this.prepare(artifact).then((blob) =>
            this.signer.sign(blob),
          );
          const bundle = await this.package(artifact, signature);
          const verificationMaterials = await Promise.all(
            this.witnesses.map((witness) =>
              witness.testify(bundle.content, publicKey(signature.key)),
            ),
          );
          const tlogEntryList = [];
          const timestampList = [];
          verificationMaterials.forEach(
            ({ tlogEntries, rfc3161Timestamps }) => {
              tlogEntryList.push(...(tlogEntries ?? []));
              timestampList.push(...(rfc3161Timestamps ?? []));
            },
          );
          bundle.verificationMaterial.tlogEntries = tlogEntryList;
          bundle.verificationMaterial.timestampVerificationData = {
            rfc3161Timestamps: timestampList,
          };
          return bundle;
        }
        async prepare(artifact) {
          return artifact.data;
        }
      }
      exports.BaseBundleBuilder = BaseBundleBuilder;
      function publicKey(key) {
        switch (key.$case) {
          case "publicKey":
            return key.publicKey;
          case "x509Certificate":
            return key.certificate;
        }
      }
    },
    6947: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toDSSEBundle = exports.toMessageSignatureBundle = void 0;
      const sigstore = __importStar(__nccwpck_require__(9715));
      const util_1 = __nccwpck_require__(724);
      function toMessageSignatureBundle(artifact, signature) {
        const digest = util_1.crypto.hash(artifact.data);
        return sigstore.toMessageSignatureBundle({
          digest,
          signature: signature.signature,
          certificate:
            signature.key.$case === "x509Certificate"
              ? util_1.pem.toDER(signature.key.certificate)
              : undefined,
          keyHint:
            signature.key.$case === "publicKey"
              ? signature.key.hint
              : undefined,
        });
      }
      exports.toMessageSignatureBundle = toMessageSignatureBundle;
      function toDSSEBundle(artifact, signature, singleCertificate) {
        return sigstore.toDSSEBundle({
          artifact: artifact.data,
          artifactType: artifact.type,
          signature: signature.signature,
          certificate:
            signature.key.$case === "x509Certificate"
              ? util_1.pem.toDER(signature.key.certificate)
              : undefined,
          keyHint:
            signature.key.$case === "publicKey"
              ? signature.key.hint
              : undefined,
          singleCertificate,
        });
      }
      exports.toDSSEBundle = toDSSEBundle;
    },
    8791: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DSSEBundleBuilder = void 0;
      const util_1 = __nccwpck_require__(724);
      const base_1 = __nccwpck_require__(5);
      const bundle_1 = __nccwpck_require__(6947);
      class DSSEBundleBuilder extends base_1.BaseBundleBuilder {
        constructor(options) {
          super(options);
          this.singleCertificate = options.singleCertificate ?? false;
        }
        async prepare(artifact) {
          const a = artifactDefaults(artifact);
          return util_1.dsse.preAuthEncoding(a.type, a.data);
        }
        async package(artifact, signature) {
          return (0, bundle_1.toDSSEBundle)(
            artifactDefaults(artifact),
            signature,
            this.singleCertificate,
          );
        }
      }
      exports.DSSEBundleBuilder = DSSEBundleBuilder;
      function artifactDefaults(artifact) {
        return { ...artifact, type: artifact.type ?? "" };
      }
    },
    4929: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageSignatureBundleBuilder = exports.DSSEBundleBuilder =
        void 0;
      var dsse_1 = __nccwpck_require__(8791);
      Object.defineProperty(exports, "DSSEBundleBuilder", {
        enumerable: true,
        get: function () {
          return dsse_1.DSSEBundleBuilder;
        },
      });
      var message_1 = __nccwpck_require__(5243);
      Object.defineProperty(exports, "MessageSignatureBundleBuilder", {
        enumerable: true,
        get: function () {
          return message_1.MessageSignatureBundleBuilder;
        },
      });
    },
    5243: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageSignatureBundleBuilder = void 0;
      const base_1 = __nccwpck_require__(5);
      const bundle_1 = __nccwpck_require__(6947);
      class MessageSignatureBundleBuilder extends base_1.BaseBundleBuilder {
        constructor(options) {
          super(options);
        }
        async package(artifact, signature) {
          return (0, bundle_1.toMessageSignatureBundle)(artifact, signature);
        }
      }
      exports.MessageSignatureBundleBuilder = MessageSignatureBundleBuilder;
    },
    532: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.internalError = exports.InternalError = void 0;
      const error_1 = __nccwpck_require__(1294);
      class InternalError extends Error {
        constructor({ code, message, cause }) {
          super(message);
          this.name = this.constructor.name;
          this.cause = cause;
          this.code = code;
        }
      }
      exports.InternalError = InternalError;
      function internalError(err, code, message) {
        if (err instanceof error_1.HTTPError) {
          message += ` - ${err.message}`;
        }
        throw new InternalError({ code, message, cause: err });
      }
      exports.internalError = internalError;
    },
    1294: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HTTPError = void 0;
      class HTTPError extends Error {
        constructor({ status, message, location }) {
          super(`(${status}) ${message}`);
          this.statusCode = status;
          this.location = location;
        }
      }
      exports.HTTPError = HTTPError;
    },
    8509: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fetchWithRetry = void 0;
      const http2_1 = __nccwpck_require__(5158);
      const make_fetch_happen_1 = __importDefault(__nccwpck_require__(9525));
      const proc_log_1 = __nccwpck_require__(6528);
      const promise_retry_1 = __importDefault(__nccwpck_require__(4742));
      const util_1 = __nccwpck_require__(724);
      const error_1 = __nccwpck_require__(1294);
      const {
        HTTP2_HEADER_LOCATION,
        HTTP2_HEADER_CONTENT_TYPE,
        HTTP2_HEADER_USER_AGENT,
        HTTP_STATUS_INTERNAL_SERVER_ERROR,
        HTTP_STATUS_TOO_MANY_REQUESTS,
        HTTP_STATUS_REQUEST_TIMEOUT,
      } = http2_1.constants;
      async function fetchWithRetry(url, options) {
        return (0, promise_retry_1.default)(async (retry, attemptNum) => {
          const method = options.method || "POST";
          const headers = {
            [HTTP2_HEADER_USER_AGENT]: util_1.ua.getUserAgent(),
            ...options.headers,
          };
          const response = await (0, make_fetch_happen_1.default)(url, {
            method,
            headers,
            body: options.body,
            timeout: options.timeout,
            retry: false,
          }).catch((reason) => {
            proc_log_1.log.http(
              "fetch",
              `${method} ${url} attempt ${attemptNum} failed with ${reason}`,
            );
            return retry(reason);
          });
          if (response.ok) {
            return response;
          } else {
            const error = await errorFromResponse(response);
            proc_log_1.log.http(
              "fetch",
              `${method} ${url} attempt ${attemptNum} failed with ${response.status}`,
            );
            if (retryable(response.status)) {
              return retry(error);
            } else {
              throw error;
            }
          }
        }, retryOpts(options.retry));
      }
      exports.fetchWithRetry = fetchWithRetry;
      const errorFromResponse = async (response) => {
        let message = response.statusText;
        const location =
          response.headers?.get(HTTP2_HEADER_LOCATION) || undefined;
        const contentType = response.headers?.get(HTTP2_HEADER_CONTENT_TYPE);
        if (contentType?.includes("application/json")) {
          try {
            const body = await response.json();
            message = body.message || message;
          } catch (e) {}
        }
        return new error_1.HTTPError({
          status: response.status,
          message,
          location,
        });
      };
      const retryable = (status) =>
        [HTTP_STATUS_REQUEST_TIMEOUT, HTTP_STATUS_TOO_MANY_REQUESTS].includes(
          status,
        ) || status >= HTTP_STATUS_INTERNAL_SERVER_ERROR;
      const retryOpts = (retry) => {
        if (typeof retry === "boolean") {
          return { retries: retry ? 1 : 0 };
        } else if (typeof retry === "number") {
          return { retries: retry };
        } else {
          return { retries: 0, ...retry };
        }
      };
    },
    2960: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Fulcio = void 0;
      const fetch_1 = __nccwpck_require__(8509);
      class Fulcio {
        constructor(options) {
          this.options = options;
        }
        async createSigningCertificate(request) {
          const { baseURL, retry, timeout } = this.options;
          const url = `${baseURL}/api/v2/signingCert`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(request),
            timeout,
            retry,
          });
          return response.json();
        }
      }
      exports.Fulcio = Fulcio;
    },
    6205: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Rekor = void 0;
      const fetch_1 = __nccwpck_require__(8509);
      class Rekor {
        constructor(options) {
          this.options = options;
        }
        async createEntry(propsedEntry) {
          const { baseURL, timeout, retry } = this.options;
          const url = `${baseURL}/api/v1/log/entries`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(propsedEntry),
            timeout,
            retry,
          });
          const data = await response.json();
          return entryFromResponse(data);
        }
        async getEntry(uuid) {
          const { baseURL, timeout, retry } = this.options;
          const url = `${baseURL}/api/v1/log/entries/${uuid}`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            method: "GET",
            headers: { Accept: "application/json" },
            timeout,
            retry,
          });
          const data = await response.json();
          return entryFromResponse(data);
        }
      }
      exports.Rekor = Rekor;
      function entryFromResponse(data) {
        const entries = Object.entries(data);
        if (entries.length != 1) {
          throw new Error("Received multiple entries in Rekor response");
        }
        const [uuid, entry] = entries[0];
        return { ...entry, uuid };
      }
    },
    2759: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TimestampAuthority = void 0;
      const fetch_1 = __nccwpck_require__(8509);
      class TimestampAuthority {
        constructor(options) {
          this.options = options;
        }
        async createTimestamp(request) {
          const { baseURL, timeout, retry } = this.options;
          const url = `${baseURL}/api/v1/timestamp`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(request),
            timeout,
            retry,
          });
          return response.buffer();
        }
      }
      exports.TimestampAuthority = TimestampAuthority;
    },
    3110: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CIContextProvider = void 0;
      const make_fetch_happen_1 = __importDefault(__nccwpck_require__(9525));
      const providers = [getGHAToken, getEnv];
      class CIContextProvider {
        constructor(audience = "sigstore") {
          this.audience = audience;
        }
        async getToken() {
          return Promise.any(
            providers.map((getToken) => getToken(this.audience)),
          ).catch(() => Promise.reject("CI: no tokens available"));
        }
      }
      exports.CIContextProvider = CIContextProvider;
      async function getGHAToken(audience) {
        if (
          !process.env.ACTIONS_ID_TOKEN_REQUEST_URL ||
          !process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN
        ) {
          return Promise.reject("no token available");
        }
        const url = new URL(process.env.ACTIONS_ID_TOKEN_REQUEST_URL);
        url.searchParams.append("audience", audience);
        const response = await (0, make_fetch_happen_1.default)(url.href, {
          retry: 2,
          headers: {
            Accept: "application/json",
            Authorization: `Bearer ${process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN}`,
          },
        });
        return response.json().then((data) => data.value);
      }
      async function getEnv() {
        if (!process.env.SIGSTORE_ID_TOKEN) {
          return Promise.reject("no token available");
        }
        return process.env.SIGSTORE_ID_TOKEN;
      }
    },
    4463: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CIContextProvider = void 0;
      var ci_1 = __nccwpck_require__(3110);
      Object.defineProperty(exports, "CIContextProvider", {
        enumerable: true,
        get: function () {
          return ci_1.CIContextProvider;
        },
      });
    },
    2071: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAWitness =
        exports.RekorWitness =
        exports.DEFAULT_REKOR_URL =
        exports.FulcioSigner =
        exports.DEFAULT_FULCIO_URL =
        exports.CIContextProvider =
        exports.InternalError =
        exports.MessageSignatureBundleBuilder =
        exports.DSSEBundleBuilder =
          void 0;
      var bundler_1 = __nccwpck_require__(4929);
      Object.defineProperty(exports, "DSSEBundleBuilder", {
        enumerable: true,
        get: function () {
          return bundler_1.DSSEBundleBuilder;
        },
      });
      Object.defineProperty(exports, "MessageSignatureBundleBuilder", {
        enumerable: true,
        get: function () {
          return bundler_1.MessageSignatureBundleBuilder;
        },
      });
      var error_1 = __nccwpck_require__(532);
      Object.defineProperty(exports, "InternalError", {
        enumerable: true,
        get: function () {
          return error_1.InternalError;
        },
      });
      var identity_1 = __nccwpck_require__(4463);
      Object.defineProperty(exports, "CIContextProvider", {
        enumerable: true,
        get: function () {
          return identity_1.CIContextProvider;
        },
      });
      var signer_1 = __nccwpck_require__(7551);
      Object.defineProperty(exports, "DEFAULT_FULCIO_URL", {
        enumerable: true,
        get: function () {
          return signer_1.DEFAULT_FULCIO_URL;
        },
      });
      Object.defineProperty(exports, "FulcioSigner", {
        enumerable: true,
        get: function () {
          return signer_1.FulcioSigner;
        },
      });
      var witness_1 = __nccwpck_require__(2170);
      Object.defineProperty(exports, "DEFAULT_REKOR_URL", {
        enumerable: true,
        get: function () {
          return witness_1.DEFAULT_REKOR_URL;
        },
      });
      Object.defineProperty(exports, "RekorWitness", {
        enumerable: true,
        get: function () {
          return witness_1.RekorWitness;
        },
      });
      Object.defineProperty(exports, "TSAWitness", {
        enumerable: true,
        get: function () {
          return witness_1.TSAWitness;
        },
      });
    },
    334: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CAClient = void 0;
      const error_1 = __nccwpck_require__(532);
      const fulcio_1 = __nccwpck_require__(2960);
      class CAClient {
        constructor(options) {
          this.fulcio = new fulcio_1.Fulcio({
            baseURL: options.fulcioBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async createSigningCertificate(identityToken, publicKey, challenge) {
          const request = toCertificateRequest(
            identityToken,
            publicKey,
            challenge,
          );
          try {
            const resp = await this.fulcio.createSigningCertificate(request);
            const cert = resp.signedCertificateEmbeddedSct
              ? resp.signedCertificateEmbeddedSct
              : resp.signedCertificateDetachedSct;
            return cert.chain.certificates;
          } catch (err) {
            (0, error_1.internalError)(
              err,
              "CA_CREATE_SIGNING_CERTIFICATE_ERROR",
              "error creating signing certificate",
            );
          }
        }
      }
      exports.CAClient = CAClient;
      function toCertificateRequest(identityToken, publicKey, challenge) {
        return {
          credentials: { oidcIdentityToken: identityToken },
          publicKeyRequest: {
            publicKey: { algorithm: "ECDSA", content: publicKey },
            proofOfPossession: challenge.toString("base64"),
          },
        };
      }
    },
    8489: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EphemeralSigner = void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const EC_KEYPAIR_TYPE = "ec";
      const P256_CURVE = "P-256";
      class EphemeralSigner {
        constructor() {
          this.keypair = crypto_1.default.generateKeyPairSync(EC_KEYPAIR_TYPE, {
            namedCurve: P256_CURVE,
          });
        }
        async sign(data) {
          const signature = crypto_1.default.sign(
            null,
            data,
            this.keypair.privateKey,
          );
          const publicKey = this.keypair.publicKey
            .export({ format: "pem", type: "spki" })
            .toString("ascii");
          return { signature, key: { $case: "publicKey", publicKey } };
        }
      }
      exports.EphemeralSigner = EphemeralSigner;
    },
    7328: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FulcioSigner = exports.DEFAULT_FULCIO_URL = void 0;
      const error_1 = __nccwpck_require__(532);
      const util_1 = __nccwpck_require__(724);
      const ca_1 = __nccwpck_require__(334);
      const ephemeral_1 = __nccwpck_require__(8489);
      exports.DEFAULT_FULCIO_URL = "https://fulcio.sigstore.dev";
      class FulcioSigner {
        constructor(options) {
          this.ca = new ca_1.CAClient({
            ...options,
            fulcioBaseURL: options.fulcioBaseURL || exports.DEFAULT_FULCIO_URL,
          });
          this.identityProvider = options.identityProvider;
          this.keyHolder =
            options.keyHolder || new ephemeral_1.EphemeralSigner();
        }
        async sign(data) {
          const identityToken = await this.getIdentityToken();
          let subject;
          try {
            subject = util_1.oidc.extractJWTSubject(identityToken);
          } catch (err) {
            throw new error_1.InternalError({
              code: "IDENTITY_TOKEN_PARSE_ERROR",
              message: `invalid identity token: ${identityToken}`,
              cause: err,
            });
          }
          const challenge = await this.keyHolder.sign(Buffer.from(subject));
          if (challenge.key.$case !== "publicKey") {
            throw new error_1.InternalError({
              code: "CA_CREATE_SIGNING_CERTIFICATE_ERROR",
              message: "unexpected format for signing key",
            });
          }
          const certificates = await this.ca.createSigningCertificate(
            identityToken,
            challenge.key.publicKey,
            challenge.signature,
          );
          const signature = await this.keyHolder.sign(data);
          return {
            signature: signature.signature,
            key: { $case: "x509Certificate", certificate: certificates[0] },
          };
        }
        async getIdentityToken() {
          try {
            return await this.identityProvider.getToken();
          } catch (err) {
            throw new error_1.InternalError({
              code: "IDENTITY_TOKEN_READ_ERROR",
              message: "error retrieving identity token",
              cause: err,
            });
          }
        }
      }
      exports.FulcioSigner = FulcioSigner;
    },
    7551: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FulcioSigner = exports.DEFAULT_FULCIO_URL = void 0;
      var fulcio_1 = __nccwpck_require__(7328);
      Object.defineProperty(exports, "DEFAULT_FULCIO_URL", {
        enumerable: true,
        get: function () {
          return fulcio_1.DEFAULT_FULCIO_URL;
        },
      });
      Object.defineProperty(exports, "FulcioSigner", {
        enumerable: true,
        get: function () {
          return fulcio_1.FulcioSigner;
        },
      });
    },
    724: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ua =
        exports.oidc =
        exports.pem =
        exports.json =
        exports.encoding =
        exports.dsse =
        exports.crypto =
          void 0;
      var core_1 = __nccwpck_require__(3352);
      Object.defineProperty(exports, "crypto", {
        enumerable: true,
        get: function () {
          return core_1.crypto;
        },
      });
      Object.defineProperty(exports, "dsse", {
        enumerable: true,
        get: function () {
          return core_1.dsse;
        },
      });
      Object.defineProperty(exports, "encoding", {
        enumerable: true,
        get: function () {
          return core_1.encoding;
        },
      });
      Object.defineProperty(exports, "json", {
        enumerable: true,
        get: function () {
          return core_1.json;
        },
      });
      Object.defineProperty(exports, "pem", {
        enumerable: true,
        get: function () {
          return core_1.pem;
        },
      });
      exports.oidc = __importStar(__nccwpck_require__(3397));
      exports.ua = __importStar(__nccwpck_require__(6253));
    },
    3397: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extractJWTSubject = void 0;
      const core_1 = __nccwpck_require__(3352);
      function extractJWTSubject(jwt) {
        const parts = jwt.split(".", 3);
        const payload = JSON.parse(core_1.encoding.base64Decode(parts[1]));
        switch (payload.iss) {
          case "https://accounts.google.com":
          case "https://oauth2.sigstore.dev/auth":
            return payload.email;
          default:
            return payload.sub;
        }
      }
      exports.extractJWTSubject = extractJWTSubject;
    },
    6253: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getUserAgent = void 0;
      const os_1 = __importDefault(__nccwpck_require__(2037));
      const getUserAgent = () => {
        const packageVersion = __nccwpck_require__(3684).version;
        const nodeVersion = process.version;
        const platformName = os_1.default.platform();
        const archName = os_1.default.arch();
        return `sigstore-js/${packageVersion} (Node ${nodeVersion}) (${platformName}/${archName})`;
      };
      exports.getUserAgent = getUserAgent;
    },
    2170: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAWitness =
        exports.RekorWitness =
        exports.DEFAULT_REKOR_URL =
          void 0;
      var tlog_1 = __nccwpck_require__(7843);
      Object.defineProperty(exports, "DEFAULT_REKOR_URL", {
        enumerable: true,
        get: function () {
          return tlog_1.DEFAULT_REKOR_URL;
        },
      });
      Object.defineProperty(exports, "RekorWitness", {
        enumerable: true,
        get: function () {
          return tlog_1.RekorWitness;
        },
      });
      var tsa_1 = __nccwpck_require__(49);
      Object.defineProperty(exports, "TSAWitness", {
        enumerable: true,
        get: function () {
          return tsa_1.TSAWitness;
        },
      });
    },
    6737: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TLogClient = void 0;
      const error_1 = __nccwpck_require__(532);
      const error_2 = __nccwpck_require__(1294);
      const rekor_1 = __nccwpck_require__(6205);
      class TLogClient {
        constructor(options) {
          this.fetchOnConflict = options.fetchOnConflict ?? false;
          this.rekor = new rekor_1.Rekor({
            baseURL: options.rekorBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async createEntry(proposedEntry) {
          let entry;
          try {
            entry = await this.rekor.createEntry(proposedEntry);
          } catch (err) {
            if (entryExistsError(err) && this.fetchOnConflict) {
              const uuid = err.location.split("/").pop() || "";
              try {
                entry = await this.rekor.getEntry(uuid);
              } catch (err) {
                (0, error_1.internalError)(
                  err,
                  "TLOG_FETCH_ENTRY_ERROR",
                  "error fetching tlog entry",
                );
              }
            } else {
              (0, error_1.internalError)(
                err,
                "TLOG_CREATE_ENTRY_ERROR",
                "error creating tlog entry",
              );
            }
          }
          return entry;
        }
      }
      exports.TLogClient = TLogClient;
      function entryExistsError(value) {
        return (
          value instanceof error_2.HTTPError &&
          value.statusCode === 409 &&
          value.location !== undefined
        );
      }
    },
    3776: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toProposedEntry = void 0;
      const bundle_1 = __nccwpck_require__(9715);
      const util_1 = __nccwpck_require__(724);
      function toProposedEntry(content, publicKey, entryType = "intoto") {
        switch (content.$case) {
          case "dsseEnvelope":
            if (entryType === "dsse") {
              return toProposedDSSEEntry(content.dsseEnvelope, publicKey);
            }
            return toProposedIntotoEntry(content.dsseEnvelope, publicKey);
          case "messageSignature":
            return toProposedHashedRekordEntry(
              content.messageSignature,
              publicKey,
            );
        }
      }
      exports.toProposedEntry = toProposedEntry;
      function toProposedHashedRekordEntry(messageSignature, publicKey) {
        const hexDigest = messageSignature.messageDigest.digest.toString("hex");
        const b64Signature = messageSignature.signature.toString("base64");
        const b64Key = util_1.encoding.base64Encode(publicKey);
        return {
          apiVersion: "0.0.1",
          kind: "hashedrekord",
          spec: {
            data: { hash: { algorithm: "sha256", value: hexDigest } },
            signature: {
              content: b64Signature,
              publicKey: { content: b64Key },
            },
          },
        };
      }
      function toProposedDSSEEntry(envelope, publicKey) {
        const envelopeJSON = JSON.stringify(
          (0, bundle_1.envelopeToJSON)(envelope),
        );
        const encodedKey = util_1.encoding.base64Encode(publicKey);
        return {
          apiVersion: "0.0.1",
          kind: "dsse",
          spec: {
            proposedContent: {
              envelope: envelopeJSON,
              verifiers: [encodedKey],
            },
          },
        };
      }
      function toProposedIntotoEntry(envelope, publicKey) {
        const payloadHash = util_1.crypto
          .hash(envelope.payload)
          .toString("hex");
        const envelopeHash = calculateDSSEHash(envelope, publicKey);
        const payload = util_1.encoding.base64Encode(
          envelope.payload.toString("base64"),
        );
        const sig = util_1.encoding.base64Encode(
          envelope.signatures[0].sig.toString("base64"),
        );
        const keyid = envelope.signatures[0].keyid;
        const encodedKey = util_1.encoding.base64Encode(publicKey);
        const dsse = {
          payloadType: envelope.payloadType,
          payload,
          signatures: [{ sig, publicKey: encodedKey }],
        };
        if (keyid.length > 0) {
          dsse.signatures[0].keyid = keyid;
        }
        return {
          apiVersion: "0.0.2",
          kind: "intoto",
          spec: {
            content: {
              envelope: dsse,
              hash: { algorithm: "sha256", value: envelopeHash },
              payloadHash: { algorithm: "sha256", value: payloadHash },
            },
          },
        };
      }
      function calculateDSSEHash(envelope, publicKey) {
        const dsse = {
          payloadType: envelope.payloadType,
          payload: envelope.payload.toString("base64"),
          signatures: [
            { sig: envelope.signatures[0].sig.toString("base64"), publicKey },
          ],
        };
        if (envelope.signatures[0].keyid.length > 0) {
          dsse.signatures[0].keyid = envelope.signatures[0].keyid;
        }
        return util_1.crypto
          .hash(util_1.json.canonicalize(dsse))
          .toString("hex");
      }
    },
    7843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RekorWitness = exports.DEFAULT_REKOR_URL = void 0;
      const util_1 = __nccwpck_require__(724);
      const client_1 = __nccwpck_require__(6737);
      const entry_1 = __nccwpck_require__(3776);
      exports.DEFAULT_REKOR_URL = "https://rekor.sigstore.dev";
      class RekorWitness {
        constructor(options) {
          this.entryType = options.entryType;
          this.tlog = new client_1.TLogClient({
            ...options,
            rekorBaseURL: options.rekorBaseURL || exports.DEFAULT_REKOR_URL,
          });
        }
        async testify(content, publicKey) {
          const proposedEntry = (0, entry_1.toProposedEntry)(
            content,
            publicKey,
            this.entryType,
          );
          const entry = await this.tlog.createEntry(proposedEntry);
          return toTransparencyLogEntry(entry);
        }
      }
      exports.RekorWitness = RekorWitness;
      function toTransparencyLogEntry(entry) {
        const logID = Buffer.from(entry.logID, "hex");
        const bodyJSON = util_1.encoding.base64Decode(entry.body);
        const entryBody = JSON.parse(bodyJSON);
        const promise = entry?.verification?.signedEntryTimestamp
          ? inclusionPromise(entry.verification.signedEntryTimestamp)
          : undefined;
        const proof = entry?.verification?.inclusionProof
          ? inclusionProof(entry.verification.inclusionProof)
          : undefined;
        const tlogEntry = {
          logIndex: entry.logIndex.toString(),
          logId: { keyId: logID },
          integratedTime: entry.integratedTime.toString(),
          kindVersion: { kind: entryBody.kind, version: entryBody.apiVersion },
          inclusionPromise: promise,
          inclusionProof: proof,
          canonicalizedBody: Buffer.from(entry.body, "base64"),
        };
        return { tlogEntries: [tlogEntry] };
      }
      function inclusionPromise(promise) {
        return { signedEntryTimestamp: Buffer.from(promise, "base64") };
      }
      function inclusionProof(proof) {
        return {
          logIndex: proof.logIndex.toString(),
          treeSize: proof.treeSize.toString(),
          rootHash: Buffer.from(proof.rootHash, "hex"),
          hashes: proof.hashes.map((h) => Buffer.from(h, "hex")),
          checkpoint: { envelope: proof.checkpoint },
        };
      }
    },
    2239: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAClient = void 0;
      const error_1 = __nccwpck_require__(532);
      const tsa_1 = __nccwpck_require__(2759);
      const util_1 = __nccwpck_require__(724);
      class TSAClient {
        constructor(options) {
          this.tsa = new tsa_1.TimestampAuthority({
            baseURL: options.tsaBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async createTimestamp(signature) {
          const request = {
            artifactHash: util_1.crypto.hash(signature).toString("base64"),
            hashAlgorithm: "sha256",
          };
          try {
            return await this.tsa.createTimestamp(request);
          } catch (err) {
            (0, error_1.internalError)(
              err,
              "TSA_CREATE_TIMESTAMP_ERROR",
              "error creating timestamp",
            );
          }
        }
      }
      exports.TSAClient = TSAClient;
    },
    49: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAWitness = void 0;
      const client_1 = __nccwpck_require__(2239);
      class TSAWitness {
        constructor(options) {
          this.tsa = new client_1.TSAClient({
            tsaBaseURL: options.tsaBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async testify(content) {
          const signature = extractSignature(content);
          const timestamp = await this.tsa.createTimestamp(signature);
          return { rfc3161Timestamps: [{ signedTimestamp: timestamp }] };
        }
      }
      exports.TSAWitness = TSAWitness;
      function extractSignature(content) {
        switch (content.$case) {
          case "dsseEnvelope":
            return content.dsseEnvelope.signatures[0].sig;
          case "messageSignature":
            return content.messageSignature.signature;
        }
      }
    },
    8134: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.appDataPath = void 0;
      const os_1 = __importDefault(__nccwpck_require__(2037));
      const path_1 = __importDefault(__nccwpck_require__(1017));
      function appDataPath(name) {
        const homedir = os_1.default.homedir();
        switch (process.platform) {
          case "darwin": {
            const appSupport = path_1.default.join(
              homedir,
              "Library",
              "Application Support",
            );
            return path_1.default.join(appSupport, name);
          }
          case "win32": {
            const localAppData =
              process.env.LOCALAPPDATA ||
              path_1.default.join(homedir, "AppData", "Local");
            return path_1.default.join(localAppData, name, "Data");
          }
          default: {
            const localData =
              process.env.XDG_DATA_HOME ||
              path_1.default.join(homedir, ".local", "share");
            return path_1.default.join(localData, name);
          }
        }
      }
      exports.appDataPath = appDataPath;
    },
    8447: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TUFClient = void 0;
      const fs_1 = __importDefault(__nccwpck_require__(7147));
      const path_1 = __importDefault(__nccwpck_require__(1017));
      const tuf_js_1 = __nccwpck_require__(9475);
      const _1 = __nccwpck_require__(8567);
      const target_1 = __nccwpck_require__(1412);
      const TARGETS_DIR_NAME = "targets";
      class TUFClient {
        constructor(options) {
          const url = new URL(options.mirrorURL);
          const repoName = encodeURIComponent(
            url.host + url.pathname.replace(/\/$/, ""),
          );
          const cachePath = path_1.default.join(options.cachePath, repoName);
          initTufCache(cachePath);
          seedCache({
            cachePath,
            mirrorURL: options.mirrorURL,
            tufRootPath: options.rootPath,
            forceInit: options.forceInit,
          });
          this.updater = initClient({
            mirrorURL: options.mirrorURL,
            cachePath,
            forceCache: options.forceCache,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async refresh() {
          return this.updater.refresh();
        }
        getTarget(targetName) {
          return (0, target_1.readTarget)(this.updater, targetName);
        }
      }
      exports.TUFClient = TUFClient;
      function initTufCache(cachePath) {
        const targetsPath = path_1.default.join(cachePath, TARGETS_DIR_NAME);
        if (!fs_1.default.existsSync(cachePath)) {
          fs_1.default.mkdirSync(cachePath, { recursive: true });
        }
        if (!fs_1.default.existsSync(targetsPath)) {
          fs_1.default.mkdirSync(targetsPath);
        }
      }
      function seedCache({ cachePath, mirrorURL, tufRootPath, forceInit }) {
        const cachedRootPath = path_1.default.join(cachePath, "root.json");
        if (!fs_1.default.existsSync(cachedRootPath) || forceInit) {
          if (tufRootPath) {
            fs_1.default.copyFileSync(tufRootPath, cachedRootPath);
          } else {
            const seeds = __nccwpck_require__(4998);
            const repoSeed = seeds[mirrorURL];
            if (!repoSeed) {
              throw new _1.TUFError({
                code: "TUF_INIT_CACHE_ERROR",
                message: `No root.json found for mirror: ${mirrorURL}`,
              });
            }
            fs_1.default.writeFileSync(
              cachedRootPath,
              Buffer.from(repoSeed["root.json"], "base64"),
            );
            Object.entries(repoSeed.targets).forEach(([targetName, target]) => {
              fs_1.default.writeFileSync(
                path_1.default.join(cachePath, TARGETS_DIR_NAME, targetName),
                Buffer.from(target, "base64"),
              );
            });
          }
        }
      }
      function initClient(options) {
        const config = {
          fetchTimeout: options.timeout,
          fetchRetry: options.retry,
        };
        return new tuf_js_1.Updater({
          metadataBaseUrl: options.mirrorURL,
          targetBaseUrl: `${options.mirrorURL}/targets`,
          metadataDir: options.cachePath,
          targetDir: path_1.default.join(options.cachePath, TARGETS_DIR_NAME),
          forceCache: options.forceCache,
          config,
        });
      }
    },
    8624: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TUFError = void 0;
      class TUFError extends Error {
        constructor({ code, message, cause }) {
          super(message);
          this.code = code;
          this.cause = cause;
          this.name = this.constructor.name;
        }
      }
      exports.TUFError = TUFError;
    },
    8567: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TUFError =
        exports.initTUF =
        exports.getTrustedRoot =
        exports.DEFAULT_MIRROR_URL =
          void 0;
      const protobuf_specs_1 = __nccwpck_require__(530);
      const appdata_1 = __nccwpck_require__(8134);
      const client_1 = __nccwpck_require__(8447);
      exports.DEFAULT_MIRROR_URL = "https://tuf-repo-cdn.sigstore.dev";
      const DEFAULT_CACHE_DIR = "sigstore-js";
      const DEFAULT_RETRY = { retries: 2 };
      const DEFAULT_TIMEOUT = 5e3;
      const TRUSTED_ROOT_TARGET = "trusted_root.json";
      async function getTrustedRoot(options = {}) {
        const client = createClient(options);
        const trustedRoot = await client.getTarget(TRUSTED_ROOT_TARGET);
        return protobuf_specs_1.TrustedRoot.fromJSON(JSON.parse(trustedRoot));
      }
      exports.getTrustedRoot = getTrustedRoot;
      async function initTUF(options = {}) {
        const client = createClient(options);
        return client.refresh().then(() => client);
      }
      exports.initTUF = initTUF;
      function createClient(options) {
        return new client_1.TUFClient({
          cachePath:
            options.cachePath || (0, appdata_1.appDataPath)(DEFAULT_CACHE_DIR),
          rootPath: options.rootPath,
          mirrorURL: options.mirrorURL || exports.DEFAULT_MIRROR_URL,
          retry: options.retry ?? DEFAULT_RETRY,
          timeout: options.timeout ?? DEFAULT_TIMEOUT,
          forceCache: options.forceCache ?? false,
          forceInit: options.forceInit ?? options.force ?? false,
        });
      }
      var error_1 = __nccwpck_require__(8624);
      Object.defineProperty(exports, "TUFError", {
        enumerable: true,
        get: function () {
          return error_1.TUFError;
        },
      });
    },
    1412: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.readTarget = void 0;
      const fs_1 = __importDefault(__nccwpck_require__(7147));
      const error_1 = __nccwpck_require__(8624);
      async function readTarget(tuf, targetPath) {
        const path = await getTargetPath(tuf, targetPath);
        return new Promise((resolve, reject) => {
          fs_1.default.readFile(path, "utf-8", (err, data) => {
            if (err) {
              reject(
                new error_1.TUFError({
                  code: "TUF_READ_TARGET_ERROR",
                  message: `error reading target ${path}`,
                  cause: err,
                }),
              );
            } else {
              resolve(data);
            }
          });
        });
      }
      exports.readTarget = readTarget;
      async function getTargetPath(tuf, target) {
        let targetInfo;
        try {
          targetInfo = await tuf.getTargetInfo(target);
        } catch (err) {
          throw new error_1.TUFError({
            code: "TUF_REFRESH_METADATA_ERROR",
            message: "error refreshing TUF metadata",
            cause: err,
          });
        }
        if (!targetInfo) {
          throw new error_1.TUFError({
            code: "TUF_FIND_TARGET_ERROR",
            message: `target ${target} not found`,
          });
        }
        let path = await tuf.findCachedTarget(targetInfo);
        if (!path) {
          try {
            path = await tuf.downloadTarget(targetInfo);
          } catch (err) {
            throw new error_1.TUFError({
              code: "TUF_DOWNLOAD_TARGET_ERROR",
              message: `error downloading target ${path}`,
              cause: err,
            });
          }
        }
        return path;
      }
    },
    4542: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DSSESignatureContent = void 0;
      const core_1 = __nccwpck_require__(3352);
      class DSSESignatureContent {
        constructor(env) {
          this.env = env;
        }
        compareDigest(digest) {
          return core_1.crypto.bufferEqual(
            digest,
            core_1.crypto.hash(this.env.payload),
          );
        }
        compareSignature(signature) {
          return core_1.crypto.bufferEqual(signature, this.signature);
        }
        verifySignature(key) {
          return core_1.crypto.verify(
            this.preAuthEncoding,
            key,
            this.signature,
          );
        }
        get signature() {
          return this.env.signatures.length > 0
            ? this.env.signatures[0].sig
            : Buffer.from("");
        }
        get preAuthEncoding() {
          return core_1.dsse.preAuthEncoding(
            this.env.payloadType,
            this.env.payload,
          );
        }
      }
      exports.DSSESignatureContent = DSSESignatureContent;
    },
    9045: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.signatureContent = exports.toSignedEntity = void 0;
      const core_1 = __nccwpck_require__(3352);
      const dsse_1 = __nccwpck_require__(4542);
      const message_1 = __nccwpck_require__(6843);
      function toSignedEntity(bundle, artifact) {
        const { tlogEntries, timestampVerificationData } =
          bundle.verificationMaterial;
        const timestamps = [];
        for (const entry of tlogEntries) {
          timestamps.push({ $case: "transparency-log", tlogEntry: entry });
        }
        for (const ts of timestampVerificationData?.rfc3161Timestamps ?? []) {
          timestamps.push({
            $case: "timestamp-authority",
            timestamp: core_1.RFC3161Timestamp.parse(ts.signedTimestamp),
          });
        }
        return {
          signature: signatureContent(bundle, artifact),
          key: key(bundle),
          tlogEntries,
          timestamps,
        };
      }
      exports.toSignedEntity = toSignedEntity;
      function signatureContent(bundle, artifact) {
        switch (bundle.content.$case) {
          case "dsseEnvelope":
            return new dsse_1.DSSESignatureContent(bundle.content.dsseEnvelope);
          case "messageSignature":
            return new message_1.MessageSignatureContent(
              bundle.content.messageSignature,
              artifact,
            );
        }
      }
      exports.signatureContent = signatureContent;
      function key(bundle) {
        switch (bundle.verificationMaterial.content.$case) {
          case "publicKey":
            return {
              $case: "public-key",
              hint: bundle.verificationMaterial.content.publicKey.hint,
            };
          case "x509CertificateChain":
            return {
              $case: "certificate",
              certificate: core_1.X509Certificate.parse(
                bundle.verificationMaterial.content.x509CertificateChain
                  .certificates[0].rawBytes,
              ),
            };
          case "certificate":
            return {
              $case: "certificate",
              certificate: core_1.X509Certificate.parse(
                bundle.verificationMaterial.content.certificate.rawBytes,
              ),
            };
        }
      }
    },
    6843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageSignatureContent = void 0;
      const core_1 = __nccwpck_require__(3352);
      class MessageSignatureContent {
        constructor(messageSignature, artifact) {
          this.signature = messageSignature.signature;
          this.messageDigest = messageSignature.messageDigest.digest;
          this.artifact = artifact;
        }
        compareSignature(signature) {
          return core_1.crypto.bufferEqual(signature, this.signature);
        }
        compareDigest(digest) {
          return core_1.crypto.bufferEqual(digest, this.messageDigest);
        }
        verifySignature(key) {
          return core_1.crypto.verify(this.artifact, key, this.signature);
        }
      }
      exports.MessageSignatureContent = MessageSignatureContent;
    },
    8948: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PolicyError = exports.VerificationError = void 0;
      class BaseError extends Error {
        constructor({ code, message, cause }) {
          super(message);
          this.code = code;
          this.cause = cause;
          this.name = this.constructor.name;
        }
      }
      class VerificationError extends BaseError {}
      exports.VerificationError = VerificationError;
      class PolicyError extends BaseError {}
      exports.PolicyError = PolicyError;
    },
    666: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Verifier =
        exports.toTrustMaterial =
        exports.VerificationError =
        exports.PolicyError =
        exports.toSignedEntity =
          void 0;
      var bundle_1 = __nccwpck_require__(9045);
      Object.defineProperty(exports, "toSignedEntity", {
        enumerable: true,
        get: function () {
          return bundle_1.toSignedEntity;
        },
      });
      var error_1 = __nccwpck_require__(8948);
      Object.defineProperty(exports, "PolicyError", {
        enumerable: true,
        get: function () {
          return error_1.PolicyError;
        },
      });
      Object.defineProperty(exports, "VerificationError", {
        enumerable: true,
        get: function () {
          return error_1.VerificationError;
        },
      });
      var trust_1 = __nccwpck_require__(4503);
      Object.defineProperty(exports, "toTrustMaterial", {
        enumerable: true,
        get: function () {
          return trust_1.toTrustMaterial;
        },
      });
      var verifier_1 = __nccwpck_require__(5456);
      Object.defineProperty(exports, "Verifier", {
        enumerable: true,
        get: function () {
          return verifier_1.Verifier;
        },
      });
    },
    8766: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CertificateChainVerifier = exports.verifyCertificateChain =
        void 0;
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      function verifyCertificateChain(leaf, certificateAuthorities) {
        const cas = (0, trust_1.filterCertAuthorities)(certificateAuthorities, {
          start: leaf.notBefore,
          end: leaf.notAfter,
        });
        let error;
        for (const ca of cas) {
          try {
            const verifier = new CertificateChainVerifier({
              trustedCerts: ca.certChain,
              untrustedCert: leaf,
            });
            return verifier.verify();
          } catch (err) {
            error = err;
          }
        }
        throw new error_1.VerificationError({
          code: "CERTIFICATE_ERROR",
          message: "Failed to verify certificate chain",
          cause: error,
        });
      }
      exports.verifyCertificateChain = verifyCertificateChain;
      class CertificateChainVerifier {
        constructor(opts) {
          this.untrustedCert = opts.untrustedCert;
          this.trustedCerts = opts.trustedCerts;
          this.localCerts = dedupeCertificates([
            ...opts.trustedCerts,
            opts.untrustedCert,
          ]);
        }
        verify() {
          const certificatePath = this.sort();
          this.checkPath(certificatePath);
          return certificatePath;
        }
        sort() {
          const leafCert = this.untrustedCert;
          let paths = this.buildPaths(leafCert);
          paths = paths.filter((path) =>
            path.some((cert) => this.trustedCerts.includes(cert)),
          );
          if (paths.length === 0) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "no trusted certificate path found",
            });
          }
          const path = paths.reduce((prev, curr) =>
            prev.length < curr.length ? prev : curr,
          );
          return [leafCert, ...path].slice(0, -1);
        }
        buildPaths(certificate) {
          const paths = [];
          const issuers = this.findIssuer(certificate);
          if (issuers.length === 0) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "no valid certificate path found",
            });
          }
          for (let i = 0; i < issuers.length; i++) {
            const issuer = issuers[i];
            if (issuer.equals(certificate)) {
              paths.push([certificate]);
              continue;
            }
            const subPaths = this.buildPaths(issuer);
            for (let j = 0; j < subPaths.length; j++) {
              paths.push([issuer, ...subPaths[j]]);
            }
          }
          return paths;
        }
        findIssuer(certificate) {
          let issuers = [];
          let keyIdentifier;
          if (certificate.subject.equals(certificate.issuer)) {
            if (certificate.verify()) {
              return [certificate];
            }
          }
          if (certificate.extAuthorityKeyID) {
            keyIdentifier = certificate.extAuthorityKeyID.keyIdentifier;
          }
          this.localCerts.forEach((possibleIssuer) => {
            if (keyIdentifier) {
              if (possibleIssuer.extSubjectKeyID) {
                if (
                  possibleIssuer.extSubjectKeyID.keyIdentifier.equals(
                    keyIdentifier,
                  )
                ) {
                  issuers.push(possibleIssuer);
                }
                return;
              }
            }
            if (possibleIssuer.subject.equals(certificate.issuer)) {
              issuers.push(possibleIssuer);
            }
          });
          issuers = issuers.filter((issuer) => {
            try {
              return certificate.verify(issuer);
            } catch (ex) {
              return false;
            }
          });
          return issuers;
        }
        checkPath(path) {
          if (path.length < 1) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message:
                "certificate chain must contain at least one certificate",
            });
          }
          const validCAs = path.slice(1).every((cert) => cert.isCA);
          if (!validCAs) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "intermediate certificate is not a CA",
            });
          }
          for (let i = path.length - 2; i >= 0; i--) {
            if (!path[i].issuer.equals(path[i + 1].subject)) {
              throw new error_1.VerificationError({
                code: "CERTIFICATE_ERROR",
                message: "incorrect certificate name chaining",
              });
            }
          }
          for (let i = 0; i < path.length; i++) {
            const cert = path[i];
            if (cert.extBasicConstraints?.isCA) {
              const pathLength = cert.extBasicConstraints.pathLenConstraint;
              if (pathLength !== undefined && pathLength < i - 1) {
                throw new error_1.VerificationError({
                  code: "CERTIFICATE_ERROR",
                  message: "path length constraint exceeded",
                });
              }
            }
          }
        }
      }
      exports.CertificateChainVerifier = CertificateChainVerifier;
      function dedupeCertificates(certs) {
        for (let i = 0; i < certs.length; i++) {
          for (let j = i + 1; j < certs.length; j++) {
            if (certs[i].equals(certs[j])) {
              certs.splice(j, 1);
              j--;
            }
          }
        }
        return certs;
      }
    },
    6829: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyCertificate = exports.verifyPublicKey = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const certificate_1 = __nccwpck_require__(8766);
      const sct_1 = __nccwpck_require__(8669);
      const OID_FULCIO_ISSUER_V1 = "1.3.6.1.4.1.57264.1.1";
      const OID_FULCIO_ISSUER_V2 = "1.3.6.1.4.1.57264.1.8";
      function verifyPublicKey(hint, timestamps, trustMaterial) {
        const key = trustMaterial.publicKey(hint);
        timestamps.forEach((timestamp) => {
          if (!key.validFor(timestamp)) {
            throw new error_1.VerificationError({
              code: "PUBLIC_KEY_ERROR",
              message: `Public key is not valid for timestamp: ${timestamp.toISOString()}`,
            });
          }
        });
        return { key: key.publicKey };
      }
      exports.verifyPublicKey = verifyPublicKey;
      function verifyCertificate(leaf, timestamps, trustMaterial) {
        const path = (0, certificate_1.verifyCertificateChain)(
          leaf,
          trustMaterial.certificateAuthorities,
        );
        const validForDate = timestamps.every((timestamp) =>
          path.every((cert) => cert.validForDate(timestamp)),
        );
        if (!validForDate) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message:
              "certificate is not valid or expired at the specified date",
          });
        }
        return {
          scts: (0, sct_1.verifySCTs)(path[0], path[1], trustMaterial.ctlogs),
          signer: getSigner(path[0]),
        };
      }
      exports.verifyCertificate = verifyCertificate;
      function getSigner(cert) {
        let issuer;
        const issuerExtension = cert.extension(OID_FULCIO_ISSUER_V2);
        if (issuerExtension) {
          issuer = issuerExtension.valueObj.subs?.[0]?.value.toString("ascii");
        } else {
          issuer = cert
            .extension(OID_FULCIO_ISSUER_V1)
            ?.value.toString("ascii");
        }
        const identity = {
          extensions: { issuer },
          subjectAlternativeName: cert.subjectAltName,
        };
        return { key: core_1.crypto.createPublicKey(cert.publicKey), identity };
      }
    },
    8669: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifySCTs = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      function verifySCTs(cert, issuer, ctlogs) {
        let extSCT;
        const clone = cert.clone();
        for (let i = 0; i < clone.extensions.length; i++) {
          const ext = clone.extensions[i];
          if (ext.subs[0].toOID() === core_1.EXTENSION_OID_SCT) {
            extSCT = new core_1.X509SCTExtension(ext);
            clone.extensions.splice(i, 1);
            break;
          }
        }
        if (!extSCT) {
          return [];
        }
        if (extSCT.signedCertificateTimestamps.length === 0) {
          return [];
        }
        const preCert = new core_1.ByteStream();
        const issuerId = core_1.crypto.hash(issuer.publicKey);
        preCert.appendView(issuerId);
        const tbs = clone.tbsCertificate.toDER();
        preCert.appendUint24(tbs.length);
        preCert.appendView(tbs);
        return extSCT.signedCertificateTimestamps.map((sct) => {
          const validCTLogs = (0, trust_1.filterTLogAuthorities)(ctlogs, {
            logID: sct.logID,
            targetDate: sct.datetime,
          });
          const verified = validCTLogs.some((log) =>
            sct.verify(preCert.buffer, log.publicKey),
          );
          if (!verified) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "SCT verification failed",
            });
          }
          return sct.logID;
        });
      }
      exports.verifySCTs = verifySCTs;
    },
    3978: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyExtensions = exports.verifySubjectAlternativeName = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifySubjectAlternativeName(policyIdentity, signerIdentity) {
        if (
          signerIdentity === undefined ||
          !signerIdentity.match(policyIdentity)
        ) {
          throw new error_1.PolicyError({
            code: "UNTRUSTED_SIGNER_ERROR",
            message: `certificate identity error - expected ${policyIdentity}, got ${signerIdentity}`,
          });
        }
      }
      exports.verifySubjectAlternativeName = verifySubjectAlternativeName;
      function verifyExtensions(policyExtensions, signerExtensions = {}) {
        let key;
        for (key in policyExtensions) {
          if (signerExtensions[key] !== policyExtensions[key]) {
            throw new error_1.PolicyError({
              code: "UNTRUSTED_SIGNER_ERROR",
              message: `invalid certificate extension - expected ${key}=${policyExtensions[key]}, got ${key}=${signerExtensions[key]}`,
            });
          }
        }
      }
      exports.verifyExtensions = verifyExtensions;
    },
    7339: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyCheckpoint = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      const CHECKPOINT_SEPARATOR = "\n\n";
      const SIGNATURE_REGEX = /\u2014 (\S+) (\S+)\n/g;
      function verifyCheckpoint(entry, tlogs) {
        const validTLogs = (0, trust_1.filterTLogAuthorities)(tlogs, {
          targetDate: new Date(Number(entry.integratedTime) * 1e3),
        });
        const inclusionProof = entry.inclusionProof;
        const signedNote = SignedNote.fromString(
          inclusionProof.checkpoint.envelope,
        );
        const checkpoint = LogCheckpoint.fromString(signedNote.note);
        if (!verifySignedNote(signedNote, validTLogs)) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "invalid checkpoint signature",
          });
        }
        if (
          !core_1.crypto.bufferEqual(
            checkpoint.logHash,
            inclusionProof.rootHash,
          )
        ) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "root hash mismatch",
          });
        }
      }
      exports.verifyCheckpoint = verifyCheckpoint;
      function verifySignedNote(signedNote, tlogs) {
        const data = Buffer.from(signedNote.note, "utf-8");
        return signedNote.signatures.every((signature) => {
          const tlog = tlogs.find((tlog) =>
            core_1.crypto.bufferEqual(
              tlog.logID.subarray(0, 4),
              signature.keyHint,
            ),
          );
          if (!tlog) {
            return false;
          }
          return core_1.crypto.verify(
            data,
            tlog.publicKey,
            signature.signature,
          );
        });
      }
      class SignedNote {
        constructor(note, signatures) {
          this.note = note;
          this.signatures = signatures;
        }
        static fromString(envelope) {
          if (!envelope.includes(CHECKPOINT_SEPARATOR)) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "missing checkpoint separator",
            });
          }
          const split = envelope.indexOf(CHECKPOINT_SEPARATOR);
          const header = envelope.slice(0, split + 1);
          const data = envelope.slice(split + CHECKPOINT_SEPARATOR.length);
          const matches = data.matchAll(SIGNATURE_REGEX);
          const signatures = Array.from(matches, (match) => {
            const [, name, signature] = match;
            const sigBytes = Buffer.from(signature, "base64");
            if (sigBytes.length < 5) {
              throw new error_1.VerificationError({
                code: "TLOG_INCLUSION_PROOF_ERROR",
                message: "malformed checkpoint signature",
              });
            }
            return {
              name,
              keyHint: sigBytes.subarray(0, 4),
              signature: sigBytes.subarray(4),
            };
          });
          if (signatures.length === 0) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "no signatures found in checkpoint",
            });
          }
          return new SignedNote(header, signatures);
        }
      }
      class LogCheckpoint {
        constructor(origin, logSize, logHash, rest) {
          this.origin = origin;
          this.logSize = logSize;
          this.logHash = logHash;
          this.rest = rest;
        }
        static fromString(note) {
          const lines = note.trimEnd().split("\n");
          if (lines.length < 3) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "too few lines in checkpoint header",
            });
          }
          const origin = lines[0];
          const logSize = BigInt(lines[1]);
          const rootHash = Buffer.from(lines[2], "base64");
          const rest = lines.slice(3);
          return new LogCheckpoint(origin, logSize, rootHash, rest);
        }
      }
    },
    9511: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyTLogTimestamp = exports.verifyTSATimestamp = void 0;
      const error_1 = __nccwpck_require__(8948);
      const checkpoint_1 = __nccwpck_require__(7339);
      const merkle_1 = __nccwpck_require__(1407);
      const set_1 = __nccwpck_require__(7527);
      const tsa_1 = __nccwpck_require__(2574);
      function verifyTSATimestamp(timestamp, data, timestampAuthorities) {
        (0, tsa_1.verifyRFC3161Timestamp)(
          timestamp,
          data,
          timestampAuthorities,
        );
        return {
          type: "timestamp-authority",
          logID: timestamp.signerSerialNumber,
          timestamp: timestamp.signingTime,
        };
      }
      exports.verifyTSATimestamp = verifyTSATimestamp;
      function verifyTLogTimestamp(entry, tlogAuthorities) {
        let inclusionVerified = false;
        if (isTLogEntryWithInclusionPromise(entry)) {
          (0, set_1.verifyTLogSET)(entry, tlogAuthorities);
          inclusionVerified = true;
        }
        if (isTLogEntryWithInclusionProof(entry)) {
          (0, merkle_1.verifyMerkleInclusion)(entry);
          (0, checkpoint_1.verifyCheckpoint)(entry, tlogAuthorities);
          inclusionVerified = true;
        }
        if (!inclusionVerified) {
          throw new error_1.VerificationError({
            code: "TLOG_MISSING_INCLUSION_ERROR",
            message: "inclusion could not be verified",
          });
        }
        return {
          type: "transparency-log",
          logID: entry.logId.keyId,
          timestamp: new Date(Number(entry.integratedTime) * 1e3),
        };
      }
      exports.verifyTLogTimestamp = verifyTLogTimestamp;
      function isTLogEntryWithInclusionPromise(entry) {
        return entry.inclusionPromise !== undefined;
      }
      function isTLogEntryWithInclusionProof(entry) {
        return entry.inclusionProof !== undefined;
      }
    },
    1407: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyMerkleInclusion = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const RFC6962_LEAF_HASH_PREFIX = Buffer.from([0]);
      const RFC6962_NODE_HASH_PREFIX = Buffer.from([1]);
      function verifyMerkleInclusion(entry) {
        const inclusionProof = entry.inclusionProof;
        const logIndex = BigInt(inclusionProof.logIndex);
        const treeSize = BigInt(inclusionProof.treeSize);
        if (logIndex < 0n || logIndex >= treeSize) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: `invalid index: ${logIndex}`,
          });
        }
        const { inner, border } = decompInclProof(logIndex, treeSize);
        if (inclusionProof.hashes.length !== inner + border) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "invalid hash count",
          });
        }
        const innerHashes = inclusionProof.hashes.slice(0, inner);
        const borderHashes = inclusionProof.hashes.slice(inner);
        const leafHash = hashLeaf(entry.canonicalizedBody);
        const calculatedHash = chainBorderRight(
          chainInner(leafHash, innerHashes, logIndex),
          borderHashes,
        );
        if (
          !core_1.crypto.bufferEqual(calculatedHash, inclusionProof.rootHash)
        ) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "calculated root hash does not match inclusion proof",
          });
        }
      }
      exports.verifyMerkleInclusion = verifyMerkleInclusion;
      function decompInclProof(index, size) {
        const inner = innerProofSize(index, size);
        const border = onesCount(index >> BigInt(inner));
        return { inner, border };
      }
      function chainInner(seed, hashes, index) {
        return hashes.reduce((acc, h, i) => {
          if ((index >> BigInt(i)) & BigInt(1)) {
            return hashChildren(h, acc);
          } else {
            return hashChildren(acc, h);
          }
        }, seed);
      }
      function chainBorderRight(seed, hashes) {
        return hashes.reduce((acc, h) => hashChildren(h, acc), seed);
      }
      function innerProofSize(index, size) {
        return bitLength(index ^ (size - BigInt(1)));
      }
      function onesCount(num) {
        return num.toString(2).split("1").length - 1;
      }
      function bitLength(n) {
        if (n === 0n) {
          return 0;
        }
        return n.toString(2).length;
      }
      function hashChildren(left, right) {
        return core_1.crypto.hash(RFC6962_NODE_HASH_PREFIX, left, right);
      }
      function hashLeaf(leaf) {
        return core_1.crypto.hash(RFC6962_LEAF_HASH_PREFIX, leaf);
      }
    },
    7527: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyTLogSET = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      function verifyTLogSET(entry, tlogs) {
        const validTLogs = (0, trust_1.filterTLogAuthorities)(tlogs, {
          logID: entry.logId.keyId,
          targetDate: new Date(Number(entry.integratedTime) * 1e3),
        });
        const verified = validTLogs.some((tlog) => {
          const payload = toVerificationPayload(entry);
          const data = Buffer.from(core_1.json.canonicalize(payload), "utf8");
          const signature = entry.inclusionPromise.signedEntryTimestamp;
          return core_1.crypto.verify(data, tlog.publicKey, signature);
        });
        if (!verified) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROMISE_ERROR",
            message: "inclusion promise could not be verified",
          });
        }
      }
      exports.verifyTLogSET = verifyTLogSET;
      function toVerificationPayload(entry) {
        const { integratedTime, logIndex, logId, canonicalizedBody } = entry;
        return {
          body: canonicalizedBody.toString("base64"),
          integratedTime: Number(integratedTime),
          logIndex: Number(logIndex),
          logID: logId.keyId.toString("hex"),
        };
      }
    },
    2574: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyRFC3161Timestamp = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const certificate_1 = __nccwpck_require__(8766);
      const trust_1 = __nccwpck_require__(4503);
      function verifyRFC3161Timestamp(timestamp, data, timestampAuthorities) {
        const signingTime = timestamp.signingTime;
        timestampAuthorities = (0, trust_1.filterCertAuthorities)(
          timestampAuthorities,
          { start: signingTime, end: signingTime },
        );
        timestampAuthorities = filterCAsBySerialAndIssuer(
          timestampAuthorities,
          {
            serialNumber: timestamp.signerSerialNumber,
            issuer: timestamp.signerIssuer,
          },
        );
        const verified = timestampAuthorities.some((ca) => {
          try {
            verifyTimestampForCA(timestamp, data, ca);
            return true;
          } catch (e) {
            return false;
          }
        });
        if (!verified) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "timestamp could not be verified",
          });
        }
      }
      exports.verifyRFC3161Timestamp = verifyRFC3161Timestamp;
      function verifyTimestampForCA(timestamp, data, ca) {
        const [leaf, ...cas] = ca.certChain;
        const signingKey = core_1.crypto.createPublicKey(leaf.publicKey);
        const signingTime = timestamp.signingTime;
        try {
          new certificate_1.CertificateChainVerifier({
            untrustedCert: leaf,
            trustedCerts: cas,
          }).verify();
        } catch (e) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "invalid certificate chain",
          });
        }
        const validAtSigningTime = ca.certChain.every((cert) =>
          cert.validForDate(signingTime),
        );
        if (!validAtSigningTime) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "timestamp was signed with an expired certificate",
          });
        }
        timestamp.verify(data, signingKey);
      }
      function filterCAsBySerialAndIssuer(timestampAuthorities, criteria) {
        return timestampAuthorities.filter(
          (ca) =>
            ca.certChain.length > 0 &&
            core_1.crypto.bufferEqual(
              ca.certChain[0].serialNumber,
              criteria.serialNumber,
            ) &&
            core_1.crypto.bufferEqual(ca.certChain[0].issuer, criteria.issuer),
        );
      }
    },
    4625: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyDSSETLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifyDSSETLogBody(tlogEntry, content) {
        switch (tlogEntry.apiVersion) {
          case "0.0.1":
            return verifyDSSE001TLogBody(tlogEntry, content);
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported dsse version: ${tlogEntry.apiVersion}`,
            });
        }
      }
      exports.verifyDSSETLogBody = verifyDSSETLogBody;
      function verifyDSSE001TLogBody(tlogEntry, content) {
        if (tlogEntry.spec.signatures?.length !== 1) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "signature count mismatch",
          });
        }
        const tlogSig = tlogEntry.spec.signatures[0].signature;
        if (!content.compareSignature(Buffer.from(tlogSig, "base64")))
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "tlog entry signature mismatch",
          });
        const tlogHash = tlogEntry.spec.payloadHash?.value || "";
        if (!content.compareDigest(Buffer.from(tlogHash, "hex"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "DSSE payload hash mismatch",
          });
        }
      }
    },
    935: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyHashedRekordTLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifyHashedRekordTLogBody(tlogEntry, content) {
        switch (tlogEntry.apiVersion) {
          case "0.0.1":
            return verifyHashedrekord001TLogBody(tlogEntry, content);
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported hashedrekord version: ${tlogEntry.apiVersion}`,
            });
        }
      }
      exports.verifyHashedRekordTLogBody = verifyHashedRekordTLogBody;
      function verifyHashedrekord001TLogBody(tlogEntry, content) {
        const tlogSig = tlogEntry.spec.signature.content || "";
        if (!content.compareSignature(Buffer.from(tlogSig, "base64"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "signature mismatch",
          });
        }
        const tlogDigest = tlogEntry.spec.data.hash?.value || "";
        if (!content.compareDigest(Buffer.from(tlogDigest, "hex"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "digest mismatch",
          });
        }
      }
    },
    4566: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyTLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      const dsse_1 = __nccwpck_require__(4625);
      const hashedrekord_1 = __nccwpck_require__(935);
      const intoto_1 = __nccwpck_require__(3109);
      function verifyTLogBody(entry, sigContent) {
        const { kind, version } = entry.kindVersion;
        const body = JSON.parse(entry.canonicalizedBody.toString("utf8"));
        if (kind !== body.kind || version !== body.apiVersion) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: `kind/version mismatch - expected: ${kind}/${version}, received: ${body.kind}/${body.apiVersion}`,
          });
        }
        switch (body.kind) {
          case "dsse":
            return (0, dsse_1.verifyDSSETLogBody)(body, sigContent);
          case "intoto":
            return (0, intoto_1.verifyIntotoTLogBody)(body, sigContent);
          case "hashedrekord":
            return (0, hashedrekord_1.verifyHashedRekordTLogBody)(
              body,
              sigContent,
            );
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported kind: ${kind}`,
            });
        }
      }
      exports.verifyTLogBody = verifyTLogBody;
    },
    3109: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyIntotoTLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifyIntotoTLogBody(tlogEntry, content) {
        switch (tlogEntry.apiVersion) {
          case "0.0.2":
            return verifyIntoto002TLogBody(tlogEntry, content);
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported intoto version: ${tlogEntry.apiVersion}`,
            });
        }
      }
      exports.verifyIntotoTLogBody = verifyIntotoTLogBody;
      function verifyIntoto002TLogBody(tlogEntry, content) {
        if (tlogEntry.spec.content.envelope.signatures?.length !== 1) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "signature count mismatch",
          });
        }
        const tlogSig = base64Decode(
          tlogEntry.spec.content.envelope.signatures[0].sig,
        );
        if (!content.compareSignature(Buffer.from(tlogSig, "base64"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "tlog entry signature mismatch",
          });
        }
        const tlogHash = tlogEntry.spec.content.payloadHash?.value || "";
        if (!content.compareDigest(Buffer.from(tlogHash, "hex"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "DSSE payload hash mismatch",
          });
        }
      }
      function base64Decode(str) {
        return Buffer.from(str, "base64").toString("utf-8");
      }
    },
    6906: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterTLogAuthorities = exports.filterCertAuthorities = void 0;
      function filterCertAuthorities(certAuthorities, criteria) {
        return certAuthorities.filter(
          (ca) =>
            ca.validFor.start <= criteria.start &&
            ca.validFor.end >= criteria.end,
        );
      }
      exports.filterCertAuthorities = filterCertAuthorities;
      function filterTLogAuthorities(tlogAuthorities, criteria) {
        return tlogAuthorities.filter((tlog) => {
          if (criteria.logID && !tlog.logID.equals(criteria.logID)) {
            return false;
          }
          return (
            tlog.validFor.start <= criteria.targetDate &&
            criteria.targetDate <= tlog.validFor.end
          );
        });
      }
      exports.filterTLogAuthorities = filterTLogAuthorities;
    },
    4503: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toTrustMaterial =
        exports.filterTLogAuthorities =
        exports.filterCertAuthorities =
          void 0;
      const core_1 = __nccwpck_require__(3352);
      const protobuf_specs_1 = __nccwpck_require__(530);
      const error_1 = __nccwpck_require__(8948);
      const BEGINNING_OF_TIME = new Date(0);
      const END_OF_TIME = new Date(864e13);
      var filter_1 = __nccwpck_require__(6906);
      Object.defineProperty(exports, "filterCertAuthorities", {
        enumerable: true,
        get: function () {
          return filter_1.filterCertAuthorities;
        },
      });
      Object.defineProperty(exports, "filterTLogAuthorities", {
        enumerable: true,
        get: function () {
          return filter_1.filterTLogAuthorities;
        },
      });
      function toTrustMaterial(root, keys) {
        const keyFinder = typeof keys === "function" ? keys : keyLocator(keys);
        return {
          certificateAuthorities:
            root.certificateAuthorities.map(createCertAuthority),
          timestampAuthorities:
            root.timestampAuthorities.map(createCertAuthority),
          tlogs: root.tlogs.map(createTLogAuthority),
          ctlogs: root.ctlogs.map(createTLogAuthority),
          publicKey: keyFinder,
        };
      }
      exports.toTrustMaterial = toTrustMaterial;
      function createTLogAuthority(tlogInstance) {
        const keyDetails = tlogInstance.publicKey.keyDetails;
        const keyType =
          keyDetails === protobuf_specs_1.PublicKeyDetails.PKCS1_RSA_PKCS1V5 ||
          keyDetails === protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V5 ||
          keyDetails ===
            protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256 ||
          keyDetails ===
            protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256 ||
          keyDetails ===
            protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256
            ? "pkcs1"
            : "spki";
        return {
          logID: tlogInstance.logId.keyId,
          publicKey: core_1.crypto.createPublicKey(
            tlogInstance.publicKey.rawBytes,
            keyType,
          ),
          validFor: {
            start: tlogInstance.publicKey.validFor?.start || BEGINNING_OF_TIME,
            end: tlogInstance.publicKey.validFor?.end || END_OF_TIME,
          },
        };
      }
      function createCertAuthority(ca) {
        return {
          certChain: ca.certChain.certificates.map((cert) =>
            core_1.X509Certificate.parse(cert.rawBytes),
          ),
          validFor: {
            start: ca.validFor?.start || BEGINNING_OF_TIME,
            end: ca.validFor?.end || END_OF_TIME,
          },
        };
      }
      function keyLocator(keys) {
        return (hint) => {
          const key = (keys || {})[hint];
          if (!key) {
            throw new error_1.VerificationError({
              code: "PUBLIC_KEY_ERROR",
              message: `key not found: ${hint}`,
            });
          }
          return {
            publicKey: core_1.crypto.createPublicKey(key.rawBytes),
            validFor: (date) =>
              (key.validFor?.start || BEGINNING_OF_TIME) <= date &&
              (key.validFor?.end || END_OF_TIME) >= date,
          };
        };
      }
    },
    5456: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Verifier = void 0;
      const util_1 = __nccwpck_require__(3837);
      const error_1 = __nccwpck_require__(8948);
      const key_1 = __nccwpck_require__(6829);
      const policy_1 = __nccwpck_require__(3978);
      const timestamp_1 = __nccwpck_require__(9511);
      const tlog_1 = __nccwpck_require__(4566);
      class Verifier {
        constructor(trustMaterial, options = {}) {
          this.trustMaterial = trustMaterial;
          this.options = {
            ctlogThreshold: options.ctlogThreshold ?? 1,
            tlogThreshold: options.tlogThreshold ?? 1,
            tsaThreshold: options.tsaThreshold ?? 0,
          };
        }
        verify(entity, policy) {
          const timestamps = this.verifyTimestamps(entity);
          const signer = this.verifySigningKey(entity, timestamps);
          this.verifyTLogs(entity);
          this.verifySignature(entity, signer);
          if (policy) {
            this.verifyPolicy(policy, signer.identity || {});
          }
          return signer;
        }
        verifyTimestamps(entity) {
          let tlogCount = 0;
          let tsaCount = 0;
          const timestamps = entity.timestamps.map((timestamp) => {
            switch (timestamp.$case) {
              case "timestamp-authority":
                tsaCount++;
                return (0, timestamp_1.verifyTSATimestamp)(
                  timestamp.timestamp,
                  entity.signature.signature,
                  this.trustMaterial.timestampAuthorities,
                );
              case "transparency-log":
                tlogCount++;
                return (0, timestamp_1.verifyTLogTimestamp)(
                  timestamp.tlogEntry,
                  this.trustMaterial.tlogs,
                );
            }
          });
          if (containsDupes(timestamps)) {
            throw new error_1.VerificationError({
              code: "TIMESTAMP_ERROR",
              message: "duplicate timestamp",
            });
          }
          if (tlogCount < this.options.tlogThreshold) {
            throw new error_1.VerificationError({
              code: "TIMESTAMP_ERROR",
              message: `expected ${this.options.tlogThreshold} tlog timestamps, got ${tlogCount}`,
            });
          }
          if (tsaCount < this.options.tsaThreshold) {
            throw new error_1.VerificationError({
              code: "TIMESTAMP_ERROR",
              message: `expected ${this.options.tsaThreshold} tsa timestamps, got ${tsaCount}`,
            });
          }
          return timestamps.map((t) => t.timestamp);
        }
        verifySigningKey({ key }, timestamps) {
          switch (key.$case) {
            case "public-key": {
              return (0, key_1.verifyPublicKey)(
                key.hint,
                timestamps,
                this.trustMaterial,
              );
            }
            case "certificate": {
              const result = (0, key_1.verifyCertificate)(
                key.certificate,
                timestamps,
                this.trustMaterial,
              );
              if (containsDupes(result.scts)) {
                throw new error_1.VerificationError({
                  code: "CERTIFICATE_ERROR",
                  message: "duplicate SCT",
                });
              }
              if (result.scts.length < this.options.ctlogThreshold) {
                throw new error_1.VerificationError({
                  code: "CERTIFICATE_ERROR",
                  message: `expected ${this.options.ctlogThreshold} SCTs, got ${result.scts.length}`,
                });
              }
              return result.signer;
            }
          }
        }
        verifyTLogs({ signature: content, tlogEntries }) {
          tlogEntries.forEach((entry) =>
            (0, tlog_1.verifyTLogBody)(entry, content),
          );
        }
        verifySignature(entity, signer) {
          if (!entity.signature.verifySignature(signer.key)) {
            throw new error_1.VerificationError({
              code: "SIGNATURE_ERROR",
              message: "signature verification failed",
            });
          }
        }
        verifyPolicy(policy, identity) {
          if (policy.subjectAlternativeName) {
            (0, policy_1.verifySubjectAlternativeName)(
              policy.subjectAlternativeName,
              identity.subjectAlternativeName,
            );
          }
          if (policy.extensions) {
            (0, policy_1.verifyExtensions)(
              policy.extensions,
              identity.extensions,
            );
          }
        }
      }
      exports.Verifier = Verifier;
      function containsDupes(arr) {
        for (let i = 0; i < arr.length; i++) {
          for (let j = i + 1; j < arr.length; j++) {
            if ((0, util_1.isDeepStrictEqual)(arr[i], arr[j])) {
              return true;
            }
          }
        }
        return false;
      }
    },
    9652: (module) => {
      const COMMA = ",";
      const COLON = ":";
      const LEFT_SQUARE_BRACKET = "[";
      const RIGHT_SQUARE_BRACKET = "]";
      const LEFT_CURLY_BRACKET = "{";
      const RIGHT_CURLY_BRACKET = "}";
      function canonicalize(object) {
        const buffer = [];
        if (typeof object === "string") {
          buffer.push(canonicalizeString(object));
        } else if (typeof object === "boolean") {
          buffer.push(JSON.stringify(object));
        } else if (Number.isInteger(object)) {
          buffer.push(JSON.stringify(object));
        } else if (object === null) {
          buffer.push(JSON.stringify(object));
        } else if (Array.isArray(object)) {
          buffer.push(LEFT_SQUARE_BRACKET);
          let first = true;
          object.forEach((element) => {
            if (!first) {
              buffer.push(COMMA);
            }
            first = false;
            buffer.push(canonicalize(element));
          });
          buffer.push(RIGHT_SQUARE_BRACKET);
        } else if (typeof object === "object") {
          buffer.push(LEFT_CURLY_BRACKET);
          let first = true;
          Object.keys(object)
            .sort()
            .forEach((property) => {
              if (!first) {
                buffer.push(COMMA);
              }
              first = false;
              buffer.push(canonicalizeString(property));
              buffer.push(COLON);
              buffer.push(canonicalize(object[property]));
            });
          buffer.push(RIGHT_CURLY_BRACKET);
        } else {
          throw new TypeError("cannot encode " + object.toString());
        }
        return buffer.join("");
      }
      function canonicalizeString(string) {
        const escapedString = string
          .replace(/\\/g, "\\\\")
          .replace(/"/g, '\\"');
        return '"' + escapedString + '"';
      }
      module.exports = { canonicalize };
    },
    159: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signed = exports.isMetadataKind = exports.MetadataKind = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      const SPECIFICATION_VERSION = ["1", "0", "31"];
      var MetadataKind;
      (function (MetadataKind) {
        MetadataKind["Root"] = "root";
        MetadataKind["Timestamp"] = "timestamp";
        MetadataKind["Snapshot"] = "snapshot";
        MetadataKind["Targets"] = "targets";
      })(MetadataKind || (exports.MetadataKind = MetadataKind = {}));
      function isMetadataKind(value) {
        return (
          typeof value === "string" &&
          Object.values(MetadataKind).includes(value)
        );
      }
      exports.isMetadataKind = isMetadataKind;
      class Signed {
        constructor(options) {
          this.specVersion =
            options.specVersion || SPECIFICATION_VERSION.join(".");
          const specList = this.specVersion.split(".");
          if (
            !(specList.length === 2 || specList.length === 3) ||
            !specList.every((item) => isNumeric(item))
          ) {
            throw new error_1.ValueError("Failed to parse specVersion");
          }
          if (specList[0] != SPECIFICATION_VERSION[0]) {
            throw new error_1.ValueError("Unsupported specVersion");
          }
          this.expires = options.expires || new Date().toISOString();
          this.version = options.version || 1;
          this.unrecognizedFields = options.unrecognizedFields || {};
        }
        equals(other) {
          if (!(other instanceof Signed)) {
            return false;
          }
          return (
            this.specVersion === other.specVersion &&
            this.expires === other.expires &&
            this.version === other.version &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        isExpired(referenceTime) {
          if (!referenceTime) {
            referenceTime = new Date();
          }
          return referenceTime >= new Date(this.expires);
        }
        static commonFieldsFromJSON(data) {
          const { spec_version, expires, version, ...rest } = data;
          if (
            utils_1.guard.isDefined(spec_version) &&
            !(typeof spec_version === "string")
          ) {
            throw new TypeError("spec_version must be a string");
          }
          if (
            utils_1.guard.isDefined(expires) &&
            !(typeof expires === "string")
          ) {
            throw new TypeError("expires must be a string");
          }
          if (
            utils_1.guard.isDefined(version) &&
            !(typeof version === "number")
          ) {
            throw new TypeError("version must be a number");
          }
          return {
            specVersion: spec_version,
            expires,
            version,
            unrecognizedFields: rest,
          };
        }
      }
      exports.Signed = Signed;
      function isNumeric(str) {
        return !isNaN(Number(str));
      }
    },
    1662: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Delegations = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const key_1 = __nccwpck_require__(6697);
      const role_1 = __nccwpck_require__(9393);
      const utils_1 = __nccwpck_require__(5688);
      class Delegations {
        constructor(options) {
          this.keys = options.keys;
          this.unrecognizedFields = options.unrecognizedFields || {};
          if (options.roles) {
            if (
              Object.keys(options.roles).some((roleName) =>
                role_1.TOP_LEVEL_ROLE_NAMES.includes(roleName),
              )
            ) {
              throw new error_1.ValueError(
                "Delegated role name conflicts with top-level role name",
              );
            }
          }
          this.succinctRoles = options.succinctRoles;
          this.roles = options.roles;
        }
        equals(other) {
          if (!(other instanceof Delegations)) {
            return false;
          }
          return (
            util_1.default.isDeepStrictEqual(this.keys, other.keys) &&
            util_1.default.isDeepStrictEqual(this.roles, other.roles) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            ) &&
            util_1.default.isDeepStrictEqual(
              this.succinctRoles,
              other.succinctRoles,
            )
          );
        }
        *rolesForTarget(targetPath) {
          if (this.roles) {
            for (const role of Object.values(this.roles)) {
              if (role.isDelegatedPath(targetPath)) {
                yield { role: role.name, terminating: role.terminating };
              }
            }
          } else if (this.succinctRoles) {
            yield {
              role: this.succinctRoles.getRoleForTarget(targetPath),
              terminating: true,
            };
          }
        }
        toJSON() {
          const json = {
            keys: keysToJSON(this.keys),
            ...this.unrecognizedFields,
          };
          if (this.roles) {
            json.roles = rolesToJSON(this.roles);
          } else if (this.succinctRoles) {
            json.succinct_roles = this.succinctRoles.toJSON();
          }
          return json;
        }
        static fromJSON(data) {
          const { keys, roles, succinct_roles, ...unrecognizedFields } = data;
          let succinctRoles;
          if (utils_1.guard.isObject(succinct_roles)) {
            succinctRoles = role_1.SuccinctRoles.fromJSON(succinct_roles);
          }
          return new Delegations({
            keys: keysFromJSON(keys),
            roles: rolesFromJSON(roles),
            unrecognizedFields,
            succinctRoles,
          });
        }
      }
      exports.Delegations = Delegations;
      function keysToJSON(keys) {
        return Object.entries(keys).reduce(
          (acc, [keyId, key]) => ({ ...acc, [keyId]: key.toJSON() }),
          {},
        );
      }
      function rolesToJSON(roles) {
        return Object.values(roles).map((role) => role.toJSON());
      }
      function keysFromJSON(data) {
        if (!utils_1.guard.isObjectRecord(data)) {
          throw new TypeError("keys is malformed");
        }
        return Object.entries(data).reduce(
          (acc, [keyID, keyData]) => ({
            ...acc,
            [keyID]: key_1.Key.fromJSON(keyID, keyData),
          }),
          {},
        );
      }
      function rolesFromJSON(data) {
        let roleMap;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectArray(data)) {
            throw new TypeError("roles is malformed");
          }
          roleMap = data.reduce((acc, role) => {
            const delegatedRole = role_1.DelegatedRole.fromJSON(role);
            return { ...acc, [delegatedRole.name]: delegatedRole };
          }, {});
        }
        return roleMap;
      }
    },
    8448: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UnsupportedAlgorithmError =
        exports.CryptoError =
        exports.LengthOrHashMismatchError =
        exports.UnsignedMetadataError =
        exports.RepositoryError =
        exports.ValueError =
          void 0;
      class ValueError extends Error {}
      exports.ValueError = ValueError;
      class RepositoryError extends Error {}
      exports.RepositoryError = RepositoryError;
      class UnsignedMetadataError extends RepositoryError {}
      exports.UnsignedMetadataError = UnsignedMetadataError;
      class LengthOrHashMismatchError extends RepositoryError {}
      exports.LengthOrHashMismatchError = LengthOrHashMismatchError;
      class CryptoError extends Error {}
      exports.CryptoError = CryptoError;
      class UnsupportedAlgorithmError extends CryptoError {}
      exports.UnsupportedAlgorithmError = UnsupportedAlgorithmError;
    },
    1923: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TargetFile = exports.MetaFile = void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      class MetaFile {
        constructor(opts) {
          if (opts.version <= 0) {
            throw new error_1.ValueError("Metafile version must be at least 1");
          }
          if (opts.length !== undefined) {
            validateLength(opts.length);
          }
          this.version = opts.version;
          this.length = opts.length;
          this.hashes = opts.hashes;
          this.unrecognizedFields = opts.unrecognizedFields || {};
        }
        equals(other) {
          if (!(other instanceof MetaFile)) {
            return false;
          }
          return (
            this.version === other.version &&
            this.length === other.length &&
            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        verify(data) {
          if (this.length !== undefined) {
            if (data.length !== this.length) {
              throw new error_1.LengthOrHashMismatchError(
                `Expected length ${this.length} but got ${data.length}`,
              );
            }
          }
          if (this.hashes) {
            Object.entries(this.hashes).forEach(([key, value]) => {
              let hash;
              try {
                hash = crypto_1.default.createHash(key);
              } catch (e) {
                throw new error_1.LengthOrHashMismatchError(
                  `Hash algorithm ${key} not supported`,
                );
              }
              const observedHash = hash.update(data).digest("hex");
              if (observedHash !== value) {
                throw new error_1.LengthOrHashMismatchError(
                  `Expected hash ${value} but got ${observedHash}`,
                );
              }
            });
          }
        }
        toJSON() {
          const json = { version: this.version, ...this.unrecognizedFields };
          if (this.length !== undefined) {
            json.length = this.length;
          }
          if (this.hashes) {
            json.hashes = this.hashes;
          }
          return json;
        }
        static fromJSON(data) {
          const { version, length, hashes, ...rest } = data;
          if (typeof version !== "number") {
            throw new TypeError("version must be a number");
          }
          if (utils_1.guard.isDefined(length) && typeof length !== "number") {
            throw new TypeError("length must be a number");
          }
          if (
            utils_1.guard.isDefined(hashes) &&
            !utils_1.guard.isStringRecord(hashes)
          ) {
            throw new TypeError("hashes must be string keys and values");
          }
          return new MetaFile({
            version,
            length,
            hashes,
            unrecognizedFields: rest,
          });
        }
      }
      exports.MetaFile = MetaFile;
      class TargetFile {
        constructor(opts) {
          validateLength(opts.length);
          this.length = opts.length;
          this.path = opts.path;
          this.hashes = opts.hashes;
          this.unrecognizedFields = opts.unrecognizedFields || {};
        }
        get custom() {
          const custom = this.unrecognizedFields["custom"];
          if (
            !custom ||
            Array.isArray(custom) ||
            !(typeof custom === "object")
          ) {
            return {};
          }
          return custom;
        }
        equals(other) {
          if (!(other instanceof TargetFile)) {
            return false;
          }
          return (
            this.length === other.length &&
            this.path === other.path &&
            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        async verify(stream) {
          let observedLength = 0;
          const digests = Object.keys(this.hashes).reduce((acc, key) => {
            try {
              acc[key] = crypto_1.default.createHash(key);
            } catch (e) {
              throw new error_1.LengthOrHashMismatchError(
                `Hash algorithm ${key} not supported`,
              );
            }
            return acc;
          }, {});
          for await (const chunk of stream) {
            observedLength += chunk.length;
            Object.values(digests).forEach((digest) => {
              digest.update(chunk);
            });
          }
          if (observedLength !== this.length) {
            throw new error_1.LengthOrHashMismatchError(
              `Expected length ${this.length} but got ${observedLength}`,
            );
          }
          Object.entries(digests).forEach(([key, value]) => {
            const expected = this.hashes[key];
            const actual = value.digest("hex");
            if (actual !== expected) {
              throw new error_1.LengthOrHashMismatchError(
                `Expected hash ${expected} but got ${actual}`,
              );
            }
          });
        }
        toJSON() {
          return {
            length: this.length,
            hashes: this.hashes,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(path, data) {
          const { length, hashes, ...rest } = data;
          if (typeof length !== "number") {
            throw new TypeError("length must be a number");
          }
          if (!utils_1.guard.isStringRecord(hashes)) {
            throw new TypeError("hashes must have string keys and values");
          }
          return new TargetFile({
            length,
            path,
            hashes,
            unrecognizedFields: rest,
          });
        }
      }
      exports.TargetFile = TargetFile;
      function validateLength(length) {
        if (length < 0) {
          throw new error_1.ValueError("Length must be at least 0");
        }
      }
    },
    5833: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Timestamp =
        exports.Targets =
        exports.Snapshot =
        exports.Signature =
        exports.Root =
        exports.Metadata =
        exports.Key =
        exports.TargetFile =
        exports.MetaFile =
        exports.ValueError =
        exports.MetadataKind =
          void 0;
      var base_1 = __nccwpck_require__(159);
      Object.defineProperty(exports, "MetadataKind", {
        enumerable: true,
        get: function () {
          return base_1.MetadataKind;
        },
      });
      var error_1 = __nccwpck_require__(8448);
      Object.defineProperty(exports, "ValueError", {
        enumerable: true,
        get: function () {
          return error_1.ValueError;
        },
      });
      var file_1 = __nccwpck_require__(1923);
      Object.defineProperty(exports, "MetaFile", {
        enumerable: true,
        get: function () {
          return file_1.MetaFile;
        },
      });
      Object.defineProperty(exports, "TargetFile", {
        enumerable: true,
        get: function () {
          return file_1.TargetFile;
        },
      });
      var key_1 = __nccwpck_require__(6697);
      Object.defineProperty(exports, "Key", {
        enumerable: true,
        get: function () {
          return key_1.Key;
        },
      });
      var metadata_1 = __nccwpck_require__(1593);
      Object.defineProperty(exports, "Metadata", {
        enumerable: true,
        get: function () {
          return metadata_1.Metadata;
        },
      });
      var root_1 = __nccwpck_require__(9392);
      Object.defineProperty(exports, "Root", {
        enumerable: true,
        get: function () {
          return root_1.Root;
        },
      });
      var signature_1 = __nccwpck_require__(4222);
      Object.defineProperty(exports, "Signature", {
        enumerable: true,
        get: function () {
          return signature_1.Signature;
        },
      });
      var snapshot_1 = __nccwpck_require__(2326);
      Object.defineProperty(exports, "Snapshot", {
        enumerable: true,
        get: function () {
          return snapshot_1.Snapshot;
        },
      });
      var targets_1 = __nccwpck_require__(5799);
      Object.defineProperty(exports, "Targets", {
        enumerable: true,
        get: function () {
          return targets_1.Targets;
        },
      });
      var timestamp_1 = __nccwpck_require__(4042);
      Object.defineProperty(exports, "Timestamp", {
        enumerable: true,
        get: function () {
          return timestamp_1.Timestamp;
        },
      });
    },
    6697: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Key = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      const key_1 = __nccwpck_require__(8725);
      class Key {
        constructor(options) {
          const { keyID, keyType, scheme, keyVal, unrecognizedFields } =
            options;
          this.keyID = keyID;
          this.keyType = keyType;
          this.scheme = scheme;
          this.keyVal = keyVal;
          this.unrecognizedFields = unrecognizedFields || {};
        }
        verifySignature(metadata) {
          const signature = metadata.signatures[this.keyID];
          if (!signature)
            throw new error_1.UnsignedMetadataError(
              "no signature for key found in metadata",
            );
          if (!this.keyVal.public)
            throw new error_1.UnsignedMetadataError("no public key found");
          const publicKey = (0, key_1.getPublicKey)({
            keyType: this.keyType,
            scheme: this.scheme,
            keyVal: this.keyVal.public,
          });
          const signedData = metadata.signed.toJSON();
          try {
            if (
              !utils_1.crypto.verifySignature(
                signedData,
                publicKey,
                signature.sig,
              )
            ) {
              throw new error_1.UnsignedMetadataError(
                `failed to verify ${this.keyID} signature`,
              );
            }
          } catch (error) {
            if (error instanceof error_1.UnsignedMetadataError) {
              throw error;
            }
            throw new error_1.UnsignedMetadataError(
              `failed to verify ${this.keyID} signature`,
            );
          }
        }
        equals(other) {
          if (!(other instanceof Key)) {
            return false;
          }
          return (
            this.keyID === other.keyID &&
            this.keyType === other.keyType &&
            this.scheme === other.scheme &&
            util_1.default.isDeepStrictEqual(this.keyVal, other.keyVal) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        toJSON() {
          return {
            keytype: this.keyType,
            scheme: this.scheme,
            keyval: this.keyVal,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(keyID, data) {
          const { keytype, scheme, keyval, ...rest } = data;
          if (typeof keytype !== "string") {
            throw new TypeError("keytype must be a string");
          }
          if (typeof scheme !== "string") {
            throw new TypeError("scheme must be a string");
          }
          if (!utils_1.guard.isStringRecord(keyval)) {
            throw new TypeError("keyval must be a string record");
          }
          return new Key({
            keyID,
            keyType: keytype,
            scheme,
            keyVal: keyval,
            unrecognizedFields: rest,
          });
        }
      }
      exports.Key = Key;
    },
    1593: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Metadata = void 0;
      const canonical_json_1 = __nccwpck_require__(9652);
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const error_1 = __nccwpck_require__(8448);
      const root_1 = __nccwpck_require__(9392);
      const signature_1 = __nccwpck_require__(4222);
      const snapshot_1 = __nccwpck_require__(2326);
      const targets_1 = __nccwpck_require__(5799);
      const timestamp_1 = __nccwpck_require__(4042);
      const utils_1 = __nccwpck_require__(5688);
      class Metadata {
        constructor(signed, signatures, unrecognizedFields) {
          this.signed = signed;
          this.signatures = signatures || {};
          this.unrecognizedFields = unrecognizedFields || {};
        }
        sign(signer, append = true) {
          const bytes = Buffer.from(
            (0, canonical_json_1.canonicalize)(this.signed.toJSON()),
          );
          const signature = signer(bytes);
          if (!append) {
            this.signatures = {};
          }
          this.signatures[signature.keyID] = signature;
        }
        verifyDelegate(delegatedRole, delegatedMetadata) {
          let role;
          let keys = {};
          switch (this.signed.type) {
            case base_1.MetadataKind.Root:
              keys = this.signed.keys;
              role = this.signed.roles[delegatedRole];
              break;
            case base_1.MetadataKind.Targets:
              if (!this.signed.delegations) {
                throw new error_1.ValueError(
                  `No delegations found for ${delegatedRole}`,
                );
              }
              keys = this.signed.delegations.keys;
              if (this.signed.delegations.roles) {
                role = this.signed.delegations.roles[delegatedRole];
              } else if (this.signed.delegations.succinctRoles) {
                if (
                  this.signed.delegations.succinctRoles.isDelegatedRole(
                    delegatedRole,
                  )
                ) {
                  role = this.signed.delegations.succinctRoles;
                }
              }
              break;
            default:
              throw new TypeError("invalid metadata type");
          }
          if (!role) {
            throw new error_1.ValueError(
              `no delegation found for ${delegatedRole}`,
            );
          }
          const signingKeys = new Set();
          role.keyIDs.forEach((keyID) => {
            const key = keys[keyID];
            if (!key) {
              return;
            }
            try {
              key.verifySignature(delegatedMetadata);
              signingKeys.add(key.keyID);
            } catch (error) {}
          });
          if (signingKeys.size < role.threshold) {
            throw new error_1.UnsignedMetadataError(
              `${delegatedRole} was signed by ${signingKeys.size}/${role.threshold} keys`,
            );
          }
        }
        equals(other) {
          if (!(other instanceof Metadata)) {
            return false;
          }
          return (
            this.signed.equals(other.signed) &&
            util_1.default.isDeepStrictEqual(
              this.signatures,
              other.signatures,
            ) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        toJSON() {
          const signatures = Object.values(this.signatures).map((signature) =>
            signature.toJSON(),
          );
          return {
            signatures,
            signed: this.signed.toJSON(),
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(type, data) {
          const { signed, signatures, ...rest } = data;
          if (
            !utils_1.guard.isDefined(signed) ||
            !utils_1.guard.isObject(signed)
          ) {
            throw new TypeError("signed is not defined");
          }
          if (type !== signed._type) {
            throw new error_1.ValueError(
              `expected '${type}', got ${signed["_type"]}`,
            );
          }
          let signedObj;
          switch (type) {
            case base_1.MetadataKind.Root:
              signedObj = root_1.Root.fromJSON(signed);
              break;
            case base_1.MetadataKind.Timestamp:
              signedObj = timestamp_1.Timestamp.fromJSON(signed);
              break;
            case base_1.MetadataKind.Snapshot:
              signedObj = snapshot_1.Snapshot.fromJSON(signed);
              break;
            case base_1.MetadataKind.Targets:
              signedObj = targets_1.Targets.fromJSON(signed);
              break;
            default:
              throw new TypeError("invalid metadata type");
          }
          const sigMap = signaturesFromJSON(signatures);
          return new Metadata(signedObj, sigMap, rest);
        }
      }
      exports.Metadata = Metadata;
      function signaturesFromJSON(data) {
        if (!utils_1.guard.isObjectArray(data)) {
          throw new TypeError("signatures is not an array");
        }
        return data.reduce((acc, sigData) => {
          const signature = signature_1.Signature.fromJSON(sigData);
          return { ...acc, [signature.keyID]: signature };
        }, {});
      }
    },
    9393: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SuccinctRoles =
        exports.DelegatedRole =
        exports.Role =
        exports.TOP_LEVEL_ROLE_NAMES =
          void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const minimatch_1 = __nccwpck_require__(4501);
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      exports.TOP_LEVEL_ROLE_NAMES = [
        "root",
        "targets",
        "snapshot",
        "timestamp",
      ];
      class Role {
        constructor(options) {
          const { keyIDs, threshold, unrecognizedFields } = options;
          if (hasDuplicates(keyIDs)) {
            throw new error_1.ValueError("duplicate key IDs found");
          }
          if (threshold < 1) {
            throw new error_1.ValueError("threshold must be at least 1");
          }
          this.keyIDs = keyIDs;
          this.threshold = threshold;
          this.unrecognizedFields = unrecognizedFields || {};
        }
        equals(other) {
          if (!(other instanceof Role)) {
            return false;
          }
          return (
            this.threshold === other.threshold &&
            util_1.default.isDeepStrictEqual(this.keyIDs, other.keyIDs) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        toJSON() {
          return {
            keyids: this.keyIDs,
            threshold: this.threshold,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { keyids, threshold, ...rest } = data;
          if (!utils_1.guard.isStringArray(keyids)) {
            throw new TypeError("keyids must be an array");
          }
          if (typeof threshold !== "number") {
            throw new TypeError("threshold must be a number");
          }
          return new Role({
            keyIDs: keyids,
            threshold,
            unrecognizedFields: rest,
          });
        }
      }
      exports.Role = Role;
      function hasDuplicates(array) {
        return new Set(array).size !== array.length;
      }
      class DelegatedRole extends Role {
        constructor(opts) {
          super(opts);
          const { name, terminating, paths, pathHashPrefixes } = opts;
          this.name = name;
          this.terminating = terminating;
          if (opts.paths && opts.pathHashPrefixes) {
            throw new error_1.ValueError(
              "paths and pathHashPrefixes are mutually exclusive",
            );
          }
          this.paths = paths;
          this.pathHashPrefixes = pathHashPrefixes;
        }
        equals(other) {
          if (!(other instanceof DelegatedRole)) {
            return false;
          }
          return (
            super.equals(other) &&
            this.name === other.name &&
            this.terminating === other.terminating &&
            util_1.default.isDeepStrictEqual(this.paths, other.paths) &&
            util_1.default.isDeepStrictEqual(
              this.pathHashPrefixes,
              other.pathHashPrefixes,
            )
          );
        }
        isDelegatedPath(targetFilepath) {
          if (this.paths) {
            return this.paths.some((pathPattern) =>
              isTargetInPathPattern(targetFilepath, pathPattern),
            );
          }
          if (this.pathHashPrefixes) {
            const hasher = crypto_1.default.createHash("sha256");
            const pathHash = hasher.update(targetFilepath).digest("hex");
            return this.pathHashPrefixes.some((pathHashPrefix) =>
              pathHash.startsWith(pathHashPrefix),
            );
          }
          return false;
        }
        toJSON() {
          const json = {
            ...super.toJSON(),
            name: this.name,
            terminating: this.terminating,
          };
          if (this.paths) {
            json.paths = this.paths;
          }
          if (this.pathHashPrefixes) {
            json.path_hash_prefixes = this.pathHashPrefixes;
          }
          return json;
        }
        static fromJSON(data) {
          const {
            keyids,
            threshold,
            name,
            terminating,
            paths,
            path_hash_prefixes,
            ...rest
          } = data;
          if (!utils_1.guard.isStringArray(keyids)) {
            throw new TypeError("keyids must be an array of strings");
          }
          if (typeof threshold !== "number") {
            throw new TypeError("threshold must be a number");
          }
          if (typeof name !== "string") {
            throw new TypeError("name must be a string");
          }
          if (typeof terminating !== "boolean") {
            throw new TypeError("terminating must be a boolean");
          }
          if (
            utils_1.guard.isDefined(paths) &&
            !utils_1.guard.isStringArray(paths)
          ) {
            throw new TypeError("paths must be an array of strings");
          }
          if (
            utils_1.guard.isDefined(path_hash_prefixes) &&
            !utils_1.guard.isStringArray(path_hash_prefixes)
          ) {
            throw new TypeError(
              "path_hash_prefixes must be an array of strings",
            );
          }
          return new DelegatedRole({
            keyIDs: keyids,
            threshold,
            name,
            terminating,
            paths,
            pathHashPrefixes: path_hash_prefixes,
            unrecognizedFields: rest,
          });
        }
      }
      exports.DelegatedRole = DelegatedRole;
      const zip = (a, b) => a.map((k, i) => [k, b[i]]);
      function isTargetInPathPattern(target, pattern) {
        const targetParts = target.split("/");
        const patternParts = pattern.split("/");
        if (patternParts.length != targetParts.length) {
          return false;
        }
        return zip(targetParts, patternParts).every(
          ([targetPart, patternPart]) =>
            (0, minimatch_1.minimatch)(targetPart, patternPart),
        );
      }
      class SuccinctRoles extends Role {
        constructor(opts) {
          super(opts);
          const { bitLength, namePrefix } = opts;
          if (bitLength <= 0 || bitLength > 32) {
            throw new error_1.ValueError("bitLength must be between 1 and 32");
          }
          this.bitLength = bitLength;
          this.namePrefix = namePrefix;
          this.numberOfBins = Math.pow(2, bitLength);
          this.suffixLen = (this.numberOfBins - 1).toString(16).length;
        }
        equals(other) {
          if (!(other instanceof SuccinctRoles)) {
            return false;
          }
          return (
            super.equals(other) &&
            this.bitLength === other.bitLength &&
            this.namePrefix === other.namePrefix
          );
        }
        getRoleForTarget(targetFilepath) {
          const hasher = crypto_1.default.createHash("sha256");
          const hasherBuffer = hasher.update(targetFilepath).digest();
          const hashBytes = hasherBuffer.subarray(0, 4);
          const shiftValue = 32 - this.bitLength;
          const binNumber = hashBytes.readUInt32BE() >>> shiftValue;
          const suffix = binNumber.toString(16).padStart(this.suffixLen, "0");
          return `${this.namePrefix}-${suffix}`;
        }
        *getRoles() {
          for (let i = 0; i < this.numberOfBins; i++) {
            const suffix = i.toString(16).padStart(this.suffixLen, "0");
            yield `${this.namePrefix}-${suffix}`;
          }
        }
        isDelegatedRole(roleName) {
          const desiredPrefix = this.namePrefix + "-";
          if (!roleName.startsWith(desiredPrefix)) {
            return false;
          }
          const suffix = roleName.slice(desiredPrefix.length, roleName.length);
          if (suffix.length != this.suffixLen) {
            return false;
          }
          if (!suffix.match(/^[0-9a-fA-F]+$/)) {
            return false;
          }
          const num = parseInt(suffix, 16);
          return 0 <= num && num < this.numberOfBins;
        }
        toJSON() {
          const json = {
            ...super.toJSON(),
            bit_length: this.bitLength,
            name_prefix: this.namePrefix,
          };
          return json;
        }
        static fromJSON(data) {
          const { keyids, threshold, bit_length, name_prefix, ...rest } = data;
          if (!utils_1.guard.isStringArray(keyids)) {
            throw new TypeError("keyids must be an array of strings");
          }
          if (typeof threshold !== "number") {
            throw new TypeError("threshold must be a number");
          }
          if (typeof bit_length !== "number") {
            throw new TypeError("bit_length must be a number");
          }
          if (typeof name_prefix !== "string") {
            throw new TypeError("name_prefix must be a string");
          }
          return new SuccinctRoles({
            keyIDs: keyids,
            threshold,
            bitLength: bit_length,
            namePrefix: name_prefix,
            unrecognizedFields: rest,
          });
        }
      }
      exports.SuccinctRoles = SuccinctRoles;
    },
    9392: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Root = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const error_1 = __nccwpck_require__(8448);
      const key_1 = __nccwpck_require__(6697);
      const role_1 = __nccwpck_require__(9393);
      const utils_1 = __nccwpck_require__(5688);
      class Root extends base_1.Signed {
        constructor(options) {
          super(options);
          this.type = base_1.MetadataKind.Root;
          this.keys = options.keys || {};
          this.consistentSnapshot = options.consistentSnapshot ?? true;
          if (!options.roles) {
            this.roles = role_1.TOP_LEVEL_ROLE_NAMES.reduce(
              (acc, role) => ({
                ...acc,
                [role]: new role_1.Role({ keyIDs: [], threshold: 1 }),
              }),
              {},
            );
          } else {
            const roleNames = new Set(Object.keys(options.roles));
            if (
              !role_1.TOP_LEVEL_ROLE_NAMES.every((role) => roleNames.has(role))
            ) {
              throw new error_1.ValueError("missing top-level role");
            }
            this.roles = options.roles;
          }
        }
        addKey(key, role) {
          if (!this.roles[role]) {
            throw new error_1.ValueError(`role ${role} does not exist`);
          }
          if (!this.roles[role].keyIDs.includes(key.keyID)) {
            this.roles[role].keyIDs.push(key.keyID);
          }
          this.keys[key.keyID] = key;
        }
        equals(other) {
          if (!(other instanceof Root)) {
            return false;
          }
          return (
            super.equals(other) &&
            this.consistentSnapshot === other.consistentSnapshot &&
            util_1.default.isDeepStrictEqual(this.keys, other.keys) &&
            util_1.default.isDeepStrictEqual(this.roles, other.roles)
          );
        }
        toJSON() {
          return {
            _type: this.type,
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            keys: keysToJSON(this.keys),
            roles: rolesToJSON(this.roles),
            consistent_snapshot: this.consistentSnapshot,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { keys, roles, consistent_snapshot, ...rest } =
            unrecognizedFields;
          if (typeof consistent_snapshot !== "boolean") {
            throw new TypeError("consistent_snapshot must be a boolean");
          }
          return new Root({
            ...commonFields,
            keys: keysFromJSON(keys),
            roles: rolesFromJSON(roles),
            consistentSnapshot: consistent_snapshot,
            unrecognizedFields: rest,
          });
        }
      }
      exports.Root = Root;
      function keysToJSON(keys) {
        return Object.entries(keys).reduce(
          (acc, [keyID, key]) => ({ ...acc, [keyID]: key.toJSON() }),
          {},
        );
      }
      function rolesToJSON(roles) {
        return Object.entries(roles).reduce(
          (acc, [roleName, role]) => ({ ...acc, [roleName]: role.toJSON() }),
          {},
        );
      }
      function keysFromJSON(data) {
        let keys;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("keys must be an object");
          }
          keys = Object.entries(data).reduce(
            (acc, [keyID, keyData]) => ({
              ...acc,
              [keyID]: key_1.Key.fromJSON(keyID, keyData),
            }),
            {},
          );
        }
        return keys;
      }
      function rolesFromJSON(data) {
        let roles;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("roles must be an object");
          }
          roles = Object.entries(data).reduce(
            (acc, [roleName, roleData]) => ({
              ...acc,
              [roleName]: role_1.Role.fromJSON(roleData),
            }),
            {},
          );
        }
        return roles;
      }
    },
    4222: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signature = void 0;
      class Signature {
        constructor(options) {
          const { keyID, sig } = options;
          this.keyID = keyID;
          this.sig = sig;
        }
        toJSON() {
          return { keyid: this.keyID, sig: this.sig };
        }
        static fromJSON(data) {
          const { keyid, sig } = data;
          if (typeof keyid !== "string") {
            throw new TypeError("keyid must be a string");
          }
          if (typeof sig !== "string") {
            throw new TypeError("sig must be a string");
          }
          return new Signature({ keyID: keyid, sig });
        }
      }
      exports.Signature = Signature;
    },
    2326: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Snapshot = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const file_1 = __nccwpck_require__(1923);
      const utils_1 = __nccwpck_require__(5688);
      class Snapshot extends base_1.Signed {
        constructor(opts) {
          super(opts);
          this.type = base_1.MetadataKind.Snapshot;
          this.meta = opts.meta || {
            "targets.json": new file_1.MetaFile({ version: 1 }),
          };
        }
        equals(other) {
          if (!(other instanceof Snapshot)) {
            return false;
          }
          return (
            super.equals(other) &&
            util_1.default.isDeepStrictEqual(this.meta, other.meta)
          );
        }
        toJSON() {
          return {
            _type: this.type,
            meta: metaToJSON(this.meta),
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { meta, ...rest } = unrecognizedFields;
          return new Snapshot({
            ...commonFields,
            meta: metaFromJSON(meta),
            unrecognizedFields: rest,
          });
        }
      }
      exports.Snapshot = Snapshot;
      function metaToJSON(meta) {
        return Object.entries(meta).reduce(
          (acc, [path, metadata]) => ({ ...acc, [path]: metadata.toJSON() }),
          {},
        );
      }
      function metaFromJSON(data) {
        let meta;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("meta field is malformed");
          } else {
            meta = Object.entries(data).reduce(
              (acc, [path, metadata]) => ({
                ...acc,
                [path]: file_1.MetaFile.fromJSON(metadata),
              }),
              {},
            );
          }
        }
        return meta;
      }
    },
    5799: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Targets = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const delegations_1 = __nccwpck_require__(1662);
      const file_1 = __nccwpck_require__(1923);
      const utils_1 = __nccwpck_require__(5688);
      class Targets extends base_1.Signed {
        constructor(options) {
          super(options);
          this.type = base_1.MetadataKind.Targets;
          this.targets = options.targets || {};
          this.delegations = options.delegations;
        }
        addTarget(target) {
          this.targets[target.path] = target;
        }
        equals(other) {
          if (!(other instanceof Targets)) {
            return false;
          }
          return (
            super.equals(other) &&
            util_1.default.isDeepStrictEqual(this.targets, other.targets) &&
            util_1.default.isDeepStrictEqual(
              this.delegations,
              other.delegations,
            )
          );
        }
        toJSON() {
          const json = {
            _type: this.type,
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            targets: targetsToJSON(this.targets),
            ...this.unrecognizedFields,
          };
          if (this.delegations) {
            json.delegations = this.delegations.toJSON();
          }
          return json;
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { targets, delegations, ...rest } = unrecognizedFields;
          return new Targets({
            ...commonFields,
            targets: targetsFromJSON(targets),
            delegations: delegationsFromJSON(delegations),
            unrecognizedFields: rest,
          });
        }
      }
      exports.Targets = Targets;
      function targetsToJSON(targets) {
        return Object.entries(targets).reduce(
          (acc, [path, target]) => ({ ...acc, [path]: target.toJSON() }),
          {},
        );
      }
      function targetsFromJSON(data) {
        let targets;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("targets must be an object");
          } else {
            targets = Object.entries(data).reduce(
              (acc, [path, target]) => ({
                ...acc,
                [path]: file_1.TargetFile.fromJSON(path, target),
              }),
              {},
            );
          }
        }
        return targets;
      }
      function delegationsFromJSON(data) {
        let delegations;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObject(data)) {
            throw new TypeError("delegations must be an object");
          } else {
            delegations = delegations_1.Delegations.fromJSON(data);
          }
        }
        return delegations;
      }
    },
    4042: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Timestamp = void 0;
      const base_1 = __nccwpck_require__(159);
      const file_1 = __nccwpck_require__(1923);
      const utils_1 = __nccwpck_require__(5688);
      class Timestamp extends base_1.Signed {
        constructor(options) {
          super(options);
          this.type = base_1.MetadataKind.Timestamp;
          this.snapshotMeta =
            options.snapshotMeta || new file_1.MetaFile({ version: 1 });
        }
        equals(other) {
          if (!(other instanceof Timestamp)) {
            return false;
          }
          return (
            super.equals(other) && this.snapshotMeta.equals(other.snapshotMeta)
          );
        }
        toJSON() {
          return {
            _type: this.type,
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            meta: { "snapshot.json": this.snapshotMeta.toJSON() },
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { meta, ...rest } = unrecognizedFields;
          return new Timestamp({
            ...commonFields,
            snapshotMeta: snapshotMetaFromJSON(meta),
            unrecognizedFields: rest,
          });
        }
      }
      exports.Timestamp = Timestamp;
      function snapshotMetaFromJSON(data) {
        let snapshotMeta;
        if (utils_1.guard.isDefined(data)) {
          const snapshotData = data["snapshot.json"];
          if (
            !utils_1.guard.isDefined(snapshotData) ||
            !utils_1.guard.isObject(snapshotData)
          ) {
            throw new TypeError("missing snapshot.json in meta");
          } else {
            snapshotMeta = file_1.MetaFile.fromJSON(snapshotData);
          }
        }
        return snapshotMeta;
      }
    },
    7106: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isObjectRecord =
        exports.isStringRecord =
        exports.isObjectArray =
        exports.isStringArray =
        exports.isObject =
        exports.isDefined =
          void 0;
      function isDefined(val) {
        return val !== undefined;
      }
      exports.isDefined = isDefined;
      function isObject(value) {
        return typeof value === "object" && value !== null;
      }
      exports.isObject = isObject;
      function isStringArray(value) {
        return (
          Array.isArray(value) && value.every((v) => typeof v === "string")
        );
      }
      exports.isStringArray = isStringArray;
      function isObjectArray(value) {
        return Array.isArray(value) && value.every(isObject);
      }
      exports.isObjectArray = isObjectArray;
      function isStringRecord(value) {
        return (
          typeof value === "object" &&
          value !== null &&
          Object.keys(value).every((k) => typeof k === "string") &&
          Object.values(value).every((v) => typeof v === "string")
        );
      }
      exports.isStringRecord = isStringRecord;
      function isObjectRecord(value) {
        return (
          typeof value === "object" &&
          value !== null &&
          Object.keys(value).every((k) => typeof k === "string") &&
          Object.values(value).every((v) => typeof v === "object" && v !== null)
        );
      }
      exports.isObjectRecord = isObjectRecord;
    },
    5688: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = exports.guard = void 0;
      exports.guard = __importStar(__nccwpck_require__(7106));
      exports.crypto = __importStar(__nccwpck_require__(8430));
    },
    8725: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPublicKey = void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const error_1 = __nccwpck_require__(8448);
      const oid_1 = __nccwpck_require__(8680);
      const ASN1_TAG_SEQUENCE = 48;
      const ANS1_TAG_BIT_STRING = 3;
      const NULL_BYTE = 0;
      const OID_EDDSA = "1.3.101.112";
      const OID_EC_PUBLIC_KEY = "1.2.840.10045.2.1";
      const OID_EC_CURVE_P256V1 = "1.2.840.10045.3.1.7";
      const PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
      function getPublicKey(keyInfo) {
        switch (keyInfo.keyType) {
          case "rsa":
            return getRSAPublicKey(keyInfo);
          case "ed25519":
            return getED25519PublicKey(keyInfo);
          case "ecdsa":
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
            return getECDCSAPublicKey(keyInfo);
          default:
            throw new error_1.UnsupportedAlgorithmError(
              `Unsupported key type: ${keyInfo.keyType}`,
            );
        }
      }
      exports.getPublicKey = getPublicKey;
      function getRSAPublicKey(keyInfo) {
        if (!keyInfo.keyVal.startsWith(PEM_HEADER)) {
          throw new error_1.CryptoError("Invalid key format");
        }
        const key = crypto_1.default.createPublicKey(keyInfo.keyVal);
        switch (keyInfo.scheme) {
          case "rsassa-pss-sha256":
            return {
              key,
              padding: crypto_1.default.constants.RSA_PKCS1_PSS_PADDING,
            };
          default:
            throw new error_1.UnsupportedAlgorithmError(
              `Unsupported RSA scheme: ${keyInfo.scheme}`,
            );
        }
      }
      function getED25519PublicKey(keyInfo) {
        let key;
        if (keyInfo.keyVal.startsWith(PEM_HEADER)) {
          key = crypto_1.default.createPublicKey(keyInfo.keyVal);
        } else {
          if (!isHex(keyInfo.keyVal)) {
            throw new error_1.CryptoError("Invalid key format");
          }
          key = crypto_1.default.createPublicKey({
            key: ed25519.hexToDER(keyInfo.keyVal),
            format: "der",
            type: "spki",
          });
        }
        return { key };
      }
      function getECDCSAPublicKey(keyInfo) {
        let key;
        if (keyInfo.keyVal.startsWith(PEM_HEADER)) {
          key = crypto_1.default.createPublicKey(keyInfo.keyVal);
        } else {
          if (!isHex(keyInfo.keyVal)) {
            throw new error_1.CryptoError("Invalid key format");
          }
          key = crypto_1.default.createPublicKey({
            key: ecdsa.hexToDER(keyInfo.keyVal),
            format: "der",
            type: "spki",
          });
        }
        return { key };
      }
      const ed25519 = {
        hexToDER: (hex) => {
          const key = Buffer.from(hex, "hex");
          const oid = (0, oid_1.encodeOIDString)(OID_EDDSA);
          const elements = Buffer.concat([
            Buffer.concat([
              Buffer.from([ASN1_TAG_SEQUENCE]),
              Buffer.from([oid.length]),
              oid,
            ]),
            Buffer.concat([
              Buffer.from([ANS1_TAG_BIT_STRING]),
              Buffer.from([key.length + 1]),
              Buffer.from([NULL_BYTE]),
              key,
            ]),
          ]);
          const der = Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([elements.length]),
            elements,
          ]);
          return der;
        },
      };
      const ecdsa = {
        hexToDER: (hex) => {
          const key = Buffer.from(hex, "hex");
          const bitString = Buffer.concat([
            Buffer.from([ANS1_TAG_BIT_STRING]),
            Buffer.from([key.length + 1]),
            Buffer.from([NULL_BYTE]),
            key,
          ]);
          const oids = Buffer.concat([
            (0, oid_1.encodeOIDString)(OID_EC_PUBLIC_KEY),
            (0, oid_1.encodeOIDString)(OID_EC_CURVE_P256V1),
          ]);
          const oidSequence = Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([oids.length]),
            oids,
          ]);
          const der = Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([oidSequence.length + bitString.length]),
            oidSequence,
            bitString,
          ]);
          return der;
        },
      };
      const isHex = (key) => /^[0-9a-fA-F]+$/.test(key);
    },
    8680: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeOIDString = void 0;
      const ANS1_TAG_OID = 6;
      function encodeOIDString(oid) {
        const parts = oid.split(".");
        const first = parseInt(parts[0], 10) * 40 + parseInt(parts[1], 10);
        const rest = [];
        parts.slice(2).forEach((part) => {
          const bytes = encodeVariableLengthInteger(parseInt(part, 10));
          rest.push(...bytes);
        });
        const der = Buffer.from([first, ...rest]);
        return Buffer.from([ANS1_TAG_OID, der.length, ...der]);
      }
      exports.encodeOIDString = encodeOIDString;
      function encodeVariableLengthInteger(value) {
        const bytes = [];
        let mask = 0;
        while (value > 0) {
          bytes.unshift((value & 127) | mask);
          value >>= 7;
          mask = 128;
        }
        return bytes;
      }
    },
    8430: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifySignature = void 0;
      const canonical_json_1 = __nccwpck_require__(9652);
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const verifySignature = (metaDataSignedData, key, signature) => {
        const canonicalData = Buffer.from(
          (0, canonical_json_1.canonicalize)(metaDataSignedData),
        );
        return crypto_1.default.verify(
          undefined,
          canonicalData,
          key,
          Buffer.from(signature, "hex"),
        );
      };
      exports.verifySignature = verifySignature;
    },
    8348: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.req = exports.json = exports.toBuffer = void 0;
      const http = __importStar(__nccwpck_require__(3685));
      const https = __importStar(__nccwpck_require__(5687));
      async function toBuffer(stream) {
        let length = 0;
        const chunks = [];
        for await (const chunk of stream) {
          length += chunk.length;
          chunks.push(chunk);
        }
        return Buffer.concat(chunks, length);
      }
      exports.toBuffer = toBuffer;
      async function json(stream) {
        const buf = await toBuffer(stream);
        const str = buf.toString("utf8");
        try {
          return JSON.parse(str);
        } catch (_err) {
          const err = _err;
          err.message += ` (input: ${str})`;
          throw err;
        }
      }
      exports.json = json;
      function req(url, opts = {}) {
        const href = typeof url === "string" ? url : url.href;
        const req = (href.startsWith("https:") ? https : http).request(
          url,
          opts,
        );
        const promise = new Promise((resolve, reject) => {
          req.once("response", resolve).once("error", reject).end();
        });
        req.then = promise.then.bind(promise);
        return req;
      }
      exports.req = req;
    },
    694: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Agent = void 0;
      const net = __importStar(__nccwpck_require__(1808));
      const http = __importStar(__nccwpck_require__(3685));
      const https_1 = __nccwpck_require__(5687);
      __exportStar(__nccwpck_require__(8348), exports);
      const INTERNAL = Symbol("AgentBaseInternalState");
      class Agent extends http.Agent {
        constructor(opts) {
          super(opts);
          this[INTERNAL] = {};
        }
        isSecureEndpoint(options) {
          if (options) {
            if (typeof options.secureEndpoint === "boolean") {
              return options.secureEndpoint;
            }
            if (typeof options.protocol === "string") {
              return options.protocol === "https:";
            }
          }
          const { stack } = new Error();
          if (typeof stack !== "string") return false;
          return stack
            .split("\n")
            .some(
              (l) =>
                l.indexOf("(https.js:") !== -1 ||
                l.indexOf("node:https:") !== -1,
            );
        }
        incrementSockets(name) {
          if (
            this.maxSockets === Infinity &&
            this.maxTotalSockets === Infinity
          ) {
            return null;
          }
          if (!this.sockets[name]) {
            this.sockets[name] = [];
          }
          const fakeSocket = new net.Socket({ writable: false });
          this.sockets[name].push(fakeSocket);
          this.totalSocketCount++;
          return fakeSocket;
        }
        decrementSockets(name, socket) {
          if (!this.sockets[name] || socket === null) {
            return;
          }
          const sockets = this.sockets[name];
          const index = sockets.indexOf(socket);
          if (index !== -1) {
            sockets.splice(index, 1);
            this.totalSocketCount--;
            if (sockets.length === 0) {
              delete this.sockets[name];
            }
          }
        }
        getName(options) {
          const secureEndpoint =
            typeof options.secureEndpoint === "boolean"
              ? options.secureEndpoint
              : this.isSecureEndpoint(options);
          if (secureEndpoint) {
            return https_1.Agent.prototype.getName.call(this, options);
          }
          return super.getName(options);
        }
        createSocket(req, options, cb) {
          const connectOpts = {
            ...options,
            secureEndpoint: this.isSecureEndpoint(options),
          };
          const name = this.getName(connectOpts);
          const fakeSocket = this.incrementSockets(name);
          Promise.resolve()
            .then(() => this.connect(req, connectOpts))
            .then(
              (socket) => {
                this.decrementSockets(name, fakeSocket);
                if (socket instanceof http.Agent) {
                  return socket.addRequest(req, connectOpts);
                }
                this[INTERNAL].currentSocket = socket;
                super.createSocket(req, options, cb);
              },
              (err) => {
                this.decrementSockets(name, fakeSocket);
                cb(err);
              },
            );
        }
        createConnection() {
          const socket = this[INTERNAL].currentSocket;
          this[INTERNAL].currentSocket = undefined;
          if (!socket) {
            throw new Error(
              "No socket was returned in the `connect()` function",
            );
          }
          return socket;
        }
        get defaultPort() {
          return (
            this[INTERNAL].defaultPort ??
            (this.protocol === "https:" ? 443 : 80)
          );
        }
        set defaultPort(v) {
          if (this[INTERNAL]) {
            this[INTERNAL].defaultPort = v;
          }
        }
        get protocol() {
          return (
            this[INTERNAL].protocol ??
            (this.isSecureEndpoint() ? "https:" : "http:")
          );
        }
        set protocol(v) {
          if (this[INTERNAL]) {
            this[INTERNAL].protocol = v;
          }
        }
      }
      exports.Agent = Agent;
    },
    9417: (module) => {
      "use strict";
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);
        var r = range(a, b, str);
        return (
          r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length),
          }
        );
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    },
    6339: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const vendors = __nccwpck_require__(3236);
      const env = process.env;
      Object.defineProperty(exports, "_vendors", {
        value: vendors.map(function (v) {
          return v.constant;
        }),
      });
      exports.name = null;
      exports.isPR = null;
      vendors.forEach(function (vendor) {
        const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
        const isCI = envs.every(function (obj) {
          return checkEnv(obj);
        });
        exports[vendor.constant] = isCI;
        if (!isCI) {
          return;
        }
        exports.name = vendor.name;
        switch (typeof vendor.pr) {
          case "string":
            exports.isPR = !!env[vendor.pr];
            break;
          case "object":
            if ("env" in vendor.pr) {
              exports.isPR =
                vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne;
            } else if ("any" in vendor.pr) {
              exports.isPR = vendor.pr.any.some(function (key) {
                return !!env[key];
              });
            } else {
              exports.isPR = checkEnv(vendor.pr);
            }
            break;
          default:
            exports.isPR = null;
        }
      });
      exports.isCI = !!(
        env.CI !== "false" &&
        (env.BUILD_ID ||
          env.BUILD_NUMBER ||
          env.CI ||
          env.CI_APP_ID ||
          env.CI_BUILD_ID ||
          env.CI_BUILD_NUMBER ||
          env.CI_NAME ||
          env.CONTINUOUS_INTEGRATION ||
          env.RUN_ID ||
          exports.name ||
          false)
      );
      function checkEnv(obj) {
        if (typeof obj === "string") return !!env[obj];
        if ("env" in obj) {
          return env[obj.env] && env[obj.env].includes(obj.includes);
        }
        if ("any" in obj) {
          return obj.any.some(function (k) {
            return !!env[k];
          });
        }
        return Object.keys(obj).every(function (k) {
          return env[k] === obj[k];
        });
      }
    },
    8222: (module, exports, __nccwpck_require__) => {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn(
              "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
            );
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33",
      ];
      function useColors() {
        if (
          typeof window !== "undefined" &&
          window.process &&
          (window.process.type === "renderer" || window.process.__nwjs)
        ) {
          return true;
        }
        if (
          typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ) {
          return false;
        }
        let m;
        return (
          (typeof document !== "undefined" &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          (typeof window !== "undefined" &&
            window.console &&
            (window.console.firebug ||
              (window.console.exception && window.console.table))) ||
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
            parseInt(m[1], 10) >= 31) ||
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        );
      }
      function formatArgs(args) {
        args[0] =
          (this.useColors ? "%c" : "") +
          this.namespace +
          (this.useColors ? " %c" : " ") +
          args[0] +
          (this.useColors ? "%c " : " ") +
          "+" +
          module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {});
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {}
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {}
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {}
      }
      module.exports = __nccwpck_require__(6243)(exports);
      const { formatters } = module.exports;
      formatters.j = function (v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    },
    6243: (module, __unused_webpack_exports, __nccwpck_require__) => {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = __nccwpck_require__(900);
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            },
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(
            this.namespace +
              (typeof delimiter === "undefined" ? ":" : delimiter) +
              namespace,
          );
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (
            typeof namespaces === "string" ? namespaces : ""
          ).split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(
                new RegExp("^" + namespaces.slice(1) + "$"),
              );
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips
              .map(toNamespace)
              .map((namespace) => "-" + namespace),
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp
            .toString()
            .substring(2, regexp.toString().length - 2)
            .replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          );
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    },
    8237: (module, __unused_webpack_exports, __nccwpck_require__) => {
      if (
        typeof process === "undefined" ||
        process.type === "renderer" ||
        process.browser === true ||
        process.__nwjs
      ) {
        module.exports = __nccwpck_require__(8222);
      } else {
        module.exports = __nccwpck_require__(5332);
      }
    },
    5332: (module, exports, __nccwpck_require__) => {
      const tty = __nccwpck_require__(6224);
      const util = __nccwpck_require__(3837);
      exports.init = init;
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.destroy = util.deprecate(
        () => {},
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = __nccwpck_require__(132);
        if (
          supportsColor &&
          (supportsColor.stderr || supportsColor).level >= 2
        ) {
          exports.colors = [
            20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,
            63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112,
            113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165,
            166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196,
            197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
            214, 215, 220, 221,
          ];
        }
      } catch (error) {}
      exports.inspectOpts = Object.keys(process.env)
        .filter((key) => /^debug_/i.test(key))
        .reduce((obj, key) => {
          const prop = key
            .substring(6)
            .toLowerCase()
            .replace(/_([a-z])/g, (_, k) => k.toUpperCase());
          let val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }
          obj[prop] = val;
          return obj;
        }, {});
      function useColors() {
        return "colors" in exports.inspectOpts
          ? Boolean(exports.inspectOpts.colors)
          : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors } = this;
        if (useColors) {
          const c = this.color;
          const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} [0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(
            colorCode + "m+" + module.exports.humanize(this.diff) + "[0m",
          );
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      function log(...args) {
        return process.stderr.write(
          util.formatWithOptions(exports.inspectOpts, ...args) + "\n",
        );
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for (let i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }
      module.exports = __nccwpck_require__(6243)(exports);
      const { formatters } = module.exports;
      formatters.o = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util
          .inspect(v, this.inspectOpts)
          .split("\n")
          .map((str) => str.trim())
          .join(" ");
      };
      formatters.O = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    },
    8685: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var iconvLite = __nccwpck_require__(9032);
      module.exports.O = convert;
      function convert(str, to, from) {
        from = checkEncoding(from || "UTF-8");
        to = checkEncoding(to || "UTF-8");
        str = str || "";
        var result;
        if (from !== "UTF-8" && typeof str === "string") {
          str = Buffer.from(str, "binary");
        }
        if (from === to) {
          if (typeof str === "string") {
            result = Buffer.from(str);
          } else {
            result = str;
          }
        } else {
          try {
            result = convertIconvLite(str, to, from);
          } catch (E) {
            console.error(E);
            result = str;
          }
        }
        if (typeof result === "string") {
          result = Buffer.from(result, "utf-8");
        }
        return result;
      }
      function convertIconvLite(str, to, from) {
        if (to === "UTF-8") {
          return iconvLite.decode(str, from);
        } else if (from === "UTF-8") {
          return iconvLite.encode(str, to);
        } else {
          return iconvLite.encode(iconvLite.decode(str, from), to);
        }
      }
      function checkEncoding(name) {
        return (name || "")
          .toString()
          .trim()
          .replace(/^latin[\-_]?(\d+)$/i, "ISO-8859-$1")
          .replace(/^win(?:dows)?[\-_]?(\d+)$/i, "WINDOWS-$1")
          .replace(/^utf[\-_]?(\d+)$/i, "UTF-$1")
          .replace(/^ks_c_5601\-1987$/i, "CP949")
          .replace(/^us[\-_]?ascii$/i, "ASCII")
          .toUpperCase();
      }
    },
    2997: (module) => {
      "use strict";
      function assign(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
          });
        }
        return obj;
      }
      function createError(err, code, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code === "object") {
          props = code;
          code = undefined;
        }
        if (code != null) {
          props.code = code;
        }
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function () {};
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          return assign(new ErrClass(), props);
        }
      }
      module.exports = createError;
    },
    1756: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const parseUrl = __nccwpck_require__(4250);
      const isGitHubShorthand = (arg) => {
        const firstHash = arg.indexOf("#");
        const firstSlash = arg.indexOf("/");
        const secondSlash = arg.indexOf("/", firstSlash + 1);
        const firstColon = arg.indexOf(":");
        const firstSpace = /\s/.exec(arg);
        const firstAt = arg.indexOf("@");
        const spaceOnlyAfterHash =
          !firstSpace || (firstHash > -1 && firstSpace.index > firstHash);
        const atOnlyAfterHash =
          firstAt === -1 || (firstHash > -1 && firstAt > firstHash);
        const colonOnlyAfterHash =
          firstColon === -1 || (firstHash > -1 && firstColon > firstHash);
        const secondSlashOnlyAfterHash =
          secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash);
        const hasSlash = firstSlash > 0;
        const doesNotEndWithSlash =
          firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
        const doesNotStartWithDot = !arg.startsWith(".");
        return (
          spaceOnlyAfterHash &&
          hasSlash &&
          doesNotEndWithSlash &&
          doesNotStartWithDot &&
          atOnlyAfterHash &&
          colonOnlyAfterHash &&
          secondSlashOnlyAfterHash
        );
      };
      module.exports = (giturl, opts, { gitHosts, protocols }) => {
        if (!giturl) {
          return;
        }
        const correctedUrl = isGitHubShorthand(giturl)
          ? `github:${giturl}`
          : giturl;
        const parsed = parseUrl(correctedUrl, protocols);
        if (!parsed) {
          return;
        }
        const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
        const gitHostDomain =
          gitHosts.byDomain[
            parsed.hostname.startsWith("www.")
              ? parsed.hostname.slice(4)
              : parsed.hostname
          ];
        const gitHostName = gitHostShortcut || gitHostDomain;
        if (!gitHostName) {
          return;
        }
        const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
        let auth = null;
        if (
          protocols[parsed.protocol]?.auth &&
          (parsed.username || parsed.password)
        ) {
          auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
        }
        let committish = null;
        let user = null;
        let project = null;
        let defaultRepresentation = null;
        try {
          if (gitHostShortcut) {
            let pathname = parsed.pathname.startsWith("/")
              ? parsed.pathname.slice(1)
              : parsed.pathname;
            const firstAt = pathname.indexOf("@");
            if (firstAt > -1) {
              pathname = pathname.slice(firstAt + 1);
            }
            const lastSlash = pathname.lastIndexOf("/");
            if (lastSlash > -1) {
              user = decodeURIComponent(pathname.slice(0, lastSlash));
              if (!user) {
                user = null;
              }
              project = decodeURIComponent(pathname.slice(lastSlash + 1));
            } else {
              project = decodeURIComponent(pathname);
            }
            if (project.endsWith(".git")) {
              project = project.slice(0, -4);
            }
            if (parsed.hash) {
              committish = decodeURIComponent(parsed.hash.slice(1));
            }
            defaultRepresentation = "shortcut";
          } else {
            if (!gitHostInfo.protocols.includes(parsed.protocol)) {
              return;
            }
            const segments = gitHostInfo.extract(parsed);
            if (!segments) {
              return;
            }
            user = segments.user && decodeURIComponent(segments.user);
            project = decodeURIComponent(segments.project);
            committish = decodeURIComponent(segments.committish);
            defaultRepresentation =
              protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
          }
        } catch (err) {
          if (err instanceof URIError) {
            return;
          } else {
            throw err;
          }
        }
        return [
          gitHostName,
          user,
          auth,
          project,
          committish,
          defaultRepresentation,
          opts,
        ];
      };
    },
    5572: (module) => {
      "use strict";
      const maybeJoin = (...args) =>
        args.every((arg) => arg) ? args.join("") : "";
      const maybeEncode = (arg) => (arg ? encodeURIComponent(arg) : "");
      const formatHashFragment = (f) =>
        f
          .toLowerCase()
          .replace(/^\W+|\/|\W+$/g, "")
          .replace(/\W+/g, "-");
      const defaults = {
        sshtemplate: ({ domain, user, project, committish }) =>
          `git@${domain}:${user}/${project}.git${maybeJoin("#", committish)}`,
        sshurltemplate: ({ domain, user, project, committish }) =>
          `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        edittemplate: ({ domain, user, project, committish, editpath, path }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", editpath, "/", maybeEncode(committish || "HEAD"), "/", path)}`,
        browsetemplate: ({ domain, user, project, committish, treepath }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}`,
        browsetreetemplate: ({
          domain,
          user,
          project,
          committish,
          treepath,
          path,
          fragment,
          hashformat,
        }) =>
          `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || "HEAD")}/${path}${maybeJoin("#", hashformat(fragment || ""))}`,
        browseblobtemplate: ({
          domain,
          user,
          project,
          committish,
          blobpath,
          path,
          fragment,
          hashformat,
        }) =>
          `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || "HEAD")}/${path}${maybeJoin("#", hashformat(fragment || ""))}`,
        docstemplate: ({ domain, user, project, treepath, committish }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}#readme`,
        httpstemplate: ({ auth, domain, user, project, committish }) =>
          `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        filetemplate: ({ domain, user, project, committish, path }) =>
          `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || "HEAD")}/${path}`,
        shortcuttemplate: ({ type, user, project, committish }) =>
          `${type}:${user}/${project}${maybeJoin("#", committish)}`,
        pathtemplate: ({ user, project, committish }) =>
          `${user}/${project}${maybeJoin("#", committish)}`,
        bugstemplate: ({ domain, user, project }) =>
          `https://${domain}/${user}/${project}/issues`,
        hashformat: formatHashFragment,
      };
      const hosts = {};
      hosts.github = {
        protocols: [
          "git:",
          "http:",
          "git+ssh:",
          "git+https:",
          "ssh:",
          "https:",
        ],
        domain: "github.com",
        treepath: "tree",
        blobpath: "blob",
        editpath: "edit",
        filetemplate: ({ auth, user, project, committish, path }) =>
          `https://${maybeJoin(auth, "@")}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || "HEAD")}/${path}`,
        gittemplate: ({ auth, domain, user, project, committish }) =>
          `git://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
        extract: (url) => {
          let [, user, project, type, committish] = url.pathname.split("/", 5);
          if (type && type !== "tree") {
            return;
          }
          if (!type) {
            committish = url.hash.slice(1);
          }
          if (project && project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (!user || !project) {
            return;
          }
          return { user, project, committish };
        },
      };
      hosts.bitbucket = {
        protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
        domain: "bitbucket.org",
        treepath: "src",
        blobpath: "src",
        editpath: "?mode=edit",
        edittemplate: ({
          domain,
          user,
          project,
          committish,
          treepath,
          path,
          editpath,
        }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish || "HEAD"), "/", path, editpath)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}/get/${maybeEncode(committish || "HEAD")}.tar.gz`,
        extract: (url) => {
          let [, user, project, aux] = url.pathname.split("/", 4);
          if (["get"].includes(aux)) {
            return;
          }
          if (project && project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (!user || !project) {
            return;
          }
          return { user, project, committish: url.hash.slice(1) };
        },
      };
      hosts.gitlab = {
        protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
        domain: "gitlab.com",
        treepath: "tree",
        blobpath: "tree",
        editpath: "-/edit",
        httpstemplate: ({ auth, domain, user, project, committish }) =>
          `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || "HEAD")}`,
        extract: (url) => {
          const path = url.pathname.slice(1);
          if (path.includes("/-/") || path.includes("/archive.tar.gz")) {
            return;
          }
          const segments = path.split("/");
          let project = segments.pop();
          if (project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          const user = segments.join("/");
          if (!user || !project) {
            return;
          }
          return { user, project, committish: url.hash.slice(1) };
        },
      };
      hosts.gist = {
        protocols: ["git:", "git+ssh:", "git+https:", "ssh:", "https:"],
        domain: "gist.github.com",
        editpath: "edit",
        sshtemplate: ({ domain, project, committish }) =>
          `git@${domain}:${project}.git${maybeJoin("#", committish)}`,
        sshurltemplate: ({ domain, project, committish }) =>
          `git+ssh://git@${domain}/${project}.git${maybeJoin("#", committish)}`,
        edittemplate: ({ domain, user, project, committish, editpath }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", maybeEncode(committish))}/${editpath}`,
        browsetemplate: ({ domain, project, committish }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
        browsetreetemplate: ({
          domain,
          project,
          committish,
          path,
          hashformat,
        }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path))}`,
        browseblobtemplate: ({
          domain,
          project,
          committish,
          path,
          hashformat,
        }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path))}`,
        docstemplate: ({ domain, project, committish }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
        httpstemplate: ({ domain, project, committish }) =>
          `git+https://${domain}/${project}.git${maybeJoin("#", committish)}`,
        filetemplate: ({ user, project, committish, path }) =>
          `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin("/", maybeEncode(committish))}/${path}`,
        shortcuttemplate: ({ type, project, committish }) =>
          `${type}:${project}${maybeJoin("#", committish)}`,
        pathtemplate: ({ project, committish }) =>
          `${project}${maybeJoin("#", committish)}`,
        bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
        gittemplate: ({ domain, project, committish }) =>
          `git://${domain}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ project, committish }) =>
          `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
        extract: (url) => {
          let [, user, project, aux] = url.pathname.split("/", 4);
          if (aux === "raw") {
            return;
          }
          if (!project) {
            if (!user) {
              return;
            }
            project = user;
            user = null;
          }
          if (project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          return { user, project, committish: url.hash.slice(1) };
        },
        hashformat: function (fragment) {
          return fragment && "file-" + formatHashFragment(fragment);
        },
      };
      hosts.sourcehut = {
        protocols: ["git+ssh:", "https:"],
        domain: "git.sr.ht",
        treepath: "tree",
        blobpath: "tree",
        filetemplate: ({ domain, user, project, committish, path }) =>
          `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || "HEAD"}/${path}`,
        httpstemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || "HEAD"}.tar.gz`,
        bugstemplate: () => null,
        extract: (url) => {
          let [, user, project, aux] = url.pathname.split("/", 4);
          if (["archive"].includes(aux)) {
            return;
          }
          if (project && project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (!user || !project) {
            return;
          }
          return { user, project, committish: url.hash.slice(1) };
        },
      };
      for (const [name, host] of Object.entries(hosts)) {
        hosts[name] = Object.assign({}, defaults, host);
      }
      module.exports = hosts;
    },
    167: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { LRUCache } = __nccwpck_require__(3866);
      const hosts = __nccwpck_require__(5572);
      const fromUrl = __nccwpck_require__(1756);
      const parseUrl = __nccwpck_require__(4250);
      const cache = new LRUCache({ max: 1e3 });
      class GitHost {
        constructor(
          type,
          user,
          auth,
          project,
          committish,
          defaultRepresentation,
          opts = {},
        ) {
          Object.assign(this, GitHost.#gitHosts[type], {
            type,
            user,
            auth,
            project,
            committish,
            default: defaultRepresentation,
            opts,
          });
        }
        static #gitHosts = { byShortcut: {}, byDomain: {} };
        static #protocols = {
          "git+ssh:": { name: "sshurl" },
          "ssh:": { name: "sshurl" },
          "git+https:": { name: "https", auth: true },
          "git:": { auth: true },
          "http:": { auth: true },
          "https:": { auth: true },
          "git+http:": { auth: true },
        };
        static addHost(name, host) {
          GitHost.#gitHosts[name] = host;
          GitHost.#gitHosts.byDomain[host.domain] = name;
          GitHost.#gitHosts.byShortcut[`${name}:`] = name;
          GitHost.#protocols[`${name}:`] = { name };
        }
        static fromUrl(giturl, opts) {
          if (typeof giturl !== "string") {
            return;
          }
          const key = giturl + JSON.stringify(opts || {});
          if (!cache.has(key)) {
            const hostArgs = fromUrl(giturl, opts, {
              gitHosts: GitHost.#gitHosts,
              protocols: GitHost.#protocols,
            });
            cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined);
          }
          return cache.get(key);
        }
        static parseUrl(url) {
          return parseUrl(url);
        }
        #fill(template, opts) {
          if (typeof template !== "function") {
            return null;
          }
          const options = { ...this, ...this.opts, ...opts };
          if (!options.path) {
            options.path = "";
          }
          if (options.path.startsWith("/")) {
            options.path = options.path.slice(1);
          }
          if (options.noCommittish) {
            options.committish = null;
          }
          const result = template(options);
          return options.noGitPlus && result.startsWith("git+")
            ? result.slice(4)
            : result;
        }
        hash() {
          return this.committish ? `#${this.committish}` : "";
        }
        ssh(opts) {
          return this.#fill(this.sshtemplate, opts);
        }
        sshurl(opts) {
          return this.#fill(this.sshurltemplate, opts);
        }
        browse(path, ...args) {
          if (typeof path !== "string") {
            return this.#fill(this.browsetemplate, path);
          }
          if (typeof args[0] !== "string") {
            return this.#fill(this.browsetreetemplate, { ...args[0], path });
          }
          return this.#fill(this.browsetreetemplate, {
            ...args[1],
            fragment: args[0],
            path,
          });
        }
        browseFile(path, ...args) {
          if (typeof args[0] !== "string") {
            return this.#fill(this.browseblobtemplate, { ...args[0], path });
          }
          return this.#fill(this.browseblobtemplate, {
            ...args[1],
            fragment: args[0],
            path,
          });
        }
        docs(opts) {
          return this.#fill(this.docstemplate, opts);
        }
        bugs(opts) {
          return this.#fill(this.bugstemplate, opts);
        }
        https(opts) {
          return this.#fill(this.httpstemplate, opts);
        }
        git(opts) {
          return this.#fill(this.gittemplate, opts);
        }
        shortcut(opts) {
          return this.#fill(this.shortcuttemplate, opts);
        }
        path(opts) {
          return this.#fill(this.pathtemplate, opts);
        }
        tarball(opts) {
          return this.#fill(this.tarballtemplate, {
            ...opts,
            noCommittish: false,
          });
        }
        file(path, opts) {
          return this.#fill(this.filetemplate, { ...opts, path });
        }
        edit(path, opts) {
          return this.#fill(this.edittemplate, { ...opts, path });
        }
        getDefaultRepresentation() {
          return this.default;
        }
        toString(opts) {
          if (this.default && typeof this[this.default] === "function") {
            return this[this.default](opts);
          }
          return this.sshurl(opts);
        }
      }
      for (const [name, host] of Object.entries(hosts)) {
        GitHost.addHost(name, host);
      }
      module.exports = GitHost;
    },
    4250: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const url = __nccwpck_require__(7310);
      const lastIndexOfBefore = (str, char, beforeChar) => {
        const startPosition = str.indexOf(beforeChar);
        return str.lastIndexOf(
          char,
          startPosition > -1 ? startPosition : Infinity,
        );
      };
      const safeUrl = (u) => {
        try {
          return new url.URL(u);
        } catch {}
      };
      const correctProtocol = (arg, protocols) => {
        const firstColon = arg.indexOf(":");
        const proto = arg.slice(0, firstColon + 1);
        if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
          return arg;
        }
        const firstAt = arg.indexOf("@");
        if (firstAt > -1) {
          if (firstAt > firstColon) {
            return `git+ssh://${arg}`;
          } else {
            return arg;
          }
        }
        const doubleSlash = arg.indexOf("//");
        if (doubleSlash === firstColon + 1) {
          return arg;
        }
        return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
      };
      const correctUrl = (giturl) => {
        const firstAt = lastIndexOfBefore(giturl, "@", "#");
        const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
        if (lastColonBeforeHash > firstAt) {
          giturl =
            giturl.slice(0, lastColonBeforeHash) +
            "/" +
            giturl.slice(lastColonBeforeHash + 1);
        }
        if (
          lastIndexOfBefore(giturl, ":", "#") === -1 &&
          giturl.indexOf("//") === -1
        ) {
          giturl = `git+ssh://${giturl}`;
        }
        return giturl;
      };
      module.exports = (giturl, protocols) => {
        const withProtocol = protocols
          ? correctProtocol(giturl, protocols)
          : giturl;
        return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
      };
    },
    1002: (module) => {
      "use strict";
      const statusCodeCacheableByDefault = new Set([
        200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501,
      ]);
      const understoodStatuses = new Set([
        200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501,
      ]);
      const errorStatusCodes = new Set([500, 502, 503, 504]);
      const hopByHopHeaders = {
        date: true,
        connection: true,
        "keep-alive": true,
        "proxy-authenticate": true,
        "proxy-authorization": true,
        te: true,
        trailer: true,
        "transfer-encoding": true,
        upgrade: true,
      };
      const excludedFromRevalidationUpdate = {
        "content-length": true,
        "content-encoding": true,
        "transfer-encoding": true,
        "content-range": true,
      };
      function toNumberOrZero(s) {
        const n = parseInt(s, 10);
        return isFinite(n) ? n : 0;
      }
      function isErrorResponse(response) {
        if (!response) {
          return true;
        }
        return errorStatusCodes.has(response.status);
      }
      function parseCacheControl(header) {
        const cc = {};
        if (!header) return cc;
        const parts = header.trim().split(/,/);
        for (const part of parts) {
          const [k, v] = part.split(/=/, 2);
          cc[k.trim()] =
            v === undefined ? true : v.trim().replace(/^"|"$/g, "");
        }
        return cc;
      }
      function formatCacheControl(cc) {
        let parts = [];
        for (const k in cc) {
          const v = cc[k];
          parts.push(v === true ? k : k + "=" + v);
        }
        if (!parts.length) {
          return undefined;
        }
        return parts.join(", ");
      }
      module.exports = class CachePolicy {
        constructor(
          req,
          res,
          {
            shared,
            cacheHeuristic,
            immutableMinTimeToLive,
            ignoreCargoCult,
            _fromObject,
          } = {},
        ) {
          if (_fromObject) {
            this._fromObject(_fromObject);
            return;
          }
          if (!res || !res.headers) {
            throw Error("Response headers missing");
          }
          this._assertRequestHasHeaders(req);
          this._responseTime = this.now();
          this._isShared = shared !== false;
          this._cacheHeuristic =
            undefined !== cacheHeuristic ? cacheHeuristic : 0.1;
          this._immutableMinTtl =
            undefined !== immutableMinTimeToLive
              ? immutableMinTimeToLive
              : 24 * 3600 * 1e3;
          this._status = "status" in res ? res.status : 200;
          this._resHeaders = res.headers;
          this._rescc = parseCacheControl(res.headers["cache-control"]);
          this._method = "method" in req ? req.method : "GET";
          this._url = req.url;
          this._host = req.headers.host;
          this._noAuthorization = !req.headers.authorization;
          this._reqHeaders = res.headers.vary ? req.headers : null;
          this._reqcc = parseCacheControl(req.headers["cache-control"]);
          if (
            ignoreCargoCult &&
            "pre-check" in this._rescc &&
            "post-check" in this._rescc
          ) {
            delete this._rescc["pre-check"];
            delete this._rescc["post-check"];
            delete this._rescc["no-cache"];
            delete this._rescc["no-store"];
            delete this._rescc["must-revalidate"];
            this._resHeaders = Object.assign({}, this._resHeaders, {
              "cache-control": formatCacheControl(this._rescc),
            });
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
          }
          if (
            res.headers["cache-control"] == null &&
            /no-cache/.test(res.headers.pragma)
          ) {
            this._rescc["no-cache"] = true;
          }
        }
        now() {
          return Date.now();
        }
        storable() {
          return !!(
            !this._reqcc["no-store"] &&
            ("GET" === this._method ||
              "HEAD" === this._method ||
              ("POST" === this._method && this._hasExplicitExpiration())) &&
            understoodStatuses.has(this._status) &&
            !this._rescc["no-store"] &&
            (!this._isShared || !this._rescc.private) &&
            (!this._isShared ||
              this._noAuthorization ||
              this._allowsStoringAuthenticated()) &&
            (this._resHeaders.expires ||
              this._rescc["max-age"] ||
              (this._isShared && this._rescc["s-maxage"]) ||
              this._rescc.public ||
              statusCodeCacheableByDefault.has(this._status))
          );
        }
        _hasExplicitExpiration() {
          return (
            (this._isShared && this._rescc["s-maxage"]) ||
            this._rescc["max-age"] ||
            this._resHeaders.expires
          );
        }
        _assertRequestHasHeaders(req) {
          if (!req || !req.headers) {
            throw Error("Request headers missing");
          }
        }
        satisfiesWithoutRevalidation(req) {
          this._assertRequestHasHeaders(req);
          const requestCC = parseCacheControl(req.headers["cache-control"]);
          if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
            return false;
          }
          if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
            return false;
          }
          if (
            requestCC["min-fresh"] &&
            this.timeToLive() < 1e3 * requestCC["min-fresh"]
          ) {
            return false;
          }
          if (this.stale()) {
            const allowsStale =
              requestCC["max-stale"] &&
              !this._rescc["must-revalidate"] &&
              (true === requestCC["max-stale"] ||
                requestCC["max-stale"] > this.age() - this.maxAge());
            if (!allowsStale) {
              return false;
            }
          }
          return this._requestMatches(req, false);
        }
        _requestMatches(req, allowHeadMethod) {
          return (
            (!this._url || this._url === req.url) &&
            this._host === req.headers.host &&
            (!req.method ||
              this._method === req.method ||
              (allowHeadMethod && "HEAD" === req.method)) &&
            this._varyMatches(req)
          );
        }
        _allowsStoringAuthenticated() {
          return (
            this._rescc["must-revalidate"] ||
            this._rescc.public ||
            this._rescc["s-maxage"]
          );
        }
        _varyMatches(req) {
          if (!this._resHeaders.vary) {
            return true;
          }
          if (this._resHeaders.vary === "*") {
            return false;
          }
          const fields = this._resHeaders.vary
            .trim()
            .toLowerCase()
            .split(/\s*,\s*/);
          for (const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
          }
          return true;
        }
        _copyWithoutHopByHopHeaders(inHeaders) {
          const headers = {};
          for (const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
          }
          if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for (const name of tokens) {
              delete headers[name];
            }
          }
          if (headers.warning) {
            const warnings = headers.warning
              .split(/,/)
              .filter((warning) => !/^\s*1[0-9][0-9]/.test(warning));
            if (!warnings.length) {
              delete headers.warning;
            } else {
              headers.warning = warnings.join(",").trim();
            }
          }
          return headers;
        }
        responseHeaders() {
          const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
          const age = this.age();
          if (
            age > 3600 * 24 &&
            !this._hasExplicitExpiration() &&
            this.maxAge() > 3600 * 24
          ) {
            headers.warning =
              (headers.warning ? `${headers.warning}, ` : "") +
              '113 - "rfc7234 5.5.4"';
          }
          headers.age = `${Math.round(age)}`;
          headers.date = new Date(this.now()).toUTCString();
          return headers;
        }
        date() {
          const serverDate = Date.parse(this._resHeaders.date);
          if (isFinite(serverDate)) {
            return serverDate;
          }
          return this._responseTime;
        }
        age() {
          let age = this._ageValue();
          const residentTime = (this.now() - this._responseTime) / 1e3;
          return age + residentTime;
        }
        _ageValue() {
          return toNumberOrZero(this._resHeaders.age);
        }
        maxAge() {
          if (!this.storable() || this._rescc["no-cache"]) {
            return 0;
          }
          if (
            this._isShared &&
            this._resHeaders["set-cookie"] &&
            !this._rescc.public &&
            !this._rescc.immutable
          ) {
            return 0;
          }
          if (this._resHeaders.vary === "*") {
            return 0;
          }
          if (this._isShared) {
            if (this._rescc["proxy-revalidate"]) {
              return 0;
            }
            if (this._rescc["s-maxage"]) {
              return toNumberOrZero(this._rescc["s-maxage"]);
            }
          }
          if (this._rescc["max-age"]) {
            return toNumberOrZero(this._rescc["max-age"]);
          }
          const defaultMinTtl = this._rescc.immutable
            ? this._immutableMinTtl
            : 0;
          const serverDate = this.date();
          if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            if (Number.isNaN(expires) || expires < serverDate) {
              return 0;
            }
            return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
          }
          if (this._resHeaders["last-modified"]) {
            const lastModified = Date.parse(this._resHeaders["last-modified"]);
            if (isFinite(lastModified) && serverDate > lastModified) {
              return Math.max(
                defaultMinTtl,
                ((serverDate - lastModified) / 1e3) * this._cacheHeuristic,
              );
            }
          }
          return defaultMinTtl;
        }
        timeToLive() {
          const age = this.maxAge() - this.age();
          const staleIfErrorAge =
            age + toNumberOrZero(this._rescc["stale-if-error"]);
          const staleWhileRevalidateAge =
            age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
          return (
            Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3
          );
        }
        stale() {
          return this.maxAge() <= this.age();
        }
        _useStaleIfError() {
          return (
            this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) >
            this.age()
          );
        }
        useStaleWhileRevalidate() {
          return (
            this.maxAge() +
              toNumberOrZero(this._rescc["stale-while-revalidate"]) >
            this.age()
          );
        }
        static fromObject(obj) {
          return new this(undefined, undefined, { _fromObject: obj });
        }
        _fromObject(obj) {
          if (this._responseTime) throw Error("Reinitialized");
          if (!obj || obj.v !== 1) throw Error("Invalid serialization");
          this._responseTime = obj.t;
          this._isShared = obj.sh;
          this._cacheHeuristic = obj.ch;
          this._immutableMinTtl =
            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1e3;
          this._status = obj.st;
          this._resHeaders = obj.resh;
          this._rescc = obj.rescc;
          this._method = obj.m;
          this._url = obj.u;
          this._host = obj.h;
          this._noAuthorization = obj.a;
          this._reqHeaders = obj.reqh;
          this._reqcc = obj.reqcc;
        }
        toObject() {
          return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
          };
        }
        revalidationHeaders(incomingReq) {
          this._assertRequestHasHeaders(incomingReq);
          const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
          delete headers["if-range"];
          if (!this._requestMatches(incomingReq, true) || !this.storable()) {
            delete headers["if-none-match"];
            delete headers["if-modified-since"];
            return headers;
          }
          if (this._resHeaders.etag) {
            headers["if-none-match"] = headers["if-none-match"]
              ? `${headers["if-none-match"]}, ${this._resHeaders.etag}`
              : this._resHeaders.etag;
          }
          const forbidsWeakValidators =
            headers["accept-ranges"] ||
            headers["if-match"] ||
            headers["if-unmodified-since"] ||
            (this._method && this._method != "GET");
          if (forbidsWeakValidators) {
            delete headers["if-modified-since"];
            if (headers["if-none-match"]) {
              const etags = headers["if-none-match"]
                .split(/,/)
                .filter((etag) => !/^\s*W\//.test(etag));
              if (!etags.length) {
                delete headers["if-none-match"];
              } else {
                headers["if-none-match"] = etags.join(",").trim();
              }
            }
          } else if (
            this._resHeaders["last-modified"] &&
            !headers["if-modified-since"]
          ) {
            headers["if-modified-since"] = this._resHeaders["last-modified"];
          }
          return headers;
        }
        revalidatedPolicy(request, response) {
          this._assertRequestHasHeaders(request);
          if (this._useStaleIfError() && isErrorResponse(response)) {
            return { modified: false, matches: false, policy: this };
          }
          if (!response || !response.headers) {
            throw Error("Response headers missing");
          }
          let matches = false;
          if (response.status !== undefined && response.status != 304) {
            matches = false;
          } else if (
            response.headers.etag &&
            !/^\s*W\//.test(response.headers.etag)
          ) {
            matches =
              this._resHeaders.etag &&
              this._resHeaders.etag.replace(/^\s*W\//, "") ===
                response.headers.etag;
          } else if (this._resHeaders.etag && response.headers.etag) {
            matches =
              this._resHeaders.etag.replace(/^\s*W\//, "") ===
              response.headers.etag.replace(/^\s*W\//, "");
          } else if (this._resHeaders["last-modified"]) {
            matches =
              this._resHeaders["last-modified"] ===
              response.headers["last-modified"];
          } else {
            if (
              !this._resHeaders.etag &&
              !this._resHeaders["last-modified"] &&
              !response.headers.etag &&
              !response.headers["last-modified"]
            ) {
              matches = true;
            }
          }
          if (!matches) {
            return {
              policy: new this.constructor(request, response),
              modified: response.status != 304,
              matches: false,
            };
          }
          const headers = {};
          for (const k in this._resHeaders) {
            headers[k] =
              k in response.headers && !excludedFromRevalidationUpdate[k]
                ? response.headers[k]
                : this._resHeaders[k];
          }
          const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
          });
          return {
            policy: new this.constructor(request, newResponse, {
              shared: this._isShared,
              cacheHeuristic: this._cacheHeuristic,
              immutableMinTimeToLive: this._immutableMinTtl,
            }),
            modified: false,
            matches: true,
          };
        }
      };
    },
    3764: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpProxyAgent = void 0;
      const net = __importStar(__nccwpck_require__(1808));
      const tls = __importStar(__nccwpck_require__(4404));
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const events_1 = __nccwpck_require__(2361);
      const agent_base_1 = __nccwpck_require__(694);
      const url_1 = __nccwpck_require__(7310);
      const debug = (0, debug_1.default)("http-proxy-agent");
      class HttpProxyAgent extends agent_base_1.Agent {
        constructor(proxy, opts) {
          super(opts);
          this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
          this.proxyHeaders = opts?.headers ?? {};
          debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
          const host = (this.proxy.hostname || this.proxy.host).replace(
            /^\[|\]$/g,
            "",
          );
          const port = this.proxy.port
            ? parseInt(this.proxy.port, 10)
            : this.proxy.protocol === "https:"
              ? 443
              : 80;
          this.connectOpts = {
            ...(opts ? omit(opts, "headers") : null),
            host,
            port,
          };
        }
        addRequest(req, opts) {
          req._header = null;
          this.setRequestProps(req, opts);
          super.addRequest(req, opts);
        }
        setRequestProps(req, opts) {
          const { proxy } = this;
          const protocol = opts.secureEndpoint ? "https:" : "http:";
          const hostname = req.getHeader("host") || "localhost";
          const base = `${protocol}//${hostname}`;
          const url = new url_1.URL(req.path, base);
          if (opts.port !== 80) {
            url.port = String(opts.port);
          }
          req.path = String(url);
          const headers =
            typeof this.proxyHeaders === "function"
              ? this.proxyHeaders()
              : { ...this.proxyHeaders };
          if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers["Proxy-Authorization"] =
              `Basic ${Buffer.from(auth).toString("base64")}`;
          }
          if (!headers["Proxy-Connection"]) {
            headers["Proxy-Connection"] = this.keepAlive
              ? "Keep-Alive"
              : "close";
          }
          for (const name of Object.keys(headers)) {
            const value = headers[name];
            if (value) {
              req.setHeader(name, value);
            }
          }
        }
        async connect(req, opts) {
          req._header = null;
          if (!req.path.includes("://")) {
            this.setRequestProps(req, opts);
          }
          let first;
          let endOfHeaders;
          debug("Regenerating stored HTTP header string for request");
          req._implicitHeader();
          if (req.outputData && req.outputData.length > 0) {
            debug(
              "Patching connection write() output buffer with updated header",
            );
            first = req.outputData[0].data;
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.outputData[0].data =
              req._header + first.substring(endOfHeaders);
            debug("Output buffer: %o", req.outputData[0].data);
          }
          let socket;
          if (this.proxy.protocol === "https:") {
            debug("Creating `tls.Socket`: %o", this.connectOpts);
            socket = tls.connect(this.connectOpts);
          } else {
            debug("Creating `net.Socket`: %o", this.connectOpts);
            socket = net.connect(this.connectOpts);
          }
          await (0, events_1.once)(socket, "connect");
          return socket;
        }
      }
      HttpProxyAgent.protocols = ["http", "https"];
      exports.HttpProxyAgent = HttpProxyAgent;
      function omit(obj, ...keys) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
    },
    7219: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpsProxyAgent = void 0;
      const net = __importStar(__nccwpck_require__(1808));
      const tls = __importStar(__nccwpck_require__(4404));
      const assert_1 = __importDefault(__nccwpck_require__(9491));
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const agent_base_1 = __nccwpck_require__(694);
      const url_1 = __nccwpck_require__(7310);
      const parse_proxy_response_1 = __nccwpck_require__(595);
      const debug = (0, debug_1.default)("https-proxy-agent");
      class HttpsProxyAgent extends agent_base_1.Agent {
        constructor(proxy, opts) {
          super(opts);
          this.options = { path: undefined };
          this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
          this.proxyHeaders = opts?.headers ?? {};
          debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
          const host = (this.proxy.hostname || this.proxy.host).replace(
            /^\[|\]$/g,
            "",
          );
          const port = this.proxy.port
            ? parseInt(this.proxy.port, 10)
            : this.proxy.protocol === "https:"
              ? 443
              : 80;
          this.connectOpts = {
            ALPNProtocols: ["http/1.1"],
            ...(opts ? omit(opts, "headers") : null),
            host,
            port,
          };
        }
        async connect(req, opts) {
          const { proxy } = this;
          if (!opts.host) {
            throw new TypeError('No "host" provided');
          }
          let socket;
          if (proxy.protocol === "https:") {
            debug("Creating `tls.Socket`: %o", this.connectOpts);
            const servername =
              this.connectOpts.servername || this.connectOpts.host;
            socket = tls.connect({ ...this.connectOpts, servername });
          } else {
            debug("Creating `net.Socket`: %o", this.connectOpts);
            socket = net.connect(this.connectOpts);
          }
          const headers =
            typeof this.proxyHeaders === "function"
              ? this.proxyHeaders()
              : { ...this.proxyHeaders };
          const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
          let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
          if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers["Proxy-Authorization"] =
              `Basic ${Buffer.from(auth).toString("base64")}`;
          }
          headers.Host = `${host}:${opts.port}`;
          if (!headers["Proxy-Connection"]) {
            headers["Proxy-Connection"] = this.keepAlive
              ? "Keep-Alive"
              : "close";
          }
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r\n`;
          }
          const proxyResponsePromise = (0,
          parse_proxy_response_1.parseProxyResponse)(socket);
          socket.write(`${payload}\r\n`);
          const { connect, buffered } = await proxyResponsePromise;
          req.emit("proxyConnect", connect);
          this.emit("proxyConnect", connect, req);
          if (connect.statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls.connect({
                ...omit(opts, "host", "path", "port"),
                socket,
                servername,
              });
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("Replaying proxy buffer for failed request");
            (0, assert_1.default)(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        }
      }
      HttpsProxyAgent.protocols = ["http", "https"];
      exports.HttpsProxyAgent = HttpsProxyAgent;
      function resume(socket) {
        socket.resume();
      }
      function omit(obj, ...keys) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
    },
    595: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseProxyResponse = void 0;
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const debug = (0, debug_1.default)(
        "https-proxy-agent:parse-proxy-response",
      );
      function parseProxyResponse(socket) {
        return new Promise((resolve, reject) => {
          let buffersLength = 0;
          const buffers = [];
          function read() {
            const b = socket.read();
            if (b) ondata(b);
            else socket.once("readable", read);
          }
          function cleanup() {
            socket.removeListener("end", onend);
            socket.removeListener("error", onerror);
            socket.removeListener("readable", read);
          }
          function onend() {
            cleanup();
            debug("onend");
            reject(
              new Error(
                "Proxy connection ended before receiving CONNECT response",
              ),
            );
          }
          function onerror(err) {
            cleanup();
            debug("onerror %o", err);
            reject(err);
          }
          function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf("\r\n\r\n");
            if (endOfHeaders === -1) {
              debug("have not received end of HTTP headers yet...");
              read();
              return;
            }
            const headerParts = buffered
              .slice(0, endOfHeaders)
              .toString("ascii")
              .split("\r\n");
            const firstLine = headerParts.shift();
            if (!firstLine) {
              socket.destroy();
              return reject(
                new Error("No header received from proxy CONNECT response"),
              );
            }
            const firstLineParts = firstLine.split(" ");
            const statusCode = +firstLineParts[1];
            const statusText = firstLineParts.slice(2).join(" ");
            const headers = {};
            for (const header of headerParts) {
              if (!header) continue;
              const firstColon = header.indexOf(":");
              if (firstColon === -1) {
                socket.destroy();
                return reject(
                  new Error(
                    `Invalid header from proxy CONNECT response: "${header}"`,
                  ),
                );
              }
              const key = header.slice(0, firstColon).toLowerCase();
              const value = header.slice(firstColon + 1).trimStart();
              const current = headers[key];
              if (typeof current === "string") {
                headers[key] = [current, value];
              } else if (Array.isArray(current)) {
                current.push(value);
              } else {
                headers[key] = value;
              }
            }
            debug("got proxy server response: %o %o", firstLine, headers);
            cleanup();
            resolve({ connect: { statusCode, statusText, headers }, buffered });
          }
          socket.on("error", onerror);
          socket.on("end", onend);
          read();
        });
      }
      exports.parseProxyResponse = parseProxyResponse;
    },
    9695: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports._dbcs = DBCSCodec;
      var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START = -10,
        NODE_START = -1e3,
        UNASSIGNED_NODE = new Array(256),
        DEF_CHAR = -1;
      for (var i = 0; i < 256; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
      function DBCSCodec(codecOptions, iconv) {
        this.encodingName = codecOptions.encodingName;
        if (!codecOptions)
          throw new Error("DBCS codec is called without the data.");
        if (!codecOptions.table)
          throw new Error("Encoding '" + this.encodingName + "' has no data.");
        var mappingTable = codecOptions.table();
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
        this.decodeTableSeq = [];
        for (var i = 0; i < mappingTable.length; i++)
          this._addDecodeChunk(mappingTable[i]);
        if (typeof codecOptions.gb18030 === "function") {
          this.gb18030 = codecOptions.gb18030();
          var commonThirdByteNodeIdx = this.decodeTables.length;
          this.decodeTables.push(UNASSIGNED_NODE.slice(0));
          var commonFourthByteNodeIdx = this.decodeTables.length;
          this.decodeTables.push(UNASSIGNED_NODE.slice(0));
          var firstByteNode = this.decodeTables[0];
          for (var i = 129; i <= 254; i++) {
            var secondByteNode =
              this.decodeTables[NODE_START - firstByteNode[i]];
            for (var j = 48; j <= 57; j++) {
              if (secondByteNode[j] === UNASSIGNED) {
                secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
              } else if (secondByteNode[j] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 2");
              }
              var thirdByteNode =
                this.decodeTables[NODE_START - secondByteNode[j]];
              for (var k = 129; k <= 254; k++) {
                if (thirdByteNode[k] === UNASSIGNED) {
                  thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                } else if (
                  thirdByteNode[k] ===
                  NODE_START - commonFourthByteNodeIdx
                ) {
                  continue;
                } else if (thirdByteNode[k] > NODE_START) {
                  throw new Error("gb18030 decode tables conflict at byte 3");
                }
                var fourthByteNode =
                  this.decodeTables[NODE_START - thirdByteNode[k]];
                for (var l = 48; l <= 57; l++) {
                  if (fourthByteNode[l] === UNASSIGNED)
                    fourthByteNode[l] = GB18030_CODE;
                }
              }
            }
          }
        }
        this.defaultCharUnicode = iconv.defaultCharUnicode;
        this.encodeTable = [];
        this.encodeTableSeq = [];
        var skipEncodeChars = {};
        if (codecOptions.encodeSkipVals)
          for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === "number") skipEncodeChars[val] = true;
            else
              for (var j = val.from; j <= val.to; j++)
                skipEncodeChars[j] = true;
          }
        this._fillEncodeTable(0, 0, skipEncodeChars);
        if (codecOptions.encodeAdd) {
          for (var uChar in codecOptions.encodeAdd)
            if (
              Object.prototype.hasOwnProperty.call(
                codecOptions.encodeAdd,
                uChar,
              )
            )
              this._setEncodeChar(
                uChar.charCodeAt(0),
                codecOptions.encodeAdd[uChar],
              );
        }
        this.defCharSB =
          this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED)
          this.defCharSB = this.encodeTable[0]["?"];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
      }
      DBCSCodec.prototype.encoder = DBCSEncoder;
      DBCSCodec.prototype.decoder = DBCSDecoder;
      DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
        var bytes = [];
        for (; addr > 0; addr >>>= 8) bytes.push(addr & 255);
        if (bytes.length == 0) bytes.push(0);
        var node = this.decodeTables[0];
        for (var i = bytes.length - 1; i > 0; i--) {
          var val = node[bytes[i]];
          if (val == UNASSIGNED) {
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push((node = UNASSIGNED_NODE.slice(0)));
          } else if (val <= NODE_START) {
            node = this.decodeTables[NODE_START - val];
          } else
            throw new Error(
              "Overwrite byte in " +
                this.encodingName +
                ", addr: " +
                addr.toString(16),
            );
        }
        return node;
      };
      DBCSCodec.prototype._addDecodeChunk = function (chunk) {
        var curAddr = parseInt(chunk[0], 16);
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 255;
        for (var k = 1; k < chunk.length; k++) {
          var part = chunk[k];
          if (typeof part === "string") {
            for (var l = 0; l < part.length; ) {
              var code = part.charCodeAt(l++);
              if (55296 <= code && code < 56320) {
                var codeTrail = part.charCodeAt(l++);
                if (56320 <= codeTrail && codeTrail < 57344)
                  writeTable[curAddr++] =
                    65536 + (code - 55296) * 1024 + (codeTrail - 56320);
                else
                  throw new Error(
                    "Incorrect surrogate pair in " +
                      this.encodingName +
                      " at chunk " +
                      chunk[0],
                  );
              } else if (4080 < code && code <= 4095) {
                var len = 4095 - code + 2;
                var seq = [];
                for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
                writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                this.decodeTableSeq.push(seq);
              } else writeTable[curAddr++] = code;
            }
          } else if (typeof part === "number") {
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
          } else
            throw new Error(
              "Incorrect type '" +
                typeof part +
                "' given in " +
                this.encodingName +
                " at chunk " +
                chunk[0],
            );
        }
        if (curAddr > 255)
          throw new Error(
            "Incorrect chunk in " +
              this.encodingName +
              " at addr " +
              chunk[0] +
              ": too long" +
              curAddr,
          );
      };
      DBCSCodec.prototype._getEncodeBucket = function (uCode) {
        var high = uCode >> 8;
        if (this.encodeTable[high] === undefined)
          this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
        return this.encodeTable[high];
      };
      DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 255;
        if (bucket[low] <= SEQ_START)
          this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
        else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
      };
      DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 255;
        var node;
        if (bucket[low] <= SEQ_START) {
          node = this.encodeTableSeq[SEQ_START - bucket[low]];
        } else {
          node = {};
          if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
          bucket[low] = SEQ_START - this.encodeTableSeq.length;
          this.encodeTableSeq.push(node);
        }
        for (var j = 1; j < seq.length - 1; j++) {
          var oldVal = node[uCode];
          if (typeof oldVal === "object") node = oldVal;
          else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
          }
        }
        uCode = seq[seq.length - 1];
        node[uCode] = dbcsCode;
      };
      DBCSCodec.prototype._fillEncodeTable = function (
        nodeIdx,
        prefix,
        skipEncodeChars,
      ) {
        var node = this.decodeTables[nodeIdx];
        var hasValues = false;
        var subNodeEmpty = {};
        for (var i = 0; i < 256; i++) {
          var uCode = node[i];
          var mbCode = prefix + i;
          if (skipEncodeChars[mbCode]) continue;
          if (uCode >= 0) {
            this._setEncodeChar(uCode, mbCode);
            hasValues = true;
          } else if (uCode <= NODE_START) {
            var subNodeIdx = NODE_START - uCode;
            if (!subNodeEmpty[subNodeIdx]) {
              var newPrefix = (mbCode << 8) >>> 0;
              if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
                hasValues = true;
              else subNodeEmpty[subNodeIdx] = true;
            }
          } else if (uCode <= SEQ_START) {
            this._setEncodeSequence(
              this.decodeTableSeq[SEQ_START - uCode],
              mbCode,
            );
            hasValues = true;
          }
        }
        return hasValues;
      };
      function DBCSEncoder(options, codec) {
        this.leadSurrogate = -1;
        this.seqObj = undefined;
        this.encodeTable = codec.encodeTable;
        this.encodeTableSeq = codec.encodeTableSeq;
        this.defaultCharSingleByte = codec.defCharSB;
        this.gb18030 = codec.gb18030;
      }
      DBCSEncoder.prototype.write = function (str) {
        var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
          leadSurrogate = this.leadSurrogate,
          seqObj = this.seqObj,
          nextChar = -1,
          i = 0,
          j = 0;
        while (true) {
          if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
          } else {
            var uCode = nextChar;
            nextChar = -1;
          }
          if (55296 <= uCode && uCode < 57344) {
            if (uCode < 56320) {
              if (leadSurrogate === -1) {
                leadSurrogate = uCode;
                continue;
              } else {
                leadSurrogate = uCode;
                uCode = UNASSIGNED;
              }
            } else {
              if (leadSurrogate !== -1) {
                uCode =
                  65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
                leadSurrogate = -1;
              } else {
                uCode = UNASSIGNED;
              }
            }
          } else if (leadSurrogate !== -1) {
            nextChar = uCode;
            uCode = UNASSIGNED;
            leadSurrogate = -1;
          }
          var dbcsCode = UNASSIGNED;
          if (seqObj !== undefined && uCode != UNASSIGNED) {
            var resCode = seqObj[uCode];
            if (typeof resCode === "object") {
              seqObj = resCode;
              continue;
            } else if (typeof resCode == "number") {
              dbcsCode = resCode;
            } else if (resCode == undefined) {
              resCode = seqObj[DEF_CHAR];
              if (resCode !== undefined) {
                dbcsCode = resCode;
                nextChar = uCode;
              } else {
              }
            }
            seqObj = undefined;
          } else if (uCode >= 0) {
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 255];
            if (dbcsCode <= SEQ_START) {
              seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
              continue;
            }
            if (dbcsCode == UNASSIGNED && this.gb18030) {
              var idx = findIdx(this.gb18030.uChars, uCode);
              if (idx != -1) {
                var dbcsCode =
                  this.gb18030.gbChars[idx] +
                  (uCode - this.gb18030.uChars[idx]);
                newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
                dbcsCode = dbcsCode % 12600;
                newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
                dbcsCode = dbcsCode % 1260;
                newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
                dbcsCode = dbcsCode % 10;
                newBuf[j++] = 48 + dbcsCode;
                continue;
              }
            }
          }
          if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else if (dbcsCode < 65536) {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          } else if (dbcsCode < 16777216) {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 255;
            newBuf[j++] = dbcsCode & 255;
          } else {
            newBuf[j++] = dbcsCode >>> 24;
            newBuf[j++] = (dbcsCode >>> 16) & 255;
            newBuf[j++] = (dbcsCode >>> 8) & 255;
            newBuf[j++] = dbcsCode & 255;
          }
        }
        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
      };
      DBCSEncoder.prototype.end = function () {
        if (this.leadSurrogate === -1 && this.seqObj === undefined) return;
        var newBuf = Buffer.alloc(10),
          j = 0;
        if (this.seqObj) {
          var dbcsCode = this.seqObj[DEF_CHAR];
          if (dbcsCode !== undefined) {
            if (dbcsCode < 256) {
              newBuf[j++] = dbcsCode;
            } else {
              newBuf[j++] = dbcsCode >> 8;
              newBuf[j++] = dbcsCode & 255;
            }
          } else {
          }
          this.seqObj = undefined;
        }
        if (this.leadSurrogate !== -1) {
          newBuf[j++] = this.defaultCharSingleByte;
          this.leadSurrogate = -1;
        }
        return newBuf.slice(0, j);
      };
      DBCSEncoder.prototype.findIdx = findIdx;
      function DBCSDecoder(options, codec) {
        this.nodeIdx = 0;
        this.prevBytes = [];
        this.decodeTables = codec.decodeTables;
        this.decodeTableSeq = codec.decodeTableSeq;
        this.defaultCharUnicode = codec.defaultCharUnicode;
        this.gb18030 = codec.gb18030;
      }
      DBCSDecoder.prototype.write = function (buf) {
        var newBuf = Buffer.alloc(buf.length * 2),
          nodeIdx = this.nodeIdx,
          prevBytes = this.prevBytes,
          prevOffset = this.prevBytes.length,
          seqStart = -this.prevBytes.length,
          uCode;
        for (var i = 0, j = 0; i < buf.length; i++) {
          var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];
          var uCode = this.decodeTables[nodeIdx][curByte];
          if (uCode >= 0) {
          } else if (uCode === UNASSIGNED) {
            uCode = this.defaultCharUnicode.charCodeAt(0);
            i = seqStart;
          } else if (uCode === GB18030_CODE) {
            if (i >= 3) {
              var ptr =
                (buf[i - 3] - 129) * 12600 +
                (buf[i - 2] - 48) * 1260 +
                (buf[i - 1] - 129) * 10 +
                (curByte - 48);
            } else {
              var ptr =
                (prevBytes[i - 3 + prevOffset] - 129) * 12600 +
                ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) -
                  48) *
                  1260 +
                ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) -
                  129) *
                  10 +
                (curByte - 48);
            }
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
          } else if (uCode <= NODE_START) {
            nodeIdx = NODE_START - uCode;
            continue;
          } else if (uCode <= SEQ_START) {
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
              uCode = seq[k];
              newBuf[j++] = uCode & 255;
              newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
          } else
            throw new Error(
              "iconv-lite internal error: invalid decoding table value " +
                uCode +
                " at " +
                nodeIdx +
                "/" +
                curByte,
            );
          if (uCode >= 65536) {
            uCode -= 65536;
            var uCodeLead = 55296 | (uCode >> 10);
            newBuf[j++] = uCodeLead & 255;
            newBuf[j++] = uCodeLead >> 8;
            uCode = 56320 | (uCode & 1023);
          }
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
          nodeIdx = 0;
          seqStart = i + 1;
        }
        this.nodeIdx = nodeIdx;
        this.prevBytes =
          seqStart >= 0
            ? Array.prototype.slice.call(buf, seqStart)
            : prevBytes
                .slice(seqStart + prevOffset)
                .concat(Array.prototype.slice.call(buf));
        return newBuf.slice(0, j).toString("ucs2");
      };
      DBCSDecoder.prototype.end = function () {
        var ret = "";
        while (this.prevBytes.length > 0) {
          ret += this.defaultCharUnicode;
          var bytesArr = this.prevBytes.slice(1);
          this.prevBytes = [];
          this.nodeIdx = 0;
          if (bytesArr.length > 0) ret += this.write(bytesArr);
        }
        this.prevBytes = [];
        this.nodeIdx = 0;
        return ret;
      };
      function findIdx(table, val) {
        if (table[0] > val) return -1;
        var l = 0,
          r = table.length;
        while (l < r - 1) {
          var mid = l + ((r - l + 1) >> 1);
          if (table[mid] <= val) l = mid;
          else r = mid;
        }
        return l;
      }
    },
    1386: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      module.exports = {
        shiftjis: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(7014);
          },
          encodeAdd: { "": 92, "": 126 },
          encodeSkipVals: [{ from: 60736, to: 63808 }],
        },
        csshiftjis: "shiftjis",
        mskanji: "shiftjis",
        sjis: "shiftjis",
        windows31j: "shiftjis",
        ms31j: "shiftjis",
        xsjis: "shiftjis",
        windows932: "shiftjis",
        ms932: "shiftjis",
        932: "shiftjis",
        cp932: "shiftjis",
        eucjp: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(1532);
          },
          encodeAdd: { "": 92, "": 126 },
        },
        gb2312: "cp936",
        gb231280: "cp936",
        gb23121980: "cp936",
        csgb2312: "cp936",
        csiso58gb231280: "cp936",
        euccn: "cp936",
        windows936: "cp936",
        ms936: "cp936",
        936: "cp936",
        cp936: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336);
          },
        },
        gbk: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336).concat(__nccwpck_require__(4346));
          },
        },
        xgbk: "gbk",
        isoir58: "gbk",
        gb18030: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336).concat(__nccwpck_require__(4346));
          },
          gb18030: function () {
            return __nccwpck_require__(6258);
          },
          encodeSkipVals: [128],
          encodeAdd: { "": 41699 },
        },
        chinese: "gb18030",
        windows949: "cp949",
        ms949: "cp949",
        949: "cp949",
        cp949: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(7348);
          },
        },
        cseuckr: "cp949",
        csksc56011987: "cp949",
        euckr: "cp949",
        isoir149: "cp949",
        korean: "cp949",
        ksc56011987: "cp949",
        ksc56011989: "cp949",
        ksc5601: "cp949",
        windows950: "cp950",
        ms950: "cp950",
        950: "cp950",
        cp950: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(4284);
          },
        },
        big5: "big5hkscs",
        big5hkscs: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(4284).concat(__nccwpck_require__(3480));
          },
          encodeSkipVals: [
            36457, 36463, 36478, 36523, 36532, 36557, 36560, 36695, 36713,
            36718, 36811, 36862, 36973, 36986, 37060, 37084, 37105, 37311,
            37551, 37552, 37553, 37554, 37585, 37959, 38090, 38361, 38652,
            39285, 39798, 39800, 39803, 39878, 39902, 39916, 39926, 40002,
            40019, 40034, 40040, 40043, 40055, 40124, 40125, 40144, 40279,
            40282, 40388, 40431, 40443, 40617, 40687, 40701, 40800, 40907,
            41079, 41180, 41183, 36812, 37576, 38468, 38637, 41636, 41637,
            41639, 41638, 41676, 41678,
          ],
        },
        cnbig5: "big5hkscs",
        csbig5: "big5hkscs",
        xxbig5: "big5hkscs",
      };
    },
    2733: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var modules = [
        __nccwpck_require__(2376),
        __nccwpck_require__(9557),
        __nccwpck_require__(1155),
        __nccwpck_require__(1644),
        __nccwpck_require__(6657),
        __nccwpck_require__(1080),
        __nccwpck_require__(1012),
        __nccwpck_require__(9695),
        __nccwpck_require__(1386),
      ];
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module)
          if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
      }
    },
    2376: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      module.exports = {
        utf8: { type: "_internal", bomAware: true },
        cesu8: { type: "_internal", bomAware: true },
        unicode11utf8: "utf8",
        ucs2: { type: "_internal", bomAware: true },
        utf16le: "ucs2",
        binary: { type: "_internal" },
        base64: { type: "_internal" },
        hex: { type: "_internal" },
        _internal: InternalCodec,
      };
      function InternalCodec(codecOptions, iconv) {
        this.enc = codecOptions.encodingName;
        this.bomAware = codecOptions.bomAware;
        if (this.enc === "base64") this.encoder = InternalEncoderBase64;
        else if (this.enc === "cesu8") {
          this.enc = "utf8";
          this.encoder = InternalEncoderCesu8;
          if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "") {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
          }
        }
      }
      InternalCodec.prototype.encoder = InternalEncoder;
      InternalCodec.prototype.decoder = InternalDecoder;
      var StringDecoder = __nccwpck_require__(1576).StringDecoder;
      if (!StringDecoder.prototype.end)
        StringDecoder.prototype.end = function () {};
      function InternalDecoder(options, codec) {
        this.decoder = new StringDecoder(codec.enc);
      }
      InternalDecoder.prototype.write = function (buf) {
        if (!Buffer.isBuffer(buf)) {
          buf = Buffer.from(buf);
        }
        return this.decoder.write(buf);
      };
      InternalDecoder.prototype.end = function () {
        return this.decoder.end();
      };
      function InternalEncoder(options, codec) {
        this.enc = codec.enc;
      }
      InternalEncoder.prototype.write = function (str) {
        return Buffer.from(str, this.enc);
      };
      InternalEncoder.prototype.end = function () {};
      function InternalEncoderBase64(options, codec) {
        this.prevStr = "";
      }
      InternalEncoderBase64.prototype.write = function (str) {
        str = this.prevStr + str;
        var completeQuads = str.length - (str.length % 4);
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);
        return Buffer.from(str, "base64");
      };
      InternalEncoderBase64.prototype.end = function () {
        return Buffer.from(this.prevStr, "base64");
      };
      function InternalEncoderCesu8(options, codec) {}
      InternalEncoderCesu8.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length * 3),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var charCode = str.charCodeAt(i);
          if (charCode < 128) buf[bufIdx++] = charCode;
          else if (charCode < 2048) {
            buf[bufIdx++] = 192 + (charCode >>> 6);
            buf[bufIdx++] = 128 + (charCode & 63);
          } else {
            buf[bufIdx++] = 224 + (charCode >>> 12);
            buf[bufIdx++] = 128 + ((charCode >>> 6) & 63);
            buf[bufIdx++] = 128 + (charCode & 63);
          }
        }
        return buf.slice(0, bufIdx);
      };
      InternalEncoderCesu8.prototype.end = function () {};
      function InternalDecoderCesu8(options, codec) {
        this.acc = 0;
        this.contBytes = 0;
        this.accBytes = 0;
        this.defaultCharUnicode = codec.defaultCharUnicode;
      }
      InternalDecoderCesu8.prototype.write = function (buf) {
        var acc = this.acc,
          contBytes = this.contBytes,
          accBytes = this.accBytes,
          res = "";
        for (var i = 0; i < buf.length; i++) {
          var curByte = buf[i];
          if ((curByte & 192) !== 128) {
            if (contBytes > 0) {
              res += this.defaultCharUnicode;
              contBytes = 0;
            }
            if (curByte < 128) {
              res += String.fromCharCode(curByte);
            } else if (curByte < 224) {
              acc = curByte & 31;
              contBytes = 1;
              accBytes = 1;
            } else if (curByte < 240) {
              acc = curByte & 15;
              contBytes = 2;
              accBytes = 1;
            } else {
              res += this.defaultCharUnicode;
            }
          } else {
            if (contBytes > 0) {
              acc = (acc << 6) | (curByte & 63);
              contBytes--;
              accBytes++;
              if (contBytes === 0) {
                if (accBytes === 2 && acc < 128 && acc > 0)
                  res += this.defaultCharUnicode;
                else if (accBytes === 3 && acc < 2048)
                  res += this.defaultCharUnicode;
                else res += String.fromCharCode(acc);
              }
            } else {
              res += this.defaultCharUnicode;
            }
          }
        }
        this.acc = acc;
        this.contBytes = contBytes;
        this.accBytes = accBytes;
        return res;
      };
      InternalDecoderCesu8.prototype.end = function () {
        var res = 0;
        if (this.contBytes > 0) res += this.defaultCharUnicode;
        return res;
      };
    },
    6657: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports._sbcs = SBCSCodec;
      function SBCSCodec(codecOptions, iconv) {
        if (!codecOptions)
          throw new Error("SBCS codec is called without the data.");
        if (
          !codecOptions.chars ||
          (codecOptions.chars.length !== 128 &&
            codecOptions.chars.length !== 256)
        )
          throw new Error(
            "Encoding '" +
              codecOptions.type +
              "' has incorrect 'chars' (must be of len 128 or 256)",
          );
        if (codecOptions.chars.length === 128) {
          var asciiString = "";
          for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
          codecOptions.chars = asciiString + codecOptions.chars;
        }
        this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");
        var encodeBuf = Buffer.alloc(
          65536,
          iconv.defaultCharSingleByte.charCodeAt(0),
        );
        for (var i = 0; i < codecOptions.chars.length; i++)
          encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
        this.encodeBuf = encodeBuf;
      }
      SBCSCodec.prototype.encoder = SBCSEncoder;
      SBCSCodec.prototype.decoder = SBCSDecoder;
      function SBCSEncoder(options, codec) {
        this.encodeBuf = codec.encodeBuf;
      }
      SBCSEncoder.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length);
        for (var i = 0; i < str.length; i++)
          buf[i] = this.encodeBuf[str.charCodeAt(i)];
        return buf;
      };
      SBCSEncoder.prototype.end = function () {};
      function SBCSDecoder(options, codec) {
        this.decodeBuf = codec.decodeBuf;
      }
      SBCSDecoder.prototype.write = function (buf) {
        var decodeBuf = this.decodeBuf;
        var newBuf = Buffer.alloc(buf.length * 2);
        var idx1 = 0,
          idx2 = 0;
        for (var i = 0; i < buf.length; i++) {
          idx1 = buf[i] * 2;
          idx2 = i * 2;
          newBuf[idx2] = decodeBuf[idx1];
          newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
        }
        return newBuf.toString("ucs2");
      };
      SBCSDecoder.prototype.end = function () {};
    },
    1012: (module) => {
      "use strict";
      module.exports = {
        437: "cp437",
        737: "cp737",
        775: "cp775",
        850: "cp850",
        852: "cp852",
        855: "cp855",
        856: "cp856",
        857: "cp857",
        858: "cp858",
        860: "cp860",
        861: "cp861",
        862: "cp862",
        863: "cp863",
        864: "cp864",
        865: "cp865",
        866: "cp866",
        869: "cp869",
        874: "windows874",
        922: "cp922",
        1046: "cp1046",
        1124: "cp1124",
        1125: "cp1125",
        1129: "cp1129",
        1133: "cp1133",
        1161: "cp1161",
        1162: "cp1162",
        1163: "cp1163",
        1250: "windows1250",
        1251: "windows1251",
        1252: "windows1252",
        1253: "windows1253",
        1254: "windows1254",
        1255: "windows1255",
        1256: "windows1256",
        1257: "windows1257",
        1258: "windows1258",
        28591: "iso88591",
        28592: "iso88592",
        28593: "iso88593",
        28594: "iso88594",
        28595: "iso88595",
        28596: "iso88596",
        28597: "iso88597",
        28598: "iso88598",
        28599: "iso88599",
        28600: "iso885910",
        28601: "iso885911",
        28603: "iso885913",
        28604: "iso885914",
        28605: "iso885915",
        28606: "iso885916",
        windows874: {
          type: "_sbcs",
          chars:
            "",
        },
        win874: "windows874",
        cp874: "windows874",
        windows1250: {
          type: "_sbcs",
          chars:
            "",
        },
        win1250: "windows1250",
        cp1250: "windows1250",
        windows1251: {
          type: "_sbcs",
          chars:
            "",
        },
        win1251: "windows1251",
        cp1251: "windows1251",
        windows1252: {
          type: "_sbcs",
          chars:
            "",
        },
        win1252: "windows1252",
        cp1252: "windows1252",
        windows1253: {
          type: "_sbcs",
          chars:
            "",
        },
        win1253: "windows1253",
        cp1253: "windows1253",
        windows1254: {
          type: "_sbcs",
          chars:
            "",
        },
        win1254: "windows1254",
        cp1254: "windows1254",
        windows1255: {
          type: "_sbcs",
          chars:
            "",
        },
        win1255: "windows1255",
        cp1255: "windows1255",
        windows1256: {
          type: "_sbcs",
          chars:
            "",
        },
        win1256: "windows1256",
        cp1256: "windows1256",
        windows1257: {
          type: "_sbcs",
          chars:
            "",
        },
        win1257: "windows1257",
        cp1257: "windows1257",
        windows1258: {
          type: "_sbcs",
          chars:
            "",
        },
        win1258: "windows1258",
        cp1258: "windows1258",
        iso88591: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28591: "iso88591",
        iso88592: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28592: "iso88592",
        iso88593: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28593: "iso88593",
        iso88594: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28594: "iso88594",
        iso88595: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28595: "iso88595",
        iso88596: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28596: "iso88596",
        iso88597: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28597: "iso88597",
        iso88598: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28598: "iso88598",
        iso88599: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28599: "iso88599",
        iso885910: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28600: "iso885910",
        iso885911: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28601: "iso885911",
        iso885913: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28603: "iso885913",
        iso885914: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28604: "iso885914",
        iso885915: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28605: "iso885915",
        iso885916: {
          type: "_sbcs",
          chars:
            "",
        },
        cp28606: "iso885916",
        cp437: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm437: "cp437",
        csibm437: "cp437",
        cp737: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm737: "cp737",
        csibm737: "cp737",
        cp775: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm775: "cp775",
        csibm775: "cp775",
        cp850: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm850: "cp850",
        csibm850: "cp850",
        cp852: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm852: "cp852",
        csibm852: "cp852",
        cp855: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm855: "cp855",
        csibm855: "cp855",
        cp856: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm856: "cp856",
        csibm856: "cp856",
        cp857: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm857: "cp857",
        csibm857: "cp857",
        cp858: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm858: "cp858",
        csibm858: "cp858",
        cp860: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm860: "cp860",
        csibm860: "cp860",
        cp861: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm861: "cp861",
        csibm861: "cp861",
        cp862: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm862: "cp862",
        csibm862: "cp862",
        cp863: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm863: "cp863",
        csibm863: "cp863",
        cp864: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        },
        ibm864: "cp864",
        csibm864: "cp864",
        cp865: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm865: "cp865",
        csibm865: "cp865",
        cp866: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm866: "cp866",
        csibm866: "cp866",
        cp869: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm869: "cp869",
        csibm869: "cp869",
        cp922: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm922: "cp922",
        csibm922: "cp922",
        cp1046: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1046: "cp1046",
        csibm1046: "cp1046",
        cp1124: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1124: "cp1124",
        csibm1124: "cp1124",
        cp1125: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1125: "cp1125",
        csibm1125: "cp1125",
        cp1129: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1129: "cp1129",
        csibm1129: "cp1129",
        cp1133: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1133: "cp1133",
        csibm1133: "cp1133",
        cp1161: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1161: "cp1161",
        csibm1161: "cp1161",
        cp1162: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1162: "cp1162",
        csibm1162: "cp1162",
        cp1163: {
          type: "_sbcs",
          chars:
            "",
        },
        ibm1163: "cp1163",
        csibm1163: "cp1163",
        maccroatian: {
          type: "_sbcs",
          chars:
            "",
        },
        maccyrillic: {
          type: "_sbcs",
          chars:
            "",
        },
        macgreek: {
          type: "_sbcs",
          chars:
            "",
        },
        maciceland: {
          type: "_sbcs",
          chars:
            "",
        },
        macroman: {
          type: "_sbcs",
          chars:
            "",
        },
        macromania: {
          type: "_sbcs",
          chars:
            "",
        },
        macthai: {
          type: "_sbcs",
          chars:
            "\ufeff",
        },
        macturkish: {
          type: "_sbcs",
          chars:
            "",
        },
        macukraine: {
          type: "_sbcs",
          chars:
            "",
        },
        koi8r: {
          type: "_sbcs",
          chars:
            "",
        },
        koi8u: {
          type: "_sbcs",
          chars:
            "",
        },
        koi8ru: {
          type: "_sbcs",
          chars:
            "",
        },
        koi8t: {
          type: "_sbcs",
          chars:
            "",
        },
        armscii8: {
          type: "_sbcs",
          chars:
            ")(.,-",
        },
        rk1048: {
          type: "_sbcs",
          chars:
            "",
        },
        tcvn: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        },
        georgianacademy: {
          type: "_sbcs",
          chars:
            "",
        },
        georgianps: {
          type: "_sbcs",
          chars:
            "",
        },
        pt154: {
          type: "_sbcs",
          chars:
            "",
        },
        viscii: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~",
        },
        iso646cn: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}",
        },
        iso646jp: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}",
        },
        hproman8: {
          type: "_sbcs",
          chars:
            "",
        },
        macintosh: {
          type: "_sbcs",
          chars:
            "",
        },
        ascii: {
          type: "_sbcs",
          chars:
            "",
        },
        tis620: {
          type: "_sbcs",
          chars:
            "",
        },
      };
    },
    1080: (module) => {
      "use strict";
      module.exports = {
        10029: "maccenteuro",
        maccenteuro: {
          type: "_sbcs",
          chars:
            "",
        },
        808: "cp808",
        ibm808: "cp808",
        cp808: {
          type: "_sbcs",
          chars:
            "",
        },
        mik: {
          type: "_sbcs",
          chars:
            "",
        },
        cp720: {
          type: "_sbcs",
          chars:
            "",
        },
        ascii8bit: "ascii",
        usascii: "ascii",
        ansix34: "ascii",
        ansix341968: "ascii",
        ansix341986: "ascii",
        csascii: "ascii",
        cp367: "ascii",
        ibm367: "ascii",
        isoir6: "ascii",
        iso646us: "ascii",
        iso646irv: "ascii",
        us: "ascii",
        latin1: "iso88591",
        latin2: "iso88592",
        latin3: "iso88593",
        latin4: "iso88594",
        latin5: "iso88599",
        latin6: "iso885910",
        latin7: "iso885913",
        latin8: "iso885914",
        latin9: "iso885915",
        latin10: "iso885916",
        csisolatin1: "iso88591",
        csisolatin2: "iso88592",
        csisolatin3: "iso88593",
        csisolatin4: "iso88594",
        csisolatincyrillic: "iso88595",
        csisolatinarabic: "iso88596",
        csisolatingreek: "iso88597",
        csisolatinhebrew: "iso88598",
        csisolatin5: "iso88599",
        csisolatin6: "iso885910",
        l1: "iso88591",
        l2: "iso88592",
        l3: "iso88593",
        l4: "iso88594",
        l5: "iso88599",
        l6: "iso885910",
        l7: "iso885913",
        l8: "iso885914",
        l9: "iso885915",
        l10: "iso885916",
        isoir14: "iso646jp",
        isoir57: "iso646cn",
        isoir100: "iso88591",
        isoir101: "iso88592",
        isoir109: "iso88593",
        isoir110: "iso88594",
        isoir144: "iso88595",
        isoir127: "iso88596",
        isoir126: "iso88597",
        isoir138: "iso88598",
        isoir148: "iso88599",
        isoir157: "iso885910",
        isoir166: "tis620",
        isoir179: "iso885913",
        isoir199: "iso885914",
        isoir203: "iso885915",
        isoir226: "iso885916",
        cp819: "iso88591",
        ibm819: "iso88591",
        cyrillic: "iso88595",
        arabic: "iso88596",
        arabic8: "iso88596",
        ecma114: "iso88596",
        asmo708: "iso88596",
        greek: "iso88597",
        greek8: "iso88597",
        ecma118: "iso88597",
        elot928: "iso88597",
        hebrew: "iso88598",
        hebrew8: "iso88598",
        turkish: "iso88599",
        turkish8: "iso88599",
        thai: "iso885911",
        thai8: "iso885911",
        celtic: "iso885914",
        celtic8: "iso885914",
        isoceltic: "iso885914",
        tis6200: "tis620",
        tis62025291: "tis620",
        tis62025330: "tis620",
        1e4: "macroman",
        10006: "macgreek",
        10007: "maccyrillic",
        10079: "maciceland",
        10081: "macturkish",
        cspc8codepage437: "cp437",
        cspc775baltic: "cp775",
        cspc850multilingual: "cp850",
        cspcp852: "cp852",
        cspc862latinhebrew: "cp862",
        cpgr: "cp869",
        msee: "cp1250",
        mscyrl: "cp1251",
        msansi: "cp1252",
        msgreek: "cp1253",
        msturk: "cp1254",
        mshebr: "cp1255",
        msarab: "cp1256",
        winbaltrim: "cp1257",
        cp20866: "koi8r",
        20866: "koi8r",
        ibm878: "koi8r",
        cskoi8r: "koi8r",
        cp21866: "koi8u",
        21866: "koi8u",
        ibm1168: "koi8u",
        strk10482002: "rk1048",
        tcvn5712: "tcvn",
        tcvn57121: "tcvn",
        gb198880: "iso646cn",
        cn: "iso646cn",
        csiso14jisc6220ro: "iso646jp",
        jisc62201969ro: "iso646jp",
        jp: "iso646jp",
        cshproman8: "hproman8",
        r8: "hproman8",
        roman8: "hproman8",
        xroman8: "hproman8",
        ibm1051: "hproman8",
        mac: "macintosh",
        csmacintosh: "macintosh",
      };
    },
    1155: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports.utf16be = Utf16BECodec;
      function Utf16BECodec() {}
      Utf16BECodec.prototype.encoder = Utf16BEEncoder;
      Utf16BECodec.prototype.decoder = Utf16BEDecoder;
      Utf16BECodec.prototype.bomAware = true;
      function Utf16BEEncoder() {}
      Utf16BEEncoder.prototype.write = function (str) {
        var buf = Buffer.from(str, "ucs2");
        for (var i = 0; i < buf.length; i += 2) {
          var tmp = buf[i];
          buf[i] = buf[i + 1];
          buf[i + 1] = tmp;
        }
        return buf;
      };
      Utf16BEEncoder.prototype.end = function () {};
      function Utf16BEDecoder() {
        this.overflowByte = -1;
      }
      Utf16BEDecoder.prototype.write = function (buf) {
        if (buf.length == 0) return "";
        var buf2 = Buffer.alloc(buf.length + 1),
          i = 0,
          j = 0;
        if (this.overflowByte !== -1) {
          buf2[0] = buf[0];
          buf2[1] = this.overflowByte;
          i = 1;
          j = 2;
        }
        for (; i < buf.length - 1; i += 2, j += 2) {
          buf2[j] = buf[i + 1];
          buf2[j + 1] = buf[i];
        }
        this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
        return buf2.slice(0, j).toString("ucs2");
      };
      Utf16BEDecoder.prototype.end = function () {
        this.overflowByte = -1;
      };
      exports.utf16 = Utf16Codec;
      function Utf16Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf16Codec.prototype.encoder = Utf16Encoder;
      Utf16Codec.prototype.decoder = Utf16Decoder;
      function Utf16Encoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder("utf-16le", options);
      }
      Utf16Encoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf16Encoder.prototype.end = function () {
        return this.encoder.end();
      };
      function Utf16Decoder(options, codec) {
        this.decoder = null;
        this.initialBufs = [];
        this.initialBufsLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf16Decoder.prototype.write = function (buf) {
        if (!this.decoder) {
          this.initialBufs.push(buf);
          this.initialBufsLen += buf.length;
          if (this.initialBufsLen < 16) return "";
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.write(buf);
      };
      Utf16Decoder.prototype.end = function () {
        if (!this.decoder) {
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          var trail = this.decoder.end();
          if (trail) resStr += trail;
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.end();
      };
      function detectEncoding(bufs, defaultEncoding) {
        var b = [];
        var charsProcessed = 0;
        var asciiCharsLE = 0,
          asciiCharsBE = 0;
        outer_loop: for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254) return "utf-16le";
                if (b[0] === 254 && b[1] === 255) return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
        if (asciiCharsBE > asciiCharsLE) return "utf-16be";
        if (asciiCharsBE < asciiCharsLE) return "utf-16le";
        return defaultEncoding || "utf-16le";
      }
    },
    9557: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports._utf32 = Utf32Codec;
      function Utf32Codec(codecOptions, iconv) {
        this.iconv = iconv;
        this.bomAware = true;
        this.isLE = codecOptions.isLE;
      }
      exports.utf32le = { type: "_utf32", isLE: true };
      exports.utf32be = { type: "_utf32", isLE: false };
      exports.ucs4le = "utf32le";
      exports.ucs4be = "utf32be";
      Utf32Codec.prototype.encoder = Utf32Encoder;
      Utf32Codec.prototype.decoder = Utf32Decoder;
      function Utf32Encoder(options, codec) {
        this.isLE = codec.isLE;
        this.highSurrogate = 0;
      }
      Utf32Encoder.prototype.write = function (str) {
        var src = Buffer.from(str, "ucs2");
        var dst = Buffer.alloc(src.length * 2);
        var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
        var offset = 0;
        for (var i = 0; i < src.length; i += 2) {
          var code = src.readUInt16LE(i);
          var isHighSurrogate = 55296 <= code && code < 56320;
          var isLowSurrogate = 56320 <= code && code < 57344;
          if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
              write32.call(dst, this.highSurrogate, offset);
              offset += 4;
            } else {
              var codepoint =
                (((this.highSurrogate - 55296) << 10) | (code - 56320)) + 65536;
              write32.call(dst, codepoint, offset);
              offset += 4;
              this.highSurrogate = 0;
              continue;
            }
          }
          if (isHighSurrogate) this.highSurrogate = code;
          else {
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
          }
        }
        if (offset < dst.length) dst = dst.slice(0, offset);
        return dst;
      };
      Utf32Encoder.prototype.end = function () {
        if (!this.highSurrogate) return;
        var buf = Buffer.alloc(4);
        if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
        else buf.writeUInt32BE(this.highSurrogate, 0);
        this.highSurrogate = 0;
        return buf;
      };
      function Utf32Decoder(options, codec) {
        this.isLE = codec.isLE;
        this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
        this.overflow = [];
      }
      Utf32Decoder.prototype.write = function (src) {
        if (src.length === 0) return "";
        var i = 0;
        var codepoint = 0;
        var dst = Buffer.alloc(src.length + 4);
        var offset = 0;
        var isLE = this.isLE;
        var overflow = this.overflow;
        var badChar = this.badChar;
        if (overflow.length > 0) {
          for (; i < src.length && overflow.length < 4; i++)
            overflow.push(src[i]);
          if (overflow.length === 4) {
            if (isLE) {
              codepoint =
                overflow[i] |
                (overflow[i + 1] << 8) |
                (overflow[i + 2] << 16) |
                (overflow[i + 3] << 24);
            } else {
              codepoint =
                overflow[i + 3] |
                (overflow[i + 2] << 8) |
                (overflow[i + 1] << 16) |
                (overflow[i] << 24);
            }
            overflow.length = 0;
            offset = _writeCodepoint(dst, offset, codepoint, badChar);
          }
        }
        for (; i < src.length - 3; i += 4) {
          if (isLE) {
            codepoint =
              src[i] |
              (src[i + 1] << 8) |
              (src[i + 2] << 16) |
              (src[i + 3] << 24);
          } else {
            codepoint =
              src[i + 3] |
              (src[i + 2] << 8) |
              (src[i + 1] << 16) |
              (src[i] << 24);
          }
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
        for (; i < src.length; i++) {
          overflow.push(src[i]);
        }
        return dst.slice(0, offset).toString("ucs2");
      };
      function _writeCodepoint(dst, offset, codepoint, badChar) {
        if (codepoint < 0 || codepoint > 1114111) {
          codepoint = badChar;
        }
        if (codepoint >= 65536) {
          codepoint -= 65536;
          var high = 55296 | (codepoint >> 10);
          dst[offset++] = high & 255;
          dst[offset++] = high >> 8;
          var codepoint = 56320 | (codepoint & 1023);
        }
        dst[offset++] = codepoint & 255;
        dst[offset++] = codepoint >> 8;
        return offset;
      }
      Utf32Decoder.prototype.end = function () {
        this.overflow.length = 0;
      };
      exports.utf32 = Utf32AutoCodec;
      exports.ucs4 = "utf32";
      function Utf32AutoCodec(options, iconv) {
        this.iconv = iconv;
      }
      Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
      Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
      function Utf32AutoEncoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder(
          options.defaultEncoding || "utf-32le",
          options,
        );
      }
      Utf32AutoEncoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf32AutoEncoder.prototype.end = function () {
        return this.encoder.end();
      };
      function Utf32AutoDecoder(options, codec) {
        this.decoder = null;
        this.initialBufs = [];
        this.initialBufsLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf32AutoDecoder.prototype.write = function (buf) {
        if (!this.decoder) {
          this.initialBufs.push(buf);
          this.initialBufsLen += buf.length;
          if (this.initialBufsLen < 32) return "";
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.write(buf);
      };
      Utf32AutoDecoder.prototype.end = function () {
        if (!this.decoder) {
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          var trail = this.decoder.end();
          if (trail) resStr += trail;
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.end();
      };
      function detectEncoding(bufs, defaultEncoding) {
        var b = [];
        var charsProcessed = 0;
        var invalidLE = 0,
          invalidBE = 0;
        var bmpCharsLE = 0,
          bmpCharsBE = 0;
        outer_loop: for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16) invalidBE++;
              if (b[3] !== 0 || b[2] > 16) invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
                bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
                bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
        if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
        if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
        return defaultEncoding || "utf-32le";
      }
    },
    1644: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports.utf7 = Utf7Codec;
      exports.unicode11utf7 = "utf7";
      function Utf7Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf7Codec.prototype.encoder = Utf7Encoder;
      Utf7Codec.prototype.decoder = Utf7Decoder;
      Utf7Codec.prototype.bomAware = true;
      var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
      function Utf7Encoder(options, codec) {
        this.iconv = codec.iconv;
      }
      Utf7Encoder.prototype.write = function (str) {
        return Buffer.from(
          str.replace(
            nonDirectChars,
            function (chunk) {
              return (
                "+" +
                (chunk === "+"
                  ? ""
                  : this.iconv
                      .encode(chunk, "utf16-be")
                      .toString("base64")
                      .replace(/=+$/, "")) +
                "-"
              );
            }.bind(this),
          ),
        );
      };
      Utf7Encoder.prototype.end = function () {};
      function Utf7Decoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = "";
      }
      var base64Regex = /[A-Za-z0-9\/+]/;
      var base64Chars = [];
      for (var i = 0; i < 256; i++)
        base64Chars[i] = base64Regex.test(String.fromCharCode(i));
      var plusChar = "+".charCodeAt(0),
        minusChar = "-".charCodeAt(0),
        andChar = "&".charCodeAt(0);
      Utf7Decoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;
        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            if (buf[i] == plusChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii");
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            if (!base64Chars[buf[i]]) {
              if (i == lastI && buf[i] == minusChar) {
                res += "+";
              } else {
                var b64str =
                  base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
                res += this.iconv.decode(
                  Buffer.from(b64str, "base64"),
                  "utf16-be",
                );
              }
              if (buf[i] != minusChar) i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = "";
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii");
        } else {
          var b64str =
            base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
          var canBeDecoded = b64str.length - (b64str.length % 8);
          base64Accum = b64str.slice(canBeDecoded);
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7Decoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
          res = this.iconv.decode(
            Buffer.from(this.base64Accum, "base64"),
            "utf16-be",
          );
        this.inBase64 = false;
        this.base64Accum = "";
        return res;
      };
      exports.utf7imap = Utf7IMAPCodec;
      function Utf7IMAPCodec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
      Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
      Utf7IMAPCodec.prototype.bomAware = true;
      function Utf7IMAPEncoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = Buffer.alloc(6);
        this.base64AccumIdx = 0;
      }
      Utf7IMAPEncoder.prototype.write = function (str) {
        var inBase64 = this.inBase64,
          base64Accum = this.base64Accum,
          base64AccumIdx = this.base64AccumIdx,
          buf = Buffer.alloc(str.length * 5 + 10),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var uChar = str.charCodeAt(i);
          if (32 <= uChar && uChar <= 126) {
            if (inBase64) {
              if (base64AccumIdx > 0) {
                bufIdx += buf.write(
                  base64Accum
                    .slice(0, base64AccumIdx)
                    .toString("base64")
                    .replace(/\//g, ",")
                    .replace(/=+$/, ""),
                  bufIdx,
                );
                base64AccumIdx = 0;
              }
              buf[bufIdx++] = minusChar;
              inBase64 = false;
            }
            if (!inBase64) {
              buf[bufIdx++] = uChar;
              if (uChar === andChar) buf[bufIdx++] = minusChar;
            }
          } else {
            if (!inBase64) {
              buf[bufIdx++] = andChar;
              inBase64 = true;
            }
            if (inBase64) {
              base64Accum[base64AccumIdx++] = uChar >> 8;
              base64Accum[base64AccumIdx++] = uChar & 255;
              if (base64AccumIdx == base64Accum.length) {
                bufIdx += buf.write(
                  base64Accum.toString("base64").replace(/\//g, ","),
                  bufIdx,
                );
                base64AccumIdx = 0;
              }
            }
          }
        }
        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;
        return buf.slice(0, bufIdx);
      };
      Utf7IMAPEncoder.prototype.end = function () {
        var buf = Buffer.alloc(10),
          bufIdx = 0;
        if (this.inBase64) {
          if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(
              this.base64Accum
                .slice(0, this.base64AccumIdx)
                .toString("base64")
                .replace(/\//g, ",")
                .replace(/=+$/, ""),
              bufIdx,
            );
            this.base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          this.inBase64 = false;
        }
        return buf.slice(0, bufIdx);
      };
      function Utf7IMAPDecoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = "";
      }
      var base64IMAPChars = base64Chars.slice();
      base64IMAPChars[",".charCodeAt(0)] = true;
      Utf7IMAPDecoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;
        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            if (buf[i] == andChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii");
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            if (!base64IMAPChars[buf[i]]) {
              if (i == lastI && buf[i] == minusChar) {
                res += "&";
              } else {
                var b64str =
                  base64Accum +
                  this.iconv
                    .decode(buf.slice(lastI, i), "ascii")
                    .replace(/,/g, "/");
                res += this.iconv.decode(
                  Buffer.from(b64str, "base64"),
                  "utf16-be",
                );
              }
              if (buf[i] != minusChar) i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = "";
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii");
        } else {
          var b64str =
            base64Accum +
            this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
          var canBeDecoded = b64str.length - (b64str.length % 8);
          base64Accum = b64str.slice(canBeDecoded);
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7IMAPDecoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
          res = this.iconv.decode(
            Buffer.from(this.base64Accum, "base64"),
            "utf16-be",
          );
        this.inBase64 = false;
        this.base64Accum = "";
        return res;
      };
    },
    7961: (__unused_webpack_module, exports) => {
      "use strict";
      var BOMChar = "\ufeff";
      exports.PrependBOM = PrependBOMWrapper;
      function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
      }
      PrependBOMWrapper.prototype.write = function (str) {
        if (this.addBOM) {
          str = BOMChar + str;
          this.addBOM = false;
        }
        return this.encoder.write(str);
      };
      PrependBOMWrapper.prototype.end = function () {
        return this.encoder.end();
      };
      exports.StripBOM = StripBOMWrapper;
      function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
      }
      StripBOMWrapper.prototype.write = function (buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res) return res;
        if (res[0] === BOMChar) {
          res = res.slice(1);
          if (typeof this.options.stripBOM === "function")
            this.options.stripBOM();
        }
        this.pass = true;
        return res;
      };
      StripBOMWrapper.prototype.end = function () {
        return this.decoder.end();
      };
    },
    9032: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      var bomHandling = __nccwpck_require__(7961),
        iconv = module.exports;
      iconv.encodings = null;
      iconv.defaultCharUnicode = "";
      iconv.defaultCharSingleByte = "?";
      iconv.encode = function encode(str, encoding, options) {
        str = "" + (str || "");
        var encoder = iconv.getEncoder(encoding, options);
        var res = encoder.write(str);
        var trail = encoder.end();
        return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
      };
      iconv.decode = function decode(buf, encoding, options) {
        if (typeof buf === "string") {
          if (!iconv.skipDecodeWarning) {
            console.error(
              "Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding",
            );
            iconv.skipDecodeWarning = true;
          }
          buf = Buffer.from("" + (buf || ""), "binary");
        }
        var decoder = iconv.getDecoder(encoding, options);
        var res = decoder.write(buf);
        var trail = decoder.end();
        return trail ? res + trail : res;
      };
      iconv.encodingExists = function encodingExists(enc) {
        try {
          iconv.getCodec(enc);
          return true;
        } catch (e) {
          return false;
        }
      };
      iconv.toEncoding = iconv.encode;
      iconv.fromEncoding = iconv.decode;
      iconv._codecDataCache = {};
      iconv.getCodec = function getCodec(encoding) {
        if (!iconv.encodings) iconv.encodings = __nccwpck_require__(2733);
        var enc = iconv._canonicalizeEncoding(encoding);
        var codecOptions = {};
        while (true) {
          var codec = iconv._codecDataCache[enc];
          if (codec) return codec;
          var codecDef = iconv.encodings[enc];
          switch (typeof codecDef) {
            case "string":
              enc = codecDef;
              break;
            case "object":
              for (var key in codecDef) codecOptions[key] = codecDef[key];
              if (!codecOptions.encodingName) codecOptions.encodingName = enc;
              enc = codecDef.type;
              break;
            case "function":
              if (!codecOptions.encodingName) codecOptions.encodingName = enc;
              codec = new codecDef(codecOptions, iconv);
              iconv._codecDataCache[codecOptions.encodingName] = codec;
              return codec;
            default:
              throw new Error(
                "Encoding not recognized: '" +
                  encoding +
                  "' (searched as: '" +
                  enc +
                  "')",
              );
          }
        }
      };
      iconv._canonicalizeEncoding = function (encoding) {
        return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
      };
      iconv.getEncoder = function getEncoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
          encoder = new codec.encoder(options, codec);
        if (codec.bomAware && options && options.addBOM)
          encoder = new bomHandling.PrependBOM(encoder, options);
        return encoder;
      };
      iconv.getDecoder = function getDecoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
          decoder = new codec.decoder(options, codec);
        if (codec.bomAware && !(options && options.stripBOM === false))
          decoder = new bomHandling.StripBOM(decoder, options);
        return decoder;
      };
      iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
        if (iconv.supportsStreams) return;
        var streams = __nccwpck_require__(6409)(stream_module);
        iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
        iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
        iconv.encodeStream = function encodeStream(encoding, options) {
          return new iconv.IconvLiteEncoderStream(
            iconv.getEncoder(encoding, options),
            options,
          );
        };
        iconv.decodeStream = function decodeStream(encoding, options) {
          return new iconv.IconvLiteDecoderStream(
            iconv.getDecoder(encoding, options),
            options,
          );
        };
        iconv.supportsStreams = true;
      };
      var stream_module;
      try {
        stream_module = __nccwpck_require__(2781);
      } catch (e) {}
      if (stream_module && stream_module.Transform) {
        iconv.enableStreamingAPI(stream_module);
      } else {
        iconv.encodeStream = iconv.decodeStream = function () {
          throw new Error(
            "iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.",
          );
        };
      }
      if (false) {
      }
    },
    6409: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      module.exports = function (stream_module) {
        var Transform = stream_module.Transform;
        function IconvLiteEncoderStream(conv, options) {
          this.conv = conv;
          options = options || {};
          options.decodeStrings = false;
          Transform.call(this, options);
        }
        IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
          constructor: { value: IconvLiteEncoderStream },
        });
        IconvLiteEncoderStream.prototype._transform = function (
          chunk,
          encoding,
          done,
        ) {
          if (typeof chunk != "string")
            return done(
              new Error("Iconv encoding stream needs strings as its input."),
            );
          try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteEncoderStream.prototype._flush = function (done) {
          try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteEncoderStream.prototype.collect = function (cb) {
          var chunks = [];
          this.on("error", cb);
          this.on("data", function (chunk) {
            chunks.push(chunk);
          });
          this.on("end", function () {
            cb(null, Buffer.concat(chunks));
          });
          return this;
        };
        function IconvLiteDecoderStream(conv, options) {
          this.conv = conv;
          options = options || {};
          options.encoding = this.encoding = "utf8";
          Transform.call(this, options);
        }
        IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
          constructor: { value: IconvLiteDecoderStream },
        });
        IconvLiteDecoderStream.prototype._transform = function (
          chunk,
          encoding,
          done,
        ) {
          if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array))
            return done(
              new Error("Iconv decoding stream needs buffers as its input."),
            );
          try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteDecoderStream.prototype._flush = function (done) {
          try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteDecoderStream.prototype.collect = function (cb) {
          var res = "";
          this.on("error", cb);
          this.on("data", function (chunk) {
            res += chunk;
          });
          this.on("end", function () {
            cb(null, res);
          });
          return this;
        };
        return { IconvLiteEncoderStream, IconvLiteDecoderStream };
      };
    },
    903: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AddressError = void 0;
      class AddressError extends Error {
        constructor(message, parseMessage) {
          super(message);
          this.name = "AddressError";
          if (parseMessage !== null) {
            this.parseMessage = parseMessage;
          }
        }
      }
      exports.AddressError = AddressError;
    },
    3233: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCorrect = exports.isInSubnet = void 0;
      function isInSubnet(address) {
        if (this.subnetMask < address.subnetMask) {
          return false;
        }
        if (this.mask(address.subnetMask) === address.mask()) {
          return true;
        }
        return false;
      }
      exports.isInSubnet = isInSubnet;
      function isCorrect(defaultBits) {
        return function () {
          if (this.addressMinusSuffix !== this.correctForm()) {
            return false;
          }
          if (this.subnetMask === defaultBits && !this.parsedSubnet) {
            return true;
          }
          return this.parsedSubnet === String(this.subnetMask);
        };
      }
      exports.isCorrect = isCorrect;
    },
    8953: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.v6 =
        exports.AddressError =
        exports.Address6 =
        exports.Address4 =
          void 0;
      const ipv4_1 = __nccwpck_require__(753);
      Object.defineProperty(exports, "Address4", {
        enumerable: true,
        get: function () {
          return ipv4_1.Address4;
        },
      });
      const ipv6_1 = __nccwpck_require__(8292);
      Object.defineProperty(exports, "Address6", {
        enumerable: true,
        get: function () {
          return ipv6_1.Address6;
        },
      });
      const address_error_1 = __nccwpck_require__(903);
      Object.defineProperty(exports, "AddressError", {
        enumerable: true,
        get: function () {
          return address_error_1.AddressError;
        },
      });
      const helpers = __importStar(__nccwpck_require__(945));
      exports.v6 = { helpers };
    },
    753: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Address4 = void 0;
      const common = __importStar(__nccwpck_require__(3233));
      const constants = __importStar(__nccwpck_require__(6417));
      const address_error_1 = __nccwpck_require__(903);
      const jsbn_1 = __nccwpck_require__(5587);
      const sprintf_js_1 = __nccwpck_require__(3988);
      class Address4 {
        constructor(address) {
          this.groups = constants.GROUPS;
          this.parsedAddress = [];
          this.parsedSubnet = "";
          this.subnet = "/32";
          this.subnetMask = 32;
          this.v4 = true;
          this.isCorrect = common.isCorrect(constants.BITS);
          this.isInSubnet = common.isInSubnet;
          this.address = address;
          const subnet = constants.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = `/${this.subnetMask}`;
            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants.RE_SUBNET_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(address);
        }
        static isValid(address) {
          try {
            new Address4(address);
            return true;
          } catch (e) {
            return false;
          }
        }
        parse(address) {
          const groups = address.split(".");
          if (!address.match(constants.RE_ADDRESS)) {
            throw new address_error_1.AddressError("Invalid IPv4 address.");
          }
          return groups;
        }
        correctForm() {
          return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
        }
        static fromHex(hex) {
          const padded = hex.replace(/:/g, "").padStart(8, "0");
          const groups = [];
          let i;
          for (i = 0; i < 8; i += 2) {
            const h = padded.slice(i, i + 2);
            groups.push(parseInt(h, 16));
          }
          return new Address4(groups.join("."));
        }
        static fromInteger(integer) {
          return Address4.fromHex(integer.toString(16));
        }
        static fromArpa(arpaFormAddress) {
          const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
          const address = leader.split(".").reverse().join(".");
          return new Address4(address);
        }
        toHex() {
          return this.parsedAddress
            .map((part) =>
              (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10)),
            )
            .join(":");
        }
        toArray() {
          return this.parsedAddress.map((part) => parseInt(part, 10));
        }
        toGroup6() {
          const output = [];
          let i;
          for (i = 0; i < constants.GROUPS; i += 2) {
            const hex = (0, sprintf_js_1.sprintf)(
              "%02x%02x",
              parseInt(this.parsedAddress[i], 10),
              parseInt(this.parsedAddress[i + 1], 10),
            );
            output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
          }
          return output.join(":");
        }
        bigInteger() {
          return new jsbn_1.BigInteger(
            this.parsedAddress
              .map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10)))
              .join(""),
            16,
          );
        }
        _startAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "0".repeat(constants.BITS - this.subnetMask),
            2,
          );
        }
        startAddress() {
          return Address4.fromBigInteger(this._startAddress());
        }
        startAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address4.fromBigInteger(this._startAddress().add(adjust));
        }
        _endAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "1".repeat(constants.BITS - this.subnetMask),
            2,
          );
        }
        endAddress() {
          return Address4.fromBigInteger(this._endAddress());
        }
        endAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address4.fromBigInteger(this._endAddress().subtract(adjust));
        }
        static fromBigInteger(bigInteger) {
          return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
        }
        mask(mask) {
          if (mask === undefined) {
            mask = this.subnetMask;
          }
          return this.getBitsBase2(0, mask);
        }
        getBitsBase2(start, end) {
          return this.binaryZeroPad().slice(start, end);
        }
        reverseForm(options) {
          if (!options) {
            options = {};
          }
          const reversed = this.correctForm().split(".").reverse().join(".");
          if (options.omitSuffix) {
            return reversed;
          }
          return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
        }
        isMulticast() {
          return this.isInSubnet(new Address4("224.0.0.0/4"));
        }
        binaryZeroPad() {
          return this.bigInteger().toString(2).padStart(constants.BITS, "0");
        }
        groupForV6() {
          const segments = this.parsedAddress;
          return this.address.replace(
            constants.RE_ADDRESS,
            (0, sprintf_js_1.sprintf)(
              '<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>',
              segments.slice(0, 2).join("."),
              segments.slice(2, 4).join("."),
            ),
          );
        }
      }
      exports.Address4 = Address4;
    },
    8292: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Address6 = void 0;
      const common = __importStar(__nccwpck_require__(3233));
      const constants4 = __importStar(__nccwpck_require__(6417));
      const constants6 = __importStar(__nccwpck_require__(7674));
      const helpers = __importStar(__nccwpck_require__(945));
      const ipv4_1 = __nccwpck_require__(753);
      const regular_expressions_1 = __nccwpck_require__(6738);
      const address_error_1 = __nccwpck_require__(903);
      const jsbn_1 = __nccwpck_require__(5587);
      const sprintf_js_1 = __nccwpck_require__(3988);
      function assert(condition) {
        if (!condition) {
          throw new Error("Assertion failed.");
        }
      }
      function addCommas(number) {
        const r = /(\d+)(\d{3})/;
        while (r.test(number)) {
          number = number.replace(r, "$1,$2");
        }
        return number;
      }
      function spanLeadingZeroes4(n) {
        n = n.replace(
          /^(0{1,})([1-9]+)$/,
          '<span class="parse-error">$1</span>$2',
        );
        n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
        return n;
      }
      function compact(address, slice) {
        const s1 = [];
        const s2 = [];
        let i;
        for (i = 0; i < address.length; i++) {
          if (i < slice[0]) {
            s1.push(address[i]);
          } else if (i > slice[1]) {
            s2.push(address[i]);
          }
        }
        return s1.concat(["compact"]).concat(s2);
      }
      function paddedHex(octet) {
        return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
      }
      function unsignByte(b) {
        return b & 255;
      }
      class Address6 {
        constructor(address, optionalGroups) {
          this.addressMinusSuffix = "";
          this.parsedSubnet = "";
          this.subnet = "/128";
          this.subnetMask = 128;
          this.v4 = false;
          this.zone = "";
          this.isInSubnet = common.isInSubnet;
          this.isCorrect = common.isCorrect(constants6.BITS);
          if (optionalGroups === undefined) {
            this.groups = constants6.GROUPS;
          } else {
            this.groups = optionalGroups;
          }
          this.address = address;
          const subnet = constants6.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = `/${this.subnetMask}`;
            if (
              Number.isNaN(this.subnetMask) ||
              this.subnetMask < 0 ||
              this.subnetMask > constants6.BITS
            ) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants6.RE_SUBNET_STRING, "");
          } else if (/\//.test(address)) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          const zone = constants6.RE_ZONE_STRING.exec(address);
          if (zone) {
            this.zone = zone[0];
            address = address.replace(constants6.RE_ZONE_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(this.addressMinusSuffix);
        }
        static isValid(address) {
          try {
            new Address6(address);
            return true;
          } catch (e) {
            return false;
          }
        }
        static fromBigInteger(bigInteger) {
          const hex = bigInteger.toString(16).padStart(32, "0");
          const groups = [];
          let i;
          for (i = 0; i < constants6.GROUPS; i++) {
            groups.push(hex.slice(i * 4, (i + 1) * 4));
          }
          return new Address6(groups.join(":"));
        }
        static fromURL(url) {
          let host;
          let port = null;
          let result;
          if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
            result = constants6.RE_URL_WITH_PORT.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address with port",
                address: null,
                port: null,
              };
            }
            host = result[1];
            port = result[2];
          } else if (url.indexOf("/") !== -1) {
            url = url.replace(/^[a-z0-9]+:\/\//, "");
            result = constants6.RE_URL.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address from URL",
                address: null,
                port: null,
              };
            }
            host = result[1];
          } else {
            host = url;
          }
          if (port) {
            port = parseInt(port, 10);
            if (port < 0 || port > 65536) {
              port = null;
            }
          } else {
            port = null;
          }
          return { address: new Address6(host), port };
        }
        static fromAddress4(address) {
          const address4 = new ipv4_1.Address4(address);
          const mask6 =
            constants6.BITS - (constants4.BITS - address4.subnetMask);
          return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
        }
        static fromArpa(arpaFormAddress) {
          let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
          const semicolonAmount = 7;
          if (address.length !== 63) {
            throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
          }
          const parts = address.split(".").reverse();
          for (let i = semicolonAmount; i > 0; i--) {
            const insertIndex = i * 4;
            parts.splice(insertIndex, 0, ":");
          }
          address = parts.join("");
          return new Address6(address);
        }
        microsoftTranscription() {
          return (0, sprintf_js_1.sprintf)(
            "%s.ipv6-literal.net",
            this.correctForm().replace(/:/g, "-"),
          );
        }
        mask(mask = this.subnetMask) {
          return this.getBitsBase2(0, mask);
        }
        possibleSubnets(subnetSize = 128) {
          const availableBits = constants6.BITS - this.subnetMask;
          const subnetBits = Math.abs(subnetSize - constants6.BITS);
          const subnetPowers = availableBits - subnetBits;
          if (subnetPowers < 0) {
            return "0";
          }
          return addCommas(
            new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10),
          );
        }
        _startAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "0".repeat(constants6.BITS - this.subnetMask),
            2,
          );
        }
        startAddress() {
          return Address6.fromBigInteger(this._startAddress());
        }
        startAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address6.fromBigInteger(this._startAddress().add(adjust));
        }
        _endAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "1".repeat(constants6.BITS - this.subnetMask),
            2,
          );
        }
        endAddress() {
          return Address6.fromBigInteger(this._endAddress());
        }
        endAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address6.fromBigInteger(this._endAddress().subtract(adjust));
        }
        getScope() {
          let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
          if (this.getType() === "Global unicast" && scope !== "Link local") {
            scope = "Global";
          }
          return scope || "Unknown";
        }
        getType() {
          for (const subnet of Object.keys(constants6.TYPES)) {
            if (this.isInSubnet(new Address6(subnet))) {
              return constants6.TYPES[subnet];
            }
          }
          return "Global unicast";
        }
        getBits(start, end) {
          return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
        }
        getBitsBase2(start, end) {
          return this.binaryZeroPad().slice(start, end);
        }
        getBitsBase16(start, end) {
          const length = end - start;
          if (length % 4 !== 0) {
            throw new Error(
              "Length of bits to retrieve must be divisible by four",
            );
          }
          return this.getBits(start, end)
            .toString(16)
            .padStart(length / 4, "0");
        }
        getBitsPastSubnet() {
          return this.getBitsBase2(this.subnetMask, constants6.BITS);
        }
        reverseForm(options) {
          if (!options) {
            options = {};
          }
          const characters = Math.floor(this.subnetMask / 4);
          const reversed = this.canonicalForm()
            .replace(/:/g, "")
            .split("")
            .slice(0, characters)
            .reverse()
            .join(".");
          if (characters > 0) {
            if (options.omitSuffix) {
              return reversed;
            }
            return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
          }
          if (options.omitSuffix) {
            return "";
          }
          return "ip6.arpa.";
        }
        correctForm() {
          let i;
          let groups = [];
          let zeroCounter = 0;
          const zeroes = [];
          for (i = 0; i < this.parsedAddress.length; i++) {
            const value = parseInt(this.parsedAddress[i], 16);
            if (value === 0) {
              zeroCounter++;
            }
            if (value !== 0 && zeroCounter > 0) {
              if (zeroCounter > 1) {
                zeroes.push([i - zeroCounter, i - 1]);
              }
              zeroCounter = 0;
            }
          }
          if (zeroCounter > 1) {
            zeroes.push([
              this.parsedAddress.length - zeroCounter,
              this.parsedAddress.length - 1,
            ]);
          }
          const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
          if (zeroes.length > 0) {
            const index = zeroLengths.indexOf(Math.max(...zeroLengths));
            groups = compact(this.parsedAddress, zeroes[index]);
          } else {
            groups = this.parsedAddress;
          }
          for (i = 0; i < groups.length; i++) {
            if (groups[i] !== "compact") {
              groups[i] = parseInt(groups[i], 16).toString(16);
            }
          }
          let correct = groups.join(":");
          correct = correct.replace(/^compact$/, "::");
          correct = correct.replace(/^compact|compact$/, ":");
          correct = correct.replace(/compact/, "");
          return correct;
        }
        binaryZeroPad() {
          return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
        }
        parse4in6(address) {
          const groups = address.split(":");
          const lastGroup = groups.slice(-1)[0];
          const address4 = lastGroup.match(constants4.RE_ADDRESS);
          if (address4) {
            this.parsedAddress4 = address4[0];
            this.address4 = new ipv4_1.Address4(this.parsedAddress4);
            for (let i = 0; i < this.address4.groups; i++) {
              if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
                throw new address_error_1.AddressError(
                  "IPv4 addresses can't have leading zeroes.",
                  address.replace(
                    constants4.RE_ADDRESS,
                    this.address4.parsedAddress
                      .map(spanLeadingZeroes4)
                      .join("."),
                  ),
                );
              }
            }
            this.v4 = true;
            groups[groups.length - 1] = this.address4.toGroup6();
            address = groups.join(":");
          }
          return address;
        }
        parse(address) {
          address = this.parse4in6(address);
          const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
          if (badCharacters) {
            throw new address_error_1.AddressError(
              (0, sprintf_js_1.sprintf)(
                "Bad character%s detected in address: %s",
                badCharacters.length > 1 ? "s" : "",
                badCharacters.join(""),
              ),
              address.replace(
                constants6.RE_BAD_CHARACTERS,
                '<span class="parse-error">$1</span>',
              ),
            );
          }
          const badAddress = address.match(constants6.RE_BAD_ADDRESS);
          if (badAddress) {
            throw new address_error_1.AddressError(
              (0, sprintf_js_1.sprintf)(
                "Address failed regex: %s",
                badAddress.join(""),
              ),
              address.replace(
                constants6.RE_BAD_ADDRESS,
                '<span class="parse-error">$1</span>',
              ),
            );
          }
          let groups = [];
          const halves = address.split("::");
          if (halves.length === 2) {
            let first = halves[0].split(":");
            let last = halves[1].split(":");
            if (first.length === 1 && first[0] === "") {
              first = [];
            }
            if (last.length === 1 && last[0] === "") {
              last = [];
            }
            const remaining = this.groups - (first.length + last.length);
            if (!remaining) {
              throw new address_error_1.AddressError("Error parsing groups");
            }
            this.elidedGroups = remaining;
            this.elisionBegin = first.length;
            this.elisionEnd = first.length + this.elidedGroups;
            groups = groups.concat(first);
            for (let i = 0; i < remaining; i++) {
              groups.push("0");
            }
            groups = groups.concat(last);
          } else if (halves.length === 1) {
            groups = address.split(":");
            this.elidedGroups = 0;
          } else {
            throw new address_error_1.AddressError("Too many :: groups found");
          }
          groups = groups.map((group) =>
            (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)),
          );
          if (groups.length !== this.groups) {
            throw new address_error_1.AddressError(
              "Incorrect number of groups found",
            );
          }
          return groups;
        }
        canonicalForm() {
          return this.parsedAddress.map(paddedHex).join(":");
        }
        decimal() {
          return this.parsedAddress
            .map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16)))
            .join(":");
        }
        bigInteger() {
          return new jsbn_1.BigInteger(
            this.parsedAddress.map(paddedHex).join(""),
            16,
          );
        }
        to4() {
          const binary = this.binaryZeroPad().split("");
          return ipv4_1.Address4.fromHex(
            new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(
              16,
            ),
          );
        }
        to4in6() {
          const address4 = this.to4();
          const address6 = new Address6(
            this.parsedAddress.slice(0, 6).join(":"),
            6,
          );
          const correct = address6.correctForm();
          let infix = "";
          if (!/:$/.test(correct)) {
            infix = ":";
          }
          return correct + infix + address4.address;
        }
        inspectTeredo() {
          const prefix = this.getBitsBase16(0, 32);
          const udpPort = this.getBits(80, 96)
            .xor(new jsbn_1.BigInteger("ffff", 16))
            .toString();
          const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
          const client4 = ipv4_1.Address4.fromHex(
            this.getBits(96, 128)
              .xor(new jsbn_1.BigInteger("ffffffff", 16))
              .toString(16),
          );
          const flags = this.getBits(64, 80);
          const flagsBase2 = this.getBitsBase2(64, 80);
          const coneNat = flags.testBit(15);
          const reserved = flags.testBit(14);
          const groupIndividual = flags.testBit(8);
          const universalLocal = flags.testBit(9);
          const nonce = new jsbn_1.BigInteger(
            flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16),
            2,
          ).toString(10);
          return {
            prefix: (0, sprintf_js_1.sprintf)(
              "%s:%s",
              prefix.slice(0, 4),
              prefix.slice(4, 8),
            ),
            server4: server4.address,
            client4: client4.address,
            flags: flagsBase2,
            coneNat,
            microsoft: { reserved, universalLocal, groupIndividual, nonce },
            udpPort,
          };
        }
        inspect6to4() {
          const prefix = this.getBitsBase16(0, 16);
          const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
          return {
            prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
            gateway: gateway.address,
          };
        }
        to6to4() {
          if (!this.is4()) {
            return null;
          }
          const addr6to4 = [
            "2002",
            this.getBitsBase16(96, 112),
            this.getBitsBase16(112, 128),
            "",
            "/16",
          ].join(":");
          return new Address6(addr6to4);
        }
        toByteArray() {
          const byteArray = this.bigInteger().toByteArray();
          if (byteArray.length === 17 && byteArray[0] === 0) {
            return byteArray.slice(1);
          }
          return byteArray;
        }
        toUnsignedByteArray() {
          return this.toByteArray().map(unsignByte);
        }
        static fromByteArray(bytes) {
          return this.fromUnsignedByteArray(bytes.map(unsignByte));
        }
        static fromUnsignedByteArray(bytes) {
          const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
          let result = new jsbn_1.BigInteger("0", 10);
          let multiplier = new jsbn_1.BigInteger("1", 10);
          for (let i = bytes.length - 1; i >= 0; i--) {
            result = result.add(
              multiplier.multiply(
                new jsbn_1.BigInteger(bytes[i].toString(10), 10),
              ),
            );
            multiplier = multiplier.multiply(BYTE_MAX);
          }
          return Address6.fromBigInteger(result);
        }
        isCanonical() {
          return this.addressMinusSuffix === this.canonicalForm();
        }
        isLinkLocal() {
          if (
            this.getBitsBase2(0, 64) ===
            "1111111010000000000000000000000000000000000000000000000000000000"
          ) {
            return true;
          }
          return false;
        }
        isMulticast() {
          return this.getType() === "Multicast";
        }
        is4() {
          return this.v4;
        }
        isTeredo() {
          return this.isInSubnet(new Address6("2001::/32"));
        }
        is6to4() {
          return this.isInSubnet(new Address6("2002::/16"));
        }
        isLoopback() {
          return this.getType() === "Loopback";
        }
        href(optionalPort) {
          if (optionalPort === undefined) {
            optionalPort = "";
          } else {
            optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
          }
          return (0, sprintf_js_1.sprintf)(
            "http://[%s]%s/",
            this.correctForm(),
            optionalPort,
          );
        }
        link(options) {
          if (!options) {
            options = {};
          }
          if (options.className === undefined) {
            options.className = "";
          }
          if (options.prefix === undefined) {
            options.prefix = "/#address=";
          }
          if (options.v4 === undefined) {
            options.v4 = false;
          }
          let formFunction = this.correctForm;
          if (options.v4) {
            formFunction = this.to4in6;
          }
          if (options.className) {
            return (0, sprintf_js_1.sprintf)(
              '<a href="%1$s%2$s" class="%3$s">%2$s</a>',
              options.prefix,
              formFunction.call(this),
              options.className,
            );
          }
          return (0, sprintf_js_1.sprintf)(
            '<a href="%1$s%2$s">%2$s</a>',
            options.prefix,
            formFunction.call(this),
          );
        }
        group() {
          if (this.elidedGroups === 0) {
            return helpers.simpleGroup(this.address).join(":");
          }
          assert(typeof this.elidedGroups === "number");
          assert(typeof this.elisionBegin === "number");
          const output = [];
          const [left, right] = this.address.split("::");
          if (left.length) {
            output.push(...helpers.simpleGroup(left));
          } else {
            output.push("");
          }
          const classes = ["hover-group"];
          for (
            let i = this.elisionBegin;
            i < this.elisionBegin + this.elidedGroups;
            i++
          ) {
            classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
          }
          output.push(
            (0, sprintf_js_1.sprintf)(
              '<span class="%s"></span>',
              classes.join(" "),
            ),
          );
          if (right.length) {
            output.push(...helpers.simpleGroup(right, this.elisionEnd));
          } else {
            output.push("");
          }
          if (this.is4()) {
            assert(this.address4 instanceof ipv4_1.Address4);
            output.pop();
            output.push(this.address4.groupForV6());
          }
          return output.join(":");
        }
        regularExpressionString(substringSearch = false) {
          let output = [];
          const address6 = new Address6(this.correctForm());
          if (address6.elidedGroups === 0) {
            output.push(
              (0, regular_expressions_1.simpleRegularExpression)(
                address6.parsedAddress,
              ),
            );
          } else if (address6.elidedGroups === constants6.GROUPS) {
            output.push(
              (0, regular_expressions_1.possibleElisions)(constants6.GROUPS),
            );
          } else {
            const halves = address6.address.split("::");
            if (halves[0].length) {
              output.push(
                (0, regular_expressions_1.simpleRegularExpression)(
                  halves[0].split(":"),
                ),
              );
            }
            assert(typeof address6.elidedGroups === "number");
            output.push(
              (0, regular_expressions_1.possibleElisions)(
                address6.elidedGroups,
                halves[0].length !== 0,
                halves[1].length !== 0,
              ),
            );
            if (halves[1].length) {
              output.push(
                (0, regular_expressions_1.simpleRegularExpression)(
                  halves[1].split(":"),
                ),
              );
            }
            output = [output.join(":")];
          }
          if (!substringSearch) {
            output = [
              "(?=^|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|[^\\w\\:])(",
              ...output,
              ")(?=[^\\w\\:]|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|$)",
            ];
          }
          return output.join("");
        }
        regularExpression(substringSearch = false) {
          return new RegExp(this.regularExpressionString(substringSearch), "i");
        }
      }
      exports.Address6 = Address6;
    },
    6417: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RE_SUBNET_STRING =
        exports.RE_ADDRESS =
        exports.GROUPS =
        exports.BITS =
          void 0;
      exports.BITS = 32;
      exports.GROUPS = 4;
      exports.RE_ADDRESS =
        /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
      exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
    },
    7674: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RE_URL_WITH_PORT =
        exports.RE_URL =
        exports.RE_ZONE_STRING =
        exports.RE_SUBNET_STRING =
        exports.RE_BAD_ADDRESS =
        exports.RE_BAD_CHARACTERS =
        exports.TYPES =
        exports.SCOPES =
        exports.GROUPS =
        exports.BITS =
          void 0;
      exports.BITS = 128;
      exports.GROUPS = 8;
      exports.SCOPES = {
        0: "Reserved",
        1: "Interface local",
        2: "Link local",
        4: "Admin local",
        5: "Site local",
        8: "Organization local",
        14: "Global",
        15: "Reserved",
      };
      exports.TYPES = {
        "ff01::1/128": "Multicast (All nodes on this interface)",
        "ff01::2/128": "Multicast (All routers on this interface)",
        "ff02::1/128": "Multicast (All nodes on this link)",
        "ff02::2/128": "Multicast (All routers on this link)",
        "ff05::2/128": "Multicast (All routers in this site)",
        "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
        "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
        "ff02::9/128": "Multicast (RIP routers)",
        "ff02::a/128": "Multicast (EIGRP routers)",
        "ff02::d/128": "Multicast (PIM routers)",
        "ff02::16/128": "Multicast (MLDv2 reports)",
        "ff01::fb/128": "Multicast (mDNSv6)",
        "ff02::fb/128": "Multicast (mDNSv6)",
        "ff05::fb/128": "Multicast (mDNSv6)",
        "ff02::1:2/128":
          "Multicast (All DHCP servers and relay agents on this link)",
        "ff05::1:2/128":
          "Multicast (All DHCP servers and relay agents in this site)",
        "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
        "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
        "::/128": "Unspecified",
        "::1/128": "Loopback",
        "ff00::/8": "Multicast",
        "fe80::/10": "Link-local unicast",
      };
      exports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
      exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
      exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
      exports.RE_ZONE_STRING = /%.*$/;
      exports.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
      exports.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
    },
    945: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.simpleGroup =
        exports.spanLeadingZeroes =
        exports.spanAll =
        exports.spanAllZeroes =
          void 0;
      const sprintf_js_1 = __nccwpck_require__(3988);
      function spanAllZeroes(s) {
        return s.replace(/(0+)/g, '<span class="zero">$1</span>');
      }
      exports.spanAllZeroes = spanAllZeroes;
      function spanAll(s, offset = 0) {
        const letters = s.split("");
        return letters
          .map((n, i) =>
            (0, sprintf_js_1.sprintf)(
              '<span class="digit value-%s position-%d">%s</span>',
              n,
              i + offset,
              spanAllZeroes(n),
            ),
          )
          .join("");
      }
      exports.spanAll = spanAll;
      function spanLeadingZeroesSimple(group) {
        return group.replace(/^(0+)/, '<span class="zero">$1</span>');
      }
      function spanLeadingZeroes(address) {
        const groups = address.split(":");
        return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
      }
      exports.spanLeadingZeroes = spanLeadingZeroes;
      function simpleGroup(addressString, offset = 0) {
        const groups = addressString.split(":");
        return groups.map((g, i) => {
          if (/group-v4/.test(g)) {
            return g;
          }
          return (0, sprintf_js_1.sprintf)(
            '<span class="hover-group group-%d">%s</span>',
            i + offset,
            spanLeadingZeroesSimple(g),
          );
        });
      }
      exports.simpleGroup = simpleGroup;
    },
    6738: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.possibleElisions =
        exports.simpleRegularExpression =
        exports.ADDRESS_BOUNDARY =
        exports.padGroup =
        exports.groupPossibilities =
          void 0;
      const v6 = __importStar(__nccwpck_require__(7674));
      const sprintf_js_1 = __nccwpck_require__(3988);
      function groupPossibilities(possibilities) {
        return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
      }
      exports.groupPossibilities = groupPossibilities;
      function padGroup(group) {
        if (group.length < 4) {
          return (0, sprintf_js_1.sprintf)(
            "0{0,%d}%s",
            4 - group.length,
            group,
          );
        }
        return group;
      }
      exports.padGroup = padGroup;
      exports.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
      function simpleRegularExpression(groups) {
        const zeroIndexes = [];
        groups.forEach((group, i) => {
          const groupInteger = parseInt(group, 16);
          if (groupInteger === 0) {
            zeroIndexes.push(i);
          }
        });
        const possibilities = zeroIndexes.map((zeroIndex) =>
          groups
            .map((group, i) => {
              if (i === zeroIndex) {
                const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
                return groupPossibilities([padGroup(group), elision]);
              }
              return padGroup(group);
            })
            .join(":"),
        );
        possibilities.push(groups.map(padGroup).join(":"));
        return groupPossibilities(possibilities);
      }
      exports.simpleRegularExpression = simpleRegularExpression;
      function possibleElisions(elidedGroups, moreLeft, moreRight) {
        const left = moreLeft ? "" : ":";
        const right = moreRight ? "" : ":";
        const possibilities = [];
        if (!moreLeft && !moreRight) {
          possibilities.push("::");
        }
        if (moreLeft && moreRight) {
          possibilities.push("");
        }
        if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {
          possibilities.push(":");
        }
        possibilities.push(
          (0, sprintf_js_1.sprintf)(
            "%s(:0{1,4}){1,%d}",
            left,
            elidedGroups - 1,
          ),
        );
        possibilities.push(
          (0, sprintf_js_1.sprintf)(
            "(0{1,4}:){1,%d}%s",
            elidedGroups - 1,
            right,
          ),
        );
        possibilities.push(
          (0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1),
        );
        for (let groups = 1; groups < elidedGroups - 1; groups++) {
          for (let position = 1; position < elidedGroups - groups; position++) {
            possibilities.push(
              (0, sprintf_js_1.sprintf)(
                "(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}",
                position,
                elidedGroups - position - groups - 1,
              ),
            );
          }
        }
        return groupPossibilities(possibilities);
      }
      exports.possibleElisions = possibleElisions;
    },
    5587: function (module, exports) {
      (function () {
        var dbits;
        var canary = 0xdeadbeefcafe;
        var j_lm = (canary & 16777215) == 15715070;
        function BigInteger(a, b, c) {
          if (a != null)
            if ("number" == typeof a) this.fromNumber(a, b, c);
            else if (b == null && "string" != typeof a) this.fromString(a, 256);
            else this.fromString(a, b);
        }
        function nbi() {
          return new BigInteger(null);
        }
        function am1(i, x, w, j, c, n) {
          while (--n >= 0) {
            var v = x * this[i++] + w[j] + c;
            c = Math.floor(v / 67108864);
            w[j++] = v & 67108863;
          }
          return c;
        }
        function am2(i, x, w, j, c, n) {
          var xl = x & 32767,
            xh = x >> 15;
          while (--n >= 0) {
            var l = this[i] & 32767;
            var h = this[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w[j++] = l & 1073741823;
          }
          return c;
        }
        function am3(i, x, w, j, c, n) {
          var xl = x & 16383,
            xh = x >> 14;
          while (--n >= 0) {
            var l = this[i] & 16383;
            var h = this[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 16383) << 14) + w[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w[j++] = l & 268435455;
          }
          return c;
        }
        var inBrowser = typeof navigator !== "undefined";
        if (
          inBrowser &&
          j_lm &&
          navigator.appName == "Microsoft Internet Explorer"
        ) {
          BigInteger.prototype.am = am2;
          dbits = 30;
        } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = (1 << dbits) - 1;
        BigInteger.prototype.DV = 1 << dbits;
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr, vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        function int2char(n) {
          return BI_RM.charAt(n);
        }
        function intAt(s, i) {
          var c = BI_RC[s.charCodeAt(i)];
          return c == null ? -1 : c;
        }
        function bnpCopyTo(r) {
          for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
          r.t = this.t;
          r.s = this.s;
        }
        function bnpFromInt(x) {
          this.t = 1;
          this.s = x < 0 ? -1 : 0;
          if (x > 0) this[0] = x;
          else if (x < -1) this[0] = x + this.DV;
          else this.t = 0;
        }
        function nbv(i) {
          var r = nbi();
          r.fromInt(i);
          return r;
        }
        function bnpFromString(s, b) {
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 256) k = 8;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else {
            this.fromRadix(s, b);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i = s.length,
            mi = false,
            sh = 0;
          while (--i >= 0) {
            var x = k == 8 ? s[i] & 255 : intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-") mi = true;
              continue;
            }
            mi = false;
            if (sh == 0) this[this.t++] = x;
            else if (sh + k > this.DB) {
              this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
              this[this.t++] = x >> (this.DB - sh);
            } else this[this.t - 1] |= x << sh;
            sh += k;
            if (sh >= this.DB) sh -= this.DB;
          }
          if (k == 8 && (s[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
          }
          this.clamp();
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpClamp() {
          var c = this.s & this.DM;
          while (this.t > 0 && this[this.t - 1] == c) --this.t;
        }
        function bnToString(b) {
          if (this.s < 0) return "-" + this.negate().toString(b);
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else return this.toRadix(b);
          var km = (1 << k) - 1,
            d,
            m = false,
            r = "",
            i = this.t;
          var p = this.DB - ((i * this.DB) % k);
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
              m = true;
              r = int2char(d);
            }
            while (i >= 0) {
              if (p < k) {
                d = (this[i] & ((1 << p) - 1)) << (k - p);
                d |= this[--i] >> (p += this.DB - k);
              } else {
                d = (this[i] >> (p -= k)) & km;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if (d > 0) m = true;
              if (m) r += int2char(d);
            }
          }
          return m ? r : "0";
        }
        function bnNegate() {
          var r = nbi();
          BigInteger.ZERO.subTo(this, r);
          return r;
        }
        function bnAbs() {
          return this.s < 0 ? this.negate() : this;
        }
        function bnCompareTo(a) {
          var r = this.s - a.s;
          if (r != 0) return r;
          var i = this.t;
          r = i - a.t;
          if (r != 0) return this.s < 0 ? -r : r;
          while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
          return 0;
        }
        function nbits(x) {
          var r = 1,
            t;
          if ((t = x >>> 16) != 0) {
            x = t;
            r += 16;
          }
          if ((t = x >> 8) != 0) {
            x = t;
            r += 8;
          }
          if ((t = x >> 4) != 0) {
            x = t;
            r += 4;
          }
          if ((t = x >> 2) != 0) {
            x = t;
            r += 2;
          }
          if ((t = x >> 1) != 0) {
            x = t;
            r += 1;
          }
          return r;
        }
        function bnBitLength() {
          if (this.t <= 0) return 0;
          return (
            this.DB * (this.t - 1) +
            nbits(this[this.t - 1] ^ (this.s & this.DM))
          );
        }
        function bnpDLShiftTo(n, r) {
          var i;
          for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
          for (i = n - 1; i >= 0; --i) r[i] = 0;
          r.t = this.t + n;
          r.s = this.s;
        }
        function bnpDRShiftTo(n, r) {
          for (var i = n; i < this.t; ++i) r[i - n] = this[i];
          r.t = Math.max(this.t - n, 0);
          r.s = this.s;
        }
        function bnpLShiftTo(n, r) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB),
            c = (this.s << bs) & this.DM,
            i;
          for (i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
          }
          for (i = ds - 1; i >= 0; --i) r[i] = 0;
          r[ds] = c;
          r.t = this.t + ds + 1;
          r.s = this.s;
          r.clamp();
        }
        function bnpRShiftTo(n, r) {
          r.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r[0] = this[ds] >> bs;
          for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
          }
          if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
          r.t = this.t - ds;
          r.clamp();
        }
        function bnpSubTo(a, r) {
          var i = 0,
            c = 0,
            m = Math.min(a.t, this.t);
          while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
              c += this[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c -= a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c -= a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c < -1) r[i++] = this.DV + c;
          else if (c > 0) r[i++] = c;
          r.t = i;
          r.clamp();
        }
        function bnpMultiplyTo(a, r) {
          var x = this.abs(),
            y = a.abs();
          var i = x.t;
          r.t = i + y.t;
          while (--i >= 0) r[i] = 0;
          for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
          r.s = 0;
          r.clamp();
          if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
        }
        function bnpSquareTo(r) {
          var x = this.abs();
          var i = (r.t = 2 * x.t);
          while (--i >= 0) r[i] = 0;
          for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if (
              (r[i + x.t] += x.am(
                i + 1,
                2 * x[i],
                r,
                2 * i + 1,
                c,
                x.t - i - 1,
              )) >= x.DV
            ) {
              r[i + x.t] -= x.DV;
              r[i + x.t + 1] = 1;
            }
          }
          if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
          r.s = 0;
          r.clamp();
        }
        function bnpDivRemTo(m, q, r) {
          var pm = m.abs();
          if (pm.t <= 0) return;
          var pt = this.abs();
          if (pt.t < pm.t) {
            if (q != null) q.fromInt(0);
            if (r != null) this.copyTo(r);
            return;
          }
          if (r == null) r = nbi();
          var y = nbi(),
            ts = this.s,
            ms = m.s;
          var nsh = this.DB - nbits(pm[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
          } else {
            pm.copyTo(y);
            pt.copyTo(r);
          }
          var ys = y.t;
          var y0 = y[ys - 1];
          if (y0 == 0) return;
          var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt,
            d2 = (1 << this.F1) / yt,
            e = 1 << this.F2;
          var i = r.t,
            j = i - ys,
            t = q == null ? nbi() : q;
          y.dlShiftTo(j, t);
          if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
          }
          BigInteger.ONE.dlShiftTo(ys, t);
          t.subTo(y, y);
          while (y.t < ys) y[y.t++] = 0;
          while (--j >= 0) {
            var qd =
              r[--i] == y0
                ? this.DM
                : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
              y.dlShiftTo(j, t);
              r.subTo(t, r);
              while (r[i] < --qd) r.subTo(t, r);
            }
          }
          if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) BigInteger.ZERO.subTo(q, q);
          }
          r.t = ys;
          r.clamp();
          if (nsh > 0) r.rShiftTo(nsh, r);
          if (ts < 0) BigInteger.ZERO.subTo(r, r);
        }
        function bnMod(a) {
          var r = nbi();
          this.abs().divRemTo(a, null, r);
          if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
          return r;
        }
        function Classic(m) {
          this.m = m;
        }
        function cConvert(x) {
          if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
          else return x;
        }
        function cRevert(x) {
          return x;
        }
        function cReduce(x) {
          x.divRemTo(this.m, null, x);
        }
        function cMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        function cSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
        function bnpInvDigit() {
          if (this.t < 1) return 0;
          var x = this[0];
          if ((x & 1) == 0) return 0;
          var y = x & 3;
          y = (y * (2 - (x & 15) * y)) & 15;
          y = (y * (2 - (x & 255) * y)) & 255;
          y = (y * (2 - (((x & 65535) * y) & 65535))) & 65535;
          y = (y * (2 - ((x * y) % this.DV))) % this.DV;
          return y > 0 ? this.DV - y : -y;
        }
        function Montgomery(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << (m.DB - 15)) - 1;
          this.mt2 = 2 * m.t;
        }
        function montConvert(x) {
          var r = nbi();
          x.abs().dlShiftTo(this.m.t, r);
          r.divRemTo(this.m, null, r);
          if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
          return r;
        }
        function montRevert(x) {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
        function montReduce(x) {
          while (x.t <= this.mt2) x[x.t++] = 0;
          for (var i = 0; i < this.m.t; ++i) {
            var j = x[i] & 32767;
            var u0 =
              (j * this.mpl +
                (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) &
              x.DM;
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            while (x[j] >= x.DV) {
              x[j] -= x.DV;
              x[++j]++;
            }
          }
          x.clamp();
          x.drShiftTo(this.m.t, x);
          if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function montSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function montMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
        function bnpIsEven() {
          return (this.t > 0 ? this[0] & 1 : this.s) == 0;
        }
        function bnpExp(e, z) {
          if (e > 4294967295 || e < 1) return BigInteger.ONE;
          var r = nbi(),
            r2 = nbi(),
            g = z.convert(this),
            i = nbits(e) - 1;
          g.copyTo(r);
          while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
            else {
              var t = r;
              r = r2;
              r2 = t;
            }
          }
          return z.revert(r);
        }
        function bnModPowInt(e, m) {
          var z;
          if (e < 256 || m.isEven()) z = new Classic(m);
          else z = new Montgomery(m);
          return this.exp(e, z);
        }
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
        function bnClone() {
          var r = nbi();
          this.copyTo(r);
          return r;
        }
        function bnIntValue() {
          if (this.s < 0) {
            if (this.t == 1) return this[0] - this.DV;
            else if (this.t == 0) return -1;
          } else if (this.t == 1) return this[0];
          else if (this.t == 0) return 0;
          return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
        }
        function bnByteValue() {
          return this.t == 0 ? this.s : (this[0] << 24) >> 24;
        }
        function bnShortValue() {
          return this.t == 0 ? this.s : (this[0] << 16) >> 16;
        }
        function bnpChunkSize(r) {
          return Math.floor((Math.LN2 * this.DB) / Math.log(r));
        }
        function bnSigNum() {
          if (this.s < 0) return -1;
          else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
          else return 1;
        }
        function bnpToRadix(b) {
          if (b == null) b = 10;
          if (this.signum() == 0 || b < 2 || b > 36) return "0";
          var cs = this.chunkSize(b);
          var a = Math.pow(b, cs);
          var d = nbv(a),
            y = nbi(),
            z = nbi(),
            r = "";
          this.divRemTo(d, y, z);
          while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
          }
          return z.intValue().toString(b) + r;
        }
        function bnpFromRadix(s, b) {
          this.fromInt(0);
          if (b == null) b = 10;
          var cs = this.chunkSize(b);
          var d = Math.pow(b, cs),
            mi = false,
            j = 0,
            w = 0;
          for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
              continue;
            }
            w = b * w + x;
            if (++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w, 0);
              j = 0;
              w = 0;
            }
          }
          if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
          }
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpFromNumber(a, b, c) {
          if ("number" == typeof b) {
            if (a < 2) this.fromInt(1);
            else {
              this.fromNumber(a, c);
              if (!this.testBit(a - 1))
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              if (this.isEven()) this.dAddOffset(1, 0);
              while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a)
                  this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
              }
            }
          } else {
            var x = new Array(),
              t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) x[0] &= (1 << t) - 1;
            else x[0] = 0;
            this.fromString(x, 256);
          }
        }
        function bnToByteArray() {
          var i = this.t,
            r = new Array();
          r[0] = this.s;
          var p = this.DB - ((i * this.DB) % 8),
            d,
            k = 0;
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
              r[k++] = d | (this.s << (this.DB - p));
            while (i >= 0) {
              if (p < 8) {
                d = (this[i] & ((1 << p) - 1)) << (8 - p);
                d |= this[--i] >> (p += this.DB - 8);
              } else {
                d = (this[i] >> (p -= 8)) & 255;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if ((d & 128) != 0) d |= -256;
              if (k == 0 && (this.s & 128) != (d & 128)) ++k;
              if (k > 0 || d != this.s) r[k++] = d;
            }
          }
          return r;
        }
        function bnEquals(a) {
          return this.compareTo(a) == 0;
        }
        function bnMin(a) {
          return this.compareTo(a) < 0 ? this : a;
        }
        function bnMax(a) {
          return this.compareTo(a) > 0 ? this : a;
        }
        function bnpBitwiseTo(a, op, r) {
          var i,
            f,
            m = Math.min(a.t, this.t);
          for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
          if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
            r.t = this.t;
          } else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
            r.t = a.t;
          }
          r.s = op(this.s, a.s);
          r.clamp();
        }
        function op_and(x, y) {
          return x & y;
        }
        function bnAnd(a) {
          var r = nbi();
          this.bitwiseTo(a, op_and, r);
          return r;
        }
        function op_or(x, y) {
          return x | y;
        }
        function bnOr(a) {
          var r = nbi();
          this.bitwiseTo(a, op_or, r);
          return r;
        }
        function op_xor(x, y) {
          return x ^ y;
        }
        function bnXor(a) {
          var r = nbi();
          this.bitwiseTo(a, op_xor, r);
          return r;
        }
        function op_andnot(x, y) {
          return x & ~y;
        }
        function bnAndNot(a) {
          var r = nbi();
          this.bitwiseTo(a, op_andnot, r);
          return r;
        }
        function bnNot() {
          var r = nbi();
          for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
          r.t = this.t;
          r.s = ~this.s;
          return r;
        }
        function bnShiftLeft(n) {
          var r = nbi();
          if (n < 0) this.rShiftTo(-n, r);
          else this.lShiftTo(n, r);
          return r;
        }
        function bnShiftRight(n) {
          var r = nbi();
          if (n < 0) this.lShiftTo(-n, r);
          else this.rShiftTo(n, r);
          return r;
        }
        function lbit(x) {
          if (x == 0) return -1;
          var r = 0;
          if ((x & 65535) == 0) {
            x >>= 16;
            r += 16;
          }
          if ((x & 255) == 0) {
            x >>= 8;
            r += 8;
          }
          if ((x & 15) == 0) {
            x >>= 4;
            r += 4;
          }
          if ((x & 3) == 0) {
            x >>= 2;
            r += 2;
          }
          if ((x & 1) == 0) ++r;
          return r;
        }
        function bnGetLowestSetBit() {
          for (var i = 0; i < this.t; ++i)
            if (this[i] != 0) return i * this.DB + lbit(this[i]);
          if (this.s < 0) return this.t * this.DB;
          return -1;
        }
        function cbit(x) {
          var r = 0;
          while (x != 0) {
            x &= x - 1;
            ++r;
          }
          return r;
        }
        function bnBitCount() {
          var r = 0,
            x = this.s & this.DM;
          for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
          return r;
        }
        function bnTestBit(n) {
          var j = Math.floor(n / this.DB);
          if (j >= this.t) return this.s != 0;
          return (this[j] & (1 << n % this.DB)) != 0;
        }
        function bnpChangeBit(n, op) {
          var r = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r, op, r);
          return r;
        }
        function bnSetBit(n) {
          return this.changeBit(n, op_or);
        }
        function bnClearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        function bnFlipBit(n) {
          return this.changeBit(n, op_xor);
        }
        function bnpAddTo(a, r) {
          var i = 0,
            c = 0,
            m = Math.min(a.t, this.t);
          while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
              c += this[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c += a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c > 0) r[i++] = c;
          else if (c < -1) r[i++] = this.DV + c;
          r.t = i;
          r.clamp();
        }
        function bnAdd(a) {
          var r = nbi();
          this.addTo(a, r);
          return r;
        }
        function bnSubtract(a) {
          var r = nbi();
          this.subTo(a, r);
          return r;
        }
        function bnMultiply(a) {
          var r = nbi();
          this.multiplyTo(a, r);
          return r;
        }
        function bnSquare() {
          var r = nbi();
          this.squareTo(r);
          return r;
        }
        function bnDivide(a) {
          var r = nbi();
          this.divRemTo(a, r, null);
          return r;
        }
        function bnRemainder(a) {
          var r = nbi();
          this.divRemTo(a, null, r);
          return r;
        }
        function bnDivideAndRemainder(a) {
          var q = nbi(),
            r = nbi();
          this.divRemTo(a, q, r);
          return new Array(q, r);
        }
        function bnpDMultiply(n) {
          this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        function bnpDAddOffset(n, w) {
          if (n == 0) return;
          while (this.t <= w) this[this.t++] = 0;
          this[w] += n;
          while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) this[this.t++] = 0;
            ++this[w];
          }
        }
        function NullExp() {}
        function nNop(x) {
          return x;
        }
        function nMulTo(x, y, r) {
          x.multiplyTo(y, r);
        }
        function nSqrTo(x, r) {
          x.squareTo(r);
        }
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
        function bnPow(e) {
          return this.exp(e, new NullExp());
        }
        function bnpMultiplyLowerTo(a, n, r) {
          var i = Math.min(this.t + a.t, n);
          r.s = 0;
          r.t = i;
          while (i > 0) r[--i] = 0;
          var j;
          for (j = r.t - this.t; i < j; ++i)
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
          for (j = Math.min(a.t, n); i < j; ++i)
            this.am(0, a[i], r, i, 0, n - i);
          r.clamp();
        }
        function bnpMultiplyUpperTo(a, n, r) {
          --n;
          var i = (r.t = this.t + a.t - n);
          r.s = 0;
          while (--i >= 0) r[i] = 0;
          for (i = Math.max(n - this.t, 0); i < a.t; ++i)
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
          r.clamp();
          r.drShiftTo(1, r);
        }
        function Barrett(m) {
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
          this.mu = this.r2.divide(m);
          this.m = m;
        }
        function barrettConvert(x) {
          if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
          else if (x.compareTo(this.m) < 0) return x;
          else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
        }
        function barrettRevert(x) {
          return x;
        }
        function barrettReduce(x) {
          x.drShiftTo(this.m.t - 1, this.r2);
          if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
          x.subTo(this.r2, x);
          while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function barrettSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function barrettMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
        function bnModPow(e, m) {
          var i = e.bitLength(),
            k,
            r = nbv(1),
            z;
          if (i <= 0) return r;
          else if (i < 18) k = 1;
          else if (i < 48) k = 3;
          else if (i < 144) k = 4;
          else if (i < 768) k = 5;
          else k = 6;
          if (i < 8) z = new Classic(m);
          else if (m.isEven()) z = new Barrett(m);
          else z = new Montgomery(m);
          var g = new Array(),
            n = 3,
            k1 = k - 1,
            km = (1 << k) - 1;
          g[1] = z.convert(this);
          if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
              g[n] = nbi();
              z.mulTo(g2, g[n - 2], g[n]);
              n += 2;
            }
          }
          var j = e.t - 1,
            w,
            is1 = true,
            r2 = nbi(),
            t;
          i = nbits(e[j]) - 1;
          while (j >= 0) {
            if (i >= k1) w = (e[j] >> (i - k1)) & km;
            else {
              w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
              if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
            }
            n = k;
            while ((w & 1) == 0) {
              w >>= 1;
              --n;
            }
            if ((i -= n) < 0) {
              i += this.DB;
              --j;
            }
            if (is1) {
              g[w].copyTo(r);
              is1 = false;
            } else {
              while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
              }
              if (n > 0) z.sqrTo(r, r2);
              else {
                t = r;
                r = r2;
                r2 = t;
              }
              z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
              z.sqrTo(r, r2);
              t = r;
              r = r2;
              r2 = t;
              if (--i < 0) {
                i = this.DB - 1;
                --j;
              }
            }
          }
          return z.revert(r);
        }
        function bnGCD(a) {
          var x = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
          }
          var i = x.getLowestSetBit(),
            g = y.getLowestSetBit();
          if (g < 0) return x;
          if (i < g) g = i;
          if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
          }
          while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
            if (x.compareTo(y) >= 0) {
              x.subTo(y, x);
              x.rShiftTo(1, x);
            } else {
              y.subTo(x, y);
              y.rShiftTo(1, y);
            }
          }
          if (g > 0) y.lShiftTo(g, y);
          return y;
        }
        function bnpModInt(n) {
          if (n <= 0) return 0;
          var d = this.DV % n,
            r = this.s < 0 ? n - 1 : 0;
          if (this.t > 0)
            if (d == 0) r = this[0] % n;
            else
              for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
          return r;
        }
        function bnModInverse(m) {
          var ac = m.isEven();
          if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
          var u = m.clone(),
            v = this.clone();
          var a = nbv(1),
            b = nbv(0),
            c = nbv(0),
            d = nbv(1);
          while (u.signum() != 0) {
            while (u.isEven()) {
              u.rShiftTo(1, u);
              if (ac) {
                if (!a.isEven() || !b.isEven()) {
                  a.addTo(this, a);
                  b.subTo(m, b);
                }
                a.rShiftTo(1, a);
              } else if (!b.isEven()) b.subTo(m, b);
              b.rShiftTo(1, b);
            }
            while (v.isEven()) {
              v.rShiftTo(1, v);
              if (ac) {
                if (!c.isEven() || !d.isEven()) {
                  c.addTo(this, c);
                  d.subTo(m, d);
                }
                c.rShiftTo(1, c);
              } else if (!d.isEven()) d.subTo(m, d);
              d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
              u.subTo(v, u);
              if (ac) a.subTo(c, a);
              b.subTo(d, b);
            } else {
              v.subTo(u, v);
              if (ac) c.subTo(a, c);
              d.subTo(b, d);
            }
          }
          if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
          if (d.compareTo(m) >= 0) return d.subtract(m);
          if (d.signum() < 0) d.addTo(m, d);
          else return d;
          if (d.signum() < 0) return d.add(m);
          else return d;
        }
        var lowprimes = [
          2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
          67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,
          139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,
          223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
          293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
          383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,
          463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,
          569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
          647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
          743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,
          839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,
          941, 947, 953, 967, 971, 977, 983, 991, 997,
        ];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
        function bnIsProbablePrime(t) {
          var i,
            x = this.abs();
          if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i)
              if (x[0] == lowprimes[i]) return true;
            return false;
          }
          if (x.isEven()) return false;
          i = 1;
          while (i < lowprimes.length) {
            var m = lowprimes[i],
              j = i + 1;
            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
            m = x.modInt(m);
            while (i < j) if (m % lowprimes[i++] == 0) return false;
          }
          return x.millerRabin(t);
        }
        function bnpMillerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if (k <= 0) return false;
          var r = n1.shiftRight(k);
          t = (t + 1) >> 1;
          if (t > lowprimes.length) t = lowprimes.length;
          var a = nbi();
          for (var i = 0; i < t; ++i) {
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0) return false;
              }
              if (y.compareTo(n1) != 0) return false;
            }
          }
          return true;
        }
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
        BigInteger.prototype.square = bnSquare;
        BigInteger.prototype.Barrett = Barrett;
        var rng_state;
        var rng_pool;
        var rng_pptr;
        function rng_seed_int(x) {
          rng_pool[rng_pptr++] ^= x & 255;
          rng_pool[rng_pptr++] ^= (x >> 8) & 255;
          rng_pool[rng_pptr++] ^= (x >> 16) & 255;
          rng_pool[rng_pptr++] ^= (x >> 24) & 255;
          if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
        }
        function rng_seed_time() {
          rng_seed_int(new Date().getTime());
        }
        if (rng_pool == null) {
          rng_pool = new Array();
          rng_pptr = 0;
          var t;
          if (typeof window !== "undefined" && window.crypto) {
            if (window.crypto.getRandomValues) {
              var ua = new Uint8Array(32);
              window.crypto.getRandomValues(ua);
              for (t = 0; t < 32; ++t) rng_pool[rng_pptr++] = ua[t];
            } else if (
              navigator.appName == "Netscape" &&
              navigator.appVersion < "5"
            ) {
              var z = window.crypto.random(32);
              for (t = 0; t < z.length; ++t)
                rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
            }
          }
          while (rng_pptr < rng_psize) {
            t = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = t >>> 8;
            rng_pool[rng_pptr++] = t & 255;
          }
          rng_pptr = 0;
          rng_seed_time();
        }
        function rng_get_byte() {
          if (rng_state == null) {
            rng_seed_time();
            rng_state = prng_newstate();
            rng_state.init(rng_pool);
            for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
              rng_pool[rng_pptr] = 0;
            rng_pptr = 0;
          }
          return rng_state.next();
        }
        function rng_get_bytes(ba) {
          var i;
          for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
        }
        function SecureRandom() {}
        SecureRandom.prototype.nextBytes = rng_get_bytes;
        function Arcfour() {
          this.i = 0;
          this.j = 0;
          this.S = new Array();
        }
        function ARC4init(key) {
          var i, j, t;
          for (i = 0; i < 256; ++i) this.S[i] = i;
          j = 0;
          for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
          }
          this.i = 0;
          this.j = 0;
        }
        function ARC4next() {
          var t;
          this.i = (this.i + 1) & 255;
          this.j = (this.j + this.S[this.i]) & 255;
          t = this.S[this.i];
          this.S[this.i] = this.S[this.j];
          this.S[this.j] = t;
          return this.S[(t + this.S[this.i]) & 255];
        }
        Arcfour.prototype.init = ARC4init;
        Arcfour.prototype.next = ARC4next;
        function prng_newstate() {
          return new Arcfour();
        }
        var rng_psize = 256;
        if (true) {
          exports = module.exports = {
            default: BigInteger,
            BigInteger,
            SecureRandom,
          };
        } else {
        }
      }).call(this);
    },
    1991: (module) => {
      var C = {};
      var LEFT_BRACE = (C.LEFT_BRACE = 1);
      var RIGHT_BRACE = (C.RIGHT_BRACE = 2);
      var LEFT_BRACKET = (C.LEFT_BRACKET = 3);
      var RIGHT_BRACKET = (C.RIGHT_BRACKET = 4);
      var COLON = (C.COLON = 5);
      var COMMA = (C.COMMA = 6);
      var TRUE = (C.TRUE = 7);
      var FALSE = (C.FALSE = 8);
      var NULL = (C.NULL = 9);
      var STRING = (C.STRING = 10);
      var NUMBER = (C.NUMBER = 11);
      var START = (C.START = 17);
      var STOP = (C.STOP = 18);
      var TRUE1 = (C.TRUE1 = 33);
      var TRUE2 = (C.TRUE2 = 34);
      var TRUE3 = (C.TRUE3 = 35);
      var FALSE1 = (C.FALSE1 = 49);
      var FALSE2 = (C.FALSE2 = 50);
      var FALSE3 = (C.FALSE3 = 51);
      var FALSE4 = (C.FALSE4 = 52);
      var NULL1 = (C.NULL1 = 65);
      var NULL2 = (C.NULL2 = 66);
      var NULL3 = (C.NULL3 = 67);
      var NUMBER1 = (C.NUMBER1 = 81);
      var NUMBER3 = (C.NUMBER3 = 83);
      var STRING1 = (C.STRING1 = 97);
      var STRING2 = (C.STRING2 = 98);
      var STRING3 = (C.STRING3 = 99);
      var STRING4 = (C.STRING4 = 100);
      var STRING5 = (C.STRING5 = 101);
      var STRING6 = (C.STRING6 = 102);
      var VALUE = (C.VALUE = 113);
      var KEY = (C.KEY = 114);
      var OBJECT = (C.OBJECT = 129);
      var ARRAY = (C.ARRAY = 130);
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "\t".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser() {
        this.tState = START;
        this.value = undefined;
        this.string = undefined;
        this.stringBuffer = Buffer.alloc
          ? Buffer.alloc(STRING_BUFFER_SIZE)
          : new Buffer(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = undefined;
        this.highSurrogate = undefined;
        this.key = undefined;
        this.mode = undefined;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = {
          2: new Buffer(2),
          3: new Buffer(3),
          4: new Buffer(4),
        };
        this.offset = -1;
      }
      Parser.toknam = function (code) {
        var keys = Object.keys(C);
        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          if (C[key] === code) {
            return key;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function (err) {
        throw err;
      };
      proto.charError = function (buffer, i) {
        this.tState = STOP;
        this.onError(
          new Error(
            "Unexpected " +
              JSON.stringify(String.fromCharCode(buffer[i])) +
              " at position " +
              i +
              " in state " +
              Parser.toknam(this.tState),
          ),
        );
      };
      proto.appendStringChar = function (char) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char;
      };
      proto.appendStringBuf = function (buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString(
            "utf8",
            0,
            this.stringBufferOffset,
          );
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function (buffer) {
        if (typeof buffer === "string") buffer = new Buffer(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON, ":");
            } else if (n === 44) {
              this.onToken(COMMA, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13) {
              } else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][
                  this.bytes_in_sequence - this.bytes_remaining + j
                ] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(
                  new Error(
                    "Invalid UTF-8 character at position " +
                      i +
                      " in state " +
                      Parser.toknam(this.tState),
                  ),
                );
              }
              if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining =
                  i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString(
                "utf8",
                0,
                this.stringBufferOffset,
              );
              this.stringBufferOffset = 0;
              this.onToken(STRING, this.string);
              this.offset += Buffer.byteLength(this.string, "utf8") + 1;
              this.string = undefined;
            } else if (n === 92) {
              this.tState = STRING2;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING2) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (
            this.tState === STRING3 ||
            this.tState === STRING4 ||
            this.tState === STRING5 ||
            this.tState === STRING6
          ) {
            n = buffer[i];
            if (
              (n >= 48 && n < 64) ||
              (n > 64 && n <= 70) ||
              (n > 96 && n <= 102)
            ) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = undefined;
                if (
                  this.highSurrogate !== undefined &&
                  intVal >= 56320 &&
                  intVal < 57343 + 1
                ) {
                  this.appendStringBuf(
                    new Buffer(String.fromCharCode(this.highSurrogate, intVal)),
                  );
                  this.highSurrogate = undefined;
                } else if (
                  this.highSurrogate === undefined &&
                  intVal >= 55296 &&
                  intVal < 56319 + 1
                ) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== undefined) {
                    this.appendStringBuf(
                      new Buffer(String.fromCharCode(this.highSurrogate)),
                    );
                    this.highSurrogate = undefined;
                  }
                  this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 46:
              case 101:
              case 69:
              case 43:
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (
                  this.string.match(/[0-9]+/) == this.string &&
                  result.toString() != this.string
                ) {
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = undefined;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL2) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function (token, value) {};
      proto.parseError = function (token, value) {
        this.tState = STOP;
        this.onError(
          new Error(
            "Unexpected " +
              Parser.toknam(token) +
              (value ? "(" + JSON.stringify(value) + ")" : "") +
              " in state " +
              Parser.toknam(this.state),
          ),
        );
      };
      proto.push = function () {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function () {
        var value = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function (value) {
        if (this.mode) {
          this.state = COMMA;
        }
        this.onValue(value);
      };
      proto.onValue = function (value) {};
      proto.onToken = function (token, value) {
        if (this.state === VALUE) {
          if (
            token === STRING ||
            token === NUMBER ||
            token === TRUE ||
            token === FALSE ||
            token === NULL
          ) {
            if (this.value) {
              this.value[this.key] = value;
            }
            this.emit(value);
          } else if (token === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = undefined;
            this.state = KEY;
            this.mode = OBJECT;
          } else if (token === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else if (token === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === KEY) {
          if (token === STRING) {
            this.key = value;
            this.state = COLON;
          } else if (token === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COLON) {
          if (token === COLON) {
            this.state = VALUE;
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COMMA) {
          if (token === COMMA) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY;
            }
          } else if (
            (token === RIGHT_BRACKET && this.mode === ARRAY) ||
            (token === RIGHT_BRACE && this.mode === OBJECT)
          ) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      };
      Parser.C = C;
      module.exports = Parser;
    },
    6763: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        publish: __nccwpck_require__(4302),
        unpublish: __nccwpck_require__(5984),
      };
    },
    7321: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const sigstore = __nccwpck_require__(9149);
      const { readFile } = __nccwpck_require__(3977);
      const ci = __nccwpck_require__(6339);
      const { env } = process;
      const INTOTO_PAYLOAD_TYPE = "application/vnd.in-toto+json";
      const INTOTO_STATEMENT_V01_TYPE = "https://in-toto.io/Statement/v0.1";
      const INTOTO_STATEMENT_V1_TYPE = "https://in-toto.io/Statement/v1";
      const SLSA_PREDICATE_V02_TYPE = "https://slsa.dev/provenance/v0.2";
      const SLSA_PREDICATE_V1_TYPE = "https://slsa.dev/provenance/v1";
      const GITHUB_BUILDER_ID_PREFIX = "https://github.com/actions/runner";
      const GITHUB_BUILD_TYPE =
        "https://slsa-framework.github.io/github-actions-buildtypes/workflow/v1";
      const GITLAB_BUILD_TYPE_PREFIX = "https://github.com/npm/cli/gitlab";
      const GITLAB_BUILD_TYPE_VERSION = "v0alpha1";
      const generateProvenance = async (subject, opts) => {
        let payload;
        if (ci.GITHUB_ACTIONS) {
          const relativeRef = (env.GITHUB_WORKFLOW_REF || "").replace(
            env.GITHUB_REPOSITORY + "/",
            "",
          );
          const delimiterIndex = relativeRef.indexOf("@");
          const workflowPath = relativeRef.slice(0, delimiterIndex);
          const workflowRef = relativeRef.slice(delimiterIndex + 1);
          payload = {
            _type: INTOTO_STATEMENT_V1_TYPE,
            subject,
            predicateType: SLSA_PREDICATE_V1_TYPE,
            predicate: {
              buildDefinition: {
                buildType: GITHUB_BUILD_TYPE,
                externalParameters: {
                  workflow: {
                    ref: workflowRef,
                    repository: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}`,
                    path: workflowPath,
                  },
                },
                internalParameters: {
                  github: {
                    event_name: env.GITHUB_EVENT_NAME,
                    repository_id: env.GITHUB_REPOSITORY_ID,
                    repository_owner_id: env.GITHUB_REPOSITORY_OWNER_ID,
                  },
                },
                resolvedDependencies: [
                  {
                    uri: `git+${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}@${env.GITHUB_REF}`,
                    digest: { gitCommit: env.GITHUB_SHA },
                  },
                ],
              },
              runDetails: {
                builder: {
                  id: `${GITHUB_BUILDER_ID_PREFIX}/${env.RUNNER_ENVIRONMENT}`,
                },
                metadata: {
                  invocationId: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}/attempts/${env.GITHUB_RUN_ATTEMPT}`,
                },
              },
            },
          };
        }
        if (ci.GITLAB) {
          payload = {
            _type: INTOTO_STATEMENT_V01_TYPE,
            subject,
            predicateType: SLSA_PREDICATE_V02_TYPE,
            predicate: {
              buildType: `${GITLAB_BUILD_TYPE_PREFIX}/${GITLAB_BUILD_TYPE_VERSION}`,
              builder: {
                id: `${env.CI_PROJECT_URL}/-/runners/${env.CI_RUNNER_ID}`,
              },
              invocation: {
                configSource: {
                  uri: `git+${env.CI_PROJECT_URL}`,
                  digest: { sha1: env.CI_COMMIT_SHA },
                  entryPoint: env.CI_JOB_NAME,
                },
                parameters: {
                  CI: env.CI,
                  CI_API_GRAPHQL_URL: env.CI_API_GRAPHQL_URL,
                  CI_API_V4_URL: env.CI_API_V4_URL,
                  CI_BUILD_BEFORE_SHA: env.CI_BUILD_BEFORE_SHA,
                  CI_BUILD_ID: env.CI_BUILD_ID,
                  CI_BUILD_NAME: env.CI_BUILD_NAME,
                  CI_BUILD_REF: env.CI_BUILD_REF,
                  CI_BUILD_REF_NAME: env.CI_BUILD_REF_NAME,
                  CI_BUILD_REF_SLUG: env.CI_BUILD_REF_SLUG,
                  CI_BUILD_STAGE: env.CI_BUILD_STAGE,
                  CI_COMMIT_BEFORE_SHA: env.CI_COMMIT_BEFORE_SHA,
                  CI_COMMIT_BRANCH: env.CI_COMMIT_BRANCH,
                  CI_COMMIT_REF_NAME: env.CI_COMMIT_REF_NAME,
                  CI_COMMIT_REF_PROTECTED: env.CI_COMMIT_REF_PROTECTED,
                  CI_COMMIT_REF_SLUG: env.CI_COMMIT_REF_SLUG,
                  CI_COMMIT_SHA: env.CI_COMMIT_SHA,
                  CI_COMMIT_SHORT_SHA: env.CI_COMMIT_SHORT_SHA,
                  CI_COMMIT_TIMESTAMP: env.CI_COMMIT_TIMESTAMP,
                  CI_COMMIT_TITLE: env.CI_COMMIT_TITLE,
                  CI_CONFIG_PATH: env.CI_CONFIG_PATH,
                  CI_DEFAULT_BRANCH: env.CI_DEFAULT_BRANCH,
                  CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX:
                    env.CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX,
                  CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX:
                    env.CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX,
                  CI_DEPENDENCY_PROXY_SERVER: env.CI_DEPENDENCY_PROXY_SERVER,
                  CI_DEPENDENCY_PROXY_USER: env.CI_DEPENDENCY_PROXY_USER,
                  CI_JOB_ID: env.CI_JOB_ID,
                  CI_JOB_NAME: env.CI_JOB_NAME,
                  CI_JOB_NAME_SLUG: env.CI_JOB_NAME_SLUG,
                  CI_JOB_STAGE: env.CI_JOB_STAGE,
                  CI_JOB_STARTED_AT: env.CI_JOB_STARTED_AT,
                  CI_JOB_URL: env.CI_JOB_URL,
                  CI_NODE_TOTAL: env.CI_NODE_TOTAL,
                  CI_PAGES_DOMAIN: env.CI_PAGES_DOMAIN,
                  CI_PAGES_URL: env.CI_PAGES_URL,
                  CI_PIPELINE_CREATED_AT: env.CI_PIPELINE_CREATED_AT,
                  CI_PIPELINE_ID: env.CI_PIPELINE_ID,
                  CI_PIPELINE_IID: env.CI_PIPELINE_IID,
                  CI_PIPELINE_SOURCE: env.CI_PIPELINE_SOURCE,
                  CI_PIPELINE_URL: env.CI_PIPELINE_URL,
                  CI_PROJECT_CLASSIFICATION_LABEL:
                    env.CI_PROJECT_CLASSIFICATION_LABEL,
                  CI_PROJECT_DESCRIPTION: env.CI_PROJECT_DESCRIPTION,
                  CI_PROJECT_ID: env.CI_PROJECT_ID,
                  CI_PROJECT_NAME: env.CI_PROJECT_NAME,
                  CI_PROJECT_NAMESPACE: env.CI_PROJECT_NAMESPACE,
                  CI_PROJECT_NAMESPACE_ID: env.CI_PROJECT_NAMESPACE_ID,
                  CI_PROJECT_PATH: env.CI_PROJECT_PATH,
                  CI_PROJECT_PATH_SLUG: env.CI_PROJECT_PATH_SLUG,
                  CI_PROJECT_REPOSITORY_LANGUAGES:
                    env.CI_PROJECT_REPOSITORY_LANGUAGES,
                  CI_PROJECT_ROOT_NAMESPACE: env.CI_PROJECT_ROOT_NAMESPACE,
                  CI_PROJECT_TITLE: env.CI_PROJECT_TITLE,
                  CI_PROJECT_URL: env.CI_PROJECT_URL,
                  CI_PROJECT_VISIBILITY: env.CI_PROJECT_VISIBILITY,
                  CI_REGISTRY: env.CI_REGISTRY,
                  CI_REGISTRY_IMAGE: env.CI_REGISTRY_IMAGE,
                  CI_REGISTRY_USER: env.CI_REGISTRY_USER,
                  CI_RUNNER_DESCRIPTION: env.CI_RUNNER_DESCRIPTION,
                  CI_RUNNER_ID: env.CI_RUNNER_ID,
                  CI_RUNNER_TAGS: env.CI_RUNNER_TAGS,
                  CI_SERVER_HOST: env.CI_SERVER_HOST,
                  CI_SERVER_NAME: env.CI_SERVER_NAME,
                  CI_SERVER_PORT: env.CI_SERVER_PORT,
                  CI_SERVER_PROTOCOL: env.CI_SERVER_PROTOCOL,
                  CI_SERVER_REVISION: env.CI_SERVER_REVISION,
                  CI_SERVER_SHELL_SSH_HOST: env.CI_SERVER_SHELL_SSH_HOST,
                  CI_SERVER_SHELL_SSH_PORT: env.CI_SERVER_SHELL_SSH_PORT,
                  CI_SERVER_URL: env.CI_SERVER_URL,
                  CI_SERVER_VERSION: env.CI_SERVER_VERSION,
                  CI_SERVER_VERSION_MAJOR: env.CI_SERVER_VERSION_MAJOR,
                  CI_SERVER_VERSION_MINOR: env.CI_SERVER_VERSION_MINOR,
                  CI_SERVER_VERSION_PATCH: env.CI_SERVER_VERSION_PATCH,
                  CI_TEMPLATE_REGISTRY_HOST: env.CI_TEMPLATE_REGISTRY_HOST,
                  GITLAB_CI: env.GITLAB_CI,
                  GITLAB_FEATURES: env.GITLAB_FEATURES,
                  GITLAB_USER_ID: env.GITLAB_USER_ID,
                  GITLAB_USER_LOGIN: env.GITLAB_USER_LOGIN,
                  RUNNER_GENERATE_ARTIFACTS_METADATA:
                    env.RUNNER_GENERATE_ARTIFACTS_METADATA,
                },
                environment: {
                  name: env.CI_RUNNER_DESCRIPTION,
                  architecture: env.CI_RUNNER_EXECUTABLE_ARCH,
                  server: env.CI_SERVER_URL,
                  project: env.CI_PROJECT_PATH,
                  job: { id: env.CI_JOB_ID },
                  pipeline: { id: env.CI_PIPELINE_ID, ref: env.CI_CONFIG_PATH },
                },
              },
              metadata: {
                buildInvocationId: `${env.CI_JOB_URL}`,
                completeness: {
                  parameters: true,
                  environment: true,
                  materials: false,
                },
                reproducible: false,
              },
              materials: [
                {
                  uri: `git+${env.CI_PROJECT_URL}`,
                  digest: { sha1: env.CI_COMMIT_SHA },
                },
              ],
            },
          };
        }
        return sigstore.attest(
          Buffer.from(JSON.stringify(payload)),
          INTOTO_PAYLOAD_TYPE,
          opts,
        );
      };
      const verifyProvenance = async (subject, provenancePath) => {
        let provenanceBundle;
        try {
          provenanceBundle = JSON.parse(await readFile(provenancePath));
        } catch (err) {
          err.message = `Invalid provenance provided: ${err.message}`;
          throw err;
        }
        const payload = extractProvenance(provenanceBundle);
        if (!payload.subject || !payload.subject.length) {
          throw new Error("No subject found in sigstore bundle payload");
        }
        if (payload.subject.length > 1) {
          throw new Error(
            "Found more than one subject in the sigstore bundle payload",
          );
        }
        const bundleSubject = payload.subject[0];
        if (subject.name !== bundleSubject.name) {
          throw new Error(
            `Provenance subject ${bundleSubject.name} does not match the package: ${subject.name}`,
          );
        }
        if (subject.digest.sha512 !== bundleSubject.digest.sha512) {
          throw new Error(
            "Provenance subject digest does not match the package",
          );
        }
        await sigstore.verify(provenanceBundle);
        return provenanceBundle;
      };
      const extractProvenance = (bundle) => {
        if (!bundle?.dsseEnvelope?.payload) {
          throw new Error(
            "No dsseEnvelope with payload found in sigstore bundle",
          );
        }
        try {
          return JSON.parse(
            Buffer.from(bundle.dsseEnvelope.payload, "base64").toString("utf8"),
          );
        } catch (err) {
          err.message = `Failed to parse payload from dsseEnvelope: ${err.message}`;
          throw err;
        }
      };
      module.exports = { generateProvenance, verifyProvenance };
    },
    4302: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { fixer } = __nccwpck_require__(3188);
      const npmFetch = __nccwpck_require__(5902);
      const npa = __nccwpck_require__(680);
      const { log } = __nccwpck_require__(6528);
      const semver = __nccwpck_require__(4541);
      const { URL } = __nccwpck_require__(1041);
      const ssri = __nccwpck_require__(4406);
      const ciInfo = __nccwpck_require__(6339);
      const { generateProvenance, verifyProvenance } =
        __nccwpck_require__(7321);
      const TLOG_BASE_URL = "https://search.sigstore.dev/";
      const publish = async (manifest, tarballData, opts) => {
        if (manifest.private) {
          throw Object.assign(
            new Error(
              `This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`,
            ),
            { code: "EPRIVATE" },
          );
        }
        const spec = npa.resolve(manifest.name, manifest.version);
        opts = {
          access: "public",
          algorithms: ["sha512"],
          defaultTag: "latest",
          ...opts,
          spec,
        };
        const reg = npmFetch.pickRegistry(spec, opts);
        const pubManifest = patchManifest(manifest, opts);
        if (!spec.scope && opts.access === "restricted") {
          throw Object.assign(
            new Error("Can't restrict access to unscoped packages."),
            { code: "EUNSCOPED" },
          );
        }
        const { metadata, transparencyLogUrl } = await buildMetadata(
          reg,
          pubManifest,
          tarballData,
          spec,
          opts,
        );
        const res = await npmFetch(spec.escapedName, {
          ...opts,
          method: "PUT",
          body: metadata,
          ignoreBody: true,
        });
        if (transparencyLogUrl) {
          res.transparencyLogUrl = transparencyLogUrl;
        }
        return res;
      };
      const patchManifest = (_manifest, opts) => {
        const { npmVersion } = opts;
        const manifest = { ..._manifest };
        manifest._nodeVersion = process.versions.node;
        if (npmVersion) {
          manifest._npmVersion = npmVersion;
        }
        fixer.fixNameField(manifest, { strict: true, allowLegacyCase: true });
        const version = semver.clean(manifest.version);
        if (!version) {
          throw Object.assign(
            new Error("invalid semver: " + manifest.version),
            { code: "EBADSEMVER" },
          );
        }
        manifest.version = version;
        return manifest;
      };
      const buildMetadata = async (
        registry,
        manifest,
        tarballData,
        spec,
        opts,
      ) => {
        const { access, defaultTag, algorithms, provenance, provenanceFile } =
          opts;
        const root = {
          _id: manifest.name,
          name: manifest.name,
          description: manifest.description,
          "dist-tags": {},
          versions: {},
          access,
        };
        root.versions[manifest.version] = manifest;
        const tag = manifest.tag || defaultTag;
        root["dist-tags"][tag] = manifest.version;
        const tarballName = `${manifest.name}-${manifest.version}.tgz`;
        const provenanceBundleName = `${manifest.name}-${manifest.version}.sigstore`;
        const tarballURI = `${manifest.name}/-/${tarballName}`;
        const integrity = ssri.fromData(tarballData, {
          algorithms: [...new Set(["sha1"].concat(algorithms))],
        });
        manifest._id = `${manifest.name}@${manifest.version}`;
        manifest.dist = { ...manifest.dist };
        manifest.dist.integrity = integrity.sha512[0].toString();
        manifest.dist.shasum = integrity.sha1[0].hexDigest();
        manifest.dist.tarball = new URL(tarballURI, registry).href.replace(
          /^https:\/\//,
          "http://",
        );
        root._attachments = {};
        root._attachments[tarballName] = {
          content_type: "application/octet-stream",
          data: tarballData.toString("base64"),
          length: tarballData.length,
        };
        let transparencyLogUrl;
        if (provenance === true || provenanceFile) {
          let provenanceBundle;
          const subject = {
            name: npa.toPurl(spec),
            digest: { sha512: integrity.sha512[0].hexDigest() },
          };
          if (provenance === true) {
            await ensureProvenanceGeneration(registry, spec, opts);
            provenanceBundle = await generateProvenance([subject], opts);
            log.notice(
              "publish",
              `Signed provenance statement with source and build information from ${ciInfo.name}`,
            );
            const tlogEntry =
              provenanceBundle?.verificationMaterial?.tlogEntries[0];
            if (tlogEntry) {
              transparencyLogUrl = `${TLOG_BASE_URL}?logIndex=${tlogEntry.logIndex}`;
              log.notice(
                "publish",
                `Provenance statement published to transparency log: ${transparencyLogUrl}`,
              );
            }
          } else {
            provenanceBundle = await verifyProvenance(subject, provenanceFile);
          }
          const serializedBundle = JSON.stringify(provenanceBundle);
          root._attachments[provenanceBundleName] = {
            content_type: provenanceBundle.mediaType,
            data: serializedBundle,
            length: serializedBundle.length,
          };
        }
        return { metadata: root, transparencyLogUrl };
      };
      const ensureProvenanceGeneration = async (registry, spec, opts) => {
        if (ciInfo.GITHUB_ACTIONS) {
          if (!process.env.ACTIONS_ID_TOKEN_REQUEST_URL) {
            throw Object.assign(
              new Error(
                'Provenance generation in GitHub Actions requires "write" access to the "id-token" permission',
              ),
              { code: "EUSAGE" },
            );
          }
        } else if (ciInfo.GITLAB) {
          if (!process.env.SIGSTORE_ID_TOKEN) {
            throw Object.assign(
              new Error(
                'Provenance generation in GitLab CI requires "SIGSTORE_ID_TOKEN" with "sigstore" audience to be present in "id_tokens". For more info see:\nhttps://docs.gitlab.com/ee/ci/secrets/id_token_authentication.html',
              ),
              { code: "EUSAGE" },
            );
          }
        } else {
          throw Object.assign(
            new Error(
              "Automatic provenance generation not supported for provider: " +
                ciInfo.name,
            ),
            { code: "EUSAGE" },
          );
        }
        let visibility = { public: false };
        if (opts.access !== "public") {
          try {
            const res = await npmFetch.json(
              `${registry}/-/package/${spec.escapedName}/visibility`,
              opts,
            );
            visibility = res;
          } catch (err) {
            if (err.code !== "E404") {
              throw err;
            }
          }
        }
        if (
          !visibility.public &&
          opts.provenance === true &&
          opts.access !== "public"
        ) {
          throw Object.assign(
            new Error(
              "Can't generate provenance for new or private package, you must set `access` to public.",
            ),
            { code: "EUSAGE" },
          );
        }
      };
      module.exports = publish;
    },
    5984: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(1041);
      const npa = __nccwpck_require__(680);
      const npmFetch = __nccwpck_require__(5902);
      const semver = __nccwpck_require__(4541);
      const getPathname = (tarball, registry) => {
        const registryUrl = new URL(registry).pathname.slice(1);
        let tarballUrl = new URL(tarball).pathname.slice(1);
        if (registryUrl) {
          tarballUrl = tarballUrl.slice(registryUrl.length);
        }
        return tarballUrl;
      };
      const unpublish = async (spec, opts) => {
        spec = npa(spec);
        opts = { force: false, ...opts, spec };
        try {
          const pkgUri = spec.escapedName;
          const pkg = await npmFetch.json(pkgUri, {
            ...opts,
            query: { write: true },
          });
          const version = spec.rawSpec;
          const allVersions = pkg.versions || {};
          const versionData = allVersions[version];
          const rawSpecs = !spec.rawSpec || spec.rawSpec === "*";
          const onlyVersion = Object.keys(allVersions).length === 1;
          const noVersions = !Object.keys(allVersions).length;
          if (!versionData && !rawSpecs && !noVersions) {
            return true;
          }
          if (rawSpecs || onlyVersion || noVersions) {
            await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {
              ...opts,
              method: "DELETE",
              ignoreBody: true,
            });
            return true;
          } else {
            const dist = allVersions[version].dist;
            delete allVersions[version];
            const latestVer = pkg["dist-tags"].latest;
            Object.keys(pkg["dist-tags"]).forEach((tag) => {
              if (pkg["dist-tags"][tag] === version) {
                delete pkg["dist-tags"][tag];
              }
            });
            if (latestVer === version) {
              pkg["dist-tags"].latest = Object.keys(allVersions)
                .sort(semver.compareLoose)
                .pop();
            }
            delete pkg._revisions;
            delete pkg._attachments;
            await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {
              ...opts,
              method: "PUT",
              body: pkg,
              ignoreBody: true,
            });
            const { _rev } = await npmFetch.json(pkgUri, {
              ...opts,
              query: { write: true },
            });
            const tarballUrl = getPathname(dist.tarball, opts.registry);
            await npmFetch(`${tarballUrl}/-rev/${_rev}`, {
              ...opts,
              method: "DELETE",
              ignoreBody: true,
            });
            return true;
          }
        } catch (err) {
          if (err.code !== "E404") {
            throw err;
          }
          return true;
        }
      };
      module.exports = unpublish;
    },
    7943: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { Request, Response } = __nccwpck_require__(8998);
      const { Minipass } = __nccwpck_require__(4968);
      const MinipassFlush = __nccwpck_require__(4181);
      const cacache = __nccwpck_require__(7129);
      const url = __nccwpck_require__(7310);
      const CachingMinipassPipeline = __nccwpck_require__(1064);
      const CachePolicy = __nccwpck_require__(7986);
      const cacheKey = __nccwpck_require__(2147);
      const remote = __nccwpck_require__(2619);
      const hasOwnProperty = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop);
      const KEEP_REQUEST_HEADERS = [
        "accept-charset",
        "accept-encoding",
        "accept-language",
        "accept",
        "cache-control",
      ];
      const KEEP_RESPONSE_HEADERS = [
        "cache-control",
        "content-encoding",
        "content-language",
        "content-type",
        "date",
        "etag",
        "expires",
        "last-modified",
        "link",
        "location",
        "pragma",
        "vary",
      ];
      const getMetadata = (request, response, options) => {
        const metadata = {
          time: Date.now(),
          url: request.url,
          reqHeaders: {},
          resHeaders: {},
          options: {
            compress:
              options.compress != null ? options.compress : request.compress,
          },
        };
        if (response.status !== 200 && response.status !== 304) {
          metadata.status = response.status;
        }
        for (const name of KEEP_REQUEST_HEADERS) {
          if (request.headers.has(name)) {
            metadata.reqHeaders[name] = request.headers.get(name);
          }
        }
        const host = request.headers.get("host");
        const parsedUrl = new url.URL(request.url);
        if (host && parsedUrl.host !== host) {
          metadata.reqHeaders.host = host;
        }
        if (response.headers.has("vary")) {
          const vary = response.headers.get("vary");
          if (vary !== "*") {
            const varyHeaders = vary
              .trim()
              .toLowerCase()
              .split(/\s*,\s*/);
            for (const name of varyHeaders) {
              if (request.headers.has(name)) {
                metadata.reqHeaders[name] = request.headers.get(name);
              }
            }
          }
        }
        for (const name of KEEP_RESPONSE_HEADERS) {
          if (response.headers.has(name)) {
            metadata.resHeaders[name] = response.headers.get(name);
          }
        }
        for (const name of options.cacheAdditionalHeaders) {
          if (response.headers.has(name)) {
            metadata.resHeaders[name] = response.headers.get(name);
          }
        }
        return metadata;
      };
      const _request = Symbol("request");
      const _response = Symbol("response");
      const _policy = Symbol("policy");
      class CacheEntry {
        constructor({ entry, request, response, options }) {
          if (entry) {
            this.key = entry.key;
            this.entry = entry;
            this.entry.metadata.time =
              this.entry.metadata.time || this.entry.time;
          } else {
            this.key = cacheKey(request);
          }
          this.options = options;
          this[_request] = request;
          this[_response] = response;
          this[_policy] = null;
        }
        static async find(request, options) {
          try {
            var matches = await cacache.index.compact(
              options.cachePath,
              cacheKey(request),
              (A, B) => {
                const entryA = new CacheEntry({ entry: A, options });
                const entryB = new CacheEntry({ entry: B, options });
                return entryA.policy.satisfies(entryB.request);
              },
              {
                validateEntry: (entry) => {
                  if (
                    entry.metadata &&
                    entry.metadata.resHeaders &&
                    entry.metadata.resHeaders["content-encoding"] === null
                  ) {
                    return false;
                  }
                  if (entry.integrity === null) {
                    return !!(entry.metadata && entry.metadata.status);
                  }
                  return true;
                },
              },
            );
          } catch (err) {
            return;
          }
          if (options.cache === "reload") {
            return;
          }
          let match;
          for (const entry of matches) {
            const _entry = new CacheEntry({ entry, options });
            if (_entry.policy.satisfies(request)) {
              match = _entry;
              break;
            }
          }
          return match;
        }
        static async invalidate(request, options) {
          const key = cacheKey(request);
          try {
            await cacache.rm.entry(options.cachePath, key, {
              removeFully: true,
            });
          } catch (err) {}
        }
        get request() {
          if (!this[_request]) {
            this[_request] = new Request(this.entry.metadata.url, {
              method: "GET",
              headers: this.entry.metadata.reqHeaders,
              ...this.entry.metadata.options,
            });
          }
          return this[_request];
        }
        get response() {
          if (!this[_response]) {
            this[_response] = new Response(null, {
              url: this.entry.metadata.url,
              counter: this.options.counter,
              status: this.entry.metadata.status || 200,
              headers: {
                ...this.entry.metadata.resHeaders,
                "content-length": this.entry.size,
              },
            });
          }
          return this[_response];
        }
        get policy() {
          if (!this[_policy]) {
            this[_policy] = new CachePolicy({
              entry: this.entry,
              request: this.request,
              response: this.response,
              options: this.options,
            });
          }
          return this[_policy];
        }
        async store(status) {
          if (
            this.request.method !== "GET" ||
            ![200, 301, 308].includes(this.response.status) ||
            !this.policy.storable()
          ) {
            this.response.headers.set("x-local-cache-status", "skip");
            return this.response;
          }
          const size = this.response.headers.get("content-length");
          const cacheOpts = {
            algorithms: this.options.algorithms,
            metadata: getMetadata(this.request, this.response, this.options),
            size,
            integrity: this.options.integrity,
            integrityEmitter:
              this.response.body.hasIntegrityEmitter && this.response.body,
          };
          let body = null;
          if (this.response.status === 200) {
            let cacheWriteResolve, cacheWriteReject;
            const cacheWritePromise = new Promise((resolve, reject) => {
              cacheWriteResolve = resolve;
              cacheWriteReject = reject;
            }).catch((err) => {
              body.emit("error", err);
            });
            body = new CachingMinipassPipeline(
              { events: ["integrity", "size"] },
              new MinipassFlush({
                flush() {
                  return cacheWritePromise;
                },
              }),
            );
            body.hasIntegrityEmitter = true;
            const onResume = () => {
              const tee = new Minipass();
              const cacheStream = cacache.put.stream(
                this.options.cachePath,
                this.key,
                cacheOpts,
              );
              cacheStream.on("integrity", (i) => body.emit("integrity", i));
              cacheStream.on("size", (s) => body.emit("size", s));
              tee.pipe(cacheStream);
              cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);
              body.unshift(tee);
              body.unshift(this.response.body);
            };
            body.once("resume", onResume);
            body.once("end", () => body.removeListener("resume", onResume));
          } else {
            await cacache.index.insert(
              this.options.cachePath,
              this.key,
              null,
              cacheOpts,
            );
          }
          this.response.headers.set(
            "x-local-cache",
            encodeURIComponent(this.options.cachePath),
          );
          this.response.headers.set(
            "x-local-cache-key",
            encodeURIComponent(this.key),
          );
          this.response.headers.set("x-local-cache-mode", "stream");
          this.response.headers.set("x-local-cache-status", status);
          this.response.headers.set(
            "x-local-cache-time",
            new Date().toISOString(),
          );
          const newResponse = new Response(body, {
            url: this.response.url,
            status: this.response.status,
            headers: this.response.headers,
            counter: this.options.counter,
          });
          return newResponse;
        }
        async respond(method, options, status) {
          let response;
          if (method === "HEAD" || [301, 308].includes(this.response.status)) {
            response = this.response;
          } else {
            const body = new Minipass();
            const headers = { ...this.policy.responseHeaders() };
            const onResume = () => {
              const cacheStream = cacache.get.stream.byDigest(
                this.options.cachePath,
                this.entry.integrity,
                { memoize: this.options.memoize },
              );
              cacheStream.on("error", async (err) => {
                cacheStream.pause();
                if (err.code === "EINTEGRITY") {
                  await cacache.rm.content(
                    this.options.cachePath,
                    this.entry.integrity,
                    { memoize: this.options.memoize },
                  );
                }
                if (err.code === "ENOENT" || err.code === "EINTEGRITY") {
                  await CacheEntry.invalidate(this.request, this.options);
                }
                body.emit("error", err);
                cacheStream.resume();
              });
              body.emit("integrity", this.entry.integrity);
              body.emit("size", Number(headers["content-length"]));
              cacheStream.pipe(body);
            };
            body.once("resume", onResume);
            body.once("end", () => body.removeListener("resume", onResume));
            response = new Response(body, {
              url: this.entry.metadata.url,
              counter: options.counter,
              status: 200,
              headers,
            });
          }
          response.headers.set(
            "x-local-cache",
            encodeURIComponent(this.options.cachePath),
          );
          response.headers.set(
            "x-local-cache-hash",
            encodeURIComponent(this.entry.integrity),
          );
          response.headers.set(
            "x-local-cache-key",
            encodeURIComponent(this.key),
          );
          response.headers.set("x-local-cache-mode", "stream");
          response.headers.set("x-local-cache-status", status);
          response.headers.set(
            "x-local-cache-time",
            new Date(this.entry.metadata.time).toUTCString(),
          );
          return response;
        }
        async revalidate(request, options) {
          const revalidateRequest = new Request(request, {
            headers: this.policy.revalidationHeaders(request),
          });
          try {
            var response = await remote(revalidateRequest, {
              ...options,
              headers: undefined,
            });
          } catch (err) {
            if (!this.policy.mustRevalidate) {
              return this.respond(request.method, options, "stale");
            }
            throw err;
          }
          if (this.policy.revalidated(revalidateRequest, response)) {
            const metadata = getMetadata(request, response, options);
            for (const name of KEEP_RESPONSE_HEADERS) {
              if (
                !hasOwnProperty(metadata.resHeaders, name) &&
                hasOwnProperty(this.entry.metadata.resHeaders, name)
              ) {
                metadata.resHeaders[name] =
                  this.entry.metadata.resHeaders[name];
              }
            }
            for (const name of options.cacheAdditionalHeaders) {
              const inMeta = hasOwnProperty(metadata.resHeaders, name);
              const inEntry = hasOwnProperty(
                this.entry.metadata.resHeaders,
                name,
              );
              const inPolicy = hasOwnProperty(
                this.policy.response.headers,
                name,
              );
              if (!inMeta && inEntry) {
                metadata.resHeaders[name] =
                  this.entry.metadata.resHeaders[name];
              }
              if (!inPolicy && inMeta) {
                this.policy.response.headers[name] = metadata.resHeaders[name];
              }
            }
            try {
              await cacache.index.insert(
                options.cachePath,
                this.key,
                this.entry.integrity,
                { size: this.entry.size, metadata },
              );
            } catch (err) {}
            return this.respond(request.method, options, "revalidated");
          }
          const newEntry = new CacheEntry({ request, response, options });
          return newEntry.store("updated");
        }
      }
      module.exports = CacheEntry;
    },
    3104: (module) => {
      class NotCachedError extends Error {
        constructor(url) {
          super(
            `request to ${url} failed: cache mode is 'only-if-cached' but no cached response is available.`,
          );
          this.code = "ENOTCACHED";
        }
      }
      module.exports = { NotCachedError };
    },
    3189: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { NotCachedError } = __nccwpck_require__(3104);
      const CacheEntry = __nccwpck_require__(7943);
      const remote = __nccwpck_require__(2619);
      const cacheFetch = async (request, options) => {
        const entry = await CacheEntry.find(request, options);
        if (!entry) {
          if (options.cache === "only-if-cached") {
            throw new NotCachedError(request.url);
          }
          const response = await remote(request, options);
          const newEntry = new CacheEntry({ request, response, options });
          return newEntry.store("miss");
        }
        if (options.cache === "no-cache") {
          return entry.revalidate(request, options);
        }
        const _needsRevalidation = entry.policy.needsRevalidation(request);
        if (
          options.cache === "force-cache" ||
          options.cache === "only-if-cached" ||
          !_needsRevalidation
        ) {
          return entry.respond(
            request.method,
            options,
            _needsRevalidation ? "stale" : "hit",
          );
        }
        return entry.revalidate(request, options);
      };
      cacheFetch.invalidate = async (request, options) => {
        if (!options.cachePath) {
          return;
        }
        return CacheEntry.invalidate(request, options);
      };
      module.exports = cacheFetch;
    },
    2147: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { URL, format } = __nccwpck_require__(7310);
      const formatOptions = {
        auth: false,
        fragment: false,
        search: true,
        unicode: false,
      };
      const cacheKey = (request) => {
        const parsed = new URL(request.url);
        return `make-fetch-happen:request-cache:${format(parsed, formatOptions)}`;
      };
      module.exports = cacheKey;
    },
    7986: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const CacheSemantics = __nccwpck_require__(1002);
      const Negotiator = __nccwpck_require__(5385);
      const ssri = __nccwpck_require__(4406);
      const policyOptions = { shared: false, ignoreCargoCult: true };
      const emptyResponse = { status: 200, headers: {} };
      const requestObject = (request) => {
        const _obj = {
          method: request.method,
          url: request.url,
          headers: {},
          compress: request.compress,
        };
        request.headers.forEach((value, key) => {
          _obj.headers[key] = value;
        });
        return _obj;
      };
      const responseObject = (response) => {
        const _obj = { status: response.status, headers: {} };
        response.headers.forEach((value, key) => {
          _obj.headers[key] = value;
        });
        return _obj;
      };
      class CachePolicy {
        constructor({ entry, request, response, options }) {
          this.entry = entry;
          this.request = requestObject(request);
          this.response = responseObject(response);
          this.options = options;
          this.policy = new CacheSemantics(
            this.request,
            this.response,
            policyOptions,
          );
          if (this.entry) {
            this.policy._responseTime = this.entry.metadata.time;
          }
        }
        static storable(request, options) {
          if (!options.cachePath) {
            return false;
          }
          if (options.cache === "no-store") {
            return false;
          }
          if (!["GET", "HEAD"].includes(request.method)) {
            return false;
          }
          const policy = new CacheSemantics(
            requestObject(request),
            emptyResponse,
            policyOptions,
          );
          return policy.storable();
        }
        satisfies(request) {
          const _req = requestObject(request);
          if (this.request.headers.host !== _req.headers.host) {
            return false;
          }
          if (this.request.compress !== _req.compress) {
            return false;
          }
          const negotiatorA = new Negotiator(this.request);
          const negotiatorB = new Negotiator(_req);
          if (
            JSON.stringify(negotiatorA.mediaTypes()) !==
            JSON.stringify(negotiatorB.mediaTypes())
          ) {
            return false;
          }
          if (
            JSON.stringify(negotiatorA.languages()) !==
            JSON.stringify(negotiatorB.languages())
          ) {
            return false;
          }
          if (
            JSON.stringify(negotiatorA.encodings()) !==
            JSON.stringify(negotiatorB.encodings())
          ) {
            return false;
          }
          if (this.options.integrity) {
            return ssri
              .parse(this.options.integrity)
              .match(this.entry.integrity);
          }
          return true;
        }
        storable() {
          return this.policy.storable();
        }
        get mustRevalidate() {
          return !!this.policy._rescc["must-revalidate"];
        }
        needsRevalidation(request) {
          const _req = requestObject(request);
          _req.method = "GET";
          return !this.policy.satisfiesWithoutRevalidation(_req);
        }
        responseHeaders() {
          return this.policy.responseHeaders();
        }
        revalidationHeaders(request) {
          const _req = requestObject(request);
          return this.policy.revalidationHeaders(_req);
        }
        revalidated(request, response) {
          const _req = requestObject(request);
          const _res = responseObject(response);
          const policy = this.policy.revalidatedPolicy(_req, _res);
          return !policy.modified;
        }
      }
      module.exports = CachePolicy;
    },
    1371: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { FetchError, Request, isRedirect } = __nccwpck_require__(8998);
      const url = __nccwpck_require__(7310);
      const CachePolicy = __nccwpck_require__(7986);
      const cache = __nccwpck_require__(3189);
      const remote = __nccwpck_require__(2619);
      const canFollowRedirect = (request, response, options) => {
        if (!isRedirect(response.status)) {
          return false;
        }
        if (options.redirect === "manual") {
          return false;
        }
        if (options.redirect === "error") {
          throw new FetchError(
            `redirect mode is set to error: ${request.url}`,
            "no-redirect",
            { code: "ENOREDIRECT" },
          );
        }
        if (!response.headers.has("location")) {
          throw new FetchError(
            `redirect location header missing for: ${request.url}`,
            "no-location",
            { code: "EINVALIDREDIRECT" },
          );
        }
        if (request.counter >= request.follow) {
          throw new FetchError(
            `maximum redirect reached at: ${request.url}`,
            "max-redirect",
            { code: "EMAXREDIRECT" },
          );
        }
        return true;
      };
      const getRedirect = (request, response, options) => {
        const _opts = { ...options };
        const location = response.headers.get("location");
        const redirectUrl = new url.URL(
          location,
          /^https?:/.test(location) ? undefined : request.url,
        );
        /**
         * @license
         * Copyright (c) 2010-2012 Mikeal Rogers
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0
         * Unless required by applicable law or agreed to in writing,
         * software distributed under the License is distributed on an "AS
         * IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
         * express or implied. See the License for the specific language
         * governing permissions and limitations under the License.
         */ if (new url.URL(request.url).hostname !== redirectUrl.hostname) {
          request.headers.delete("authorization");
          request.headers.delete("cookie");
        }
        if (
          response.status === 303 ||
          (request.method === "POST" && [301, 302].includes(response.status))
        ) {
          _opts.method = "GET";
          _opts.body = null;
          request.headers.delete("content-length");
        }
        _opts.headers = {};
        request.headers.forEach((value, key) => {
          _opts.headers[key] = value;
        });
        _opts.counter = ++request.counter;
        const redirectReq = new Request(url.format(redirectUrl), _opts);
        return { request: redirectReq, options: _opts };
      };
      const fetch = async (request, options) => {
        const response = CachePolicy.storable(request, options)
          ? await cache(request, options)
          : await remote(request, options);
        if (
          !["GET", "HEAD"].includes(request.method) &&
          response.status >= 200 &&
          response.status <= 399
        ) {
          await cache.invalidate(request, options);
        }
        if (!canFollowRedirect(request, response, options)) {
          return response;
        }
        const redirect = getRedirect(request, response, options);
        return fetch(redirect.request, redirect.options);
      };
      module.exports = fetch;
    },
    9525: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { FetchError, Headers, Request, Response } =
        __nccwpck_require__(8998);
      const configureOptions = __nccwpck_require__(5530);
      const fetch = __nccwpck_require__(1371);
      const makeFetchHappen = (url, opts) => {
        const options = configureOptions(opts);
        const request = new Request(url, options);
        return fetch(request, options);
      };
      makeFetchHappen.defaults = (
        defaultUrl,
        defaultOptions = {},
        wrappedFetch = makeFetchHappen,
      ) => {
        if (typeof defaultUrl === "object") {
          defaultOptions = defaultUrl;
          defaultUrl = null;
        }
        const defaultedFetch = (url, options = {}) => {
          const finalUrl = url || defaultUrl;
          const finalOptions = {
            ...defaultOptions,
            ...options,
            headers: { ...defaultOptions.headers, ...options.headers },
          };
          return wrappedFetch(finalUrl, finalOptions);
        };
        defaultedFetch.defaults = (defaultUrl1, defaultOptions1 = {}) =>
          makeFetchHappen.defaults(
            defaultUrl1,
            defaultOptions1,
            defaultedFetch,
          );
        return defaultedFetch;
      };
      module.exports = makeFetchHappen;
      module.exports.FetchError = FetchError;
      module.exports.Headers = Headers;
      module.exports.Request = Request;
      module.exports.Response = Response;
    },
    5530: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const dns = __nccwpck_require__(7578);
      const conditionalHeaders = [
        "if-modified-since",
        "if-none-match",
        "if-unmodified-since",
        "if-match",
        "if-range",
      ];
      const configureOptions = (opts) => {
        const { strictSSL, ...options } = { ...opts };
        options.method = options.method ? options.method.toUpperCase() : "GET";
        options.rejectUnauthorized = strictSSL !== false;
        if (!options.retry) {
          options.retry = { retries: 0 };
        } else if (typeof options.retry === "string") {
          const retries = parseInt(options.retry, 10);
          if (isFinite(retries)) {
            options.retry = { retries };
          } else {
            options.retry = { retries: 0 };
          }
        } else if (typeof options.retry === "number") {
          options.retry = { retries: options.retry };
        } else {
          options.retry = { retries: 0, ...options.retry };
        }
        options.dns = { ttl: 5 * 60 * 1e3, lookup: dns.lookup, ...options.dns };
        options.cache = options.cache || "default";
        if (options.cache === "default") {
          const hasConditionalHeader = Object.keys(options.headers || {}).some(
            (name) => conditionalHeaders.includes(name.toLowerCase()),
          );
          if (hasConditionalHeader) {
            options.cache = "no-store";
          }
        }
        options.cacheAdditionalHeaders = options.cacheAdditionalHeaders || [];
        if (options.cacheManager && !options.cachePath) {
          options.cachePath = options.cacheManager;
        }
        return options;
      };
      module.exports = configureOptions;
    },
    1064: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const MinipassPipeline = __nccwpck_require__(9891);
      class CachingMinipassPipeline extends MinipassPipeline {
        #events = [];
        #data = new Map();
        constructor(opts, ...streams) {
          super();
          this.#events = opts.events;
          if (streams.length) {
            this.push(...streams);
          }
        }
        on(event, handler) {
          if (this.#events.includes(event) && this.#data.has(event)) {
            return handler(...this.#data.get(event));
          }
          return super.on(event, handler);
        }
        emit(event, ...data) {
          if (this.#events.includes(event)) {
            this.#data.set(event, data);
          }
          return super.emit(event, ...data);
        }
      }
      module.exports = CachingMinipassPipeline;
    },
    2619: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { Minipass } = __nccwpck_require__(4968);
      const fetch = __nccwpck_require__(8998);
      const promiseRetry = __nccwpck_require__(4742);
      const ssri = __nccwpck_require__(4406);
      const { log } = __nccwpck_require__(6528);
      const CachingMinipassPipeline = __nccwpck_require__(1064);
      const { getAgent } = __nccwpck_require__(9907);
      const pkg = __nccwpck_require__(3684);
      const USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;
      const RETRY_ERRORS = [
        "ECONNRESET",
        "ECONNREFUSED",
        "EADDRINUSE",
        "ETIMEDOUT",
        "ECONNECTIONTIMEOUT",
        "EIDLETIMEOUT",
        "ERESPONSETIMEOUT",
        "ETRANSFERTIMEOUT",
      ];
      const RETRY_TYPES = ["request-timeout"];
      const remoteFetch = (request, options) => {
        const agent = getAgent(request.url, options);
        if (!request.headers.has("connection")) {
          request.headers.set("connection", agent ? "keep-alive" : "close");
        }
        if (!request.headers.has("user-agent")) {
          request.headers.set("user-agent", USER_AGENT);
        }
        const _opts = { ...options, agent, redirect: "manual" };
        return promiseRetry(async (retryHandler, attemptNum) => {
          const req = new fetch.Request(request, _opts);
          try {
            let res = await fetch(req, _opts);
            if (_opts.integrity && res.status === 200) {
              const integrityStream = ssri.integrityStream({
                algorithms: _opts.algorithms,
                integrity: _opts.integrity,
                size: _opts.size,
              });
              const pipeline = new CachingMinipassPipeline(
                { events: ["integrity", "size"] },
                res.body,
                integrityStream,
              );
              integrityStream.on("integrity", (i) =>
                pipeline.emit("integrity", i),
              );
              integrityStream.on("size", (s) => pipeline.emit("size", s));
              res = new fetch.Response(pipeline, res);
              res.body.hasIntegrityEmitter = true;
            }
            res.headers.set("x-fetch-attempts", attemptNum);
            const isStream = Minipass.isStream(req.body);
            const isRetriable =
              req.method !== "POST" &&
              !isStream &&
              ([408, 420, 429].includes(res.status) || res.status >= 500);
            if (isRetriable) {
              if (typeof options.onRetry === "function") {
                options.onRetry(res);
              }
              log.http(
                "fetch",
                `${req.method} ${req.url} attempt ${attemptNum} failed with ${res.status}`,
              );
              return retryHandler(res);
            }
            return res;
          } catch (err) {
            const code =
              err.code === "EPROMISERETRY" ? err.retried.code : err.code;
            const isRetryError =
              err.retried instanceof fetch.Response ||
              (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type));
            if (req.method === "POST" || isRetryError) {
              throw err;
            }
            if (typeof options.onRetry === "function") {
              options.onRetry(err);
            }
            log.http(
              "fetch",
              `${req.method} ${req.url} attempt ${attemptNum} failed with ${err.code}`,
            );
            return retryHandler(err);
          }
        }, options.retry).catch((err) => {
          if (err.status >= 400 && err.type !== "system") {
            return err;
          }
          throw err;
        });
      };
      module.exports = remoteFetch;
    },
    8184: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var balanced = __nccwpck_require__(9417);
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str
          .split("\\\\")
          .join(escSlash)
          .split("\\{")
          .join(escOpen)
          .split("\\}")
          .join(escClose)
          .split("\\,")
          .join(escComma)
          .split("\\.")
          .join(escPeriod);
      }
      function unescapeBraces(str) {
        return str
          .split(escSlash)
          .join("\\")
          .split(escOpen)
          .join("{")
          .split(escClose)
          .join("}")
          .split(escComma)
          .join(",")
          .split(escPeriod)
          .join(".");
      }
      function parseCommaParts(str) {
        if (!str) return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m) return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str) return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m) return [str];
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(
            m.body,
          );
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function (p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\") c = "";
              } else {
                c = String(i);
                if (pad) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0) c = "-" + z + c.slice(1);
                    else c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion) expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    },
    1078: (module) => {
      "use strict";
      class AbortError extends Error {
        constructor(message) {
          super(message);
          this.code = "FETCH_ABORTED";
          this.type = "aborted";
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "AbortError";
        }
        set name(s) {}
      }
      module.exports = AbortError;
    },
    7911: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { Minipass } = __nccwpck_require__(4968);
      const TYPE = Symbol("type");
      const BUFFER = Symbol("buffer");
      class Blob {
        constructor(blobParts, options) {
          this[TYPE] = "";
          const buffers = [];
          let size = 0;
          if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for (let i = 0; i < length; i++) {
              const element = a[i];
              const buffer =
                element instanceof Buffer
                  ? element
                  : ArrayBuffer.isView(element)
                    ? Buffer.from(
                        element.buffer,
                        element.byteOffset,
                        element.byteLength,
                      )
                    : element instanceof ArrayBuffer
                      ? Buffer.from(element)
                      : element instanceof Blob
                        ? element[BUFFER]
                        : typeof element === "string"
                          ? Buffer.from(element)
                          : Buffer.from(String(element));
              size += buffer.length;
              buffers.push(buffer);
            }
          }
          this[BUFFER] = Buffer.concat(buffers, size);
          const type =
            options &&
            options.type !== undefined &&
            String(options.type).toLowerCase();
          if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
          }
        }
        get size() {
          return this[BUFFER].length;
        }
        get type() {
          return this[TYPE];
        }
        text() {
          return Promise.resolve(this[BUFFER].toString());
        }
        arrayBuffer() {
          const buf = this[BUFFER];
          const off = buf.byteOffset;
          const len = buf.byteLength;
          const ab = buf.buffer.slice(off, off + len);
          return Promise.resolve(ab);
        }
        stream() {
          return new Minipass().end(this[BUFFER]);
        }
        slice(start, end, type) {
          const size = this.size;
          const relativeStart =
            start === undefined
              ? 0
              : start < 0
                ? Math.max(size + start, 0)
                : Math.min(start, size);
          const relativeEnd =
            end === undefined
              ? size
              : end < 0
                ? Math.max(size + end, 0)
                : Math.min(end, size);
          const span = Math.max(relativeEnd - relativeStart, 0);
          const buffer = this[BUFFER];
          const slicedBuffer = buffer.slice(
            relativeStart,
            relativeStart + span,
          );
          const blob = new Blob([], { type });
          blob[BUFFER] = slicedBuffer;
          return blob;
        }
        get [Symbol.toStringTag]() {
          return "Blob";
        }
        static get BUFFER() {
          return BUFFER;
        }
      }
      Object.defineProperties(Blob.prototype, {
        size: { enumerable: true },
        type: { enumerable: true },
      });
      module.exports = Blob;
    },
    7223: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { Minipass } = __nccwpck_require__(4968);
      const MinipassSized = __nccwpck_require__(5952);
      const Blob = __nccwpck_require__(7911);
      const { BUFFER } = Blob;
      const FetchError = __nccwpck_require__(2899);
      let convert;
      try {
        convert = __nccwpck_require__(8685).O;
      } catch (e) {}
      const INTERNALS = Symbol("Body internals");
      const CONSUME_BODY = Symbol("consumeBody");
      class Body {
        constructor(bodyArg, options = {}) {
          const { size = 0, timeout = 0 } = options;
          const body =
            bodyArg === undefined || bodyArg === null
              ? null
              : isURLSearchParams(bodyArg)
                ? Buffer.from(bodyArg.toString())
                : isBlob(bodyArg)
                  ? bodyArg
                  : Buffer.isBuffer(bodyArg)
                    ? bodyArg
                    : Object.prototype.toString.call(bodyArg) ===
                        "[object ArrayBuffer]"
                      ? Buffer.from(bodyArg)
                      : ArrayBuffer.isView(bodyArg)
                        ? Buffer.from(
                            bodyArg.buffer,
                            bodyArg.byteOffset,
                            bodyArg.byteLength,
                          )
                        : Minipass.isStream(bodyArg)
                          ? bodyArg
                          : Buffer.from(String(bodyArg));
          this[INTERNALS] = { body, disturbed: false, error: null };
          this.size = size;
          this.timeout = timeout;
          if (Minipass.isStream(body)) {
            body.on("error", (er) => {
              const error =
                er.name === "AbortError"
                  ? er
                  : new FetchError(
                      `Invalid response while trying to fetch ${this.url}: ${er.message}`,
                      "system",
                      er,
                    );
              this[INTERNALS].error = error;
            });
          }
        }
        get body() {
          return this[INTERNALS].body;
        }
        get bodyUsed() {
          return this[INTERNALS].disturbed;
        }
        arrayBuffer() {
          return this[CONSUME_BODY]().then((buf) =>
            buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength),
          );
        }
        blob() {
          const ct = (this.headers && this.headers.get("content-type")) || "";
          return this[CONSUME_BODY]().then((buf) =>
            Object.assign(new Blob([], { type: ct.toLowerCase() }), {
              [BUFFER]: buf,
            }),
          );
        }
        async json() {
          const buf = await this[CONSUME_BODY]();
          try {
            return JSON.parse(buf.toString());
          } catch (er) {
            throw new FetchError(
              `invalid json response body at ${this.url} reason: ${er.message}`,
              "invalid-json",
            );
          }
        }
        text() {
          return this[CONSUME_BODY]().then((buf) => buf.toString());
        }
        buffer() {
          return this[CONSUME_BODY]();
        }
        textConverted() {
          return this[CONSUME_BODY]().then((buf) =>
            convertBody(buf, this.headers),
          );
        }
        [CONSUME_BODY]() {
          if (this[INTERNALS].disturbed) {
            return Promise.reject(
              new TypeError(`body used already for: ${this.url}`),
            );
          }
          this[INTERNALS].disturbed = true;
          if (this[INTERNALS].error) {
            return Promise.reject(this[INTERNALS].error);
          }
          if (this.body === null) {
            return Promise.resolve(Buffer.alloc(0));
          }
          if (Buffer.isBuffer(this.body)) {
            return Promise.resolve(this.body);
          }
          const upstream = isBlob(this.body) ? this.body.stream() : this.body;
          if (!Minipass.isStream(upstream)) {
            return Promise.resolve(Buffer.alloc(0));
          }
          const stream =
            this.size && upstream instanceof MinipassSized
              ? upstream
              : !this.size &&
                  upstream instanceof Minipass &&
                  !(upstream instanceof MinipassSized)
                ? upstream
                : this.size
                  ? new MinipassSized({ size: this.size })
                  : new Minipass();
          const resTimeout =
            this.timeout && stream.writable
              ? setTimeout(() => {
                  stream.emit(
                    "error",
                    new FetchError(
                      `Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`,
                      "body-timeout",
                    ),
                  );
                }, this.timeout)
              : null;
          if (resTimeout && resTimeout.unref) {
            resTimeout.unref();
          }
          return new Promise((resolve) => {
            if (stream !== upstream) {
              upstream.on("error", (er) => stream.emit("error", er));
              upstream.pipe(stream);
            }
            resolve();
          })
            .then(() => stream.concat())
            .then((buf) => {
              clearTimeout(resTimeout);
              return buf;
            })
            .catch((er) => {
              clearTimeout(resTimeout);
              if (er.name === "AbortError" || er.name === "FetchError") {
                throw er;
              } else if (er.name === "RangeError") {
                throw new FetchError(
                  `Could not create Buffer from response body for ${this.url}: ${er.message}`,
                  "system",
                  er,
                );
              } else {
                throw new FetchError(
                  `Invalid response body while trying to fetch ${this.url}: ${er.message}`,
                  "system",
                  er,
                );
              }
            });
        }
        static clone(instance) {
          if (instance.bodyUsed) {
            throw new Error("cannot clone body after it is used");
          }
          const body = instance.body;
          if (
            Minipass.isStream(body) &&
            typeof body.getBoundary !== "function"
          ) {
            const tee = new Minipass();
            const p1 = new Minipass();
            const p2 = new Minipass();
            tee.on("error", (er) => {
              p1.emit("error", er);
              p2.emit("error", er);
            });
            body.on("error", (er) => tee.emit("error", er));
            tee.pipe(p1);
            tee.pipe(p2);
            body.pipe(tee);
            instance[INTERNALS].body = p1;
            return p2;
          } else {
            return instance.body;
          }
        }
        static extractContentType(body) {
          return body === null || body === undefined
            ? null
            : typeof body === "string"
              ? "text/plain;charset=UTF-8"
              : isURLSearchParams(body)
                ? "application/x-www-form-urlencoded;charset=UTF-8"
                : isBlob(body)
                  ? body.type || null
                  : Buffer.isBuffer(body)
                    ? null
                    : Object.prototype.toString.call(body) ===
                        "[object ArrayBuffer]"
                      ? null
                      : ArrayBuffer.isView(body)
                        ? null
                        : typeof body.getBoundary === "function"
                          ? `multipart/form-data;boundary=${body.getBoundary()}`
                          : Minipass.isStream(body)
                            ? null
                            : "text/plain;charset=UTF-8";
        }
        static getTotalBytes(instance) {
          const { body } = instance;
          return body === null || body === undefined
            ? 0
            : isBlob(body)
              ? body.size
              : Buffer.isBuffer(body)
                ? body.length
                : body &&
                    typeof body.getLengthSync === "function" &&
                    ((body._lengthRetrievers &&
                      body._lengthRetrievers.length === 0) ||
                      (body.hasKnownLength && body.hasKnownLength()))
                  ? body.getLengthSync()
                  : null;
        }
        static writeToStream(dest, instance) {
          const { body } = instance;
          if (body === null || body === undefined) {
            dest.end();
          } else if (Buffer.isBuffer(body) || typeof body === "string") {
            dest.end(body);
          } else {
            const stream = isBlob(body) ? body.stream() : body;
            stream.on("error", (er) => dest.emit("error", er)).pipe(dest);
          }
          return dest;
        }
      }
      Object.defineProperties(Body.prototype, {
        body: { enumerable: true },
        bodyUsed: { enumerable: true },
        arrayBuffer: { enumerable: true },
        blob: { enumerable: true },
        json: { enumerable: true },
        text: { enumerable: true },
      });
      const isURLSearchParams = (obj) =>
        typeof obj !== "object" ||
        typeof obj.append !== "function" ||
        typeof obj.delete !== "function" ||
        typeof obj.get !== "function" ||
        typeof obj.getAll !== "function" ||
        typeof obj.has !== "function" ||
        typeof obj.set !== "function"
          ? false
          : obj.constructor.name === "URLSearchParams" ||
            Object.prototype.toString.call(obj) ===
              "[object URLSearchParams]" ||
            typeof obj.sort === "function";
      const isBlob = (obj) =>
        typeof obj === "object" &&
        typeof obj.arrayBuffer === "function" &&
        typeof obj.type === "string" &&
        typeof obj.stream === "function" &&
        typeof obj.constructor === "function" &&
        typeof obj.constructor.name === "string" &&
        /^(Blob|File)$/.test(obj.constructor.name) &&
        /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
      const convertBody = (buffer, headers) => {
        if (typeof convert !== "function") {
          throw new Error(
            "The package `encoding` must be installed to use the textConverted() function",
          );
        }
        const ct = headers && headers.get("content-type");
        let charset = "utf-8";
        let res;
        if (ct) {
          res = /charset=([^;]*)/i.exec(ct);
        }
        const str = buffer.slice(0, 1024).toString();
        if (!res && str) {
          res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
        }
        if (!res && str) {
          res =
            /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(
              str,
            );
          if (!res) {
            res =
              /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(
                str,
              );
            if (res) {
              res.pop();
            }
          }
          if (res) {
            res = /charset=(.*)/i.exec(res.pop());
          }
        }
        if (!res && str) {
          res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
        }
        if (res) {
          charset = res.pop();
          if (charset === "gb2312" || charset === "gbk") {
            charset = "gb18030";
          }
        }
        return convert(buffer, "UTF-8", charset).toString();
      };
      module.exports = Body;
    },
    2899: (module) => {
      "use strict";
      class FetchError extends Error {
        constructor(message, type, systemError) {
          super(message);
          this.code = "FETCH_ERROR";
          if (systemError) {
            Object.assign(this, systemError);
          }
          this.errno = this.code;
          this.type =
            this.code === "EBADSIZE" && this.found > this.expect
              ? "max-size"
              : type;
          this.message = message;
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "FetchError";
        }
        set name(n) {}
        get [Symbol.toStringTag]() {
          return "FetchError";
        }
      }
      module.exports = FetchError;
    },
    1504: (module) => {
      "use strict";
      const invalidTokenRegex = /[^^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
      const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      const validateName = (name) => {
        name = `${name}`;
        if (invalidTokenRegex.test(name) || name === "") {
          throw new TypeError(`${name} is not a legal HTTP header name`);
        }
      };
      const validateValue = (value) => {
        value = `${value}`;
        if (invalidHeaderCharRegex.test(value)) {
          throw new TypeError(`${value} is not a legal HTTP header value`);
        }
      };
      const find = (map, name) => {
        name = name.toLowerCase();
        for (const key in map) {
          if (key.toLowerCase() === name) {
            return key;
          }
        }
        return undefined;
      };
      const MAP = Symbol("map");
      class Headers {
        constructor(init = undefined) {
          this[MAP] = Object.create(null);
          if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) {
              for (const value of rawHeaders[headerName]) {
                this.append(headerName, value);
              }
            }
            return;
          }
          if (init === undefined || init === null) {
            return;
          }
          if (typeof init === "object") {
            const method = init[Symbol.iterator];
            if (method !== null && method !== undefined) {
              if (typeof method !== "function") {
                throw new TypeError("Header pairs must be iterable");
              }
              const pairs = [];
              for (const pair of init) {
                if (
                  typeof pair !== "object" ||
                  typeof pair[Symbol.iterator] !== "function"
                ) {
                  throw new TypeError("Each header pair must be iterable");
                }
                const arrPair = Array.from(pair);
                if (arrPair.length !== 2) {
                  throw new TypeError(
                    "Each header pair must be a name/value tuple",
                  );
                }
                pairs.push(arrPair);
              }
              for (const pair of pairs) {
                this.append(pair[0], pair[1]);
              }
            } else {
              for (const key of Object.keys(init)) {
                this.append(key, init[key]);
              }
            }
          } else {
            throw new TypeError("Provided initializer must be an object");
          }
        }
        get(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key === undefined) {
            return null;
          }
          return this[MAP][key].join(", ");
        }
        forEach(callback, thisArg = undefined) {
          let pairs = getHeaders(this);
          for (let i = 0; i < pairs.length; i++) {
            const [name, value] = pairs[i];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
          }
        }
        set(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          this[MAP][key !== undefined ? key : name] = [value];
        }
        append(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          if (key !== undefined) {
            this[MAP][key].push(value);
          } else {
            this[MAP][name] = [value];
          }
        }
        has(name) {
          name = `${name}`;
          validateName(name);
          return find(this[MAP], name) !== undefined;
        }
        delete(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key !== undefined) {
            delete this[MAP][key];
          }
        }
        raw() {
          return this[MAP];
        }
        keys() {
          return new HeadersIterator(this, "key");
        }
        values() {
          return new HeadersIterator(this, "value");
        }
        [Symbol.iterator]() {
          return new HeadersIterator(this, "key+value");
        }
        entries() {
          return new HeadersIterator(this, "key+value");
        }
        get [Symbol.toStringTag]() {
          return "Headers";
        }
        static exportNodeCompatibleHeaders(headers) {
          const obj = Object.assign(Object.create(null), headers[MAP]);
          const hostHeaderKey = find(headers[MAP], "Host");
          if (hostHeaderKey !== undefined) {
            obj[hostHeaderKey] = obj[hostHeaderKey][0];
          }
          return obj;
        }
        static createHeadersLenient(obj) {
          const headers = new Headers();
          for (const name of Object.keys(obj)) {
            if (invalidTokenRegex.test(name)) {
              continue;
            }
            if (Array.isArray(obj[name])) {
              for (const val of obj[name]) {
                if (invalidHeaderCharRegex.test(val)) {
                  continue;
                }
                if (headers[MAP][name] === undefined) {
                  headers[MAP][name] = [val];
                } else {
                  headers[MAP][name].push(val);
                }
              }
            } else if (!invalidHeaderCharRegex.test(obj[name])) {
              headers[MAP][name] = [obj[name]];
            }
          }
          return headers;
        }
      }
      Object.defineProperties(Headers.prototype, {
        get: { enumerable: true },
        forEach: { enumerable: true },
        set: { enumerable: true },
        append: { enumerable: true },
        has: { enumerable: true },
        delete: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true },
      });
      const getHeaders = (headers, kind = "key+value") =>
        Object.keys(headers[MAP])
          .sort()
          .map(
            kind === "key"
              ? (k) => k.toLowerCase()
              : kind === "value"
                ? (k) => headers[MAP][k].join(", ")
                : (k) => [k.toLowerCase(), headers[MAP][k].join(", ")],
          );
      const INTERNAL = Symbol("internal");
      class HeadersIterator {
        constructor(target, kind) {
          this[INTERNAL] = { target, kind, index: 0 };
        }
        get [Symbol.toStringTag]() {
          return "HeadersIterator";
        }
        next() {
          if (
            !this ||
            Object.getPrototypeOf(this) !== HeadersIterator.prototype
          ) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          const { target, kind, index } = this[INTERNAL];
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return { value: undefined, done: true };
          }
          this[INTERNAL].index++;
          return { value: values[index], done: false };
        }
      }
      Object.setPrototypeOf(
        HeadersIterator.prototype,
        Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())),
      );
      module.exports = Headers;
    },
    8998: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(7310);
      const http = __nccwpck_require__(3685);
      const https = __nccwpck_require__(5687);
      const zlib = __nccwpck_require__(3486);
      const { Minipass } = __nccwpck_require__(4968);
      const Body = __nccwpck_require__(7223);
      const { writeToStream, getTotalBytes } = Body;
      const Response = __nccwpck_require__(2587);
      const Headers = __nccwpck_require__(1504);
      const { createHeadersLenient } = Headers;
      const Request = __nccwpck_require__(4410);
      const { getNodeRequestOptions } = Request;
      const FetchError = __nccwpck_require__(2899);
      const AbortError = __nccwpck_require__(1078);
      const fetch = async (url, opts) => {
        if (/^data:/.test(url)) {
          const request = new Request(url, opts);
          return Promise.resolve().then(
            () =>
              new Promise((resolve, reject) => {
                let type, data;
                try {
                  const { pathname, search } = new URL(url);
                  const split = pathname.split(",");
                  if (split.length < 2) {
                    throw new Error("invalid data: URI");
                  }
                  const mime = split.shift();
                  const base64 = /;base64$/.test(mime);
                  type = base64 ? mime.slice(0, -1 * ";base64".length) : mime;
                  const rawData = decodeURIComponent(split.join(",") + search);
                  data = base64
                    ? Buffer.from(rawData, "base64")
                    : Buffer.from(rawData);
                } catch (er) {
                  return reject(
                    new FetchError(
                      `[${request.method}] ${request.url} invalid URL, ${er.message}`,
                      "system",
                      er,
                    ),
                  );
                }
                const { signal } = request;
                if (signal && signal.aborted) {
                  return reject(new AbortError("The user aborted a request."));
                }
                const headers = { "Content-Length": data.length };
                if (type) {
                  headers["Content-Type"] = type;
                }
                return resolve(new Response(data, { headers }));
              }),
          );
        }
        return new Promise((resolve, reject) => {
          const request = new Request(url, opts);
          let options;
          try {
            options = getNodeRequestOptions(request);
          } catch (er) {
            return reject(er);
          }
          const send = (options.protocol === "https:" ? https : http).request;
          const { signal } = request;
          let response = null;
          const abort = () => {
            const error = new AbortError("The user aborted a request.");
            reject(error);
            if (
              Minipass.isStream(request.body) &&
              typeof request.body.destroy === "function"
            ) {
              request.body.destroy(error);
            }
            if (response && response.body) {
              response.body.emit("error", error);
            }
          };
          if (signal && signal.aborted) {
            return abort();
          }
          const abortAndFinalize = () => {
            abort();
            finalize();
          };
          const finalize = () => {
            req.abort();
            if (signal) {
              signal.removeEventListener("abort", abortAndFinalize);
            }
            clearTimeout(reqTimeout);
          };
          const req = send(options);
          if (signal) {
            signal.addEventListener("abort", abortAndFinalize);
          }
          let reqTimeout = null;
          if (request.timeout) {
            req.once("socket", () => {
              reqTimeout = setTimeout(() => {
                reject(
                  new FetchError(
                    `network timeout at: ${request.url}`,
                    "request-timeout",
                  ),
                );
                finalize();
              }, request.timeout);
            });
          }
          req.on("error", (er) => {
            if (req.res) {
              req.res.emit("error", er);
            }
            reject(
              new FetchError(
                `request to ${request.url} failed, reason: ${er.message}`,
                "system",
                er,
              ),
            );
            finalize();
          });
          req.on("response", (res) => {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            if (fetch.isRedirect(res.statusCode)) {
              const location = headers.get("Location");
              let locationURL = null;
              try {
                locationURL =
                  location === null
                    ? null
                    : new URL(location, request.url).toString();
              } catch {
                if (request.redirect !== "manual") {
                  reject(
                    new FetchError(
                      `uri requested responds with an invalid redirect URL: ${location}`,
                      "invalid-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
              }
              if (request.redirect === "error") {
                reject(
                  new FetchError(
                    "uri requested responds with a redirect, " +
                      `redirect mode is set to error: ${request.url}`,
                    "no-redirect",
                  ),
                );
                finalize();
                return;
              } else if (request.redirect === "manual") {
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
              } else if (
                request.redirect === "follow" &&
                locationURL !== null
              ) {
                if (request.counter >= request.follow) {
                  reject(
                    new FetchError(
                      `maximum redirect reached at: ${request.url}`,
                      "max-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
                if (
                  res.statusCode !== 303 &&
                  request.body &&
                  getTotalBytes(request) === null
                ) {
                  reject(
                    new FetchError(
                      "Cannot follow redirect with body being a readable stream",
                      "unsupported-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
                request.headers.set("host", new URL(locationURL).host);
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                };
                const parsedOriginal = new URL(request.url);
                const parsedRedirect = new URL(locationURL);
                if (parsedOriginal.hostname !== parsedRedirect.hostname) {
                  requestOpts.headers.delete("authorization");
                  requestOpts.headers.delete("cookie");
                }
                if (
                  res.statusCode === 303 ||
                  ((res.statusCode === 301 || res.statusCode === 302) &&
                    request.method === "POST")
                ) {
                  requestOpts.method = "GET";
                  requestOpts.body = undefined;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
              }
            }
            res.once(
              "end",
              () =>
                signal && signal.removeEventListener("abort", abortAndFinalize),
            );
            const body = new Minipass();
            body.on("error", finalize);
            res.on("error", (er) => body.emit("error", er));
            res.on("data", (chunk) => body.write(chunk));
            res.on("end", () => body.end());
            const responseOptions = {
              url: request.url,
              status: res.statusCode,
              statusText: res.statusMessage,
              headers,
              size: request.size,
              timeout: request.timeout,
              counter: request.counter,
              trailer: new Promise((resolveTrailer) =>
                res.on("end", () =>
                  resolveTrailer(createHeadersLenient(res.trailers)),
                ),
              ),
            };
            const codings = headers.get("Content-Encoding");
            if (
              !request.compress ||
              request.method === "HEAD" ||
              codings === null ||
              res.statusCode === 204 ||
              res.statusCode === 304
            ) {
              response = new Response(body, responseOptions);
              resolve(response);
              return;
            }
            const zlibOptions = {
              flush: zlib.constants.Z_SYNC_FLUSH,
              finishFlush: zlib.constants.Z_SYNC_FLUSH,
            };
            if (codings === "gzip" || codings === "x-gzip") {
              const unzip = new zlib.Gunzip(zlibOptions);
              response = new Response(
                body.on("error", (er) => unzip.emit("error", er)).pipe(unzip),
                responseOptions,
              );
              resolve(response);
              return;
            }
            if (codings === "deflate" || codings === "x-deflate") {
              const raw = res.pipe(new Minipass());
              raw.once("data", (chunk) => {
                const decoder =
                  (chunk[0] & 15) === 8
                    ? new zlib.Inflate()
                    : new zlib.InflateRaw();
                body
                  .on("error", (er) => decoder.emit("error", er))
                  .pipe(decoder);
                response = new Response(decoder, responseOptions);
                resolve(response);
              });
              return;
            }
            if (codings === "br") {
              try {
                var decoder = new zlib.BrotliDecompress();
              } catch (err) {
                reject(err);
                finalize();
                return;
              }
              body.on("error", (er) => decoder.emit("error", er)).pipe(decoder);
              response = new Response(decoder, responseOptions);
              resolve(response);
              return;
            }
            response = new Response(body, responseOptions);
            resolve(response);
          });
          writeToStream(req, request);
        });
      };
      module.exports = fetch;
      fetch.isRedirect = (code) =>
        code === 301 ||
        code === 302 ||
        code === 303 ||
        code === 307 ||
        code === 308;
      fetch.Headers = Headers;
      fetch.Request = Request;
      fetch.Response = Response;
      fetch.FetchError = FetchError;
      fetch.AbortError = AbortError;
    },
    4410: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(7310);
      const { Minipass } = __nccwpck_require__(4968);
      const Headers = __nccwpck_require__(1504);
      const { exportNodeCompatibleHeaders } = Headers;
      const Body = __nccwpck_require__(7223);
      const { clone, extractContentType, getTotalBytes } = Body;
      const version = __nccwpck_require__(3684).version;
      const defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;
      const INTERNALS = Symbol("Request internals");
      const isRequest = (input) =>
        typeof input === "object" && typeof input[INTERNALS] === "object";
      const isAbortSignal = (signal) => {
        const proto =
          signal && typeof signal === "object" && Object.getPrototypeOf(signal);
        return !!(proto && proto.constructor.name === "AbortSignal");
      };
      class Request extends Body {
        constructor(input, init = {}) {
          const parsedURL = isRequest(input)
            ? new URL(input.url)
            : input && input.href
              ? new URL(input.href)
              : new URL(`${input}`);
          if (isRequest(input)) {
            init = { ...input[INTERNALS], ...init };
          } else if (!input || typeof input === "string") {
            input = {};
          }
          const method = (init.method || input.method || "GET").toUpperCase();
          const isGETHEAD = method === "GET" || method === "HEAD";
          if (
            ((init.body !== null && init.body !== undefined) ||
              (isRequest(input) && input.body !== null)) &&
            isGETHEAD
          ) {
            throw new TypeError(
              "Request with GET/HEAD method cannot have body",
            );
          }
          const inputBody =
            init.body !== null && init.body !== undefined
              ? init.body
              : isRequest(input) && input.body !== null
                ? clone(input)
                : null;
          super(inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0,
          });
          const headers = new Headers(init.headers || input.headers || {});
          if (
            inputBody !== null &&
            inputBody !== undefined &&
            !headers.has("Content-Type")
          ) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          const signal = "signal" in init ? init.signal : null;
          if (
            signal !== null &&
            signal !== undefined &&
            !isAbortSignal(signal)
          ) {
            throw new TypeError(
              "Expected signal must be an instanceof AbortSignal",
            );
          }
          const {
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !==
              "0",
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
          } = init;
          this[INTERNALS] = {
            method,
            redirect: init.redirect || input.redirect || "follow",
            headers,
            parsedURL,
            signal,
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized,
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
          };
          this.follow =
            init.follow !== undefined
              ? init.follow
              : input.follow !== undefined
                ? input.follow
                : 20;
          this.compress =
            init.compress !== undefined
              ? init.compress
              : input.compress !== undefined
                ? input.compress
                : true;
          this.counter = init.counter || input.counter || 0;
          this.agent = init.agent || input.agent;
        }
        get method() {
          return this[INTERNALS].method;
        }
        get url() {
          return this[INTERNALS].parsedURL.toString();
        }
        get headers() {
          return this[INTERNALS].headers;
        }
        get redirect() {
          return this[INTERNALS].redirect;
        }
        get signal() {
          return this[INTERNALS].signal;
        }
        clone() {
          return new Request(this);
        }
        get [Symbol.toStringTag]() {
          return "Request";
        }
        static getNodeRequestOptions(request) {
          const parsedURL = request[INTERNALS].parsedURL;
          const headers = new Headers(request[INTERNALS].headers);
          if (!headers.has("Accept")) {
            headers.set("Accept", "*/*");
          }
          if (!/^https?:$/.test(parsedURL.protocol)) {
            throw new TypeError("Only HTTP(S) protocols are supported");
          }
          if (
            request.signal &&
            Minipass.isStream(request.body) &&
            typeof request.body.destroy !== "function"
          ) {
            throw new Error(
              "Cancellation of streamed requests with AbortSignal is not supported",
            );
          }
          const contentLengthValue =
            (request.body === null || request.body === undefined) &&
            /^(POST|PUT)$/i.test(request.method)
              ? "0"
              : request.body !== null && request.body !== undefined
                ? getTotalBytes(request)
                : null;
          if (contentLengthValue) {
            headers.set("Content-Length", contentLengthValue + "");
          }
          if (!headers.has("User-Agent")) {
            headers.set("User-Agent", defaultUserAgent);
          }
          if (request.compress && !headers.has("Accept-Encoding")) {
            headers.set("Accept-Encoding", "gzip,deflate");
          }
          const agent =
            typeof request.agent === "function"
              ? request.agent(parsedURL)
              : request.agent;
          if (!headers.has("Connection") && !agent) {
            headers.set("Connection", "close");
          }
          const {
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized,
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
          } = request[INTERNALS];
          const urlProps = {
            auth:
              parsedURL.username || parsedURL.password
                ? `${parsedURL.username}:${parsedURL.password}`
                : "",
            host: parsedURL.host,
            hostname: parsedURL.hostname,
            path: `${parsedURL.pathname}${parsedURL.search}`,
            port: parsedURL.port,
            protocol: parsedURL.protocol,
          };
          return {
            ...urlProps,
            method: request.method,
            headers: exportNodeCompatibleHeaders(headers),
            agent,
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized,
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
            timeout: request.timeout,
          };
        }
      }
      module.exports = Request;
      Object.defineProperties(Request.prototype, {
        method: { enumerable: true },
        url: { enumerable: true },
        headers: { enumerable: true },
        redirect: { enumerable: true },
        clone: { enumerable: true },
        signal: { enumerable: true },
      });
    },
    2587: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const http = __nccwpck_require__(3685);
      const { STATUS_CODES } = http;
      const Headers = __nccwpck_require__(1504);
      const Body = __nccwpck_require__(7223);
      const { clone, extractContentType } = Body;
      const INTERNALS = Symbol("Response internals");
      class Response extends Body {
        constructor(body = null, opts = {}) {
          super(body, opts);
          const status = opts.status || 200;
          const headers = new Headers(opts.headers);
          if (
            body !== null &&
            body !== undefined &&
            !headers.has("Content-Type")
          ) {
            const contentType = extractContentType(body);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          this[INTERNALS] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter,
            trailer: Promise.resolve(opts.trailer || new Headers()),
          };
        }
        get trailer() {
          return this[INTERNALS].trailer;
        }
        get url() {
          return this[INTERNALS].url || "";
        }
        get status() {
          return this[INTERNALS].status;
        }
        get ok() {
          return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
        }
        get redirected() {
          return this[INTERNALS].counter > 0;
        }
        get statusText() {
          return this[INTERNALS].statusText;
        }
        get headers() {
          return this[INTERNALS].headers;
        }
        clone() {
          return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected,
            trailer: this.trailer,
          });
        }
        get [Symbol.toStringTag]() {
          return "Response";
        }
      }
      module.exports = Response;
      Object.defineProperties(Response.prototype, {
        url: { enumerable: true },
        status: { enumerable: true },
        ok: { enumerable: true },
        redirected: { enumerable: true },
        statusText: { enumerable: true },
        headers: { enumerable: true },
        clone: { enumerable: true },
      });
    },
    4181: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Minipass = __nccwpck_require__(7818);
      const _flush = Symbol("_flush");
      const _flushed = Symbol("_flushed");
      const _flushing = Symbol("_flushing");
      class Flush extends Minipass {
        constructor(opt = {}) {
          if (typeof opt === "function") opt = { flush: opt };
          super(opt);
          if (
            typeof opt.flush !== "function" &&
            typeof this.flush !== "function"
          )
            throw new TypeError("must provide flush function in options");
          this[_flush] = opt.flush || this.flush;
        }
        emit(ev, ...data) {
          if ((ev !== "end" && ev !== "finish") || this[_flushed])
            return super.emit(ev, ...data);
          if (this[_flushing]) return;
          this[_flushing] = true;
          const afterFlush = (er) => {
            this[_flushed] = true;
            er ? super.emit("error", er) : super.emit("end");
          };
          const ret = this[_flush](afterFlush);
          if (ret && ret.then)
            ret.then(
              () => afterFlush(),
              (er) => afterFlush(er),
            );
        }
      }
      module.exports = Flush;
    },
    7818: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    9891: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Minipass = __nccwpck_require__(3392);
      const EE = __nccwpck_require__(2361);
      const isStream = (s) =>
        s &&
        s instanceof EE &&
        (typeof s.pipe === "function" ||
          (typeof s.write === "function" && typeof s.end === "function"));
      const _head = Symbol("_head");
      const _tail = Symbol("_tail");
      const _linkStreams = Symbol("_linkStreams");
      const _setHead = Symbol("_setHead");
      const _setTail = Symbol("_setTail");
      const _onError = Symbol("_onError");
      const _onData = Symbol("_onData");
      const _onEnd = Symbol("_onEnd");
      const _onDrain = Symbol("_onDrain");
      const _streams = Symbol("_streams");
      class Pipeline extends Minipass {
        constructor(opts, ...streams) {
          if (isStream(opts)) {
            streams.unshift(opts);
            opts = {};
          }
          super(opts);
          this[_streams] = [];
          if (streams.length) this.push(...streams);
        }
        [_linkStreams](streams) {
          return streams.reduce((src, dest) => {
            src.on("error", (er) => dest.emit("error", er));
            src.pipe(dest);
            return dest;
          });
        }
        push(...streams) {
          this[_streams].push(...streams);
          if (this[_tail]) streams.unshift(this[_tail]);
          const linkRet = this[_linkStreams](streams);
          this[_setTail](linkRet);
          if (!this[_head]) this[_setHead](streams[0]);
        }
        unshift(...streams) {
          this[_streams].unshift(...streams);
          if (this[_head]) streams.push(this[_head]);
          const linkRet = this[_linkStreams](streams);
          this[_setHead](streams[0]);
          if (!this[_tail]) this[_setTail](linkRet);
        }
        destroy(er) {
          this[_streams].forEach(
            (s) => typeof s.destroy === "function" && s.destroy(),
          );
          return super.destroy(er);
        }
        [_setTail](stream) {
          this[_tail] = stream;
          stream.on("error", (er) => this[_onError](stream, er));
          stream.on("data", (chunk) => this[_onData](stream, chunk));
          stream.on("end", () => this[_onEnd](stream));
          stream.on("finish", () => this[_onEnd](stream));
        }
        [_onError](stream, er) {
          if (stream === this[_tail]) this.emit("error", er);
        }
        [_onData](stream, chunk) {
          if (stream === this[_tail]) super.write(chunk);
        }
        [_onEnd](stream) {
          if (stream === this[_tail]) super.end();
        }
        pause() {
          super.pause();
          return this[_tail] && this[_tail].pause && this[_tail].pause();
        }
        emit(ev, ...args) {
          if (ev === "resume" && this[_tail] && this[_tail].resume)
            this[_tail].resume();
          return super.emit(ev, ...args);
        }
        [_setHead](stream) {
          this[_head] = stream;
          stream.on("drain", () => this[_onDrain](stream));
        }
        [_onDrain](stream) {
          if (stream === this[_head]) this.emit("drain");
        }
        write(chunk, enc, cb) {
          return (
            this[_head].write(chunk, enc, cb) &&
            (this.flowing || this.buffer.length === 0)
          );
        }
        end(chunk, enc, cb) {
          this[_head].end(chunk, enc, cb);
          return this;
        }
      }
      module.exports = Pipeline;
    },
    3392: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    5952: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Minipass = __nccwpck_require__(8024);
      class SizeError extends Error {
        constructor(found, expect) {
          super(`Bad data size: expected ${expect} bytes, but got ${found}`);
          this.expect = expect;
          this.found = found;
          this.code = "EBADSIZE";
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "SizeError";
        }
      }
      class MinipassSized extends Minipass {
        constructor(options = {}) {
          super(options);
          if (options.objectMode)
            throw new TypeError(
              `${this.constructor.name} streams only work with string and buffer data`,
            );
          this.found = 0;
          this.expect = options.size;
          if (
            typeof this.expect !== "number" ||
            this.expect > Number.MAX_SAFE_INTEGER ||
            isNaN(this.expect) ||
            this.expect < 0 ||
            !isFinite(this.expect) ||
            this.expect !== Math.floor(this.expect)
          )
            throw new Error("invalid expected size: " + this.expect);
        }
        write(chunk, encoding, cb) {
          const buffer = Buffer.isBuffer(chunk)
            ? chunk
            : typeof chunk === "string"
              ? Buffer.from(
                  chunk,
                  typeof encoding === "string" ? encoding : "utf8",
                )
              : chunk;
          if (!Buffer.isBuffer(buffer)) {
            this.emit(
              "error",
              new TypeError(
                `${this.constructor.name} streams only work with string and buffer data`,
              ),
            );
            return false;
          }
          this.found += buffer.length;
          if (this.found > this.expect)
            this.emit("error", new SizeError(this.found, this.expect));
          return super.write(chunk, encoding, cb);
        }
        emit(ev, ...data) {
          if (ev === "end") {
            if (this.found !== this.expect)
              this.emit("error", new SizeError(this.found, this.expect));
          }
          return super.emit(ev, ...data);
        }
      }
      MinipassSized.SizeError = SizeError;
      module.exports = MinipassSized;
    },
    8024: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    6769: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const realZlibConstants = __nccwpck_require__(9796).constants || {
        ZLIB_VERNUM: 4736,
      };
      module.exports = Object.freeze(
        Object.assign(
          Object.create(null),
          {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_VERSION_ERROR: -6,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            DEFLATE: 1,
            INFLATE: 2,
            GZIP: 3,
            GUNZIP: 4,
            DEFLATERAW: 5,
            INFLATERAW: 6,
            UNZIP: 7,
            BROTLI_DECODE: 8,
            BROTLI_ENCODE: 9,
            Z_MIN_WINDOWBITS: 8,
            Z_MAX_WINDOWBITS: 15,
            Z_DEFAULT_WINDOWBITS: 15,
            Z_MIN_CHUNK: 64,
            Z_MAX_CHUNK: Infinity,
            Z_DEFAULT_CHUNK: 16384,
            Z_MIN_MEMLEVEL: 1,
            Z_MAX_MEMLEVEL: 9,
            Z_DEFAULT_MEMLEVEL: 8,
            Z_MIN_LEVEL: -1,
            Z_MAX_LEVEL: 9,
            Z_DEFAULT_LEVEL: -1,
            BROTLI_OPERATION_PROCESS: 0,
            BROTLI_OPERATION_FLUSH: 1,
            BROTLI_OPERATION_FINISH: 2,
            BROTLI_OPERATION_EMIT_METADATA: 3,
            BROTLI_MODE_GENERIC: 0,
            BROTLI_MODE_TEXT: 1,
            BROTLI_MODE_FONT: 2,
            BROTLI_DEFAULT_MODE: 0,
            BROTLI_MIN_QUALITY: 0,
            BROTLI_MAX_QUALITY: 11,
            BROTLI_DEFAULT_QUALITY: 11,
            BROTLI_MIN_WINDOW_BITS: 10,
            BROTLI_MAX_WINDOW_BITS: 24,
            BROTLI_LARGE_MAX_WINDOW_BITS: 30,
            BROTLI_DEFAULT_WINDOW: 22,
            BROTLI_MIN_INPUT_BLOCK_BITS: 16,
            BROTLI_MAX_INPUT_BLOCK_BITS: 24,
            BROTLI_PARAM_MODE: 0,
            BROTLI_PARAM_QUALITY: 1,
            BROTLI_PARAM_LGWIN: 2,
            BROTLI_PARAM_LGBLOCK: 3,
            BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
            BROTLI_PARAM_SIZE_HINT: 5,
            BROTLI_PARAM_LARGE_WINDOW: 6,
            BROTLI_PARAM_NPOSTFIX: 7,
            BROTLI_PARAM_NDIRECT: 8,
            BROTLI_DECODER_RESULT_ERROR: 0,
            BROTLI_DECODER_RESULT_SUCCESS: 1,
            BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
            BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
            BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
            BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
            BROTLI_DECODER_NO_ERROR: 0,
            BROTLI_DECODER_SUCCESS: 1,
            BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
            BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
            BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
            BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
            BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
            BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
            BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
            BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
            BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
            BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
            BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
            BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
            BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
            BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
            BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
            BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
            BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
            BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
            BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
            BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
            BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
            BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
            BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
            BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
            BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
            BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
            BROTLI_DECODER_ERROR_UNREACHABLE: -31,
          },
          realZlibConstants,
        ),
      );
    },
    3486: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const assert = __nccwpck_require__(9491);
      const Buffer = __nccwpck_require__(4300).Buffer;
      const realZlib = __nccwpck_require__(9796);
      const constants = (exports.constants = __nccwpck_require__(6769));
      const Minipass = __nccwpck_require__(7557);
      const OriginalBufferConcat = Buffer.concat;
      const _superWrite = Symbol("_superWrite");
      class ZlibError extends Error {
        constructor(err) {
          super("zlib: " + err.message);
          this.code = err.code;
          this.errno = err.errno;
          if (!this.code) this.code = "ZLIB_ERROR";
          this.message = "zlib: " + err.message;
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "ZlibError";
        }
      }
      const _opts = Symbol("opts");
      const _flushFlag = Symbol("flushFlag");
      const _finishFlushFlag = Symbol("finishFlushFlag");
      const _fullFlushFlag = Symbol("fullFlushFlag");
      const _handle = Symbol("handle");
      const _onError = Symbol("onError");
      const _sawError = Symbol("sawError");
      const _level = Symbol("level");
      const _strategy = Symbol("strategy");
      const _ended = Symbol("ended");
      const _defaultFullFlush = Symbol("_defaultFullFlush");
      class ZlibBase extends Minipass {
        constructor(opts, mode) {
          if (!opts || typeof opts !== "object")
            throw new TypeError("invalid options for ZlibBase constructor");
          super(opts);
          this[_sawError] = false;
          this[_ended] = false;
          this[_opts] = opts;
          this[_flushFlag] = opts.flush;
          this[_finishFlushFlag] = opts.finishFlush;
          try {
            this[_handle] = new realZlib[mode](opts);
          } catch (er) {
            throw new ZlibError(er);
          }
          this[_onError] = (err) => {
            if (this[_sawError]) return;
            this[_sawError] = true;
            this.close();
            this.emit("error", err);
          };
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
          this.once("end", () => this.close);
        }
        close() {
          if (this[_handle]) {
            this[_handle].close();
            this[_handle] = null;
            this.emit("close");
          }
        }
        reset() {
          if (!this[_sawError]) {
            assert(this[_handle], "zlib binding closed");
            return this[_handle].reset();
          }
        }
        flush(flushFlag) {
          if (this.ended) return;
          if (typeof flushFlag !== "number") flushFlag = this[_fullFlushFlag];
          this.write(
            Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }),
          );
        }
        end(chunk, encoding, cb) {
          if (chunk) this.write(chunk, encoding);
          this.flush(this[_finishFlushFlag]);
          this[_ended] = true;
          return super.end(null, null, cb);
        }
        get ended() {
          return this[_ended];
        }
        write(chunk, encoding, cb) {
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
          if (this[_sawError]) return;
          assert(this[_handle], "zlib binding closed");
          const nativeHandle = this[_handle]._handle;
          const originalNativeClose = nativeHandle.close;
          nativeHandle.close = () => {};
          const originalClose = this[_handle].close;
          this[_handle].close = () => {};
          Buffer.concat = (args) => args;
          let result;
          try {
            const flushFlag =
              typeof chunk[_flushFlag] === "number"
                ? chunk[_flushFlag]
                : this[_flushFlag];
            result = this[_handle]._processChunk(chunk, flushFlag);
            Buffer.concat = OriginalBufferConcat;
          } catch (err) {
            Buffer.concat = OriginalBufferConcat;
            this[_onError](new ZlibError(err));
          } finally {
            if (this[_handle]) {
              this[_handle]._handle = nativeHandle;
              nativeHandle.close = originalNativeClose;
              this[_handle].close = originalClose;
              this[_handle].removeAllListeners("error");
            }
          }
          if (this[_handle])
            this[_handle].on("error", (er) =>
              this[_onError](new ZlibError(er)),
            );
          let writeReturn;
          if (result) {
            if (Array.isArray(result) && result.length > 0) {
              writeReturn = this[_superWrite](Buffer.from(result[0]));
              for (let i = 1; i < result.length; i++) {
                writeReturn = this[_superWrite](result[i]);
              }
            } else {
              writeReturn = this[_superWrite](Buffer.from(result));
            }
          }
          if (cb) cb();
          return writeReturn;
        }
        [_superWrite](data) {
          return super.write(data);
        }
      }
      class Zlib extends ZlibBase {
        constructor(opts, mode) {
          opts = opts || {};
          opts.flush = opts.flush || constants.Z_NO_FLUSH;
          opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
          super(opts, mode);
          this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
          this[_level] = opts.level;
          this[_strategy] = opts.strategy;
        }
        params(level, strategy) {
          if (this[_sawError]) return;
          if (!this[_handle])
            throw new Error("cannot switch params when binding is closed");
          if (!this[_handle].params)
            throw new Error("not supported in this implementation");
          if (this[_level] !== level || this[_strategy] !== strategy) {
            this.flush(constants.Z_SYNC_FLUSH);
            assert(this[_handle], "zlib binding closed");
            const origFlush = this[_handle].flush;
            this[_handle].flush = (flushFlag, cb) => {
              this.flush(flushFlag);
              cb();
            };
            try {
              this[_handle].params(level, strategy);
            } finally {
              this[_handle].flush = origFlush;
            }
            if (this[_handle]) {
              this[_level] = level;
              this[_strategy] = strategy;
            }
          }
        }
      }
      class Deflate extends Zlib {
        constructor(opts) {
          super(opts, "Deflate");
        }
      }
      class Inflate extends Zlib {
        constructor(opts) {
          super(opts, "Inflate");
        }
      }
      const _portable = Symbol("_portable");
      class Gzip extends Zlib {
        constructor(opts) {
          super(opts, "Gzip");
          this[_portable] = opts && !!opts.portable;
        }
        [_superWrite](data) {
          if (!this[_portable]) return super[_superWrite](data);
          this[_portable] = false;
          data[9] = 255;
          return super[_superWrite](data);
        }
      }
      class Gunzip extends Zlib {
        constructor(opts) {
          super(opts, "Gunzip");
        }
      }
      class DeflateRaw extends Zlib {
        constructor(opts) {
          super(opts, "DeflateRaw");
        }
      }
      class InflateRaw extends Zlib {
        constructor(opts) {
          super(opts, "InflateRaw");
        }
      }
      class Unzip extends Zlib {
        constructor(opts) {
          super(opts, "Unzip");
        }
      }
      class Brotli extends ZlibBase {
        constructor(opts, mode) {
          opts = opts || {};
          opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
          opts.finishFlush =
            opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
          super(opts, mode);
          this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
        }
      }
      class BrotliCompress extends Brotli {
        constructor(opts) {
          super(opts, "BrotliCompress");
        }
      }
      class BrotliDecompress extends Brotli {
        constructor(opts) {
          super(opts, "BrotliDecompress");
        }
      }
      exports.Deflate = Deflate;
      exports.Inflate = Inflate;
      exports.Gzip = Gzip;
      exports.Gunzip = Gunzip;
      exports.DeflateRaw = DeflateRaw;
      exports.InflateRaw = InflateRaw;
      exports.Unzip = Unzip;
      if (typeof realZlib.BrotliCompress === "function") {
        exports.BrotliCompress = BrotliCompress;
        exports.BrotliDecompress = BrotliDecompress;
      } else {
        exports.BrotliCompress = exports.BrotliDecompress = class {
          constructor() {
            throw new Error(
              "Brotli is not supported in this version of Node.js",
            );
          }
        };
      }
    },
    7557: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    900: (module) => {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function (val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" +
            JSON.stringify(val),
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match =
          /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str,
          );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return undefined;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    },
    5385: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /*!
       * negotiator
       * Copyright(c) 2012 Federico Romero
       * Copyright(c) 2012-2014 Isaac Z. Schlueter
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */ var preferredCharsets = __nccwpck_require__(9296);
      var preferredEncodings = __nccwpck_require__(5297);
      var preferredLanguages = __nccwpck_require__(9722);
      var preferredMediaTypes = __nccwpck_require__(2563);
      module.exports = Negotiator;
      module.exports.Negotiator = Negotiator;
      function Negotiator(request) {
        if (!(this instanceof Negotiator)) {
          return new Negotiator(request);
        }
        this.request = request;
      }
      Negotiator.prototype.charset = function charset(available) {
        var set = this.charsets(available);
        return set && set[0];
      };
      Negotiator.prototype.charsets = function charsets(available) {
        return preferredCharsets(
          this.request.headers["accept-charset"],
          available,
        );
      };
      Negotiator.prototype.encoding = function encoding(available, preferred) {
        var set = this.encodings(available, preferred);
        return set && set[0];
      };
      Negotiator.prototype.encodings = function encodings(
        available,
        preferred,
      ) {
        return preferredEncodings(
          this.request.headers["accept-encoding"],
          available,
          preferred,
        );
      };
      Negotiator.prototype.language = function language(available) {
        var set = this.languages(available);
        return set && set[0];
      };
      Negotiator.prototype.languages = function languages(available) {
        return preferredLanguages(
          this.request.headers["accept-language"],
          available,
        );
      };
      Negotiator.prototype.mediaType = function mediaType(available) {
        var set = this.mediaTypes(available);
        return set && set[0];
      };
      Negotiator.prototype.mediaTypes = function mediaTypes(available) {
        return preferredMediaTypes(this.request.headers.accept, available);
      };
      Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
      Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
      Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
      Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
      Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
      Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
      Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
      Negotiator.prototype.preferredMediaTypes =
        Negotiator.prototype.mediaTypes;
    },
    9296: (module) => {
      "use strict";
      module.exports = preferredCharsets;
      module.exports.preferredCharsets = preferredCharsets;
      var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
      function parseAcceptCharset(accept) {
        var accepts = accept.split(",");
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var charset = parseCharset(accepts[i].trim(), i);
          if (charset) {
            accepts[j++] = charset;
          }
        }
        accepts.length = j;
        return accepts;
      }
      function parseCharset(str, i) {
        var match = simpleCharsetRegExp.exec(str);
        if (!match) return null;
        var charset = match[1];
        var q = 1;
        if (match[2]) {
          var params = match[2].split(";");
          for (var j = 0; j < params.length; j++) {
            var p = params[j].trim().split("=");
            if (p[0] === "q") {
              q = parseFloat(p[1]);
              break;
            }
          }
        }
        return { charset, q, i };
      }
      function getCharsetPriority(charset, accepted, index) {
        var priority = { o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(charset, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(charset, spec, index) {
        var s = 0;
        if (spec.charset.toLowerCase() === charset.toLowerCase()) {
          s |= 1;
        } else if (spec.charset !== "*") {
          return null;
        }
        return { i: index, o: spec.i, q: spec.q, s };
      }
      function preferredCharsets(accept, provided) {
        var accepts = parseAcceptCharset(
          accept === undefined ? "*" : accept || "",
        );
        if (!provided) {
          return accepts
            .filter(isQuality)
            .sort(compareSpecs)
            .map(getFullCharset);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getCharsetPriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(compareSpecs)
          .map(function getCharset(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
      }
      function getFullCharset(spec) {
        return spec.charset;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
    },
    5297: (module) => {
      "use strict";
      module.exports = preferredEncodings;
      module.exports.preferredEncodings = preferredEncodings;
      var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
      function parseAcceptEncoding(accept) {
        var accepts = accept.split(",");
        var hasIdentity = false;
        var minQuality = 1;
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var encoding = parseEncoding(accepts[i].trim(), i);
          if (encoding) {
            accepts[j++] = encoding;
            hasIdentity = hasIdentity || specify("identity", encoding);
            minQuality = Math.min(minQuality, encoding.q || 1);
          }
        }
        if (!hasIdentity) {
          accepts[j++] = { encoding: "identity", q: minQuality, i };
        }
        accepts.length = j;
        return accepts;
      }
      function parseEncoding(str, i) {
        var match = simpleEncodingRegExp.exec(str);
        if (!match) return null;
        var encoding = match[1];
        var q = 1;
        if (match[2]) {
          var params = match[2].split(";");
          for (var j = 0; j < params.length; j++) {
            var p = params[j].trim().split("=");
            if (p[0] === "q") {
              q = parseFloat(p[1]);
              break;
            }
          }
        }
        return { encoding, q, i };
      }
      function getEncodingPriority(encoding, accepted, index) {
        var priority = { encoding, o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(encoding, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(encoding, spec, index) {
        var s = 0;
        if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
          s |= 1;
        } else if (spec.encoding !== "*") {
          return null;
        }
        return { encoding, i: index, o: spec.i, q: spec.q, s };
      }
      function preferredEncodings(accept, provided, preferred) {
        var accepts = parseAcceptEncoding(accept || "");
        var comparator = preferred
          ? function comparator(a, b) {
              if (a.q !== b.q) {
                return b.q - a.q;
              }
              var aPreferred = preferred.indexOf(a.encoding);
              var bPreferred = preferred.indexOf(b.encoding);
              if (aPreferred === -1 && bPreferred === -1) {
                return b.s - a.s || a.o - b.o || a.i - b.i;
              }
              if (aPreferred !== -1 && bPreferred !== -1) {
                return aPreferred - bPreferred;
              }
              return aPreferred === -1 ? 1 : -1;
            }
          : compareSpecs;
        if (!provided) {
          return accepts
            .filter(isQuality)
            .sort(comparator)
            .map(getFullEncoding);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getEncodingPriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(comparator)
          .map(function getEncoding(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
      }
      function getFullEncoding(spec) {
        return spec.encoding;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
    },
    9722: (module) => {
      "use strict";
      module.exports = preferredLanguages;
      module.exports.preferredLanguages = preferredLanguages;
      var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
      function parseAcceptLanguage(accept) {
        var accepts = accept.split(",");
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var language = parseLanguage(accepts[i].trim(), i);
          if (language) {
            accepts[j++] = language;
          }
        }
        accepts.length = j;
        return accepts;
      }
      function parseLanguage(str, i) {
        var match = simpleLanguageRegExp.exec(str);
        if (!match) return null;
        var prefix = match[1];
        var suffix = match[2];
        var full = prefix;
        if (suffix) full += "-" + suffix;
        var q = 1;
        if (match[3]) {
          var params = match[3].split(";");
          for (var j = 0; j < params.length; j++) {
            var p = params[j].split("=");
            if (p[0] === "q") q = parseFloat(p[1]);
          }
        }
        return { prefix, suffix, q, i, full };
      }
      function getLanguagePriority(language, accepted, index) {
        var priority = { o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(language, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(language, spec, index) {
        var p = parseLanguage(language);
        if (!p) return null;
        var s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
          s |= 4;
        } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
          s |= 2;
        } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
          s |= 1;
        } else if (spec.full !== "*") {
          return null;
        }
        return { i: index, o: spec.i, q: spec.q, s };
      }
      function preferredLanguages(accept, provided) {
        var accepts = parseAcceptLanguage(
          accept === undefined ? "*" : accept || "",
        );
        if (!provided) {
          return accepts
            .filter(isQuality)
            .sort(compareSpecs)
            .map(getFullLanguage);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getLanguagePriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(compareSpecs)
          .map(function getLanguage(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
      }
      function getFullLanguage(spec) {
        return spec.full;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
    },
    2563: (module) => {
      "use strict";
      module.exports = preferredMediaTypes;
      module.exports.preferredMediaTypes = preferredMediaTypes;
      var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
      function parseAccept(accept) {
        var accepts = splitMediaTypes(accept);
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var mediaType = parseMediaType(accepts[i].trim(), i);
          if (mediaType) {
            accepts[j++] = mediaType;
          }
        }
        accepts.length = j;
        return accepts;
      }
      function parseMediaType(str, i) {
        var match = simpleMediaTypeRegExp.exec(str);
        if (!match) return null;
        var params = Object.create(null);
        var q = 1;
        var subtype = match[2];
        var type = match[1];
        if (match[3]) {
          var kvps = splitParameters(match[3]).map(splitKeyValuePair);
          for (var j = 0; j < kvps.length; j++) {
            var pair = kvps[j];
            var key = pair[0].toLowerCase();
            var val = pair[1];
            var value =
              val && val[0] === '"' && val[val.length - 1] === '"'
                ? val.slice(1, -1)
                : val;
            if (key === "q") {
              q = parseFloat(value);
              break;
            }
            params[key] = value;
          }
        }
        return { type, subtype, params, q, i };
      }
      function getMediaTypePriority(type, accepted, index) {
        var priority = { o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(type, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(type, spec, index) {
        var p = parseMediaType(type);
        var s = 0;
        if (!p) {
          return null;
        }
        if (spec.type.toLowerCase() == p.type.toLowerCase()) {
          s |= 4;
        } else if (spec.type != "*") {
          return null;
        }
        if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
          s |= 2;
        } else if (spec.subtype != "*") {
          return null;
        }
        var keys = Object.keys(spec.params);
        if (keys.length > 0) {
          if (
            keys.every(function (k) {
              return (
                spec.params[k] == "*" ||
                (spec.params[k] || "").toLowerCase() ==
                  (p.params[k] || "").toLowerCase()
              );
            })
          ) {
            s |= 1;
          } else {
            return null;
          }
        }
        return { i: index, o: spec.i, q: spec.q, s };
      }
      function preferredMediaTypes(accept, provided) {
        var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
          return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getMediaTypePriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(compareSpecs)
          .map(function getType(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
      }
      function getFullType(spec) {
        return spec.type + "/" + spec.subtype;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
      function quoteCount(string) {
        var count = 0;
        var index = 0;
        while ((index = string.indexOf('"', index)) !== -1) {
          count++;
          index++;
        }
        return count;
      }
      function splitKeyValuePair(str) {
        var index = str.indexOf("=");
        var key;
        var val;
        if (index === -1) {
          key = str;
        } else {
          key = str.slice(0, index);
          val = str.slice(index + 1);
        }
        return [key, val];
      }
      function splitMediaTypes(accept) {
        var accepts = accept.split(",");
        for (var i = 1, j = 0; i < accepts.length; i++) {
          if (quoteCount(accepts[j]) % 2 == 0) {
            accepts[++j] = accepts[i];
          } else {
            accepts[j] += "," + accepts[i];
          }
        }
        accepts.length = j + 1;
        return accepts;
      }
      function splitParameters(str) {
        var parameters = str.split(";");
        for (var i = 1, j = 0; i < parameters.length; i++) {
          if (quoteCount(parameters[j]) % 2 == 0) {
            parameters[++j] = parameters[i];
          } else {
            parameters[j] += ";" + parameters[i];
          }
        }
        parameters.length = j + 1;
        for (var i = 0; i < parameters.length; i++) {
          parameters[i] = parameters[i].trim();
        }
        return parameters;
      }
    },
    6976: (module) => {
      module.exports = extractDescription;
      function extractDescription(d) {
        if (!d) {
          return;
        }
        if (d === "ERROR: No README data found!") {
          return;
        }
        d = d.trim().split("\n");
        let s = 0;
        while (d[s] && d[s].trim().match(/^(#|$)/)) {
          s++;
        }
        const l = d.length;
        let e = s + 1;
        while (e < l && d[e].trim()) {
          e++;
        }
        return d.slice(s, e).join(" ").trim();
      }
    },
    3492: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isValidSemver = __nccwpck_require__(9601);
      var cleanSemver = __nccwpck_require__(8848);
      var validateLicense = __nccwpck_require__(2524);
      var hostedGitInfo = __nccwpck_require__(167);
      var moduleBuiltin = __nccwpck_require__(2033);
      var depTypes = [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
      ];
      var extractDescription = __nccwpck_require__(6976);
      var url = __nccwpck_require__(7310);
      var typos = __nccwpck_require__(1947);
      var isEmail = (str) =>
        str.includes("@") && str.indexOf("@") < str.lastIndexOf(".");
      module.exports = {
        warn: function () {},
        fixRepositoryField: function (data) {
          if (data.repositories) {
            this.warn("repositories");
            data.repository = data.repositories[0];
          }
          if (!data.repository) {
            return this.warn("missingRepository");
          }
          if (typeof data.repository === "string") {
            data.repository = { type: "git", url: data.repository };
          }
          var r = data.repository.url || "";
          if (r) {
            var hosted = hostedGitInfo.fromUrl(r);
            if (hosted) {
              r = data.repository.url =
                hosted.getDefaultRepresentation() === "shortcut"
                  ? hosted.https()
                  : hosted.toString();
            }
          }
          if (r.match(/github.com\/[^/]+\/[^/]+\.git\.git$/)) {
            this.warn("brokenGitUrl", r);
          }
        },
        fixTypos: function (data) {
          Object.keys(typos.topLevel).forEach(function (d) {
            if (Object.prototype.hasOwnProperty.call(data, d)) {
              this.warn("typo", d, typos.topLevel[d]);
            }
          }, this);
        },
        fixScriptsField: function (data) {
          if (!data.scripts) {
            return;
          }
          if (typeof data.scripts !== "object") {
            this.warn("nonObjectScripts");
            delete data.scripts;
            return;
          }
          Object.keys(data.scripts).forEach(function (k) {
            if (typeof data.scripts[k] !== "string") {
              this.warn("nonStringScript");
              delete data.scripts[k];
            } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
              this.warn("typo", k, typos.script[k], "scripts");
            }
          }, this);
        },
        fixFilesField: function (data) {
          var files = data.files;
          if (files && !Array.isArray(files)) {
            this.warn("nonArrayFiles");
            delete data.files;
          } else if (data.files) {
            data.files = data.files.filter(function (file) {
              if (!file || typeof file !== "string") {
                this.warn("invalidFilename", file);
                return false;
              } else {
                return true;
              }
            }, this);
          }
        },
        fixBinField: function (data) {
          if (!data.bin) {
            return;
          }
          if (typeof data.bin === "string") {
            var b = {};
            var match;
            if ((match = data.name.match(/^@[^/]+[/](.*)$/))) {
              b[match[1]] = data.bin;
            } else {
              b[data.name] = data.bin;
            }
            data.bin = b;
          }
        },
        fixManField: function (data) {
          if (!data.man) {
            return;
          }
          if (typeof data.man === "string") {
            data.man = [data.man];
          }
        },
        fixBundleDependenciesField: function (data) {
          var bdd = "bundledDependencies";
          var bd = "bundleDependencies";
          if (data[bdd] && !data[bd]) {
            data[bd] = data[bdd];
            delete data[bdd];
          }
          if (data[bd] && !Array.isArray(data[bd])) {
            this.warn("nonArrayBundleDependencies");
            delete data[bd];
          } else if (data[bd]) {
            data[bd] = data[bd].filter(function (filtered) {
              if (!filtered || typeof filtered !== "string") {
                this.warn("nonStringBundleDependency", filtered);
                return false;
              } else {
                if (!data.dependencies) {
                  data.dependencies = {};
                }
                if (
                  !Object.prototype.hasOwnProperty.call(
                    data.dependencies,
                    filtered,
                  )
                ) {
                  this.warn("nonDependencyBundleDependency", filtered);
                  data.dependencies[filtered] = "*";
                }
                return true;
              }
            }, this);
          }
        },
        fixDependencies: function (data) {
          objectifyDeps(data, this.warn);
          addOptionalDepsToDeps(data, this.warn);
          this.fixBundleDependenciesField(data);
          ["dependencies", "devDependencies"].forEach(function (deps) {
            if (!(deps in data)) {
              return;
            }
            if (!data[deps] || typeof data[deps] !== "object") {
              this.warn("nonObjectDependencies", deps);
              delete data[deps];
              return;
            }
            Object.keys(data[deps]).forEach(function (d) {
              var r = data[deps][d];
              if (typeof r !== "string") {
                this.warn("nonStringDependency", d, JSON.stringify(r));
                delete data[deps][d];
              }
              var hosted = hostedGitInfo.fromUrl(data[deps][d]);
              if (hosted) {
                data[deps][d] = hosted.toString();
              }
            }, this);
          }, this);
        },
        fixModulesField: function (data) {
          if (data.modules) {
            this.warn("deprecatedModules");
            delete data.modules;
          }
        },
        fixKeywordsField: function (data) {
          if (typeof data.keywords === "string") {
            data.keywords = data.keywords.split(/,\s+/);
          }
          if (data.keywords && !Array.isArray(data.keywords)) {
            delete data.keywords;
            this.warn("nonArrayKeywords");
          } else if (data.keywords) {
            data.keywords = data.keywords.filter(function (kw) {
              if (typeof kw !== "string" || !kw) {
                this.warn("nonStringKeyword");
                return false;
              } else {
                return true;
              }
            }, this);
          }
        },
        fixVersionField: function (data, strict) {
          var loose = !strict;
          if (!data.version) {
            data.version = "";
            return true;
          }
          if (!isValidSemver(data.version, loose)) {
            throw new Error('Invalid version: "' + data.version + '"');
          }
          data.version = cleanSemver(data.version, loose);
          return true;
        },
        fixPeople: function (data) {
          modifyPeople(data, unParsePerson);
          modifyPeople(data, parsePerson);
        },
        fixNameField: function (data, options) {
          if (typeof options === "boolean") {
            options = { strict: options };
          } else if (typeof options === "undefined") {
            options = {};
          }
          var strict = options.strict;
          if (!data.name && !strict) {
            data.name = "";
            return;
          }
          if (typeof data.name !== "string") {
            throw new Error("name field must be a string.");
          }
          if (!strict) {
            data.name = data.name.trim();
          }
          ensureValidName(data.name, strict, options.allowLegacyCase);
          if (moduleBuiltin.builtinModules.includes(data.name)) {
            this.warn("conflictingName", data.name);
          }
        },
        fixDescriptionField: function (data) {
          if (data.description && typeof data.description !== "string") {
            this.warn("nonStringDescription");
            delete data.description;
          }
          if (data.readme && !data.description) {
            data.description = extractDescription(data.readme);
          }
          if (data.description === undefined) {
            delete data.description;
          }
          if (!data.description) {
            this.warn("missingDescription");
          }
        },
        fixReadmeField: function (data) {
          if (!data.readme) {
            this.warn("missingReadme");
            data.readme = "ERROR: No README data found!";
          }
        },
        fixBugsField: function (data) {
          if (!data.bugs && data.repository && data.repository.url) {
            var hosted = hostedGitInfo.fromUrl(data.repository.url);
            if (hosted && hosted.bugs()) {
              data.bugs = { url: hosted.bugs() };
            }
          } else if (data.bugs) {
            if (typeof data.bugs === "string") {
              if (isEmail(data.bugs)) {
                data.bugs = { email: data.bugs };
              } else if (url.parse(data.bugs).protocol) {
                data.bugs = { url: data.bugs };
              } else {
                this.warn("nonEmailUrlBugsString");
              }
            } else {
              bugsTypos(data.bugs, this.warn);
              var oldBugs = data.bugs;
              data.bugs = {};
              if (oldBugs.url) {
                if (
                  typeof oldBugs.url === "string" &&
                  url.parse(oldBugs.url).protocol
                ) {
                  data.bugs.url = oldBugs.url;
                } else {
                  this.warn("nonUrlBugsUrlField");
                }
              }
              if (oldBugs.email) {
                if (
                  typeof oldBugs.email === "string" &&
                  isEmail(oldBugs.email)
                ) {
                  data.bugs.email = oldBugs.email;
                } else {
                  this.warn("nonEmailBugsEmailField");
                }
              }
            }
            if (!data.bugs.email && !data.bugs.url) {
              delete data.bugs;
              this.warn("emptyNormalizedBugs");
            }
          }
        },
        fixHomepageField: function (data) {
          if (!data.homepage && data.repository && data.repository.url) {
            var hosted = hostedGitInfo.fromUrl(data.repository.url);
            if (hosted && hosted.docs()) {
              data.homepage = hosted.docs();
            }
          }
          if (!data.homepage) {
            return;
          }
          if (typeof data.homepage !== "string") {
            this.warn("nonUrlHomepage");
            return delete data.homepage;
          }
          if (!url.parse(data.homepage).protocol) {
            data.homepage = "http://" + data.homepage;
          }
        },
        fixLicenseField: function (data) {
          const license = data.license || data.licence;
          if (!license) {
            return this.warn("missingLicense");
          }
          if (
            typeof license !== "string" ||
            license.length < 1 ||
            license.trim() === ""
          ) {
            return this.warn("invalidLicense");
          }
          if (!validateLicense(license).validForNewPackages) {
            return this.warn("invalidLicense");
          }
        },
      };
      function isValidScopedPackageName(spec) {
        if (spec.charAt(0) !== "@") {
          return false;
        }
        var rest = spec.slice(1).split("/");
        if (rest.length !== 2) {
          return false;
        }
        return (
          rest[0] &&
          rest[1] &&
          rest[0] === encodeURIComponent(rest[0]) &&
          rest[1] === encodeURIComponent(rest[1])
        );
      }
      function isCorrectlyEncodedName(spec) {
        return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec);
      }
      function ensureValidName(name, strict, allowLegacyCase) {
        if (
          name.charAt(0) === "." ||
          !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) ||
          (strict && !allowLegacyCase && name !== name.toLowerCase()) ||
          name.toLowerCase() === "node_modules" ||
          name.toLowerCase() === "favicon.ico"
        ) {
          throw new Error("Invalid name: " + JSON.stringify(name));
        }
      }
      function modifyPeople(data, fn) {
        if (data.author) {
          data.author = fn(data.author);
        }
        ["maintainers", "contributors"].forEach(function (set) {
          if (!Array.isArray(data[set])) {
            return;
          }
          data[set] = data[set].map(fn);
        });
        return data;
      }
      function unParsePerson(person) {
        if (typeof person === "string") {
          return person;
        }
        var name = person.name || "";
        var u = person.url || person.web;
        var wrappedUrl = u ? " (" + u + ")" : "";
        var e = person.email || person.mail;
        var wrappedEmail = e ? " <" + e + ">" : "";
        return name + wrappedEmail + wrappedUrl;
      }
      function parsePerson(person) {
        if (typeof person !== "string") {
          return person;
        }
        var matchedName = person.match(/^([^(<]+)/);
        var matchedUrl = person.match(/\(([^()]+)\)/);
        var matchedEmail = person.match(/<([^<>]+)>/);
        var obj = {};
        if (matchedName && matchedName[0].trim()) {
          obj.name = matchedName[0].trim();
        }
        if (matchedEmail) {
          obj.email = matchedEmail[1];
        }
        if (matchedUrl) {
          obj.url = matchedUrl[1];
        }
        return obj;
      }
      function addOptionalDepsToDeps(data) {
        var o = data.optionalDependencies;
        if (!o) {
          return;
        }
        var d = data.dependencies || {};
        Object.keys(o).forEach(function (k) {
          d[k] = o[k];
        });
        data.dependencies = d;
      }
      function depObjectify(deps, type, warn) {
        if (!deps) {
          return {};
        }
        if (typeof deps === "string") {
          deps = deps.trim().split(/[\n\r\s\t ,]+/);
        }
        if (!Array.isArray(deps)) {
          return deps;
        }
        warn("deprecatedArrayDependencies", type);
        var o = {};
        deps
          .filter(function (d) {
            return typeof d === "string";
          })
          .forEach(function (d) {
            d = d.trim().split(/(:?[@\s><=])/);
            var dn = d.shift();
            var dv = d.join("");
            dv = dv.trim();
            dv = dv.replace(/^@/, "");
            o[dn] = dv;
          });
        return o;
      }
      function objectifyDeps(data, warn) {
        depTypes.forEach(function (type) {
          if (!data[type]) {
            return;
          }
          data[type] = depObjectify(data[type], type, warn);
        });
      }
      function bugsTypos(bugs, warn) {
        if (!bugs) {
          return;
        }
        Object.keys(bugs).forEach(function (k) {
          if (typos.bugs[k]) {
            warn("typo", k, typos.bugs[k], "bugs");
            bugs[typos.bugs[k]] = bugs[k];
            delete bugs[k];
          }
        });
      }
    },
    9671: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var util = __nccwpck_require__(3837);
      var messages = __nccwpck_require__(6271);
      module.exports = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        var warningName = args.shift();
        if (warningName === "typo") {
          return makeTypoWarning.apply(null, args);
        } else {
          var msgTemplate = messages[warningName]
            ? messages[warningName]
            : warningName + ": '%s'";
          args.unshift(msgTemplate);
          return util.format.apply(null, args);
        }
      };
      function makeTypoWarning(providedName, probableName, field) {
        if (field) {
          providedName = field + "['" + providedName + "']";
          probableName = field + "['" + probableName + "']";
        }
        return util.format(messages.typo, providedName, probableName);
      }
    },
    3188: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = normalize;
      var fixer = __nccwpck_require__(3492);
      normalize.fixer = fixer;
      var makeWarning = __nccwpck_require__(9671);
      var fieldsToFix = [
        "name",
        "version",
        "description",
        "repository",
        "modules",
        "scripts",
        "files",
        "bin",
        "man",
        "bugs",
        "keywords",
        "readme",
        "homepage",
        "license",
      ];
      var otherThingsToFix = ["dependencies", "people", "typos"];
      var thingsToFix = fieldsToFix.map(function (fieldName) {
        return ucFirst(fieldName) + "Field";
      });
      thingsToFix = thingsToFix.concat(otherThingsToFix);
      function normalize(data, warn, strict) {
        if (warn === true) {
          warn = null;
          strict = true;
        }
        if (!strict) {
          strict = false;
        }
        if (!warn || data.private) {
          warn = function () {};
        }
        if (
          data.scripts &&
          data.scripts.install === "node-gyp rebuild" &&
          !data.scripts.preinstall
        ) {
          data.gypfile = true;
        }
        fixer.warn = function () {
          warn(makeWarning.apply(null, arguments));
        };
        thingsToFix.forEach(function (thingName) {
          fixer["fix" + ucFirst(thingName)](data, strict);
        });
        data._id = data.name + "@" + data.version;
      }
      function ucFirst(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
    },
    680: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      module.exports = npa;
      module.exports.resolve = resolve;
      module.exports.toPurl = toPurl;
      module.exports.Result = Result;
      const { URL } = __nccwpck_require__(7310);
      const HostedGit = __nccwpck_require__(167);
      const semver = __nccwpck_require__(4541);
      const path = global.FAKE_WINDOWS
        ? __nccwpck_require__(1017).win32
        : __nccwpck_require__(1017);
      const validatePackageName = __nccwpck_require__(4006);
      const { homedir } = __nccwpck_require__(2037);
      const { log } = __nccwpck_require__(6528);
      const isWindows = process.platform === "win32" || global.FAKE_WINDOWS;
      const hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
      const isURL = /^(?:git[+])?[a-z]+:/i;
      const isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i;
      const isFilename = /[.](?:tgz|tar.gz|tar)$/i;
      function npa(arg, where) {
        let name;
        let spec;
        if (typeof arg === "object") {
          if (arg instanceof Result && (!where || where === arg.where)) {
            return arg;
          } else if (arg.name && arg.rawSpec) {
            return npa.resolve(arg.name, arg.rawSpec, where || arg.where);
          } else {
            return npa(arg.raw, where || arg.where);
          }
        }
        const nameEndsAt =
          arg[0] === "@" ? arg.slice(1).indexOf("@") + 1 : arg.indexOf("@");
        const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
        if (isURL.test(arg)) {
          spec = arg;
        } else if (isGit.test(arg)) {
          spec = `git+ssh://${arg}`;
        } else if (
          namePart[0] !== "@" &&
          (hasSlashes.test(namePart) || isFilename.test(namePart))
        ) {
          spec = arg;
        } else if (nameEndsAt > 0) {
          name = namePart;
          spec = arg.slice(nameEndsAt + 1) || "*";
        } else {
          const valid = validatePackageName(arg);
          if (valid.validForOldPackages) {
            name = arg;
            spec = "*";
          } else {
            spec = arg;
          }
        }
        return resolve(name, spec, where, arg);
      }
      const isFilespec = isWindows
        ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/
        : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
      function resolve(name, spec, where, arg) {
        const res = new Result({
          raw: arg,
          name,
          rawSpec: spec,
          fromArgument: arg != null,
        });
        if (name) {
          res.setName(name);
        }
        if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {
          return fromFile(res, where);
        } else if (spec && /^npm:/i.test(spec)) {
          return fromAlias(res, where);
        }
        const hosted = HostedGit.fromUrl(spec, {
          noGitPlus: true,
          noCommittish: true,
        });
        if (hosted) {
          return fromHostedGit(res, hosted);
        } else if (spec && isURL.test(spec)) {
          return fromURL(res);
        } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {
          return fromFile(res, where);
        } else {
          return fromRegistry(res);
        }
      }
      const defaultRegistry = "https://registry.npmjs.org";
      function toPurl(arg, reg = defaultRegistry) {
        const res = npa(arg);
        if (res.type !== "version") {
          throw invalidPurlType(res.type, res.raw);
        }
        let purl =
          "pkg:npm/" + res.name.replace(/^@/, "%40") + "@" + res.rawSpec;
        if (reg !== defaultRegistry) {
          purl += "?repository_url=" + reg;
        }
        return purl;
      }
      function invalidPackageName(name, valid, raw) {
        const err = new Error(
          `Invalid package name "${name}" of package "${raw}": ${valid.errors.join("; ")}.`,
        );
        err.code = "EINVALIDPACKAGENAME";
        return err;
      }
      function invalidTagName(name, raw) {
        const err = new Error(
          `Invalid tag name "${name}" of package "${raw}": Tags may not have any characters that encodeURIComponent encodes.`,
        );
        err.code = "EINVALIDTAGNAME";
        return err;
      }
      function invalidPurlType(type, raw) {
        const err = new Error(
          `Invalid type "${type}" of package "${raw}": Purl can only be generated for "version" types.`,
        );
        err.code = "EINVALIDPURLTYPE";
        return err;
      }
      function Result(opts) {
        this.type = opts.type;
        this.registry = opts.registry;
        this.where = opts.where;
        if (opts.raw == null) {
          this.raw = opts.name ? opts.name + "@" + opts.rawSpec : opts.rawSpec;
        } else {
          this.raw = opts.raw;
        }
        this.name = undefined;
        this.escapedName = undefined;
        this.scope = undefined;
        this.rawSpec = opts.rawSpec || "";
        this.saveSpec = opts.saveSpec;
        this.fetchSpec = opts.fetchSpec;
        if (opts.name) {
          this.setName(opts.name);
        }
        this.gitRange = opts.gitRange;
        this.gitCommittish = opts.gitCommittish;
        this.gitSubdir = opts.gitSubdir;
        this.hosted = opts.hosted;
      }
      Result.prototype.setName = function (name) {
        const valid = validatePackageName(name);
        if (!valid.validForOldPackages) {
          throw invalidPackageName(name, valid, this.raw);
        }
        this.name = name;
        this.scope =
          name[0] === "@" ? name.slice(0, name.indexOf("/")) : undefined;
        this.escapedName = name.replace("/", "%2f");
        return this;
      };
      Result.prototype.toString = function () {
        const full = [];
        if (this.name != null && this.name !== "") {
          full.push(this.name);
        }
        const spec = this.saveSpec || this.fetchSpec || this.rawSpec;
        if (spec != null && spec !== "") {
          full.push(spec);
        }
        return full.length ? full.join("@") : this.raw;
      };
      Result.prototype.toJSON = function () {
        const result = Object.assign({}, this);
        delete result.hosted;
        return result;
      };
      function setGitAttrs(res, committish) {
        if (!committish) {
          res.gitCommittish = null;
          return;
        }
        for (const part of committish.split("::")) {
          if (!part.includes(":")) {
            if (res.gitRange) {
              throw new Error(
                "cannot override existing semver range with a committish",
              );
            }
            if (res.gitCommittish) {
              throw new Error(
                "cannot override existing committish with a second committish",
              );
            }
            res.gitCommittish = part;
            continue;
          }
          const [name, value] = part.split(":");
          if (name === "semver") {
            if (res.gitCommittish) {
              throw new Error(
                "cannot override existing committish with a semver range",
              );
            }
            if (res.gitRange) {
              throw new Error(
                "cannot override existing semver range with a second semver range",
              );
            }
            res.gitRange = decodeURIComponent(value);
            continue;
          }
          if (name === "path") {
            if (res.gitSubdir) {
              throw new Error(
                "cannot override existing path with a second path",
              );
            }
            res.gitSubdir = `/${value}`;
            continue;
          }
          log.warn("npm-package-arg", `ignoring unknown key "${name}"`);
        }
      }
      function fromFile(res, where) {
        if (!where) {
          where = process.cwd();
        }
        res.type = isFilename.test(res.rawSpec) ? "file" : "directory";
        res.where = where;
        let specUrl;
        let resolvedUrl;
        const prefix = !/^file:/.test(res.rawSpec) ? "file:" : "";
        const rawWithPrefix = prefix + res.rawSpec;
        let rawNoPrefix = rawWithPrefix.replace(/^file:/, "");
        try {
          resolvedUrl = new URL(
            rawWithPrefix,
            `file://${path.resolve(where)}/`,
          );
          specUrl = new URL(rawWithPrefix);
        } catch (originalError) {
          const er = new Error("Invalid file: URL, must comply with RFC 8089");
          throw Object.assign(er, {
            raw: res.rawSpec,
            spec: res,
            where,
            originalError,
          });
        }
        if (resolvedUrl.host && resolvedUrl.host !== "localhost") {
          const rawSpec = res.rawSpec.replace(/^file:\/\//, "file:///");
          resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`);
          specUrl = new URL(rawSpec);
          rawNoPrefix = rawSpec.replace(/^file:/, "");
        }
        if (/^\/{1,3}\.\.?(\/|$)/.test(rawNoPrefix)) {
          const rawSpec = res.rawSpec.replace(/^file:\/{1,3}/, "file:");
          resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`);
          specUrl = new URL(rawSpec);
          rawNoPrefix = rawSpec.replace(/^file:/, "");
        }
        let specPath = decodeURIComponent(specUrl.pathname);
        let resolvedPath = decodeURIComponent(resolvedUrl.pathname);
        if (isWindows) {
          specPath = specPath.replace(/^\/+([a-z]:\/)/i, "$1");
          resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, "$1");
        }
        if (/^\/~(\/|$)/.test(specPath)) {
          res.saveSpec = `file:${specPath.substr(1)}`;
          resolvedPath = path.resolve(homedir(), specPath.substr(3));
        } else if (!path.isAbsolute(rawNoPrefix)) {
          res.saveSpec = `file:${path.relative(where, resolvedPath)}`;
        } else {
          res.saveSpec = `file:${path.resolve(resolvedPath)}`;
        }
        res.fetchSpec = path.resolve(where, resolvedPath);
        return res;
      }
      function fromHostedGit(res, hosted) {
        res.type = "git";
        res.hosted = hosted;
        res.saveSpec = hosted.toString({
          noGitPlus: false,
          noCommittish: false,
        });
        res.fetchSpec =
          hosted.getDefaultRepresentation() === "shortcut"
            ? null
            : hosted.toString();
        setGitAttrs(res, hosted.committish);
        return res;
      }
      function unsupportedURLType(protocol, spec) {
        const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
        err.code = "EUNSUPPORTEDPROTOCOL";
        return err;
      }
      function fromURL(res) {
        let rawSpec = res.rawSpec;
        res.saveSpec = rawSpec;
        if (rawSpec.startsWith("git+ssh:")) {
          const matched = rawSpec.match(
            /^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i,
          );
          if (matched && !matched[1].match(/:[0-9]+\/?.*$/i)) {
            res.type = "git";
            setGitAttrs(res, matched[2]);
            res.fetchSpec = matched[1];
            return res;
          }
        } else if (rawSpec.startsWith("git+file://")) {
          rawSpec = rawSpec.replace(/\\/g, "/");
        }
        const parsedUrl = new URL(rawSpec);
        switch (parsedUrl.protocol) {
          case "git:":
          case "git+http:":
          case "git+https:":
          case "git+rsync:":
          case "git+ftp:":
          case "git+file:":
          case "git+ssh:":
            res.type = "git";
            setGitAttrs(res, parsedUrl.hash.slice(1));
            if (
              parsedUrl.protocol === "git+file:" &&
              /^git\+file:\/\/[a-z]:/i.test(rawSpec)
            ) {
              res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`;
            } else {
              parsedUrl.hash = "";
              res.fetchSpec = parsedUrl.toString();
            }
            if (res.fetchSpec.startsWith("git+")) {
              res.fetchSpec = res.fetchSpec.slice(4);
            }
            break;
          case "http:":
          case "https:":
            res.type = "remote";
            res.fetchSpec = res.saveSpec;
            break;
          default:
            throw unsupportedURLType(parsedUrl.protocol, rawSpec);
        }
        return res;
      }
      function fromAlias(res, where) {
        const subSpec = npa(res.rawSpec.substr(4), where);
        if (subSpec.type === "alias") {
          throw new Error("nested aliases not supported");
        }
        if (!subSpec.registry) {
          throw new Error("aliases only work for registry deps");
        }
        if (!subSpec.name) {
          throw new Error("aliases must have a name");
        }
        res.subSpec = subSpec;
        res.registry = true;
        res.type = "alias";
        res.saveSpec = null;
        res.fetchSpec = null;
        return res;
      }
      function fromRegistry(res) {
        res.registry = true;
        const spec = res.rawSpec.trim();
        res.saveSpec = null;
        res.fetchSpec = spec;
        const version = semver.valid(spec, true);
        const range = semver.validRange(spec, true);
        if (version) {
          res.type = "version";
        } else if (range) {
          res.type = "range";
        } else {
          if (encodeURIComponent(spec) !== spec) {
            throw invalidTagName(spec, res.raw);
          }
          res.type = "tag";
        }
        return res;
      }
    },
    7570: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const fs = __nccwpck_require__(7147);
      const npa = __nccwpck_require__(680);
      const { URL } = __nccwpck_require__(7310);
      const regFromURI = (uri, opts) => {
        const parsed = new URL(uri);
        let regKey = `//${parsed.host}${parsed.pathname}`;
        while (regKey.length > "//".length) {
          const authKey = hasAuth(regKey, opts);
          if (authKey) {
            return { regKey, authKey };
          }
          regKey = regKey.replace(/([^/]+|\/)$/, "");
        }
        return { regKey: false, authKey: null };
      };
      const hasAuth = (regKey, opts) => {
        if (opts[`${regKey}:_authToken`]) {
          return "_authToken";
        }
        if (opts[`${regKey}:_auth`]) {
          return "_auth";
        }
        if (opts[`${regKey}:username`] && opts[`${regKey}:_password`]) {
          return "username";
        }
        if (opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`]) {
          return "certfile";
        }
        return false;
      };
      const sameHost = (a, b) => {
        const parsedA = new URL(a);
        const parsedB = new URL(b);
        return parsedA.host === parsedB.host;
      };
      const getRegistry = (opts) => {
        const { spec } = opts;
        const { scope: specScope, subSpec } = spec ? npa(spec) : {};
        const subSpecScope = subSpec && subSpec.scope;
        const scope = subSpec ? subSpecScope : specScope;
        const scopeReg = scope && opts[`${scope}:registry`];
        return scopeReg || opts.registry;
      };
      const maybeReadFile = (file) => {
        try {
          return fs.readFileSync(file, "utf8");
        } catch (er) {
          if (er.code !== "ENOENT") {
            throw er;
          }
          return null;
        }
      };
      const getAuth = (uri, opts = {}) => {
        const { forceAuth } = opts;
        if (!uri) {
          throw new Error("URI is required");
        }
        const { regKey, authKey } = regFromURI(uri, forceAuth || opts);
        if (forceAuth && !regKey) {
          return new Auth({
            regKey: false,
            authKey: null,
            scopeAuthKey: null,
            token: forceAuth._authToken || forceAuth.token,
            username: forceAuth.username,
            password: forceAuth._password || forceAuth.password,
            auth: forceAuth._auth || forceAuth.auth,
            certfile: forceAuth.certfile,
            keyfile: forceAuth.keyfile,
          });
        }
        if (!regKey) {
          const registry = getRegistry(opts);
          if (registry && uri !== registry && sameHost(uri, registry)) {
            return getAuth(registry, opts);
          } else if (registry !== opts.registry) {
            const { regKey: scopeAuthKey, authKey: _authKey } = regFromURI(
              registry,
              opts,
            );
            return new Auth({
              scopeAuthKey,
              regKey: scopeAuthKey,
              authKey: _authKey,
            });
          }
        }
        const {
          [`${regKey}:_authToken`]: token,
          [`${regKey}:username`]: username,
          [`${regKey}:_password`]: password,
          [`${regKey}:_auth`]: auth,
          [`${regKey}:certfile`]: certfile,
          [`${regKey}:keyfile`]: keyfile,
        } = opts;
        return new Auth({
          scopeAuthKey: null,
          regKey,
          authKey,
          token,
          auth,
          username,
          password,
          certfile,
          keyfile,
        });
      };
      class Auth {
        constructor({
          token,
          auth,
          username,
          password,
          scopeAuthKey,
          certfile,
          keyfile,
          regKey,
          authKey,
        }) {
          this.scopeAuthKey = scopeAuthKey;
          this.regKey = regKey;
          this.authKey = authKey;
          this.token = null;
          this.auth = null;
          this.isBasicAuth = false;
          this.cert = null;
          this.key = null;
          if (token) {
            this.token = token;
          } else if (auth) {
            this.auth = auth;
          } else if (username && password) {
            const p = Buffer.from(password, "base64").toString("utf8");
            this.auth = Buffer.from(`${username}:${p}`, "utf8").toString(
              "base64",
            );
            this.isBasicAuth = true;
          }
          if (certfile && keyfile) {
            const cert = maybeReadFile(certfile, "utf-8");
            const key = maybeReadFile(keyfile, "utf-8");
            if (cert && key) {
              this.cert = cert;
              this.key = key;
            }
          }
        }
      }
      module.exports = getAuth;
    },
    6302: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const errors = __nccwpck_require__(3774);
      const { Response } = __nccwpck_require__(8998);
      const defaultOpts = __nccwpck_require__(305);
      const { log } = __nccwpck_require__(6528);
      const { redact: cleanUrl } = __nccwpck_require__(8217);
      const moreInfoUrl =
        "https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry";
      const checkResponse = async ({
        method,
        uri,
        res,
        startTime,
        auth,
        opts,
      }) => {
        opts = { ...defaultOpts, ...opts };
        if (
          res.headers.has("npm-notice") &&
          !res.headers.has("x-local-cache")
        ) {
          log.notice("", res.headers.get("npm-notice"));
        }
        if (res.status >= 400) {
          logRequest(method, res, startTime);
          if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {
            log.warn(
              "registry",
              `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: ${moreInfoUrl}`,
            );
          }
          return checkErrors(method, res, startTime, opts);
        } else {
          res.body.on("end", () => logRequest(method, res, startTime, opts));
          if (opts.ignoreBody) {
            res.body.resume();
            return new Response(null, res);
          }
          return res;
        }
      };
      module.exports = checkResponse;
      function logRequest(method, res, startTime) {
        const elapsedTime = Date.now() - startTime;
        const attempt = res.headers.get("x-fetch-attempts");
        const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : "";
        const cacheStatus = res.headers.get("x-local-cache-status");
        const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : "";
        const urlStr = cleanUrl(res.url);
        log.http(
          "fetch",
          `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`,
        );
      }
      function checkErrors(method, res, startTime, opts) {
        return res
          .buffer()
          .catch(() => null)
          .then((body) => {
            let parsed = body;
            try {
              parsed = JSON.parse(body.toString("utf8"));
            } catch {}
            if (res.status === 401 && res.headers.get("www-authenticate")) {
              const auth = res.headers
                .get("www-authenticate")
                .split(/,\s*/)
                .map((s) => s.toLowerCase());
              if (auth.indexOf("ipaddress") !== -1) {
                throw new errors.HttpErrorAuthIPAddress(
                  method,
                  res,
                  parsed,
                  opts.spec,
                );
              } else if (auth.indexOf("otp") !== -1) {
                throw new errors.HttpErrorAuthOTP(
                  method,
                  res,
                  parsed,
                  opts.spec,
                );
              } else {
                throw new errors.HttpErrorAuthUnknown(
                  method,
                  res,
                  parsed,
                  opts.spec,
                );
              }
            } else if (
              res.status === 401 &&
              body != null &&
              /one-time pass/.test(body.toString("utf8"))
            ) {
              throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);
            } else {
              throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);
            }
          });
      }
    },
    305: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const pkg = __nccwpck_require__(3684);
      module.exports = {
        maxSockets: 12,
        method: "GET",
        registry: "https://registry.npmjs.org/",
        timeout: 5 * 60 * 1e3,
        strictSSL: true,
        noProxy: process.env.NOPROXY,
        userAgent: `${pkg.name}@${pkg.version}/node@${process.version}+${process.arch} (${process.platform})`,
      };
    },
    3774: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(1041);
      function packageName(href) {
        try {
          let basePath = new URL(href).pathname.slice(1);
          if (!basePath.match(/^-/)) {
            basePath = basePath.split("/");
            var index = basePath.indexOf("_rewrite");
            if (index === -1) {
              index = basePath.length - 1;
            } else {
              index++;
            }
            return decodeURIComponent(basePath[index]);
          }
        } catch {}
      }
      class HttpErrorBase extends Error {
        constructor(method, res, body, spec) {
          super();
          this.name = this.constructor.name;
          this.headers =
            typeof res.headers?.raw === "function"
              ? res.headers.raw()
              : res.headers;
          this.statusCode = res.status;
          this.code = `E${res.status}`;
          this.method = method;
          this.uri = res.url;
          this.body = body;
          this.pkgid = spec ? spec.toString() : packageName(res.url);
          Error.captureStackTrace(this, this.constructor);
        }
      }
      class HttpErrorGeneral extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message = `${res.status} ${res.statusText} - ${this.method.toUpperCase()} ${this.spec || this.uri}${body && body.error ? " - " + body.error : ""}`;
        }
      }
      class HttpErrorAuthOTP extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message = "OTP required for authentication";
          this.code = "EOTP";
        }
      }
      class HttpErrorAuthIPAddress extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message = "Login is not allowed from your IP address";
          this.code = "EAUTHIP";
        }
      }
      class HttpErrorAuthUnknown extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message =
            "Unable to authenticate, need: " +
            res.headers.get("www-authenticate");
        }
      }
      module.exports = {
        HttpErrorBase,
        HttpErrorGeneral,
        HttpErrorAuthOTP,
        HttpErrorAuthIPAddress,
        HttpErrorAuthUnknown,
      };
    },
    5902: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { HttpErrorAuthOTP } = __nccwpck_require__(3774);
      const checkResponse = __nccwpck_require__(6302);
      const getAuth = __nccwpck_require__(7570);
      const fetch = __nccwpck_require__(9525);
      const JSONStream = __nccwpck_require__(965);
      const npa = __nccwpck_require__(680);
      const qs = __nccwpck_require__(3477);
      const url = __nccwpck_require__(7310);
      const zlib = __nccwpck_require__(3486);
      const { Minipass } = __nccwpck_require__(4968);
      const defaultOpts = __nccwpck_require__(305);
      const urlIsValid = (u) => {
        try {
          return !!new url.URL(u);
        } catch (_) {
          return false;
        }
      };
      module.exports = regFetch;
      function regFetch(uri, opts_ = {}) {
        const opts = { ...defaultOpts, ...opts_ };
        const uriValid = urlIsValid(uri);
        let registry = opts.registry || defaultOpts.registry;
        if (!uriValid) {
          registry = opts.registry =
            (opts.spec && pickRegistry(opts.spec, opts)) ||
            opts.registry ||
            registry;
          uri = `${registry.trim().replace(/\/?$/g, "")}/${uri.trim().replace(/^\//, "")}`;
          new url.URL(uri);
        }
        const method = opts.method || "GET";
        const startTime = Date.now();
        const auth = getAuth(uri, opts);
        const headers = getHeaders(uri, auth, opts);
        let body = opts.body;
        const bodyIsStream = Minipass.isStream(body);
        const bodyIsPromise =
          body && typeof body === "object" && typeof body.then === "function";
        if (
          body &&
          !bodyIsStream &&
          !bodyIsPromise &&
          typeof body !== "string" &&
          !Buffer.isBuffer(body)
        ) {
          headers["content-type"] =
            headers["content-type"] || "application/json";
          body = JSON.stringify(body);
        } else if (body && !headers["content-type"]) {
          headers["content-type"] = "application/octet-stream";
        }
        if (opts.gzip) {
          headers["content-encoding"] = "gzip";
          if (bodyIsStream) {
            const gz = new zlib.Gzip();
            body.on("error", (err) => gz.emit("error", err));
            body = body.pipe(gz);
          } else if (!bodyIsPromise) {
            body = new zlib.Gzip().end(body).concat();
          }
        }
        const parsed = new url.URL(uri);
        if (opts.query) {
          const q =
            typeof opts.query === "string" ? qs.parse(opts.query) : opts.query;
          Object.keys(q).forEach((key) => {
            if (q[key] !== undefined) {
              parsed.searchParams.set(key, q[key]);
            }
          });
          uri = url.format(parsed);
        }
        if (parsed.searchParams.get("write") === "true" && method === "GET") {
          opts.offline = false;
          opts.preferOffline = false;
          opts.preferOnline = true;
        }
        const doFetch = async (fetchBody) => {
          const p = fetch(uri, {
            agent: opts.agent,
            algorithms: opts.algorithms,
            body: fetchBody,
            cache: getCacheMode(opts),
            cachePath: opts.cache,
            ca: opts.ca,
            cert: auth.cert || opts.cert,
            headers,
            integrity: opts.integrity,
            key: auth.key || opts.key,
            localAddress: opts.localAddress,
            maxSockets: opts.maxSockets,
            memoize: opts.memoize,
            method,
            noProxy: opts.noProxy,
            proxy: opts.httpsProxy || opts.proxy,
            retry: opts.retry
              ? opts.retry
              : {
                  retries: opts.fetchRetries,
                  factor: opts.fetchRetryFactor,
                  minTimeout: opts.fetchRetryMintimeout,
                  maxTimeout: opts.fetchRetryMaxtimeout,
                },
            strictSSL: opts.strictSSL,
            timeout: opts.timeout || 30 * 1e3,
          }).then((res) =>
            checkResponse({
              method,
              uri,
              res,
              registry,
              startTime,
              auth,
              opts,
            }),
          );
          if (typeof opts.otpPrompt === "function") {
            return p.catch(async (er) => {
              if (er instanceof HttpErrorAuthOTP) {
                let otp;
                try {
                  otp = await opts.otpPrompt();
                } catch (_) {}
                if (!otp) {
                  throw er;
                }
                return regFetch(uri, { ...opts, otp });
              }
              throw er;
            });
          } else {
            return p;
          }
        };
        return Promise.resolve(body).then(doFetch);
      }
      module.exports.getAuth = getAuth;
      module.exports.json = fetchJSON;
      function fetchJSON(uri, opts) {
        return regFetch(uri, opts).then((res) => res.json());
      }
      module.exports.json.stream = fetchJSONStream;
      function fetchJSONStream(uri, jsonPath, opts_ = {}) {
        const opts = { ...defaultOpts, ...opts_ };
        const parser = JSONStream.parse(jsonPath, opts.mapJSON);
        regFetch(uri, opts)
          .then((res) =>
            res.body.on("error", (er) => parser.emit("error", er)).pipe(parser),
          )
          .catch((er) => parser.emit("error", er));
        return parser;
      }
      module.exports.pickRegistry = pickRegistry;
      function pickRegistry(spec, opts = {}) {
        spec = npa(spec);
        let registry =
          spec.scope && opts[spec.scope.replace(/^@?/, "@") + ":registry"];
        if (!registry && opts.scope) {
          registry = opts[opts.scope.replace(/^@?/, "@") + ":registry"];
        }
        if (!registry) {
          registry = opts.registry || defaultOpts.registry;
        }
        return registry;
      }
      function getCacheMode(opts) {
        return opts.offline
          ? "only-if-cached"
          : opts.preferOffline
            ? "force-cache"
            : opts.preferOnline
              ? "no-cache"
              : "default";
      }
      function getHeaders(uri, auth, opts) {
        const headers = Object.assign(
          { "user-agent": opts.userAgent },
          opts.headers || {},
        );
        if (opts.authType) {
          headers["npm-auth-type"] = opts.authType;
        }
        if (opts.scope) {
          headers["npm-scope"] = opts.scope;
        }
        if (opts.npmSession) {
          headers["npm-session"] = opts.npmSession;
        }
        if (opts.npmCommand) {
          headers["npm-command"] = opts.npmCommand;
        }
        if (auth.token) {
          headers.authorization = `Bearer ${auth.token}`;
        } else if (auth.auth) {
          headers.authorization = `Basic ${auth.auth}`;
        }
        if (opts.otp) {
          headers["npm-otp"] = opts.otp;
        }
        return headers;
      }
    },
    965: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Parser = __nccwpck_require__(1991);
      const { Minipass } = __nccwpck_require__(4968);
      class JSONStreamError extends Error {
        constructor(err, caller) {
          super(err.message);
          Error.captureStackTrace(this, caller || this.constructor);
        }
        get name() {
          return "JSONStreamError";
        }
      }
      const check = (x, y) =>
        typeof x === "string"
          ? String(y) === x
          : x && typeof x.test === "function"
            ? x.test(y)
            : typeof x === "boolean" || typeof x === "object"
              ? x
              : typeof x === "function"
                ? x(y)
                : false;
      class JSONStream extends Minipass {
        #count = 0;
        #ending = false;
        #footer = null;
        #header = null;
        #map = null;
        #onTokenOriginal;
        #parser;
        #path = null;
        #root = null;
        constructor(opts) {
          super({ ...opts, objectMode: true });
          const parser = (this.#parser = new Parser());
          parser.onValue = (value) => this.#onValue(value);
          this.#onTokenOriginal = parser.onToken;
          parser.onToken = (token, value) => this.#onToken(token, value);
          parser.onError = (er) => this.#onError(er);
          this.#path =
            typeof opts.path === "string"
              ? opts.path
                  .split(".")
                  .map((e) =>
                    e === "$*"
                      ? { emitKey: true }
                      : e === "*"
                        ? true
                        : e === ""
                          ? { recurse: true }
                          : e,
                  )
              : Array.isArray(opts.path) && opts.path.length
                ? opts.path
                : null;
          if (typeof opts.map === "function") {
            this.#map = opts.map;
          }
        }
        #setHeaderFooter(key, value) {
          if (this.#header !== false) {
            this.#header = this.#header || {};
            this.#header[key] = value;
          }
          if (this.#footer !== false && this.#header === false) {
            this.#footer = this.#footer || {};
            this.#footer[key] = value;
          }
        }
        #onError(er) {
          const caller = this.#ending ? this.end : this.write;
          this.#ending = false;
          return this.emit("error", new JSONStreamError(er, caller));
        }
        #onToken(token, value) {
          const parser = this.#parser;
          this.#onTokenOriginal.call(this.#parser, token, value);
          if (parser.stack.length === 0) {
            if (this.#root) {
              const root = this.#root;
              if (!this.#path) {
                super.write(root);
              }
              this.#root = null;
              this.#count = 0;
            }
          }
        }
        #onValue(value) {
          const parser = this.#parser;
          this.#root = value;
          if (!this.#path) {
            return;
          }
          let i = 0;
          let j = 0;
          let emitKey = false;
          while (i < this.#path.length) {
            const key = this.#path[i];
            j++;
            if (key && !key.recurse) {
              const c = j === parser.stack.length ? parser : parser.stack[j];
              if (!c) {
                return;
              }
              if (!check(key, c.key)) {
                this.#setHeaderFooter(c.key, value);
                return;
              }
              emitKey = !!key.emitKey;
              i++;
            } else {
              i++;
              if (i >= this.#path.length) {
                return;
              }
              const nextKey = this.#path[i];
              if (!nextKey) {
                return;
              }
              while (true) {
                const c = j === parser.stack.length ? parser : parser.stack[j];
                if (!c) {
                  return;
                }
                if (check(nextKey, c.key)) {
                  i++;
                  if (!Object.isFrozen(parser.stack[j])) {
                    parser.stack[j].value = null;
                  }
                  break;
                } else {
                  this.#setHeaderFooter(c.key, value);
                }
                j++;
              }
            }
          }
          if (this.#header) {
            const header = this.#header;
            this.#header = false;
            this.emit("header", header);
          }
          if (j !== parser.stack.length) {
            return;
          }
          this.#count++;
          const actualPath = parser.stack
            .slice(1)
            .map((e) => e.key)
            .concat([parser.key]);
          if (value !== null && value !== undefined) {
            const data = this.#map ? this.#map(value, actualPath) : value;
            if (data !== null && data !== undefined) {
              const emit = emitKey ? { value: data } : data;
              if (emitKey) {
                emit.key = parser.key;
              }
              super.write(emit);
            }
          }
          if (parser.value) {
            delete parser.value[parser.key];
          }
          for (const k of parser.stack) {
            k.value = null;
          }
        }
        write(chunk, encoding) {
          if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
          } else if (!Buffer.isBuffer(chunk)) {
            return this.emit(
              "error",
              new TypeError("Can only parse JSON from string or buffer input"),
            );
          }
          this.#parser.write(chunk);
          return this.flowing;
        }
        end(chunk, encoding) {
          this.#ending = true;
          if (chunk) {
            this.write(chunk, encoding);
          }
          const h = this.#header;
          this.#header = null;
          const f = this.#footer;
          this.#footer = null;
          if (h) {
            this.emit("header", h);
          }
          if (f) {
            this.emit("footer", f);
          }
          return super.end();
        }
        static get JSONStreamError() {
          return JSONStreamError;
        }
        static parse(path, map) {
          return new JSONStream({ path, map });
        }
      }
      module.exports = JSONStream;
    },
    6528: (module) => {
      const META = Symbol("proc-log.meta");
      module.exports = {
        META,
        output: {
          LEVELS: ["standard", "error", "buffer", "flush"],
          KEYS: {
            standard: "standard",
            error: "error",
            buffer: "buffer",
            flush: "flush",
          },
          standard: function (...args) {
            return process.emit("output", "standard", ...args);
          },
          error: function (...args) {
            return process.emit("output", "error", ...args);
          },
          buffer: function (...args) {
            return process.emit("output", "buffer", ...args);
          },
          flush: function (...args) {
            return process.emit("output", "flush", ...args);
          },
        },
        log: {
          LEVELS: [
            "notice",
            "error",
            "warn",
            "info",
            "verbose",
            "http",
            "silly",
            "timing",
            "pause",
            "resume",
          ],
          KEYS: {
            notice: "notice",
            error: "error",
            warn: "warn",
            info: "info",
            verbose: "verbose",
            http: "http",
            silly: "silly",
            timing: "timing",
            pause: "pause",
            resume: "resume",
          },
          error: function (...args) {
            return process.emit("log", "error", ...args);
          },
          notice: function (...args) {
            return process.emit("log", "notice", ...args);
          },
          warn: function (...args) {
            return process.emit("log", "warn", ...args);
          },
          info: function (...args) {
            return process.emit("log", "info", ...args);
          },
          verbose: function (...args) {
            return process.emit("log", "verbose", ...args);
          },
          http: function (...args) {
            return process.emit("log", "http", ...args);
          },
          silly: function (...args) {
            return process.emit("log", "silly", ...args);
          },
          timing: function (...args) {
            return process.emit("log", "timing", ...args);
          },
          pause: function () {
            return process.emit("log", "pause");
          },
          resume: function () {
            return process.emit("log", "resume");
          },
        },
        time: {
          LEVELS: ["start", "end"],
          KEYS: { start: "start", end: "end" },
          start: function (name, fn) {
            process.emit("time", "start", name);
            function end() {
              return process.emit("time", "end", name);
            }
            if (typeof fn === "function") {
              const res = fn();
              if (res && res.finally) {
                return res.finally(end);
              }
              end();
              return res;
            }
            return end;
          },
          end: function (name) {
            return process.emit("time", "end", name);
          },
        },
        input: {
          LEVELS: ["start", "end", "read"],
          KEYS: { start: "start", end: "end", read: "read" },
          start: function (fn) {
            process.emit("input", "start");
            function end() {
              return process.emit("input", "end");
            }
            if (typeof fn === "function") {
              const res = fn();
              if (res && res.finally) {
                return res.finally(end);
              }
              end();
              return res;
            }
            return end;
          },
          end: function () {
            return process.emit("input", "end");
          },
          read: function (...args) {
            let resolve, reject;
            const promise = new Promise((_resolve, _reject) => {
              resolve = _resolve;
              reject = _reject;
            });
            process.emit("input", "read", resolve, reject, ...args);
            return promise;
          },
        },
      };
    },
    4742: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var errcode = __nccwpck_require__(2997);
      var retry = __nccwpck_require__(4347);
      var hasOwn = Object.prototype.hasOwnProperty;
      function isRetryError(err) {
        return (
          err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried")
        );
      }
      function promiseRetry(fn, options) {
        var temp;
        var operation;
        if (typeof fn === "object" && typeof options === "function") {
          temp = options;
          options = fn;
          fn = temp;
        }
        operation = retry.operation(options);
        return new Promise(function (resolve, reject) {
          operation.attempt(function (number) {
            Promise.resolve()
              .then(function () {
                return fn(function (err) {
                  if (isRetryError(err)) {
                    err = err.retried;
                  }
                  throw errcode(new Error("Retrying"), "EPROMISERETRY", {
                    retried: err,
                  });
                }, number);
              })
              .then(resolve, function (err) {
                if (isRetryError(err)) {
                  err = err.retried;
                  if (operation.retry(err || new Error())) {
                    return;
                  }
                }
                reject(err);
              });
          });
        });
      }
      module.exports = promiseRetry;
    },
    4347: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(6244);
    },
    6244: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var RetryOperation = __nccwpck_require__(5369);
      exports.operation = function (options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && options.forever,
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime,
        });
      };
      exports.timeouts = function (options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false,
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
          timeouts.push(this.createTimeout(i, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i, opts));
        }
        timeouts.sort(function (a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports.createTimeout = function (attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1;
        var timeout = Math.round(
          random * opts.minTimeout * Math.pow(opts.factor, attempt),
        );
        timeout = Math.min(timeout, opts.maxTimeout);
        return timeout;
      };
      exports.wrap = function (obj, options, methods) {
        if (options instanceof Array) {
          methods = options;
          options = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          var original = obj[method];
          obj[method] = function retryWrapper(original) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function (err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function () {
              original.apply(obj, args);
            });
          }.bind(obj, original);
          obj[method].options = options;
        }
      };
    },
    5369: (module) => {
      function RetryOperation(timeouts, options) {
        if (typeof options === "boolean") {
          options = { forever: options };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options || {};
        this._maxRetryTime = (options && options.maxRetryTime) || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      module.exports = RetryOperation;
      RetryOperation.prototype.reset = function () {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts;
      };
      RetryOperation.prototype.stop = function () {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function (err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = new Date().getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === undefined) {
          if (this._cachedTimeouts) {
            this._errors.splice(this._errors.length - 1, this._errors.length);
            this._timeouts = this._cachedTimeouts.slice(0);
            timeout = this._timeouts.shift();
          } else {
            return false;
          }
        }
        var self = this;
        var timer = setTimeout(function () {
          self._attempts++;
          if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function () {
              self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
              self._timeout.unref();
            }
          }
          self._fn(self._attempts);
        }, timeout);
        if (this._options.unref) {
          timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function (fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function () {
            self._operationTimeoutCb();
          }, self._operationTimeout);
        }
        this._operationStart = new Date().getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function (fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function (fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function () {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function () {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function () {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error = this._errors[i];
          var message = error.message;
          var count = (counts[message] || 0) + 1;
          counts[message] = count;
          if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
    },
    5118: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var buffer = __nccwpck_require__(4300);
      var Buffer = buffer.Buffer;
      var safer = {};
      var key;
      for (key in buffer) {
        if (!buffer.hasOwnProperty(key)) continue;
        if (key === "SlowBuffer" || key === "Buffer") continue;
        safer[key] = buffer[key];
      }
      var Safer = (safer.Buffer = {});
      for (key in Buffer) {
        if (!Buffer.hasOwnProperty(key)) continue;
        if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
        Safer[key] = Buffer[key];
      }
      safer.Buffer.prototype = Buffer.prototype;
      if (!Safer.from || Safer.from === Uint8Array.from) {
        Safer.from = function (value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError(
              'The "value" argument must not be of type number. Received type ' +
                typeof value,
            );
          }
          if (value && typeof value.length === "undefined") {
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof value,
            );
          }
          return Buffer(value, encodingOrOffset, length);
        };
      }
      if (!Safer.alloc) {
        Safer.alloc = function (size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError(
              'The "size" argument must be of type number. Received type ' +
                typeof size,
            );
          }
          if (size < 0 || size >= 2 * (1 << 30)) {
            throw new RangeError(
              'The value "' + size + '" is invalid for option "size"',
            );
          }
          var buf = Buffer(size);
          if (!fill || fill.length === 0) {
            buf.fill(0);
          } else if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
          return buf;
        };
      }
      if (!safer.kStringMaxLength) {
        try {
          safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
        } catch (e) {}
      }
      if (!safer.constants) {
        safer.constants = { MAX_LENGTH: safer.kMaxLength };
        if (safer.kStringMaxLength) {
          safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
      }
      module.exports = safer;
    },
    8088: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const debug = __nccwpck_require__(427);
      const { MAX_LENGTH, MAX_SAFE_INTEGER } = __nccwpck_require__(2293);
      const { safeRe: re, t } = __nccwpck_require__(9523);
      const parseOptions = __nccwpck_require__(785);
      const { compareIdentifiers } = __nccwpck_require__(2463);
      class SemVer {
        constructor(version, options) {
          options = parseOptions(options);
          if (version instanceof SemVer) {
            if (
              version.loose === !!options.loose &&
              version.includePrerelease === !!options.includePrerelease
            ) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== "string") {
            throw new TypeError(
              `Invalid version. Must be a string. Got type "${typeof version}".`,
            );
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`,
            );
          }
          debug("SemVer", version, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version
            .trim()
            .match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return (
            compareIdentifiers(this.major, other.major) ||
            compareIdentifiers(this.minor, other.minor) ||
            compareIdentifiers(this.patch, other.patch)
          );
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug("build compare", i, a, b);
            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        inc(release, identifier, identifierBase) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (
                this.minor !== 0 ||
                this.patch !== 0 ||
                this.prerelease.length === 0
              ) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error(
                  "invalid increment argument: identifier is empty",
                );
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  if (
                    identifier === this.prerelease.join(".") &&
                    identifierBase === false
                  ) {
                    throw new Error(
                      "invalid increment argument: identifier already exists",
                    );
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      }
      module.exports = SemVer;
    },
    8848: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const parse = __nccwpck_require__(5925);
      const clean = (version, options) => {
        const s = parse(version.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      };
      module.exports = clean;
    },
    5925: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const SemVer = __nccwpck_require__(8088);
      const parse = (version, options, throwErrors = false) => {
        if (version instanceof SemVer) {
          return version;
        }
        try {
          return new SemVer(version, options);
        } catch (er) {
          if (!throwErrors) {
            return null;
          }
          throw er;
        }
      };
      module.exports = parse;
    },
    9601: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const parse = __nccwpck_require__(5925);
      const valid = (version, options) => {
        const v = parse(version, options);
        return v ? v.version : null;
      };
      module.exports = valid;
    },
    2293: (module) => {
      const SEMVER_SPEC_VERSION = "2.0.0";
      const MAX_LENGTH = 256;
      const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      const MAX_SAFE_COMPONENT_LENGTH = 16;
      const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      const RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease",
      ];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2,
      };
    },
    427: (module) => {
      const debug =
        typeof process === "object" &&
        process.env &&
        process.env.NODE_DEBUG &&
        /\bsemver\b/i.test(process.env.NODE_DEBUG)
          ? (...args) => console.error("SEMVER", ...args)
          : () => {};
      module.exports = debug;
    },
    2463: (module) => {
      const numeric = /^[0-9]+$/;
      const compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b
          ? 0
          : anum && !bnum
            ? -1
            : bnum && !anum
              ? 1
              : a < b
                ? -1
                : 1;
      };
      const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module.exports = { compareIdentifiers, rcompareIdentifiers };
    },
    785: (module) => {
      const looseOption = Object.freeze({ loose: true });
      const emptyOpts = Object.freeze({});
      const parseOptions = (options) => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== "object") {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    },
    9523: (module, exports, __nccwpck_require__) => {
      const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } =
        __nccwpck_require__(2293);
      const debug = __nccwpck_require__(427);
      exports = module.exports = {};
      const re = (exports.re = []);
      const safeRe = (exports.safeRe = []);
      const src = (exports.src = []);
      const t = (exports.t = {});
      let R = 0;
      const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      const safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
      ];
      const makeSafeRegex = (value) => {
        for (const [token, max] of safeRegexReplacements) {
          value = value
            .split(`${token}*`)
            .join(`${token}{0,${max}}`)
            .split(`${token}+`)
            .join(`${token}{1,${max}}`);
        }
        return value;
      };
      const createToken = (name, value, isGlobal) => {
        const safe = makeSafeRegex(value);
        const index = R++;
        debug(name, index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : undefined);
        safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken(
        "MAINVERSION",
        `(${src[t.NUMERICIDENTIFIER]})\\.` +
          `(${src[t.NUMERICIDENTIFIER]})\\.` +
          `(${src[t.NUMERICIDENTIFIER]})`,
      );
      createToken(
        "MAINVERSIONLOOSE",
        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
          `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
          `(${src[t.NUMERICIDENTIFIERLOOSE]})`,
      );
      createToken(
        "PRERELEASEIDENTIFIER",
        `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`,
      );
      createToken(
        "PRERELEASEIDENTIFIERLOOSE",
        `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`,
      );
      createToken(
        "PRERELEASE",
        `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`,
      );
      createToken(
        "PRERELEASELOOSE",
        `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`,
      );
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken(
        "BUILD",
        `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`,
      );
      createToken(
        "FULLPLAIN",
        `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`,
      );
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken(
        "LOOSEPLAIN",
        `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`,
      );
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken(
        "XRANGEIDENTIFIERLOOSE",
        `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`,
      );
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken(
        "XRANGEPLAIN",
        `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
          `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` +
          `)?)?`,
      );
      createToken(
        "XRANGEPLAINLOOSE",
        `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` +
          `)?)?`,
      );
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken(
        "XRANGELOOSE",
        `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`,
      );
      createToken(
        "COERCEPLAIN",
        `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` +
          `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
          `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`,
      );
      createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken(
        "COERCEFULL",
        src[t.COERCEPLAIN] +
          `(?:${src[t.PRERELEASE]})?` +
          `(?:${src[t.BUILD]})?` +
          `(?:$|[^\\d])`,
      );
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("COERCERTLFULL", src[t.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken(
        "TILDELOOSE",
        `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`,
      );
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken(
        "CARETLOOSE",
        `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`,
      );
      createToken(
        "COMPARATORLOOSE",
        `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`,
      );
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken(
        "COMPARATORTRIM",
        `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,
        true,
      );
      exports.comparatorTrimReplace = "$1$2$3";
      createToken(
        "HYPHENRANGE",
        `^\\s*(${src[t.XRANGEPLAIN]})` +
          `\\s+-\\s+` +
          `(${src[t.XRANGEPLAIN]})` +
          `\\s*$`,
      );
      createToken(
        "HYPHENRANGELOOSE",
        `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
          `\\s+-\\s+` +
          `(${src[t.XRANGEPLAINLOOSE]})` +
          `\\s*$`,
      );
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    },
    3430: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createVerificationPolicy =
        exports.createKeyFinder =
        exports.createBundleBuilder =
        exports.DEFAULT_TIMEOUT =
        exports.DEFAULT_RETRY =
          void 0;
      const core_1 = __nccwpck_require__(3352);
      const sign_1 = __nccwpck_require__(2071);
      const verify_1 = __nccwpck_require__(666);
      exports.DEFAULT_RETRY = { retries: 2 };
      exports.DEFAULT_TIMEOUT = 5e3;
      function createBundleBuilder(bundleType, options) {
        const bundlerOptions = {
          signer: initSigner(options),
          witnesses: initWitnesses(options),
        };
        switch (bundleType) {
          case "messageSignature":
            return new sign_1.MessageSignatureBundleBuilder(bundlerOptions);
          case "dsseEnvelope":
            return new sign_1.DSSEBundleBuilder(bundlerOptions);
        }
      }
      exports.createBundleBuilder = createBundleBuilder;
      function createKeyFinder(keySelector) {
        return (hint) => {
          const key = keySelector(hint);
          if (!key) {
            throw new verify_1.VerificationError({
              code: "PUBLIC_KEY_ERROR",
              message: `key not found: ${hint}`,
            });
          }
          return {
            publicKey: core_1.crypto.createPublicKey(key),
            validFor: () => true,
          };
        };
      }
      exports.createKeyFinder = createKeyFinder;
      function createVerificationPolicy(options) {
        const policy = {};
        const san =
          options.certificateIdentityEmail || options.certificateIdentityURI;
        if (san) {
          policy.subjectAlternativeName = san;
        }
        if (options.certificateIssuer) {
          policy.extensions = { issuer: options.certificateIssuer };
        }
        return policy;
      }
      exports.createVerificationPolicy = createVerificationPolicy;
      function initSigner(options) {
        return new sign_1.FulcioSigner({
          fulcioBaseURL: options.fulcioURL,
          identityProvider:
            options.identityProvider || initIdentityProvider(options),
          retry: options.retry ?? exports.DEFAULT_RETRY,
          timeout: options.timeout ?? exports.DEFAULT_TIMEOUT,
        });
      }
      function initIdentityProvider(options) {
        const token = options.identityToken;
        if (token) {
          return { getToken: () => Promise.resolve(token) };
        } else {
          return new sign_1.CIContextProvider("sigstore");
        }
      }
      function initWitnesses(options) {
        const witnesses = [];
        if (isRekorEnabled(options)) {
          witnesses.push(
            new sign_1.RekorWitness({
              rekorBaseURL: options.rekorURL,
              fetchOnConflict: false,
              retry: options.retry ?? exports.DEFAULT_RETRY,
              timeout: options.timeout ?? exports.DEFAULT_TIMEOUT,
            }),
          );
        }
        if (isTSAEnabled(options)) {
          witnesses.push(
            new sign_1.TSAWitness({
              tsaBaseURL: options.tsaServerURL,
              retry: options.retry ?? exports.DEFAULT_RETRY,
              timeout: options.timeout ?? exports.DEFAULT_TIMEOUT,
            }),
          );
        }
        return witnesses;
      }
      function isRekorEnabled(options) {
        return options.tlogUpload !== false;
      }
      function isTSAEnabled(options) {
        return options.tsaServerURL !== undefined;
      }
    },
    9149: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verify =
        exports.sign =
        exports.createVerifier =
        exports.attest =
        exports.VerificationError =
        exports.PolicyError =
        exports.TUFError =
        exports.InternalError =
        exports.DEFAULT_REKOR_URL =
        exports.DEFAULT_FULCIO_URL =
        exports.ValidationError =
          void 0;
      var bundle_1 = __nccwpck_require__(9715);
      Object.defineProperty(exports, "ValidationError", {
        enumerable: true,
        get: function () {
          return bundle_1.ValidationError;
        },
      });
      var sign_1 = __nccwpck_require__(2071);
      Object.defineProperty(exports, "DEFAULT_FULCIO_URL", {
        enumerable: true,
        get: function () {
          return sign_1.DEFAULT_FULCIO_URL;
        },
      });
      Object.defineProperty(exports, "DEFAULT_REKOR_URL", {
        enumerable: true,
        get: function () {
          return sign_1.DEFAULT_REKOR_URL;
        },
      });
      Object.defineProperty(exports, "InternalError", {
        enumerable: true,
        get: function () {
          return sign_1.InternalError;
        },
      });
      var tuf_1 = __nccwpck_require__(8567);
      Object.defineProperty(exports, "TUFError", {
        enumerable: true,
        get: function () {
          return tuf_1.TUFError;
        },
      });
      var verify_1 = __nccwpck_require__(666);
      Object.defineProperty(exports, "PolicyError", {
        enumerable: true,
        get: function () {
          return verify_1.PolicyError;
        },
      });
      Object.defineProperty(exports, "VerificationError", {
        enumerable: true,
        get: function () {
          return verify_1.VerificationError;
        },
      });
      var sigstore_1 = __nccwpck_require__(1111);
      Object.defineProperty(exports, "attest", {
        enumerable: true,
        get: function () {
          return sigstore_1.attest;
        },
      });
      Object.defineProperty(exports, "createVerifier", {
        enumerable: true,
        get: function () {
          return sigstore_1.createVerifier;
        },
      });
      Object.defineProperty(exports, "sign", {
        enumerable: true,
        get: function () {
          return sigstore_1.sign;
        },
      });
      Object.defineProperty(exports, "verify", {
        enumerable: true,
        get: function () {
          return sigstore_1.verify;
        },
      });
    },
    1111: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createVerifier =
        exports.verify =
        exports.attest =
        exports.sign =
          void 0;
      const bundle_1 = __nccwpck_require__(9715);
      const tuf = __importStar(__nccwpck_require__(8567));
      const verify_1 = __nccwpck_require__(666);
      const config = __importStar(__nccwpck_require__(3430));
      async function sign(payload, options = {}) {
        const bundler = config.createBundleBuilder("messageSignature", options);
        const bundle = await bundler.create({ data: payload });
        return (0, bundle_1.bundleToJSON)(bundle);
      }
      exports.sign = sign;
      async function attest(payload, payloadType, options = {}) {
        const bundler = config.createBundleBuilder("dsseEnvelope", options);
        const bundle = await bundler.create({
          data: payload,
          type: payloadType,
        });
        return (0, bundle_1.bundleToJSON)(bundle);
      }
      exports.attest = attest;
      async function verify(bundle, dataOrOptions, options) {
        let data;
        if (Buffer.isBuffer(dataOrOptions)) {
          data = dataOrOptions;
        } else {
          options = dataOrOptions;
        }
        return createVerifier(options).then((verifier) =>
          verifier.verify(bundle, data),
        );
      }
      exports.verify = verify;
      async function createVerifier(options = {}) {
        const trustedRoot = await tuf.getTrustedRoot({
          mirrorURL: options.tufMirrorURL,
          rootPath: options.tufRootPath,
          cachePath: options.tufCachePath,
          forceCache: options.tufForceCache,
          retry: options.retry ?? config.DEFAULT_RETRY,
          timeout: options.timeout ?? config.DEFAULT_TIMEOUT,
        });
        const keyFinder = options.keySelector
          ? config.createKeyFinder(options.keySelector)
          : undefined;
        const trustMaterial = (0, verify_1.toTrustMaterial)(
          trustedRoot,
          keyFinder,
        );
        const verifierOptions = {
          ctlogThreshold: options.ctLogThreshold,
          tlogThreshold: options.tlogThreshold,
        };
        const verifier = new verify_1.Verifier(trustMaterial, verifierOptions);
        const policy = config.createVerificationPolicy(options);
        return {
          verify: (bundle, payload) => {
            const deserializedBundle = (0, bundle_1.bundleFromJSON)(bundle);
            const signedEntity = (0, verify_1.toSignedEntity)(
              deserializedBundle,
              payload,
            );
            verifier.verify(signedEntity, policy);
            return;
          },
        };
      }
      exports.createVerifier = createVerifier;
    },
    1062: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      const utils_1 = __nccwpck_require__(8132);
      const DEFAULT_SMARTBUFFER_SIZE = 4096;
      const DEFAULT_SMARTBUFFER_ENCODING = "utf8";
      class SmartBuffer {
        constructor(options) {
          this.length = 0;
          this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
          this._writeOffset = 0;
          this._readOffset = 0;
          if (SmartBuffer.isSmartBufferOptions(options)) {
            if (options.encoding) {
              utils_1.checkEncoding(options.encoding);
              this._encoding = options.encoding;
            }
            if (options.size) {
              if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
                this._buff = Buffer.allocUnsafe(options.size);
              } else {
                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
              }
            } else if (options.buff) {
              if (Buffer.isBuffer(options.buff)) {
                this._buff = options.buff;
                this.length = options.buff.length;
              } else {
                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
              }
            } else {
              this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
            }
          } else {
            if (typeof options !== "undefined") {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
            }
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        }
        static fromSize(size, encoding) {
          return new this({ size, encoding });
        }
        static fromBuffer(buff, encoding) {
          return new this({ buff, encoding });
        }
        static fromOptions(options) {
          return new this(options);
        }
        static isSmartBufferOptions(options) {
          const castOptions = options;
          return (
            castOptions &&
            (castOptions.encoding !== undefined ||
              castOptions.size !== undefined ||
              castOptions.buff !== undefined)
          );
        }
        readInt8(offset) {
          return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
        }
        readInt16BE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
        }
        readInt16LE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
        }
        readInt32BE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
        }
        readInt32LE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
        }
        readBigInt64BE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
          return this._readNumberValue(
            Buffer.prototype.readBigInt64BE,
            8,
            offset,
          );
        }
        readBigInt64LE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
          return this._readNumberValue(
            Buffer.prototype.readBigInt64LE,
            8,
            offset,
          );
        }
        writeInt8(value, offset) {
          this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
          return this;
        }
        insertInt8(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt8,
            1,
            value,
            offset,
          );
        }
        writeInt16BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt16BE,
            2,
            value,
            offset,
          );
        }
        insertInt16BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt16BE,
            2,
            value,
            offset,
          );
        }
        writeInt16LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt16LE,
            2,
            value,
            offset,
          );
        }
        insertInt16LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt16LE,
            2,
            value,
            offset,
          );
        }
        writeInt32BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt32BE,
            4,
            value,
            offset,
          );
        }
        insertInt32BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt32BE,
            4,
            value,
            offset,
          );
        }
        writeInt32LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt32LE,
            4,
            value,
            offset,
          );
        }
        insertInt32LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt32LE,
            4,
            value,
            offset,
          );
        }
        writeBigInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigInt64BE,
            8,
            value,
            offset,
          );
        }
        insertBigInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigInt64BE,
            8,
            value,
            offset,
          );
        }
        writeBigInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigInt64LE,
            8,
            value,
            offset,
          );
        }
        insertBigInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigInt64LE,
            8,
            value,
            offset,
          );
        }
        readUInt8(offset) {
          return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
        }
        readUInt16BE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt16BE,
            2,
            offset,
          );
        }
        readUInt16LE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt16LE,
            2,
            offset,
          );
        }
        readUInt32BE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt32BE,
            4,
            offset,
          );
        }
        readUInt32LE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt32LE,
            4,
            offset,
          );
        }
        readBigUInt64BE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
          return this._readNumberValue(
            Buffer.prototype.readBigUInt64BE,
            8,
            offset,
          );
        }
        readBigUInt64LE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
          return this._readNumberValue(
            Buffer.prototype.readBigUInt64LE,
            8,
            offset,
          );
        }
        writeUInt8(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt8,
            1,
            value,
            offset,
          );
        }
        insertUInt8(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt8,
            1,
            value,
            offset,
          );
        }
        writeUInt16BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt16BE,
            2,
            value,
            offset,
          );
        }
        insertUInt16BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt16BE,
            2,
            value,
            offset,
          );
        }
        writeUInt16LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt16LE,
            2,
            value,
            offset,
          );
        }
        insertUInt16LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt16LE,
            2,
            value,
            offset,
          );
        }
        writeUInt32BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt32BE,
            4,
            value,
            offset,
          );
        }
        insertUInt32BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt32BE,
            4,
            value,
            offset,
          );
        }
        writeUInt32LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt32LE,
            4,
            value,
            offset,
          );
        }
        insertUInt32LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt32LE,
            4,
            value,
            offset,
          );
        }
        writeBigUInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigUInt64BE,
            8,
            value,
            offset,
          );
        }
        insertBigUInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigUInt64BE,
            8,
            value,
            offset,
          );
        }
        writeBigUInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigUInt64LE,
            8,
            value,
            offset,
          );
        }
        insertBigUInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigUInt64LE,
            8,
            value,
            offset,
          );
        }
        readFloatBE(offset) {
          return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
        }
        readFloatLE(offset) {
          return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
        }
        writeFloatBE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeFloatBE,
            4,
            value,
            offset,
          );
        }
        insertFloatBE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeFloatBE,
            4,
            value,
            offset,
          );
        }
        writeFloatLE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeFloatLE,
            4,
            value,
            offset,
          );
        }
        insertFloatLE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeFloatLE,
            4,
            value,
            offset,
          );
        }
        readDoubleBE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readDoubleBE,
            8,
            offset,
          );
        }
        readDoubleLE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readDoubleLE,
            8,
            offset,
          );
        }
        writeDoubleBE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeDoubleBE,
            8,
            value,
            offset,
          );
        }
        insertDoubleBE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeDoubleBE,
            8,
            value,
            offset,
          );
        }
        writeDoubleLE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeDoubleLE,
            8,
            value,
            offset,
          );
        }
        insertDoubleLE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeDoubleLE,
            8,
            value,
            offset,
          );
        }
        readString(arg1, encoding) {
          let lengthVal;
          if (typeof arg1 === "number") {
            utils_1.checkLengthValue(arg1);
            lengthVal = Math.min(arg1, this.length - this._readOffset);
          } else {
            encoding = arg1;
            lengthVal = this.length - this._readOffset;
          }
          if (typeof encoding !== "undefined") {
            utils_1.checkEncoding(encoding);
          }
          const value = this._buff
            .slice(this._readOffset, this._readOffset + lengthVal)
            .toString(encoding || this._encoding);
          this._readOffset += lengthVal;
          return value;
        }
        insertString(value, offset, encoding) {
          utils_1.checkOffsetValue(offset);
          return this._handleString(value, true, offset, encoding);
        }
        writeString(value, arg2, encoding) {
          return this._handleString(value, false, arg2, encoding);
        }
        readStringNT(encoding) {
          if (typeof encoding !== "undefined") {
            utils_1.checkEncoding(encoding);
          }
          let nullPos = this.length;
          for (let i = this._readOffset; i < this.length; i++) {
            if (this._buff[i] === 0) {
              nullPos = i;
              break;
            }
          }
          const value = this._buff.slice(this._readOffset, nullPos);
          this._readOffset = nullPos + 1;
          return value.toString(encoding || this._encoding);
        }
        insertStringNT(value, offset, encoding) {
          utils_1.checkOffsetValue(offset);
          this.insertString(value, offset, encoding);
          this.insertUInt8(0, offset + value.length);
          return this;
        }
        writeStringNT(value, arg2, encoding) {
          this.writeString(value, arg2, encoding);
          this.writeUInt8(
            0,
            typeof arg2 === "number" ? arg2 + value.length : this.writeOffset,
          );
          return this;
        }
        readBuffer(length) {
          if (typeof length !== "undefined") {
            utils_1.checkLengthValue(length);
          }
          const lengthVal = typeof length === "number" ? length : this.length;
          const endPoint = Math.min(this.length, this._readOffset + lengthVal);
          const value = this._buff.slice(this._readOffset, endPoint);
          this._readOffset = endPoint;
          return value;
        }
        insertBuffer(value, offset) {
          utils_1.checkOffsetValue(offset);
          return this._handleBuffer(value, true, offset);
        }
        writeBuffer(value, offset) {
          return this._handleBuffer(value, false, offset);
        }
        readBufferNT() {
          let nullPos = this.length;
          for (let i = this._readOffset; i < this.length; i++) {
            if (this._buff[i] === 0) {
              nullPos = i;
              break;
            }
          }
          const value = this._buff.slice(this._readOffset, nullPos);
          this._readOffset = nullPos + 1;
          return value;
        }
        insertBufferNT(value, offset) {
          utils_1.checkOffsetValue(offset);
          this.insertBuffer(value, offset);
          this.insertUInt8(0, offset + value.length);
          return this;
        }
        writeBufferNT(value, offset) {
          if (typeof offset !== "undefined") {
            utils_1.checkOffsetValue(offset);
          }
          this.writeBuffer(value, offset);
          this.writeUInt8(
            0,
            typeof offset === "number"
              ? offset + value.length
              : this._writeOffset,
          );
          return this;
        }
        clear() {
          this._writeOffset = 0;
          this._readOffset = 0;
          this.length = 0;
          return this;
        }
        remaining() {
          return this.length - this._readOffset;
        }
        get readOffset() {
          return this._readOffset;
        }
        set readOffset(offset) {
          utils_1.checkOffsetValue(offset);
          utils_1.checkTargetOffset(offset, this);
          this._readOffset = offset;
        }
        get writeOffset() {
          return this._writeOffset;
        }
        set writeOffset(offset) {
          utils_1.checkOffsetValue(offset);
          utils_1.checkTargetOffset(offset, this);
          this._writeOffset = offset;
        }
        get encoding() {
          return this._encoding;
        }
        set encoding(encoding) {
          utils_1.checkEncoding(encoding);
          this._encoding = encoding;
        }
        get internalBuffer() {
          return this._buff;
        }
        toBuffer() {
          return this._buff.slice(0, this.length);
        }
        toString(encoding) {
          const encodingVal =
            typeof encoding === "string" ? encoding : this._encoding;
          utils_1.checkEncoding(encodingVal);
          return this._buff.toString(encodingVal, 0, this.length);
        }
        destroy() {
          this.clear();
          return this;
        }
        _handleString(value, isInsert, arg3, encoding) {
          let offsetVal = this._writeOffset;
          let encodingVal = this._encoding;
          if (typeof arg3 === "number") {
            offsetVal = arg3;
          } else if (typeof arg3 === "string") {
            utils_1.checkEncoding(arg3);
            encodingVal = arg3;
          }
          if (typeof encoding === "string") {
            utils_1.checkEncoding(encoding);
            encodingVal = encoding;
          }
          const byteLength = Buffer.byteLength(value, encodingVal);
          if (isInsert) {
            this.ensureInsertable(byteLength, offsetVal);
          } else {
            this._ensureWriteable(byteLength, offsetVal);
          }
          this._buff.write(value, offsetVal, byteLength, encodingVal);
          if (isInsert) {
            this._writeOffset += byteLength;
          } else {
            if (typeof arg3 === "number") {
              this._writeOffset = Math.max(
                this._writeOffset,
                offsetVal + byteLength,
              );
            } else {
              this._writeOffset += byteLength;
            }
          }
          return this;
        }
        _handleBuffer(value, isInsert, offset) {
          const offsetVal =
            typeof offset === "number" ? offset : this._writeOffset;
          if (isInsert) {
            this.ensureInsertable(value.length, offsetVal);
          } else {
            this._ensureWriteable(value.length, offsetVal);
          }
          value.copy(this._buff, offsetVal);
          if (isInsert) {
            this._writeOffset += value.length;
          } else {
            if (typeof offset === "number") {
              this._writeOffset = Math.max(
                this._writeOffset,
                offsetVal + value.length,
              );
            } else {
              this._writeOffset += value.length;
            }
          }
          return this;
        }
        ensureReadable(length, offset) {
          let offsetVal = this._readOffset;
          if (typeof offset !== "undefined") {
            utils_1.checkOffsetValue(offset);
            offsetVal = offset;
          }
          if (offsetVal < 0 || offsetVal + length > this.length) {
            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
          }
        }
        ensureInsertable(dataLength, offset) {
          utils_1.checkOffsetValue(offset);
          this._ensureCapacity(this.length + dataLength);
          if (offset < this.length) {
            this._buff.copy(
              this._buff,
              offset + dataLength,
              offset,
              this._buff.length,
            );
          }
          if (offset + dataLength > this.length) {
            this.length = offset + dataLength;
          } else {
            this.length += dataLength;
          }
        }
        _ensureWriteable(dataLength, offset) {
          const offsetVal =
            typeof offset === "number" ? offset : this._writeOffset;
          this._ensureCapacity(offsetVal + dataLength);
          if (offsetVal + dataLength > this.length) {
            this.length = offsetVal + dataLength;
          }
        }
        _ensureCapacity(minLength) {
          const oldLength = this._buff.length;
          if (minLength > oldLength) {
            let data = this._buff;
            let newLength = (oldLength * 3) / 2 + 1;
            if (newLength < minLength) {
              newLength = minLength;
            }
            this._buff = Buffer.allocUnsafe(newLength);
            data.copy(this._buff, 0, 0, oldLength);
          }
        }
        _readNumberValue(func, byteSize, offset) {
          this.ensureReadable(byteSize, offset);
          const value = func.call(
            this._buff,
            typeof offset === "number" ? offset : this._readOffset,
          );
          if (typeof offset === "undefined") {
            this._readOffset += byteSize;
          }
          return value;
        }
        _insertNumberValue(func, byteSize, value, offset) {
          utils_1.checkOffsetValue(offset);
          this.ensureInsertable(byteSize, offset);
          func.call(this._buff, value, offset);
          this._writeOffset += byteSize;
          return this;
        }
        _writeNumberValue(func, byteSize, value, offset) {
          if (typeof offset === "number") {
            if (offset < 0) {
              throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
            }
            utils_1.checkOffsetValue(offset);
          }
          const offsetVal =
            typeof offset === "number" ? offset : this._writeOffset;
          this._ensureWriteable(byteSize, offsetVal);
          func.call(this._buff, value, offsetVal);
          if (typeof offset === "number") {
            this._writeOffset = Math.max(
              this._writeOffset,
              offsetVal + byteSize,
            );
          } else {
            this._writeOffset += byteSize;
          }
          return this;
        }
      }
      exports.SmartBuffer = SmartBuffer;
    },
    8132: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      const buffer_1 = __nccwpck_require__(4300);
      const ERRORS = {
        INVALID_ENCODING:
          "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
        INVALID_SMARTBUFFER_SIZE:
          "Invalid size provided. Size must be a valid integer greater than zero.",
        INVALID_SMARTBUFFER_BUFFER:
          "Invalid Buffer provided in SmartBufferOptions.",
        INVALID_SMARTBUFFER_OBJECT:
          "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
        INVALID_OFFSET: "An invalid offset value was provided.",
        INVALID_OFFSET_NON_NUMBER:
          "An invalid offset value was provided. A numeric value is required.",
        INVALID_LENGTH: "An invalid length value was provided.",
        INVALID_LENGTH_NON_NUMBER:
          "An invalid length value was provived. A numeric value is required.",
        INVALID_TARGET_OFFSET:
          "Target offset is beyond the bounds of the internal SmartBuffer data.",
        INVALID_TARGET_LENGTH:
          "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
        INVALID_READ_BEYOND_BOUNDS:
          "Attempted to read beyond the bounds of the managed data.",
        INVALID_WRITE_BEYOND_BOUNDS:
          "Attempted to write beyond the bounds of the managed data.",
      };
      exports.ERRORS = ERRORS;
      function checkEncoding(encoding) {
        if (!buffer_1.Buffer.isEncoding(encoding)) {
          throw new Error(ERRORS.INVALID_ENCODING);
        }
      }
      exports.checkEncoding = checkEncoding;
      function isFiniteInteger(value) {
        return typeof value === "number" && isFinite(value) && isInteger(value);
      }
      exports.isFiniteInteger = isFiniteInteger;
      function checkOffsetOrLengthValue(value, offset) {
        if (typeof value === "number") {
          if (!isFiniteInteger(value) || value < 0) {
            throw new Error(
              offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH,
            );
          }
        } else {
          throw new Error(
            offset
              ? ERRORS.INVALID_OFFSET_NON_NUMBER
              : ERRORS.INVALID_LENGTH_NON_NUMBER,
          );
        }
      }
      function checkLengthValue(length) {
        checkOffsetOrLengthValue(length, false);
      }
      exports.checkLengthValue = checkLengthValue;
      function checkOffsetValue(offset) {
        checkOffsetOrLengthValue(offset, true);
      }
      exports.checkOffsetValue = checkOffsetValue;
      function checkTargetOffset(offset, buff) {
        if (offset < 0 || offset > buff.length) {
          throw new Error(ERRORS.INVALID_TARGET_OFFSET);
        }
      }
      exports.checkTargetOffset = checkTargetOffset;
      function isInteger(value) {
        return (
          typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value
        );
      }
      function bigIntAndBufferInt64Check(bufferMethod) {
        if (typeof BigInt === "undefined") {
          throw new Error("Platform does not support JS BigInt type.");
        }
        if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
          throw new Error(
            `Platform does not support Buffer.prototype.${bufferMethod}.`,
          );
        }
      }
      exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
    },
    5038: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SocksProxyAgent = void 0;
      const socks_1 = __nccwpck_require__(4754);
      const agent_base_1 = __nccwpck_require__(694);
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const dns = __importStar(__nccwpck_require__(7578));
      const tls = __importStar(__nccwpck_require__(4404));
      const url_1 = __nccwpck_require__(7310);
      const debug = (0, debug_1.default)("socks-proxy-agent");
      function parseSocksURL(url) {
        let lookup = false;
        let type = 5;
        const host = url.hostname;
        const port = parseInt(url.port, 10) || 1080;
        switch (url.protocol.replace(":", "")) {
          case "socks4":
            lookup = true;
            type = 4;
            break;
          case "socks4a":
            type = 4;
            break;
          case "socks5":
            lookup = true;
            type = 5;
            break;
          case "socks":
            type = 5;
            break;
          case "socks5h":
            type = 5;
            break;
          default:
            throw new TypeError(
              `A "socks" protocol must be specified! Got: ${String(url.protocol)}`,
            );
        }
        const proxy = { host, port, type };
        if (url.username) {
          Object.defineProperty(proxy, "userId", {
            value: decodeURIComponent(url.username),
            enumerable: false,
          });
        }
        if (url.password != null) {
          Object.defineProperty(proxy, "password", {
            value: decodeURIComponent(url.password),
            enumerable: false,
          });
        }
        return { lookup, proxy };
      }
      class SocksProxyAgent extends agent_base_1.Agent {
        constructor(uri, opts) {
          super(opts);
          const url = typeof uri === "string" ? new url_1.URL(uri) : uri;
          const { proxy, lookup } = parseSocksURL(url);
          this.shouldLookup = lookup;
          this.proxy = proxy;
          this.timeout = opts?.timeout ?? null;
          this.socketOptions = opts?.socketOptions ?? null;
        }
        async connect(req, opts) {
          const { shouldLookup, proxy, timeout } = this;
          if (!opts.host) {
            throw new Error("No `host` defined!");
          }
          let { host } = opts;
          const { port, lookup: lookupFn = dns.lookup } = opts;
          if (shouldLookup) {
            host = await new Promise((resolve, reject) => {
              lookupFn(host, {}, (err, res) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res);
                }
              });
            });
          }
          const socksOpts = {
            proxy,
            destination: {
              host,
              port: typeof port === "number" ? port : parseInt(port, 10),
            },
            command: "connect",
            timeout: timeout ?? undefined,
            socket_options: this.socketOptions ?? undefined,
          };
          const cleanup = (tlsSocket) => {
            req.destroy();
            socket.destroy();
            if (tlsSocket) tlsSocket.destroy();
          };
          debug("Creating socks proxy connection: %o", socksOpts);
          const { socket } =
            await socks_1.SocksClient.createConnection(socksOpts);
          debug("Successfully created socks proxy connection");
          if (timeout !== null) {
            socket.setTimeout(timeout);
            socket.on("timeout", () => cleanup());
          }
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            const tlsSocket = tls.connect({
              ...omit(opts, "host", "path", "port"),
              socket,
              servername,
            });
            tlsSocket.once("error", (error) => {
              debug("Socket TLS error", error.message);
              cleanup(tlsSocket);
            });
            return tlsSocket;
          }
          return socket;
        }
      }
      SocksProxyAgent.protocols = [
        "socks",
        "socks4",
        "socks4a",
        "socks5",
        "socks5h",
      ];
      exports.SocksProxyAgent = SocksProxyAgent;
      function omit(obj, ...keys) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
    },
    6127: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SocksClientError = exports.SocksClient = void 0;
      const events_1 = __nccwpck_require__(2361);
      const net = __nccwpck_require__(1808);
      const smart_buffer_1 = __nccwpck_require__(1062);
      const constants_1 = __nccwpck_require__(9647);
      const helpers_1 = __nccwpck_require__(4324);
      const receivebuffer_1 = __nccwpck_require__(9740);
      const util_1 = __nccwpck_require__(5523);
      Object.defineProperty(exports, "SocksClientError", {
        enumerable: true,
        get: function () {
          return util_1.SocksClientError;
        },
      });
      const ip_address_1 = __nccwpck_require__(8953);
      class SocksClient extends events_1.EventEmitter {
        constructor(options) {
          super();
          this.options = Object.assign({}, options);
          (0, helpers_1.validateSocksClientOptions)(options);
          this.setState(constants_1.SocksClientState.Created);
        }
        static createConnection(options, callback) {
          return new Promise((resolve, reject) => {
            try {
              (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
            } catch (err) {
              if (typeof callback === "function") {
                callback(err);
                return resolve(err);
              } else {
                return reject(err);
              }
            }
            const client = new SocksClient(options);
            client.connect(options.existing_socket);
            client.once("established", (info) => {
              client.removeAllListeners();
              if (typeof callback === "function") {
                callback(null, info);
                resolve(info);
              } else {
                resolve(info);
              }
            });
            client.once("error", (err) => {
              client.removeAllListeners();
              if (typeof callback === "function") {
                callback(err);
                resolve(err);
              } else {
                reject(err);
              }
            });
          });
        }
        static createConnectionChain(options, callback) {
          return new Promise((resolve, reject) =>
            __awaiter(this, void 0, void 0, function* () {
              try {
                (0, helpers_1.validateSocksClientChainOptions)(options);
              } catch (err) {
                if (typeof callback === "function") {
                  callback(err);
                  return resolve(err);
                } else {
                  return reject(err);
                }
              }
              if (options.randomizeChain) {
                (0, util_1.shuffleArray)(options.proxies);
              }
              try {
                let sock;
                for (let i = 0; i < options.proxies.length; i++) {
                  const nextProxy = options.proxies[i];
                  const nextDestination =
                    i === options.proxies.length - 1
                      ? options.destination
                      : {
                          host:
                            options.proxies[i + 1].host ||
                            options.proxies[i + 1].ipaddress,
                          port: options.proxies[i + 1].port,
                        };
                  const result = yield SocksClient.createConnection({
                    command: "connect",
                    proxy: nextProxy,
                    destination: nextDestination,
                    existing_socket: sock,
                  });
                  sock = sock || result.socket;
                }
                if (typeof callback === "function") {
                  callback(null, { socket: sock });
                  resolve({ socket: sock });
                } else {
                  resolve({ socket: sock });
                }
              } catch (err) {
                if (typeof callback === "function") {
                  callback(err);
                  resolve(err);
                } else {
                  reject(err);
                }
              }
            }),
          );
        }
        static createUDPFrame(options) {
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt16BE(0);
          buff.writeUInt8(options.frameNumber || 0);
          if (net.isIPv4(options.remoteHost.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv4);
            buff.writeUInt32BE(
              (0, helpers_1.ipv4ToInt32)(options.remoteHost.host),
            );
          } else if (net.isIPv6(options.remoteHost.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv6);
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(options.remoteHost.host),
            );
          } else {
            buff.writeUInt8(constants_1.Socks5HostType.Hostname);
            buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
            buff.writeString(options.remoteHost.host);
          }
          buff.writeUInt16BE(options.remoteHost.port);
          buff.writeBuffer(options.data);
          return buff.toBuffer();
        }
        static parseUDPFrame(data) {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const frameNumber = buff.readUInt8();
          const hostType = buff.readUInt8();
          let remoteHost;
          if (hostType === constants_1.Socks5HostType.IPv4) {
            remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
          } else if (hostType === constants_1.Socks5HostType.IPv6) {
            remoteHost = ip_address_1.Address6.fromByteArray(
              Array.from(buff.readBuffer(16)),
            ).canonicalForm();
          } else {
            remoteHost = buff.readString(buff.readUInt8());
          }
          const remotePort = buff.readUInt16BE();
          return {
            frameNumber,
            remoteHost: { host: remoteHost, port: remotePort },
            data: buff.readBuffer(),
          };
        }
        setState(newState) {
          if (this.state !== constants_1.SocksClientState.Error) {
            this.state = newState;
          }
        }
        connect(existingSocket) {
          this.onDataReceived = (data) => this.onDataReceivedHandler(data);
          this.onClose = () => this.onCloseHandler();
          this.onError = (err) => this.onErrorHandler(err);
          this.onConnect = () => this.onConnectHandler();
          const timer = setTimeout(
            () => this.onEstablishedTimeout(),
            this.options.timeout || constants_1.DEFAULT_TIMEOUT,
          );
          if (timer.unref && typeof timer.unref === "function") {
            timer.unref();
          }
          if (existingSocket) {
            this.socket = existingSocket;
          } else {
            this.socket = new net.Socket();
          }
          this.socket.once("close", this.onClose);
          this.socket.once("error", this.onError);
          this.socket.once("connect", this.onConnect);
          this.socket.on("data", this.onDataReceived);
          this.setState(constants_1.SocksClientState.Connecting);
          this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
          if (existingSocket) {
            this.socket.emit("connect");
          } else {
            this.socket.connect(this.getSocketOptions());
            if (
              this.options.set_tcp_nodelay !== undefined &&
              this.options.set_tcp_nodelay !== null
            ) {
              this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
            }
          }
          this.prependOnceListener("established", (info) => {
            setImmediate(() => {
              if (this.receiveBuffer.length > 0) {
                const excessData = this.receiveBuffer.get(
                  this.receiveBuffer.length,
                );
                info.socket.emit("data", excessData);
              }
              info.socket.resume();
            });
          });
        }
        getSocketOptions() {
          return Object.assign(Object.assign({}, this.options.socket_options), {
            host: this.options.proxy.host || this.options.proxy.ipaddress,
            port: this.options.proxy.port,
          });
        }
        onEstablishedTimeout() {
          if (
            this.state !== constants_1.SocksClientState.Established &&
            this.state !==
              constants_1.SocksClientState.BoundWaitingForConnection
          ) {
            this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
          }
        }
        onConnectHandler() {
          this.setState(constants_1.SocksClientState.Connected);
          if (this.options.proxy.type === 4) {
            this.sendSocks4InitialHandshake();
          } else {
            this.sendSocks5InitialHandshake();
          }
          this.setState(constants_1.SocksClientState.SentInitialHandshake);
        }
        onDataReceivedHandler(data) {
          this.receiveBuffer.append(data);
          this.processData();
        }
        processData() {
          while (
            this.state !== constants_1.SocksClientState.Established &&
            this.state !== constants_1.SocksClientState.Error &&
            this.receiveBuffer.length >= this.nextRequiredPacketBufferSize
          ) {
            if (
              this.state === constants_1.SocksClientState.SentInitialHandshake
            ) {
              if (this.options.proxy.type === 4) {
                this.handleSocks4FinalHandshakeResponse();
              } else {
                this.handleInitialSocks5HandshakeResponse();
              }
            } else if (
              this.state === constants_1.SocksClientState.SentAuthentication
            ) {
              this.handleInitialSocks5AuthenticationHandshakeResponse();
            } else if (
              this.state === constants_1.SocksClientState.SentFinalHandshake
            ) {
              this.handleSocks5FinalHandshakeResponse();
            } else if (
              this.state ===
              constants_1.SocksClientState.BoundWaitingForConnection
            ) {
              if (this.options.proxy.type === 4) {
                this.handleSocks4IncomingConnectionResponse();
              } else {
                this.handleSocks5IncomingConnectionResponse();
              }
            } else {
              this.closeSocket(constants_1.ERRORS.InternalError);
              break;
            }
          }
        }
        onCloseHandler() {
          this.closeSocket(constants_1.ERRORS.SocketClosed);
        }
        onErrorHandler(err) {
          this.closeSocket(err.message);
        }
        removeInternalSocketHandlers() {
          this.socket.pause();
          this.socket.removeListener("data", this.onDataReceived);
          this.socket.removeListener("close", this.onClose);
          this.socket.removeListener("error", this.onError);
          this.socket.removeListener("connect", this.onConnect);
        }
        closeSocket(err) {
          if (this.state !== constants_1.SocksClientState.Error) {
            this.setState(constants_1.SocksClientState.Error);
            this.socket.destroy();
            this.removeInternalSocketHandlers();
            this.emit("error", new util_1.SocksClientError(err, this.options));
          }
        }
        sendSocks4InitialHandshake() {
          const userId = this.options.proxy.userId || "";
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt8(4);
          buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
          buff.writeUInt16BE(this.options.destination.port);
          if (net.isIPv4(this.options.destination.host)) {
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(this.options.destination.host),
            );
            buff.writeStringNT(userId);
          } else {
            buff.writeUInt8(0);
            buff.writeUInt8(0);
            buff.writeUInt8(0);
            buff.writeUInt8(1);
            buff.writeStringNT(userId);
            buff.writeStringNT(this.options.destination.host);
          }
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
          this.socket.write(buff.toBuffer());
        }
        handleSocks4FinalHandshakeResponse() {
          const data = this.receiveBuffer.get(8);
          if (data[1] !== constants_1.Socks4Response.Granted) {
            this.closeSocket(
              `${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`,
            );
          } else {
            if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.bind
            ) {
              const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
              buff.readOffset = 2;
              const remoteHost = {
                port: buff.readUInt16BE(),
                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              };
              if (remoteHost.host === "0.0.0.0") {
                remoteHost.host = this.options.proxy.ipaddress;
              }
              this.setState(
                constants_1.SocksClientState.BoundWaitingForConnection,
              );
              this.emit("bound", { remoteHost, socket: this.socket });
            } else {
              this.setState(constants_1.SocksClientState.Established);
              this.removeInternalSocketHandlers();
              this.emit("established", { socket: this.socket });
            }
          }
        }
        handleSocks4IncomingConnectionResponse() {
          const data = this.receiveBuffer.get(8);
          if (data[1] !== constants_1.Socks4Response.Granted) {
            this.closeSocket(
              `${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`,
            );
          } else {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            };
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          }
        }
        sendSocks5InitialHandshake() {
          const buff = new smart_buffer_1.SmartBuffer();
          const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
          if (this.options.proxy.userId || this.options.proxy.password) {
            supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
          }
          if (this.options.proxy.custom_auth_method !== undefined) {
            supportedAuthMethods.push(this.options.proxy.custom_auth_method);
          }
          buff.writeUInt8(5);
          buff.writeUInt8(supportedAuthMethods.length);
          for (const authMethod of supportedAuthMethods) {
            buff.writeUInt8(authMethod);
          }
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
          this.socket.write(buff.toBuffer());
          this.setState(constants_1.SocksClientState.SentInitialHandshake);
        }
        handleInitialSocks5HandshakeResponse() {
          const data = this.receiveBuffer.get(2);
          if (data[0] !== 5) {
            this.closeSocket(
              constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion,
            );
          } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
            this.closeSocket(
              constants_1.ERRORS
                .InvalidSocks5InitialHandshakeNoAcceptedAuthType,
            );
          } else {
            if (data[1] === constants_1.Socks5Auth.NoAuth) {
              this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
              this.sendSocks5CommandRequest();
            } else if (data[1] === constants_1.Socks5Auth.UserPass) {
              this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
              this.sendSocks5UserPassAuthentication();
            } else if (data[1] === this.options.proxy.custom_auth_method) {
              this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
              this.sendSocks5CustomAuthentication();
            } else {
              this.closeSocket(
                constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType,
              );
            }
          }
        }
        sendSocks5UserPassAuthentication() {
          const userId = this.options.proxy.userId || "";
          const password = this.options.proxy.password || "";
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt8(1);
          buff.writeUInt8(Buffer.byteLength(userId));
          buff.writeString(userId);
          buff.writeUInt8(Buffer.byteLength(password));
          buff.writeString(password);
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
          this.socket.write(buff.toBuffer());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        }
        sendSocks5CustomAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            this.nextRequiredPacketBufferSize =
              this.options.proxy.custom_auth_response_size;
            this.socket.write(
              yield this.options.proxy.custom_auth_request_handler(),
            );
            this.setState(constants_1.SocksClientState.SentAuthentication);
          });
        }
        handleSocks5CustomAuthHandshakeResponse(data) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.options.proxy.custom_auth_response_handler(data);
          });
        }
        handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
          return __awaiter(this, void 0, void 0, function* () {
            return data[1] === 0;
          });
        }
        handleSocks5AuthenticationUserPassHandshakeResponse(data) {
          return __awaiter(this, void 0, void 0, function* () {
            return data[1] === 0;
          });
        }
        handleInitialSocks5AuthenticationHandshakeResponse() {
          return __awaiter(this, void 0, void 0, function* () {
            this.setState(
              constants_1.SocksClientState.ReceivedAuthenticationResponse,
            );
            let authResult = false;
            if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
              authResult =
                yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(
                  this.receiveBuffer.get(2),
                );
            } else if (
              this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass
            ) {
              authResult =
                yield this.handleSocks5AuthenticationUserPassHandshakeResponse(
                  this.receiveBuffer.get(2),
                );
            } else if (
              this.socks5ChosenAuthType ===
              this.options.proxy.custom_auth_method
            ) {
              authResult = yield this.handleSocks5CustomAuthHandshakeResponse(
                this.receiveBuffer.get(
                  this.options.proxy.custom_auth_response_size,
                ),
              );
            }
            if (!authResult) {
              this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
            } else {
              this.sendSocks5CommandRequest();
            }
          });
        }
        sendSocks5CommandRequest() {
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt8(5);
          buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
          buff.writeUInt8(0);
          if (net.isIPv4(this.options.destination.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv4);
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(this.options.destination.host),
            );
          } else if (net.isIPv6(this.options.destination.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv6);
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(this.options.destination.host),
            );
          } else {
            buff.writeUInt8(constants_1.Socks5HostType.Hostname);
            buff.writeUInt8(this.options.destination.host.length);
            buff.writeString(this.options.destination.host);
          }
          buff.writeUInt16BE(this.options.destination.port);
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.socket.write(buff.toBuffer());
          this.setState(constants_1.SocksClientState.SentFinalHandshake);
        }
        handleSocks5FinalHandshakeResponse() {
          const header = this.receiveBuffer.peek(5);
          if (
            header[0] !== 5 ||
            header[1] !== constants_1.Socks5Response.Granted
          ) {
            this.closeSocket(
              `${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`,
            );
          } else {
            const addressType = header[3];
            let remoteHost;
            let buff;
            if (addressType === constants_1.Socks5HostType.IPv4) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
                port: buff.readUInt16BE(),
              };
              if (remoteHost.host === "0.0.0.0") {
                remoteHost.host = this.options.proxy.ipaddress;
              }
            } else if (addressType === constants_1.Socks5HostType.Hostname) {
              const hostLength = header[4];
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(
                  hostLength,
                );
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(5),
              );
              remoteHost = {
                host: buff.readString(hostLength),
                port: buff.readUInt16BE(),
              };
            } else if (addressType === constants_1.Socks5HostType.IPv6) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: ip_address_1.Address6.fromByteArray(
                  Array.from(buff.readBuffer(16)),
                ).canonicalForm(),
                port: buff.readUInt16BE(),
              };
            }
            this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
            if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.connect
            ) {
              this.setState(constants_1.SocksClientState.Established);
              this.removeInternalSocketHandlers();
              this.emit("established", { remoteHost, socket: this.socket });
            } else if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.bind
            ) {
              this.setState(
                constants_1.SocksClientState.BoundWaitingForConnection,
              );
              this.nextRequiredPacketBufferSize =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
              this.emit("bound", { remoteHost, socket: this.socket });
            } else if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.associate
            ) {
              this.setState(constants_1.SocksClientState.Established);
              this.removeInternalSocketHandlers();
              this.emit("established", { remoteHost, socket: this.socket });
            }
          }
        }
        handleSocks5IncomingConnectionResponse() {
          const header = this.receiveBuffer.peek(5);
          if (
            header[0] !== 5 ||
            header[1] !== constants_1.Socks5Response.Granted
          ) {
            this.closeSocket(
              `${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`,
            );
          } else {
            const addressType = header[3];
            let remoteHost;
            let buff;
            if (addressType === constants_1.Socks5HostType.IPv4) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
                port: buff.readUInt16BE(),
              };
              if (remoteHost.host === "0.0.0.0") {
                remoteHost.host = this.options.proxy.ipaddress;
              }
            } else if (addressType === constants_1.Socks5HostType.Hostname) {
              const hostLength = header[4];
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(
                  hostLength,
                );
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(5),
              );
              remoteHost = {
                host: buff.readString(hostLength),
                port: buff.readUInt16BE(),
              };
            } else if (addressType === constants_1.Socks5HostType.IPv6) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: ip_address_1.Address6.fromByteArray(
                  Array.from(buff.readBuffer(16)),
                ).canonicalForm(),
                port: buff.readUInt16BE(),
              };
            }
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          }
        }
        get socksClientOptions() {
          return Object.assign({}, this.options);
        }
      }
      exports.SocksClient = SocksClient;
    },
    9647: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SOCKS5_NO_ACCEPTABLE_AUTH =
        exports.SOCKS5_CUSTOM_AUTH_END =
        exports.SOCKS5_CUSTOM_AUTH_START =
        exports.SOCKS_INCOMING_PACKET_SIZES =
        exports.SocksClientState =
        exports.Socks5Response =
        exports.Socks5HostType =
        exports.Socks5Auth =
        exports.Socks4Response =
        exports.SocksCommand =
        exports.ERRORS =
        exports.DEFAULT_TIMEOUT =
          void 0;
      const DEFAULT_TIMEOUT = 3e4;
      exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
      const ERRORS = {
        InvalidSocksCommand:
          "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
        InvalidSocksCommandForOperation:
          "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
        InvalidSocksCommandChain:
          "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
        InvalidSocksClientOptionsDestination:
          "An invalid destination host was provided.",
        InvalidSocksClientOptionsExistingSocket:
          "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
        InvalidSocksClientOptionsProxy:
          "Invalid SOCKS proxy details were provided.",
        InvalidSocksClientOptionsTimeout:
          "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
        InvalidSocksClientOptionsProxiesLength:
          "At least two socks proxies must be provided for chaining.",
        InvalidSocksClientOptionsCustomAuthRange:
          "Custom auth must be a value between 0x80 and 0xFE.",
        InvalidSocksClientOptionsCustomAuthOptions:
          "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
        NegotiationError: "Negotiation error",
        SocketClosed: "Socket closed",
        ProxyConnectionTimedOut: "Proxy connection timed out",
        InternalError: "SocksClient internal error (this should not happen)",
        InvalidSocks4HandshakeResponse:
          "Received invalid Socks4 handshake response",
        Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
        InvalidSocks4IncomingConnectionResponse:
          "Socks4 invalid incoming connection response",
        Socks4ProxyRejectedIncomingBoundConnection:
          "Socks4 Proxy rejected incoming bound connection",
        InvalidSocks5InitialHandshakeResponse:
          "Received invalid Socks5 initial handshake response",
        InvalidSocks5IntiailHandshakeSocksVersion:
          "Received invalid Socks5 initial handshake (invalid socks version)",
        InvalidSocks5InitialHandshakeNoAcceptedAuthType:
          "Received invalid Socks5 initial handshake (no accepted authentication type)",
        InvalidSocks5InitialHandshakeUnknownAuthType:
          "Received invalid Socks5 initial handshake (unknown authentication type)",
        Socks5AuthenticationFailed: "Socks5 Authentication failed",
        InvalidSocks5FinalHandshake:
          "Received invalid Socks5 final handshake response",
        InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
        InvalidSocks5IncomingConnectionResponse:
          "Received invalid Socks5 incoming connection response",
        Socks5ProxyRejectedIncomingBoundConnection:
          "Socks5 Proxy rejected incoming bound connection",
      };
      exports.ERRORS = ERRORS;
      const SOCKS_INCOMING_PACKET_SIZES = {
        Socks5InitialHandshakeResponse: 2,
        Socks5UserPassAuthenticationResponse: 2,
        Socks5ResponseHeader: 5,
        Socks5ResponseIPv4: 10,
        Socks5ResponseIPv6: 22,
        Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
        Socks4Response: 8,
      };
      exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
      var SocksCommand;
      (function (SocksCommand) {
        SocksCommand[(SocksCommand["connect"] = 1)] = "connect";
        SocksCommand[(SocksCommand["bind"] = 2)] = "bind";
        SocksCommand[(SocksCommand["associate"] = 3)] = "associate";
      })(SocksCommand || (exports.SocksCommand = SocksCommand = {}));
      var Socks4Response;
      (function (Socks4Response) {
        Socks4Response[(Socks4Response["Granted"] = 90)] = "Granted";
        Socks4Response[(Socks4Response["Failed"] = 91)] = "Failed";
        Socks4Response[(Socks4Response["Rejected"] = 92)] = "Rejected";
        Socks4Response[(Socks4Response["RejectedIdent"] = 93)] =
          "RejectedIdent";
      })(Socks4Response || (exports.Socks4Response = Socks4Response = {}));
      var Socks5Auth;
      (function (Socks5Auth) {
        Socks5Auth[(Socks5Auth["NoAuth"] = 0)] = "NoAuth";
        Socks5Auth[(Socks5Auth["GSSApi"] = 1)] = "GSSApi";
        Socks5Auth[(Socks5Auth["UserPass"] = 2)] = "UserPass";
      })(Socks5Auth || (exports.Socks5Auth = Socks5Auth = {}));
      const SOCKS5_CUSTOM_AUTH_START = 128;
      exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
      const SOCKS5_CUSTOM_AUTH_END = 254;
      exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
      const SOCKS5_NO_ACCEPTABLE_AUTH = 255;
      exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
      var Socks5Response;
      (function (Socks5Response) {
        Socks5Response[(Socks5Response["Granted"] = 0)] = "Granted";
        Socks5Response[(Socks5Response["Failure"] = 1)] = "Failure";
        Socks5Response[(Socks5Response["NotAllowed"] = 2)] = "NotAllowed";
        Socks5Response[(Socks5Response["NetworkUnreachable"] = 3)] =
          "NetworkUnreachable";
        Socks5Response[(Socks5Response["HostUnreachable"] = 4)] =
          "HostUnreachable";
        Socks5Response[(Socks5Response["ConnectionRefused"] = 5)] =
          "ConnectionRefused";
        Socks5Response[(Socks5Response["TTLExpired"] = 6)] = "TTLExpired";
        Socks5Response[(Socks5Response["CommandNotSupported"] = 7)] =
          "CommandNotSupported";
        Socks5Response[(Socks5Response["AddressNotSupported"] = 8)] =
          "AddressNotSupported";
      })(Socks5Response || (exports.Socks5Response = Socks5Response = {}));
      var Socks5HostType;
      (function (Socks5HostType) {
        Socks5HostType[(Socks5HostType["IPv4"] = 1)] = "IPv4";
        Socks5HostType[(Socks5HostType["Hostname"] = 3)] = "Hostname";
        Socks5HostType[(Socks5HostType["IPv6"] = 4)] = "IPv6";
      })(Socks5HostType || (exports.Socks5HostType = Socks5HostType = {}));
      var SocksClientState;
      (function (SocksClientState) {
        SocksClientState[(SocksClientState["Created"] = 0)] = "Created";
        SocksClientState[(SocksClientState["Connecting"] = 1)] = "Connecting";
        SocksClientState[(SocksClientState["Connected"] = 2)] = "Connected";
        SocksClientState[(SocksClientState["SentInitialHandshake"] = 3)] =
          "SentInitialHandshake";
        SocksClientState[
          (SocksClientState["ReceivedInitialHandshakeResponse"] = 4)
        ] = "ReceivedInitialHandshakeResponse";
        SocksClientState[(SocksClientState["SentAuthentication"] = 5)] =
          "SentAuthentication";
        SocksClientState[
          (SocksClientState["ReceivedAuthenticationResponse"] = 6)
        ] = "ReceivedAuthenticationResponse";
        SocksClientState[(SocksClientState["SentFinalHandshake"] = 7)] =
          "SentFinalHandshake";
        SocksClientState[(SocksClientState["ReceivedFinalResponse"] = 8)] =
          "ReceivedFinalResponse";
        SocksClientState[(SocksClientState["BoundWaitingForConnection"] = 9)] =
          "BoundWaitingForConnection";
        SocksClientState[(SocksClientState["Established"] = 10)] =
          "Established";
        SocksClientState[(SocksClientState["Disconnected"] = 11)] =
          "Disconnected";
        SocksClientState[(SocksClientState["Error"] = 99)] = "Error";
      })(
        SocksClientState || (exports.SocksClientState = SocksClientState = {}),
      );
    },
    4324: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ipToBuffer =
        exports.int32ToIpv4 =
        exports.ipv4ToInt32 =
        exports.validateSocksClientChainOptions =
        exports.validateSocksClientOptions =
          void 0;
      const util_1 = __nccwpck_require__(5523);
      const constants_1 = __nccwpck_require__(9647);
      const stream = __nccwpck_require__(2781);
      const ip_address_1 = __nccwpck_require__(8953);
      const net = __nccwpck_require__(1808);
      function validateSocksClientOptions(
        options,
        acceptedCommands = ["connect", "bind", "associate"],
      ) {
        if (!constants_1.SocksCommand[options.command]) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksCommand,
            options,
          );
        }
        if (acceptedCommands.indexOf(options.command) === -1) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksCommandForOperation,
            options,
          );
        }
        if (!isValidSocksRemoteHost(options.destination)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsDestination,
            options,
          );
        }
        if (!isValidSocksProxy(options.proxy)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsProxy,
            options,
          );
        }
        validateCustomProxyAuth(options.proxy, options);
        if (options.timeout && !isValidTimeoutValue(options.timeout)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsTimeout,
            options,
          );
        }
        if (
          options.existing_socket &&
          !(options.existing_socket instanceof stream.Duplex)
        ) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket,
            options,
          );
        }
      }
      exports.validateSocksClientOptions = validateSocksClientOptions;
      function validateSocksClientChainOptions(options) {
        if (options.command !== "connect") {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksCommandChain,
            options,
          );
        }
        if (!isValidSocksRemoteHost(options.destination)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsDestination,
            options,
          );
        }
        if (
          !(
            options.proxies &&
            Array.isArray(options.proxies) &&
            options.proxies.length >= 2
          )
        ) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength,
            options,
          );
        }
        options.proxies.forEach((proxy) => {
          if (!isValidSocksProxy(proxy)) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsProxy,
              options,
            );
          }
          validateCustomProxyAuth(proxy, options);
        });
        if (options.timeout && !isValidTimeoutValue(options.timeout)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsTimeout,
            options,
          );
        }
      }
      exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
      function validateCustomProxyAuth(proxy, options) {
        if (proxy.custom_auth_method !== undefined) {
          if (
            proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START ||
            proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END
          ) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange,
              options,
            );
          }
          if (
            proxy.custom_auth_request_handler === undefined ||
            typeof proxy.custom_auth_request_handler !== "function"
          ) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,
              options,
            );
          }
          if (proxy.custom_auth_response_size === undefined) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,
              options,
            );
          }
          if (
            proxy.custom_auth_response_handler === undefined ||
            typeof proxy.custom_auth_response_handler !== "function"
          ) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,
              options,
            );
          }
        }
      }
      function isValidSocksRemoteHost(remoteHost) {
        return (
          remoteHost &&
          typeof remoteHost.host === "string" &&
          typeof remoteHost.port === "number" &&
          remoteHost.port >= 0 &&
          remoteHost.port <= 65535
        );
      }
      function isValidSocksProxy(proxy) {
        return (
          proxy &&
          (typeof proxy.host === "string" ||
            typeof proxy.ipaddress === "string") &&
          typeof proxy.port === "number" &&
          proxy.port >= 0 &&
          proxy.port <= 65535 &&
          (proxy.type === 4 || proxy.type === 5)
        );
      }
      function isValidTimeoutValue(value) {
        return typeof value === "number" && value > 0;
      }
      function ipv4ToInt32(ip) {
        const address = new ip_address_1.Address4(ip);
        return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
      }
      exports.ipv4ToInt32 = ipv4ToInt32;
      function int32ToIpv4(int32) {
        const octet1 = (int32 >>> 24) & 255;
        const octet2 = (int32 >>> 16) & 255;
        const octet3 = (int32 >>> 8) & 255;
        const octet4 = int32 & 255;
        return [octet1, octet2, octet3, octet4].join(".");
      }
      exports.int32ToIpv4 = int32ToIpv4;
      function ipToBuffer(ip) {
        if (net.isIPv4(ip)) {
          const address = new ip_address_1.Address4(ip);
          return Buffer.from(address.toArray());
        } else if (net.isIPv6(ip)) {
          const address = new ip_address_1.Address6(ip);
          return Buffer.from(
            address
              .canonicalForm()
              .split(":")
              .map((segment) => segment.padStart(4, "0"))
              .join(""),
            "hex",
          );
        } else {
          throw new Error("Invalid IP address format");
        }
      }
      exports.ipToBuffer = ipToBuffer;
    },
    9740: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReceiveBuffer = void 0;
      class ReceiveBuffer {
        constructor(size = 4096) {
          this.buffer = Buffer.allocUnsafe(size);
          this.offset = 0;
          this.originalSize = size;
        }
        get length() {
          return this.offset;
        }
        append(data) {
          if (!Buffer.isBuffer(data)) {
            throw new Error(
              "Attempted to append a non-buffer instance to ReceiveBuffer.",
            );
          }
          if (this.offset + data.length >= this.buffer.length) {
            const tmp = this.buffer;
            this.buffer = Buffer.allocUnsafe(
              Math.max(
                this.buffer.length + this.originalSize,
                this.buffer.length + data.length,
              ),
            );
            tmp.copy(this.buffer);
          }
          data.copy(this.buffer, this.offset);
          return (this.offset += data.length);
        }
        peek(length) {
          if (length > this.offset) {
            throw new Error(
              "Attempted to read beyond the bounds of the managed internal data.",
            );
          }
          return this.buffer.slice(0, length);
        }
        get(length) {
          if (length > this.offset) {
            throw new Error(
              "Attempted to read beyond the bounds of the managed internal data.",
            );
          }
          const value = Buffer.allocUnsafe(length);
          this.buffer.slice(0, length).copy(value);
          this.buffer.copyWithin(0, length, length + this.offset - length);
          this.offset -= length;
          return value;
        }
      }
      exports.ReceiveBuffer = ReceiveBuffer;
    },
    5523: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shuffleArray = exports.SocksClientError = void 0;
      class SocksClientError extends Error {
        constructor(message, options) {
          super(message);
          this.options = options;
        }
      }
      exports.SocksClientError = SocksClientError;
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      exports.shuffleArray = shuffleArray;
    },
    4754: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(__nccwpck_require__(6127), exports);
    },
    2372: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var parse = __nccwpck_require__(1620);
      var spdxLicenseIds = __nccwpck_require__(6033);
      function valid(string) {
        try {
          parse(string);
          return true;
        } catch (error) {
          return false;
        }
      }
      function sortTranspositions(a, b) {
        var length = b[0].length - a[0].length;
        if (length !== 0) return length;
        return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
      }
      var transpositions = [
        ["APGL", "AGPL"],
        ["Gpl", "GPL"],
        ["GLP", "GPL"],
        ["APL", "Apache"],
        ["ISD", "ISC"],
        ["GLP", "GPL"],
        ["IST", "ISC"],
        ["Claude", "Clause"],
        [" or later", "+"],
        [" International", ""],
        ["GNU", "GPL"],
        ["GUN", "GPL"],
        ["+", ""],
        ["GNU GPL", "GPL"],
        ["GNU LGPL", "LGPL"],
        ["GNU/GPL", "GPL"],
        ["GNU GLP", "GPL"],
        ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
        ["GNU Lesser General Public License", "LGPL"],
        ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
        ["GNU Lesser General Public License", "LGPL-2.1"],
        ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
        ["Lesser General Public License", "LGPL"],
        ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
        ["Lesser General Public License", "LGPL-2.1"],
        ["GNU General Public License", "GPL"],
        ["Gnu public license", "GPL"],
        ["GNU Public License", "GPL"],
        ["GNU GENERAL PUBLIC LICENSE", "GPL"],
        ["MTI", "MIT"],
        ["Mozilla Public License", "MPL"],
        ["Universal Permissive License", "UPL"],
        ["WTH", "WTF"],
        ["WTFGPL", "WTFPL"],
        ["-License", ""],
      ].sort(sortTranspositions);
      var TRANSPOSED = 0;
      var CORRECT = 1;
      var transforms = [
        function (argument) {
          return argument.toUpperCase();
        },
        function (argument) {
          return argument.trim();
        },
        function (argument) {
          return argument.replace(/\./g, "");
        },
        function (argument) {
          return argument.replace(/\s+/g, "");
        },
        function (argument) {
          return argument.replace(/\s+/g, "-");
        },
        function (argument) {
          return argument.replace("v", "-");
        },
        function (argument) {
          return argument.replace(/,?\s*(\d)/, "-$1");
        },
        function (argument) {
          return argument.replace(/,?\s*(\d)/, "-$1.0");
        },
        function (argument) {
          return argument.replace(
            /,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/,
            "-$2",
          );
        },
        function (argument) {
          return argument.replace(
            /,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/,
            "-$2.0",
          );
        },
        function (argument) {
          return argument[0].toUpperCase() + argument.slice(1);
        },
        function (argument) {
          return argument.replace("/", "-");
        },
        function (argument) {
          return argument
            .replace(/\s*V\s*(\d)/, "-$1")
            .replace(/(\d)$/, "$1.0");
        },
        function (argument) {
          if (argument.indexOf("3.0") !== -1) {
            return argument + "-or-later";
          } else {
            return argument + "-only";
          }
        },
        function (argument) {
          return argument + "only";
        },
        function (argument) {
          return argument.replace(/(\d)$/, "-$1.0");
        },
        function (argument) {
          return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
        },
        function (argument) {
          return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
        },
        function (argument) {
          return argument.replace(
            /\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i,
            "BSD-3-Clause",
          );
        },
        function (argument) {
          return argument.replace(
            /\bSimplified(-| )?BSD((-| )License)?/i,
            "BSD-2-Clause",
          );
        },
        function (argument) {
          return argument.replace(
            /\b(Free|Net)(-| )?BSD((-| )License)?/i,
            "BSD-2-Clause-$1BSD",
          );
        },
        function (argument) {
          return argument.replace(
            /\bClear(-| )?BSD((-| )License)?/i,
            "BSD-3-Clause-Clear",
          );
        },
        function (argument) {
          return argument.replace(
            /\b(Old|Original)(-| )?BSD((-| )License)?/i,
            "BSD-4-Clause",
          );
        },
        function (argument) {
          return "CC-" + argument;
        },
        function (argument) {
          return "CC-" + argument + "-4.0";
        },
        function (argument) {
          return argument
            .replace("Attribution", "BY")
            .replace("NonCommercial", "NC")
            .replace("NoDerivatives", "ND")
            .replace(/ (\d)/, "-$1")
            .replace(/ ?International/, "");
        },
        function (argument) {
          return (
            "CC-" +
            argument
              .replace("Attribution", "BY")
              .replace("NonCommercial", "NC")
              .replace("NoDerivatives", "ND")
              .replace(/ (\d)/, "-$1")
              .replace(/ ?International/, "") +
            "-4.0"
          );
        },
      ];
      var licensesWithVersions = spdxLicenseIds
        .map(function (id) {
          var match = /^(.*)-\d+\.\d+$/.exec(id);
          return match ? [match[0], match[1]] : [id, null];
        })
        .reduce(function (objectMap, item) {
          var key = item[1];
          objectMap[key] = objectMap[key] || [];
          objectMap[key].push(item[0]);
          return objectMap;
        }, {});
      var licensesWithOneVersion = Object.keys(licensesWithVersions)
        .map(function makeEntries(key) {
          return [key, licensesWithVersions[key]];
        })
        .filter(function identifySoleVersions(item) {
          return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
        })
        .map(function createLastResorts(item) {
          return [item[0], item[1][0]];
        });
      licensesWithVersions = undefined;
      var lastResorts = [
        ["UNLI", "Unlicense"],
        ["WTF", "WTFPL"],
        ["2 CLAUSE", "BSD-2-Clause"],
        ["2-CLAUSE", "BSD-2-Clause"],
        ["3 CLAUSE", "BSD-3-Clause"],
        ["3-CLAUSE", "BSD-3-Clause"],
        ["AFFERO", "AGPL-3.0-or-later"],
        ["AGPL", "AGPL-3.0-or-later"],
        ["APACHE", "Apache-2.0"],
        ["ARTISTIC", "Artistic-2.0"],
        ["Affero", "AGPL-3.0-or-later"],
        ["BEER", "Beerware"],
        ["BOOST", "BSL-1.0"],
        ["BSD", "BSD-2-Clause"],
        ["CDDL", "CDDL-1.1"],
        ["ECLIPSE", "EPL-1.0"],
        ["FUCK", "WTFPL"],
        ["GNU", "GPL-3.0-or-later"],
        ["LGPL", "LGPL-3.0-or-later"],
        ["GPLV1", "GPL-1.0-only"],
        ["GPL-1", "GPL-1.0-only"],
        ["GPLV2", "GPL-2.0-only"],
        ["GPL-2", "GPL-2.0-only"],
        ["GPL", "GPL-3.0-or-later"],
        ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
        ["MIT", "MIT"],
        ["MPL", "MPL-2.0"],
        ["X11", "X11"],
        ["ZLIB", "Zlib"],
      ]
        .concat(licensesWithOneVersion)
        .sort(sortTranspositions);
      var SUBSTRING = 0;
      var IDENTIFIER = 1;
      var validTransformation = function (identifier) {
        for (var i = 0; i < transforms.length; i++) {
          var transformed = transforms[i](identifier).trim();
          if (transformed !== identifier && valid(transformed)) {
            return transformed;
          }
        }
        return null;
      };
      var validLastResort = function (identifier) {
        var upperCased = identifier.toUpperCase();
        for (var i = 0; i < lastResorts.length; i++) {
          var lastResort = lastResorts[i];
          if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
            return lastResort[IDENTIFIER];
          }
        }
        return null;
      };
      var anyCorrection = function (identifier, check) {
        for (var i = 0; i < transpositions.length; i++) {
          var transposition = transpositions[i];
          var transposed = transposition[TRANSPOSED];
          if (identifier.indexOf(transposed) > -1) {
            var corrected = identifier.replace(
              transposed,
              transposition[CORRECT],
            );
            var checked = check(corrected);
            if (checked !== null) {
              return checked;
            }
          }
        }
        return null;
      };
      module.exports = function (identifier, options) {
        options = options || {};
        var upgrade = options.upgrade === undefined ? true : !!options.upgrade;
        function postprocess(value) {
          return upgrade ? upgradeGPLs(value) : value;
        }
        var validArugment =
          typeof identifier === "string" && identifier.trim().length !== 0;
        if (!validArugment) {
          throw Error("Invalid argument. Expected non-empty string.");
        }
        identifier = identifier.trim();
        if (valid(identifier)) {
          return postprocess(identifier);
        }
        var noPlus = identifier.replace(/\+$/, "").trim();
        if (valid(noPlus)) {
          return postprocess(noPlus);
        }
        var transformed = validTransformation(identifier);
        if (transformed !== null) {
          return postprocess(transformed);
        }
        transformed = anyCorrection(identifier, function (argument) {
          if (valid(argument)) {
            return argument;
          }
          return validTransformation(argument);
        });
        if (transformed !== null) {
          return postprocess(transformed);
        }
        transformed = validLastResort(identifier);
        if (transformed !== null) {
          return postprocess(transformed);
        }
        transformed = anyCorrection(identifier, validLastResort);
        if (transformed !== null) {
          return postprocess(transformed);
        }
        return null;
      };
      function upgradeGPLs(value) {
        if (
          [
            "GPL-1.0",
            "LGPL-1.0",
            "AGPL-1.0",
            "GPL-2.0",
            "LGPL-2.0",
            "AGPL-2.0",
            "LGPL-2.1",
          ].indexOf(value) !== -1
        ) {
          return value + "-only";
        } else if (
          [
            "GPL-1.0+",
            "GPL-2.0+",
            "GPL-3.0+",
            "LGPL-2.0+",
            "LGPL-2.1+",
            "LGPL-3.0+",
            "AGPL-1.0+",
            "AGPL-3.0+",
          ].indexOf(value) !== -1
        ) {
          return value.replace(/\+$/, "-or-later");
        } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
          return value + "-or-later";
        } else {
          return value;
        }
      }
    },
    1620: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var scan = __nccwpck_require__(7380);
      var parse = __nccwpck_require__(9868);
      module.exports = function (source) {
        return parse(scan(source));
      };
    },
    9868: (module) => {
      "use strict";
      module.exports = function (tokens) {
        var index = 0;
        function hasMore() {
          return index < tokens.length;
        }
        function token() {
          return hasMore() ? tokens[index] : null;
        }
        function next() {
          if (!hasMore()) {
            throw new Error();
          }
          index++;
        }
        function parseOperator(operator) {
          var t = token();
          if (t && t.type === "OPERATOR" && operator === t.string) {
            next();
            return t.string;
          }
        }
        function parseWith() {
          if (parseOperator("WITH")) {
            var t = token();
            if (t && t.type === "EXCEPTION") {
              next();
              return t.string;
            }
            throw new Error("Expected exception after `WITH`");
          }
        }
        function parseLicenseRef() {
          var begin = index;
          var string = "";
          var t = token();
          if (t.type === "DOCUMENTREF") {
            next();
            string += "DocumentRef-" + t.string + ":";
            if (!parseOperator(":")) {
              throw new Error("Expected `:` after `DocumentRef-...`");
            }
          }
          t = token();
          if (t.type === "LICENSEREF") {
            next();
            string += "LicenseRef-" + t.string;
            return { license: string };
          }
          index = begin;
        }
        function parseLicense() {
          var t = token();
          if (t && t.type === "LICENSE") {
            next();
            var node = { license: t.string };
            if (parseOperator("+")) {
              node.plus = true;
            }
            var exception = parseWith();
            if (exception) {
              node.exception = exception;
            }
            return node;
          }
        }
        function parseParenthesizedExpression() {
          var left = parseOperator("(");
          if (!left) {
            return;
          }
          var expr = parseExpression();
          if (!parseOperator(")")) {
            throw new Error("Expected `)`");
          }
          return expr;
        }
        function parseAtom() {
          return (
            parseParenthesizedExpression() ||
            parseLicenseRef() ||
            parseLicense()
          );
        }
        function makeBinaryOpParser(operator, nextParser) {
          return function parseBinaryOp() {
            var left = nextParser();
            if (!left) {
              return;
            }
            if (!parseOperator(operator)) {
              return left;
            }
            var right = parseBinaryOp();
            if (!right) {
              throw new Error("Expected expression");
            }
            return { left, conjunction: operator.toLowerCase(), right };
          };
        }
        var parseAnd = makeBinaryOpParser("AND", parseAtom);
        var parseExpression = makeBinaryOpParser("OR", parseAnd);
        var node = parseExpression();
        if (!node || hasMore()) {
          throw new Error("Syntax error");
        }
        return node;
      };
    },
    7380: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var licenses = []
        .concat(__nccwpck_require__(6033))
        .concat(__nccwpck_require__(6765));
      var exceptions = __nccwpck_require__(238);
      module.exports = function (source) {
        var index = 0;
        function hasMore() {
          return index < source.length;
        }
        function read(value) {
          if (value instanceof RegExp) {
            var chars = source.slice(index);
            var match = chars.match(value);
            if (match) {
              index += match[0].length;
              return match[0];
            }
          } else {
            if (source.indexOf(value, index) === index) {
              index += value.length;
              return value;
            }
          }
        }
        function skipWhitespace() {
          read(/[ ]*/);
        }
        function operator() {
          var string;
          var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
          for (var i = 0; i < possibilities.length; i++) {
            string = read(possibilities[i]);
            if (string) {
              break;
            }
          }
          if (string === "+" && index > 1 && source[index - 2] === " ") {
            throw new Error("Space before `+`");
          }
          return string && { type: "OPERATOR", string };
        }
        function idstring() {
          return read(/[A-Za-z0-9-.]+/);
        }
        function expectIdstring() {
          var string = idstring();
          if (!string) {
            throw new Error("Expected idstring at offset " + index);
          }
          return string;
        }
        function documentRef() {
          if (read("DocumentRef-")) {
            var string = expectIdstring();
            return { type: "DOCUMENTREF", string };
          }
        }
        function licenseRef() {
          if (read("LicenseRef-")) {
            var string = expectIdstring();
            return { type: "LICENSEREF", string };
          }
        }
        function identifier() {
          var begin = index;
          var string = idstring();
          if (licenses.indexOf(string) !== -1) {
            return { type: "LICENSE", string };
          } else if (exceptions.indexOf(string) !== -1) {
            return { type: "EXCEPTION", string };
          }
          index = begin;
        }
        function parseToken() {
          return operator() || documentRef() || licenseRef() || identifier();
        }
        var tokens = [];
        while (hasMore()) {
          skipWhitespace();
          if (!hasMore()) {
            break;
          }
          var token = parseToken();
          if (!token) {
            throw new Error(
              "Unexpected `" + source[index] + "` at offset " + index,
            );
          }
          tokens.push(token);
        }
        return tokens;
      };
    },
    3988: (__unused_webpack_module, exports) => {
      !(function () {
        "use strict";
        var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder:
            /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/,
        };
        function sprintf(key) {
          return sprintf_format(sprintf_parse(key), arguments);
        }
        function vsprintf(fmt, argv) {
          return sprintf.apply(null, [fmt].concat(argv || []));
        }
        function sprintf_format(parse_tree, argv) {
          var cursor = 1,
            tree_length = parse_tree.length,
            arg,
            output = "",
            i,
            k,
            ph,
            pad,
            pad_character,
            pad_length,
            is_positive,
            sign;
          for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === "string") {
              output += parse_tree[i];
            } else if (typeof parse_tree[i] === "object") {
              ph = parse_tree[i];
              if (ph.keys) {
                arg = argv[cursor];
                for (k = 0; k < ph.keys.length; k++) {
                  if (arg == undefined) {
                    throw new Error(
                      sprintf(
                        '[sprintf] Cannot access property "%s" of undefined value "%s"',
                        ph.keys[k],
                        ph.keys[k - 1],
                      ),
                    );
                  }
                  arg = arg[ph.keys[k]];
                }
              } else if (ph.param_no) {
                arg = argv[ph.param_no];
              } else {
                arg = argv[cursor++];
              }
              if (
                re.not_type.test(ph.type) &&
                re.not_primitive.test(ph.type) &&
                arg instanceof Function
              ) {
                arg = arg();
              }
              if (
                re.numeric_arg.test(ph.type) &&
                typeof arg !== "number" &&
                isNaN(arg)
              ) {
                throw new TypeError(
                  sprintf("[sprintf] expecting number but found %T", arg),
                );
              }
              if (re.number.test(ph.type)) {
                is_positive = arg >= 0;
              }
              switch (ph.type) {
                case "b":
                  arg = parseInt(arg, 10).toString(2);
                  break;
                case "c":
                  arg = String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                case "i":
                  arg = parseInt(arg, 10);
                  break;
                case "j":
                  arg = JSON.stringify(
                    arg,
                    null,
                    ph.width ? parseInt(ph.width) : 0,
                  );
                  break;
                case "e":
                  arg = ph.precision
                    ? parseFloat(arg).toExponential(ph.precision)
                    : parseFloat(arg).toExponential();
                  break;
                case "f":
                  arg = ph.precision
                    ? parseFloat(arg).toFixed(ph.precision)
                    : parseFloat(arg);
                  break;
                case "g":
                  arg = ph.precision
                    ? String(Number(arg.toPrecision(ph.precision)))
                    : parseFloat(arg);
                  break;
                case "o":
                  arg = (parseInt(arg, 10) >>> 0).toString(8);
                  break;
                case "s":
                  arg = String(arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "t":
                  arg = String(!!arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "T":
                  arg = Object.prototype.toString
                    .call(arg)
                    .slice(8, -1)
                    .toLowerCase();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "u":
                  arg = parseInt(arg, 10) >>> 0;
                  break;
                case "v":
                  arg = arg.valueOf();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "x":
                  arg = (parseInt(arg, 10) >>> 0).toString(16);
                  break;
                case "X":
                  arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                  break;
              }
              if (re.json.test(ph.type)) {
                output += arg;
              } else {
                if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                  sign = is_positive ? "+" : "-";
                  arg = arg.toString().replace(re.sign, "");
                } else {
                  sign = "";
                }
                pad_character = ph.pad_char
                  ? ph.pad_char === "0"
                    ? "0"
                    : ph.pad_char.charAt(1)
                  : " ";
                pad_length = ph.width - (sign + arg).length;
                pad = ph.width
                  ? pad_length > 0
                    ? pad_character.repeat(pad_length)
                    : ""
                  : "";
                output += ph.align
                  ? sign + arg + pad
                  : pad_character === "0"
                    ? sign + pad + arg
                    : pad + sign + arg;
              }
            }
          }
          return output;
        }
        var sprintf_cache = Object.create(null);
        function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
          }
          var _fmt = fmt,
            match,
            parse_tree = [],
            arg_names = 0;
          while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
              parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
              parse_tree.push("%");
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
              if (match[2]) {
                arg_names |= 1;
                var field_list = [],
                  replacement_field = match[2],
                  field_match = [];
                if ((field_match = re.key.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                  while (
                    (replacement_field = replacement_field.substring(
                      field_match[0].length,
                    )) !== ""
                  ) {
                    if (
                      (field_match = re.key_access.exec(replacement_field)) !==
                      null
                    ) {
                      field_list.push(field_match[1]);
                    } else if (
                      (field_match =
                        re.index_access.exec(replacement_field)) !== null
                    ) {
                      field_list.push(field_match[1]);
                    } else {
                      throw new SyntaxError(
                        "[sprintf] failed to parse named argument key",
                      );
                    }
                  }
                } else {
                  throw new SyntaxError(
                    "[sprintf] failed to parse named argument key",
                  );
                }
                match[2] = field_list;
              } else {
                arg_names |= 2;
              }
              if (arg_names === 3) {
                throw new Error(
                  "[sprintf] mixing positional and named placeholders is not (yet) supported",
                );
              }
              parse_tree.push({
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8],
              });
            } else {
              throw new SyntaxError("[sprintf] unexpected placeholder");
            }
            _fmt = _fmt.substring(match[0].length);
          }
          return (sprintf_cache[fmt] = parse_tree);
        }
        if (true) {
          exports.sprintf = sprintf;
          exports.vsprintf = vsprintf;
        }
        if (typeof window !== "undefined") {
          window["sprintf"] = sprintf;
          window["vsprintf"] = vsprintf;
          if (typeof define === "function" && define["amd"]) {
            define(function () {
              return { sprintf, vsprintf };
            });
          }
        }
      })();
    },
    4406: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const crypto = __nccwpck_require__(6113);
      const { Minipass } = __nccwpck_require__(4968);
      const SPEC_ALGORITHMS = ["sha512", "sha384", "sha256"];
      const DEFAULT_ALGORITHMS = ["sha512"];
      const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
      const SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\S*]*)$/;
      const STRICT_SRI_REGEX =
        /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)?$/;
      const VCHAR_REGEX = /^[\x21-\x7E]+$/;
      const getOptString = (options) =>
        options?.length ? `?${options.join("?")}` : "";
      class IntegrityStream extends Minipass {
        #emittedIntegrity;
        #emittedSize;
        #emittedVerified;
        constructor(opts) {
          super();
          this.size = 0;
          this.opts = opts;
          this.#getOptions();
          if (opts?.algorithms) {
            this.algorithms = [...opts.algorithms];
          } else {
            this.algorithms = [...DEFAULT_ALGORITHMS];
          }
          if (
            this.algorithm !== null &&
            !this.algorithms.includes(this.algorithm)
          ) {
            this.algorithms.push(this.algorithm);
          }
          this.hashes = this.algorithms.map(crypto.createHash);
        }
        #getOptions() {
          this.sri = this.opts?.integrity
            ? parse(this.opts?.integrity, this.opts)
            : null;
          this.expectedSize = this.opts?.size;
          if (!this.sri) {
            this.algorithm = null;
          } else if (this.sri.isHash) {
            this.goodSri = true;
            this.algorithm = this.sri.algorithm;
          } else {
            this.goodSri = !this.sri.isEmpty();
            this.algorithm = this.sri.pickAlgorithm(this.opts);
          }
          this.digests = this.goodSri ? this.sri[this.algorithm] : null;
          this.optString = getOptString(this.opts?.options);
        }
        on(ev, handler) {
          if (ev === "size" && this.#emittedSize) {
            return handler(this.#emittedSize);
          }
          if (ev === "integrity" && this.#emittedIntegrity) {
            return handler(this.#emittedIntegrity);
          }
          if (ev === "verified" && this.#emittedVerified) {
            return handler(this.#emittedVerified);
          }
          return super.on(ev, handler);
        }
        emit(ev, data) {
          if (ev === "end") {
            this.#onEnd();
          }
          return super.emit(ev, data);
        }
        write(data) {
          this.size += data.length;
          this.hashes.forEach((h) => h.update(data));
          return super.write(data);
        }
        #onEnd() {
          if (!this.goodSri) {
            this.#getOptions();
          }
          const newSri = parse(
            this.hashes
              .map(
                (h, i) =>
                  `${this.algorithms[i]}-${h.digest("base64")}${this.optString}`,
              )
              .join(" "),
            this.opts,
          );
          const match = this.goodSri && newSri.match(this.sri, this.opts);
          if (
            typeof this.expectedSize === "number" &&
            this.size !== this.expectedSize
          ) {
            const err = new Error(
              `stream size mismatch when checking ${this.sri}.\n  Wanted: ${this.expectedSize}\n  Found: ${this.size}`,
            );
            err.code = "EBADSIZE";
            err.found = this.size;
            err.expected = this.expectedSize;
            err.sri = this.sri;
            this.emit("error", err);
          } else if (this.sri && !match) {
            const err = new Error(
              `${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`,
            );
            err.code = "EINTEGRITY";
            err.found = newSri;
            err.expected = this.digests;
            err.algorithm = this.algorithm;
            err.sri = this.sri;
            this.emit("error", err);
          } else {
            this.#emittedSize = this.size;
            this.emit("size", this.size);
            this.#emittedIntegrity = newSri;
            this.emit("integrity", newSri);
            if (match) {
              this.#emittedVerified = match;
              this.emit("verified", match);
            }
          }
        }
      }
      class Hash {
        get isHash() {
          return true;
        }
        constructor(hash, opts) {
          const strict = opts?.strict;
          this.source = hash.trim();
          this.digest = "";
          this.algorithm = "";
          this.options = [];
          const match = this.source.match(
            strict ? STRICT_SRI_REGEX : SRI_REGEX,
          );
          if (!match) {
            return;
          }
          if (strict && !SPEC_ALGORITHMS.includes(match[1])) {
            return;
          }
          this.algorithm = match[1];
          this.digest = match[2];
          const rawOpts = match[3];
          if (rawOpts) {
            this.options = rawOpts.slice(1).split("?");
          }
        }
        hexDigest() {
          return (
            this.digest && Buffer.from(this.digest, "base64").toString("hex")
          );
        }
        toJSON() {
          return this.toString();
        }
        match(integrity, opts) {
          const other = parse(integrity, opts);
          if (!other) {
            return false;
          }
          if (other.isIntegrity) {
            const algo = other.pickAlgorithm(opts, [this.algorithm]);
            if (!algo) {
              return false;
            }
            const foundHash = other[algo].find(
              (hash) => hash.digest === this.digest,
            );
            if (foundHash) {
              return foundHash;
            }
            return false;
          }
          return other.digest === this.digest ? other : false;
        }
        toString(opts) {
          if (opts?.strict) {
            if (
              !(
                SPEC_ALGORITHMS.includes(this.algorithm) &&
                this.digest.match(BASE64_REGEX) &&
                this.options.every((opt) => opt.match(VCHAR_REGEX))
              )
            ) {
              return "";
            }
          }
          return `${this.algorithm}-${this.digest}${getOptString(this.options)}`;
        }
      }
      function integrityHashToString(toString, sep, opts, hashes) {
        const toStringIsNotEmpty = toString !== "";
        let shouldAddFirstSep = false;
        let complement = "";
        const lastIndex = hashes.length - 1;
        for (let i = 0; i < lastIndex; i++) {
          const hashString = Hash.prototype.toString.call(hashes[i], opts);
          if (hashString) {
            shouldAddFirstSep = true;
            complement += hashString;
            complement += sep;
          }
        }
        const finalHashString = Hash.prototype.toString.call(
          hashes[lastIndex],
          opts,
        );
        if (finalHashString) {
          shouldAddFirstSep = true;
          complement += finalHashString;
        }
        if (toStringIsNotEmpty && shouldAddFirstSep) {
          return toString + sep + complement;
        }
        return toString + complement;
      }
      class Integrity {
        get isIntegrity() {
          return true;
        }
        toJSON() {
          return this.toString();
        }
        isEmpty() {
          return Object.keys(this).length === 0;
        }
        toString(opts) {
          let sep = opts?.sep || " ";
          let toString = "";
          if (opts?.strict) {
            sep = sep.replace(/\S+/g, " ");
            for (const hash of SPEC_ALGORITHMS) {
              if (this[hash]) {
                toString = integrityHashToString(
                  toString,
                  sep,
                  opts,
                  this[hash],
                );
              }
            }
          } else {
            for (const hash of Object.keys(this)) {
              toString = integrityHashToString(toString, sep, opts, this[hash]);
            }
          }
          return toString;
        }
        concat(integrity, opts) {
          const other =
            typeof integrity === "string"
              ? integrity
              : stringify(integrity, opts);
          return parse(`${this.toString(opts)} ${other}`, opts);
        }
        hexDigest() {
          return parse(this, { single: true }).hexDigest();
        }
        merge(integrity, opts) {
          const other = parse(integrity, opts);
          for (const algo in other) {
            if (this[algo]) {
              if (
                !this[algo].find((hash) =>
                  other[algo].find(
                    (otherhash) => hash.digest === otherhash.digest,
                  ),
                )
              ) {
                throw new Error("hashes do not match, cannot update integrity");
              }
            } else {
              this[algo] = other[algo];
            }
          }
        }
        match(integrity, opts) {
          const other = parse(integrity, opts);
          if (!other) {
            return false;
          }
          const algo = other.pickAlgorithm(opts, Object.keys(this));
          return (
            (!!algo &&
              this[algo] &&
              other[algo] &&
              this[algo].find((hash) =>
                other[algo].find(
                  (otherhash) => hash.digest === otherhash.digest,
                ),
              )) ||
            false
          );
        }
        pickAlgorithm(opts, hashes) {
          const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash;
          const keys = Object.keys(this).filter((k) => {
            if (hashes?.length) {
              return hashes.includes(k);
            }
            return true;
          });
          if (keys.length) {
            return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc);
          }
          return null;
        }
      }
      module.exports.parse = parse;
      function parse(sri, opts) {
        if (!sri) {
          return null;
        }
        if (typeof sri === "string") {
          return _parse(sri, opts);
        } else if (sri.algorithm && sri.digest) {
          const fullSri = new Integrity();
          fullSri[sri.algorithm] = [sri];
          return _parse(stringify(fullSri, opts), opts);
        } else {
          return _parse(stringify(sri, opts), opts);
        }
      }
      function _parse(integrity, opts) {
        if (opts?.single) {
          return new Hash(integrity, opts);
        }
        const hashes = integrity
          .trim()
          .split(/\s+/)
          .reduce((acc, string) => {
            const hash = new Hash(string, opts);
            if (hash.algorithm && hash.digest) {
              const algo = hash.algorithm;
              if (!acc[algo]) {
                acc[algo] = [];
              }
              acc[algo].push(hash);
            }
            return acc;
          }, new Integrity());
        return hashes.isEmpty() ? null : hashes;
      }
      module.exports.stringify = stringify;
      function stringify(obj, opts) {
        if (obj.algorithm && obj.digest) {
          return Hash.prototype.toString.call(obj, opts);
        } else if (typeof obj === "string") {
          return stringify(parse(obj, opts), opts);
        } else {
          return Integrity.prototype.toString.call(obj, opts);
        }
      }
      module.exports.fromHex = fromHex;
      function fromHex(hexDigest, algorithm, opts) {
        const optString = getOptString(opts?.options);
        return parse(
          `${algorithm}-${Buffer.from(hexDigest, "hex").toString("base64")}${optString}`,
          opts,
        );
      }
      module.exports.fromData = fromData;
      function fromData(data, opts) {
        const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
        const optString = getOptString(opts?.options);
        return algorithms.reduce((acc, algo) => {
          const digest = crypto.createHash(algo).update(data).digest("base64");
          const hash = new Hash(`${algo}-${digest}${optString}`, opts);
          if (hash.algorithm && hash.digest) {
            const hashAlgo = hash.algorithm;
            if (!acc[hashAlgo]) {
              acc[hashAlgo] = [];
            }
            acc[hashAlgo].push(hash);
          }
          return acc;
        }, new Integrity());
      }
      module.exports.fromStream = fromStream;
      function fromStream(stream, opts) {
        const istream = integrityStream(opts);
        return new Promise((resolve, reject) => {
          stream.pipe(istream);
          stream.on("error", reject);
          istream.on("error", reject);
          let sri;
          istream.on("integrity", (s) => {
            sri = s;
          });
          istream.on("end", () => resolve(sri));
          istream.resume();
        });
      }
      module.exports.checkData = checkData;
      function checkData(data, sri, opts) {
        sri = parse(sri, opts);
        if (!sri || !Object.keys(sri).length) {
          if (opts?.error) {
            throw Object.assign(
              new Error("No valid integrity hashes to check against"),
              { code: "EINTEGRITY" },
            );
          } else {
            return false;
          }
        }
        const algorithm = sri.pickAlgorithm(opts);
        const digest = crypto
          .createHash(algorithm)
          .update(data)
          .digest("base64");
        const newSri = parse({ algorithm, digest });
        const match = newSri.match(sri, opts);
        opts = opts || {};
        if (match || !opts.error) {
          return match;
        } else if (typeof opts.size === "number" && data.length !== opts.size) {
          const err = new Error(
            `data size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${data.length}`,
          );
          err.code = "EBADSIZE";
          err.found = data.length;
          err.expected = opts.size;
          err.sri = sri;
          throw err;
        } else {
          const err = new Error(
            `Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`,
          );
          err.code = "EINTEGRITY";
          err.found = newSri;
          err.expected = sri;
          err.algorithm = algorithm;
          err.sri = sri;
          throw err;
        }
      }
      module.exports.checkStream = checkStream;
      function checkStream(stream, sri, opts) {
        opts = opts || Object.create(null);
        opts.integrity = sri;
        sri = parse(sri, opts);
        if (!sri || !Object.keys(sri).length) {
          return Promise.reject(
            Object.assign(
              new Error("No valid integrity hashes to check against"),
              { code: "EINTEGRITY" },
            ),
          );
        }
        const checker = integrityStream(opts);
        return new Promise((resolve, reject) => {
          stream.pipe(checker);
          stream.on("error", reject);
          checker.on("error", reject);
          let verified;
          checker.on("verified", (s) => {
            verified = s;
          });
          checker.on("end", () => resolve(verified));
          checker.resume();
        });
      }
      module.exports.integrityStream = integrityStream;
      function integrityStream(opts = Object.create(null)) {
        return new IntegrityStream(opts);
      }
      module.exports.create = createIntegrity;
      function createIntegrity(opts) {
        const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
        const optString = getOptString(opts?.options);
        const hashes = algorithms.map(crypto.createHash);
        return {
          update: function (chunk, enc) {
            hashes.forEach((h) => h.update(chunk, enc));
            return this;
          },
          digest: function () {
            const integrity = algorithms.reduce((acc, algo) => {
              const digest = hashes.shift().digest("base64");
              const hash = new Hash(`${algo}-${digest}${optString}`, opts);
              if (hash.algorithm && hash.digest) {
                const hashAlgo = hash.algorithm;
                if (!acc[hashAlgo]) {
                  acc[hashAlgo] = [];
                }
                acc[hashAlgo].push(hash);
              }
              return acc;
            }, new Integrity());
            return integrity;
          },
        };
      }
      const NODE_HASHES = crypto.getHashes();
      const DEFAULT_PRIORITY = [
        "md5",
        "whirlpool",
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "sha3",
        "sha3-256",
        "sha3-384",
        "sha3-512",
        "sha3_256",
        "sha3_384",
        "sha3_512",
      ].filter((algo) => NODE_HASHES.includes(algo));
      function getPrioritizedHash(algo1, algo2) {
        return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >=
          DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())
          ? algo1
          : algo2;
      }
    },
    9530: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultConfig = void 0;
      exports.defaultConfig = {
        maxRootRotations: 32,
        maxDelegations: 32,
        rootMaxLength: 512e3,
        timestampMaxLength: 16384,
        snapshotMaxLength: 2e6,
        targetsMaxLength: 5e6,
        prefixTargetsWithHash: true,
        fetchTimeout: 1e5,
        fetchRetries: undefined,
        fetchRetry: 2,
      };
    },
    7040: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DownloadHTTPError =
        exports.DownloadLengthMismatchError =
        exports.DownloadError =
        exports.ExpiredMetadataError =
        exports.EqualVersionError =
        exports.BadVersionError =
        exports.RepositoryError =
        exports.PersistError =
        exports.RuntimeError =
        exports.ValueError =
          void 0;
      class ValueError extends Error {}
      exports.ValueError = ValueError;
      class RuntimeError extends Error {}
      exports.RuntimeError = RuntimeError;
      class PersistError extends Error {}
      exports.PersistError = PersistError;
      class RepositoryError extends Error {}
      exports.RepositoryError = RepositoryError;
      class BadVersionError extends RepositoryError {}
      exports.BadVersionError = BadVersionError;
      class EqualVersionError extends BadVersionError {}
      exports.EqualVersionError = EqualVersionError;
      class ExpiredMetadataError extends RepositoryError {}
      exports.ExpiredMetadataError = ExpiredMetadataError;
      class DownloadError extends Error {}
      exports.DownloadError = DownloadError;
      class DownloadLengthMismatchError extends DownloadError {}
      exports.DownloadLengthMismatchError = DownloadLengthMismatchError;
      class DownloadHTTPError extends DownloadError {
        constructor(message, statusCode) {
          super(message);
          this.statusCode = statusCode;
        }
      }
      exports.DownloadHTTPError = DownloadHTTPError;
    },
    5991: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultFetcher = exports.BaseFetcher = void 0;
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const fs_1 = __importDefault(__nccwpck_require__(7147));
      const make_fetch_happen_1 = __importDefault(__nccwpck_require__(9525));
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(7040);
      const tmpfile_1 = __nccwpck_require__(6400);
      const log = (0, debug_1.default)("tuf:fetch");
      class BaseFetcher {
        async downloadFile(url, maxLength, handler) {
          return (0, tmpfile_1.withTempFile)(async (tmpFile) => {
            const reader = await this.fetch(url);
            let numberOfBytesReceived = 0;
            const fileStream = fs_1.default.createWriteStream(tmpFile);
            try {
              for await (const chunk of reader) {
                const bufferChunk = Buffer.from(chunk);
                numberOfBytesReceived += bufferChunk.length;
                if (numberOfBytesReceived > maxLength) {
                  throw new error_1.DownloadLengthMismatchError(
                    "Max length reached",
                  );
                }
                await writeBufferToStream(fileStream, bufferChunk);
              }
            } finally {
              await util_1.default
                .promisify(fileStream.close)
                .bind(fileStream)();
            }
            return handler(tmpFile);
          });
        }
        async downloadBytes(url, maxLength) {
          return this.downloadFile(url, maxLength, async (file) => {
            const stream = fs_1.default.createReadStream(file);
            const chunks = [];
            for await (const chunk of stream) {
              chunks.push(chunk);
            }
            return Buffer.concat(chunks);
          });
        }
      }
      exports.BaseFetcher = BaseFetcher;
      class DefaultFetcher extends BaseFetcher {
        constructor(options = {}) {
          super();
          this.timeout = options.timeout;
          this.retry = options.retry;
        }
        async fetch(url) {
          log("GET %s", url);
          const response = await (0, make_fetch_happen_1.default)(url, {
            timeout: this.timeout,
            retry: this.retry,
          });
          if (!response.ok || !response?.body) {
            throw new error_1.DownloadHTTPError(
              "Failed to download",
              response.status,
            );
          }
          return response.body;
        }
      }
      exports.DefaultFetcher = DefaultFetcher;
      const writeBufferToStream = async (stream, buffer) =>
        new Promise((resolve, reject) => {
          stream.write(buffer, (err) => {
            if (err) {
              reject(err);
            }
            resolve(true);
          });
        });
    },
    9475: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Updater = exports.BaseFetcher = exports.TargetFile = void 0;
      var models_1 = __nccwpck_require__(5833);
      Object.defineProperty(exports, "TargetFile", {
        enumerable: true,
        get: function () {
          return models_1.TargetFile;
        },
      });
      var fetcher_1 = __nccwpck_require__(5991);
      Object.defineProperty(exports, "BaseFetcher", {
        enumerable: true,
        get: function () {
          return fetcher_1.BaseFetcher;
        },
      });
      var updater_1 = __nccwpck_require__(7977);
      Object.defineProperty(exports, "Updater", {
        enumerable: true,
        get: function () {
          return updater_1.Updater;
        },
      });
    },
    7001: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TrustedMetadataStore = void 0;
      const models_1 = __nccwpck_require__(5833);
      const error_1 = __nccwpck_require__(7040);
      class TrustedMetadataStore {
        constructor(rootData) {
          this.trustedSet = {};
          this.referenceTime = new Date();
          this.loadTrustedRoot(rootData);
        }
        get root() {
          if (!this.trustedSet.root) {
            throw new ReferenceError("No trusted root metadata");
          }
          return this.trustedSet.root;
        }
        get timestamp() {
          return this.trustedSet.timestamp;
        }
        get snapshot() {
          return this.trustedSet.snapshot;
        }
        get targets() {
          return this.trustedSet.targets;
        }
        getRole(name) {
          return this.trustedSet[name];
        }
        updateRoot(bytesBuffer) {
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newRoot = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Root,
            data,
          );
          if (newRoot.signed.type != models_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(
              `Expected 'root', got ${newRoot.signed.type}`,
            );
          }
          this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);
          if (newRoot.signed.version != this.root.signed.version + 1) {
            throw new error_1.BadVersionError(
              `Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`,
            );
          }
          newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);
          this.trustedSet.root = newRoot;
          return newRoot;
        }
        updateTimestamp(bytesBuffer) {
          if (this.snapshot) {
            throw new error_1.RuntimeError(
              "Cannot update timestamp after snapshot",
            );
          }
          if (this.root.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(
              "Final root.json is expired",
            );
          }
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newTimestamp = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Timestamp,
            data,
          );
          if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {
            throw new error_1.RepositoryError(
              `Expected 'timestamp', got ${newTimestamp.signed.type}`,
            );
          }
          this.root.verifyDelegate(
            models_1.MetadataKind.Timestamp,
            newTimestamp,
          );
          if (this.timestamp) {
            if (newTimestamp.signed.version < this.timestamp.signed.version) {
              throw new error_1.BadVersionError(
                `New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`,
              );
            }
            if (newTimestamp.signed.version === this.timestamp.signed.version) {
              throw new error_1.EqualVersionError(
                `New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`,
              );
            }
            const snapshotMeta = this.timestamp.signed.snapshotMeta;
            const newSnapshotMeta = newTimestamp.signed.snapshotMeta;
            if (newSnapshotMeta.version < snapshotMeta.version) {
              throw new error_1.BadVersionError(
                `New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`,
              );
            }
          }
          this.trustedSet.timestamp = newTimestamp;
          this.checkFinalTimestamp();
          return newTimestamp;
        }
        updateSnapshot(bytesBuffer, trusted = false) {
          if (!this.timestamp) {
            throw new error_1.RuntimeError(
              "Cannot update snapshot before timestamp",
            );
          }
          if (this.targets) {
            throw new error_1.RuntimeError(
              "Cannot update snapshot after targets",
            );
          }
          this.checkFinalTimestamp();
          const snapshotMeta = this.timestamp.signed.snapshotMeta;
          if (!trusted) {
            snapshotMeta.verify(bytesBuffer);
          }
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newSnapshot = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Snapshot,
            data,
          );
          if (newSnapshot.signed.type != models_1.MetadataKind.Snapshot) {
            throw new error_1.RepositoryError(
              `Expected 'snapshot', got ${newSnapshot.signed.type}`,
            );
          }
          this.root.verifyDelegate(models_1.MetadataKind.Snapshot, newSnapshot);
          if (this.snapshot) {
            Object.entries(this.snapshot.signed.meta).forEach(
              ([fileName, fileInfo]) => {
                const newFileInfo = newSnapshot.signed.meta[fileName];
                if (!newFileInfo) {
                  throw new error_1.RepositoryError(
                    `Missing file ${fileName} in new snapshot`,
                  );
                }
                if (newFileInfo.version < fileInfo.version) {
                  throw new error_1.BadVersionError(
                    `New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`,
                  );
                }
              },
            );
          }
          this.trustedSet.snapshot = newSnapshot;
          this.checkFinalSnapsnot();
          return newSnapshot;
        }
        updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {
          if (!this.snapshot) {
            throw new error_1.RuntimeError(
              "Cannot update delegated targets before snapshot",
            );
          }
          this.checkFinalSnapsnot();
          const delegator = this.trustedSet[delegatorName];
          if (!delegator) {
            throw new error_1.RuntimeError(
              `No trusted ${delegatorName} metadata`,
            );
          }
          const meta = this.snapshot.signed.meta?.[`${roleName}.json`];
          if (!meta) {
            throw new error_1.RepositoryError(
              `Missing ${roleName}.json in snapshot`,
            );
          }
          meta.verify(bytesBuffer);
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newDelegate = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Targets,
            data,
          );
          if (newDelegate.signed.type != models_1.MetadataKind.Targets) {
            throw new error_1.RepositoryError(
              `Expected 'targets', got ${newDelegate.signed.type}`,
            );
          }
          delegator.verifyDelegate(roleName, newDelegate);
          const version = newDelegate.signed.version;
          if (version != meta.version) {
            throw new error_1.BadVersionError(
              `Version ${version} of ${roleName} does not match snapshot version ${meta.version}`,
            );
          }
          if (newDelegate.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(
              `${roleName}.json is expired`,
            );
          }
          this.trustedSet[roleName] = newDelegate;
        }
        loadTrustedRoot(bytesBuffer) {
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const root = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Root,
            data,
          );
          if (root.signed.type != models_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(
              `Expected 'root', got ${root.signed.type}`,
            );
          }
          root.verifyDelegate(models_1.MetadataKind.Root, root);
          this.trustedSet["root"] = root;
        }
        checkFinalTimestamp() {
          if (!this.timestamp) {
            throw new ReferenceError("No trusted timestamp metadata");
          }
          if (this.timestamp.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(
              "Final timestamp.json is expired",
            );
          }
        }
        checkFinalSnapsnot() {
          if (!this.snapshot) {
            throw new ReferenceError("No trusted snapshot metadata");
          }
          if (!this.timestamp) {
            throw new ReferenceError("No trusted timestamp metadata");
          }
          if (this.snapshot.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError("snapshot.json is expired");
          }
          const snapshotMeta = this.timestamp.signed.snapshotMeta;
          if (this.snapshot.signed.version !== snapshotMeta.version) {
            throw new error_1.BadVersionError(
              "Snapshot version doesn't match timestamp",
            );
          }
        }
      }
      exports.TrustedMetadataStore = TrustedMetadataStore;
    },
    7977: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Updater = void 0;
      const models_1 = __nccwpck_require__(5833);
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const fs = __importStar(__nccwpck_require__(7147));
      const path = __importStar(__nccwpck_require__(1017));
      const config_1 = __nccwpck_require__(9530);
      const error_1 = __nccwpck_require__(7040);
      const fetcher_1 = __nccwpck_require__(5991);
      const store_1 = __nccwpck_require__(7001);
      const url = __importStar(__nccwpck_require__(5961));
      const log = (0, debug_1.default)("tuf:cache");
      class Updater {
        constructor(options) {
          const {
            metadataDir,
            metadataBaseUrl,
            targetDir,
            targetBaseUrl,
            fetcher,
            config,
          } = options;
          this.dir = metadataDir;
          this.metadataBaseUrl = metadataBaseUrl;
          this.targetDir = targetDir;
          this.targetBaseUrl = targetBaseUrl;
          this.forceCache = options.forceCache ?? false;
          const data = this.loadLocalMetadata(models_1.MetadataKind.Root);
          this.trustedSet = new store_1.TrustedMetadataStore(data);
          this.config = { ...config_1.defaultConfig, ...config };
          this.fetcher =
            fetcher ||
            new fetcher_1.DefaultFetcher({
              timeout: this.config.fetchTimeout,
              retry: this.config.fetchRetries ?? this.config.fetchRetry,
            });
        }
        async refresh() {
          if (this.forceCache) {
            try {
              await this.loadTimestamp({ checkRemote: false });
            } catch (error) {
              await this.loadRoot();
              await this.loadTimestamp();
            }
          } else {
            await this.loadRoot();
            await this.loadTimestamp();
          }
          await this.loadSnapshot();
          await this.loadTargets(
            models_1.MetadataKind.Targets,
            models_1.MetadataKind.Root,
          );
        }
        async getTargetInfo(targetPath) {
          if (!this.trustedSet.targets) {
            await this.refresh();
          }
          return this.preorderDepthFirstWalk(targetPath);
        }
        async downloadTarget(targetInfo, filePath, targetBaseUrl) {
          const targetPath = filePath || this.generateTargetPath(targetInfo);
          if (!targetBaseUrl) {
            if (!this.targetBaseUrl) {
              throw new error_1.ValueError("Target base URL not set");
            }
            targetBaseUrl = this.targetBaseUrl;
          }
          let targetFilePath = targetInfo.path;
          const consistentSnapshot =
            this.trustedSet.root.signed.consistentSnapshot;
          if (consistentSnapshot && this.config.prefixTargetsWithHash) {
            const hashes = Object.values(targetInfo.hashes);
            const { dir, base } = path.parse(targetFilePath);
            const filename = `${hashes[0]}.${base}`;
            targetFilePath = dir ? `${dir}/${filename}` : filename;
          }
          const targetUrl = url.join(targetBaseUrl, targetFilePath);
          await this.fetcher.downloadFile(
            targetUrl,
            targetInfo.length,
            async (fileName) => {
              await targetInfo.verify(fs.createReadStream(fileName));
              log("WRITE %s", targetPath);
              fs.copyFileSync(fileName, targetPath);
            },
          );
          return targetPath;
        }
        async findCachedTarget(targetInfo, filePath) {
          if (!filePath) {
            filePath = this.generateTargetPath(targetInfo);
          }
          try {
            if (fs.existsSync(filePath)) {
              await targetInfo.verify(fs.createReadStream(filePath));
              return filePath;
            }
          } catch (error) {
            return;
          }
          return;
        }
        loadLocalMetadata(fileName) {
          const filePath = path.join(this.dir, `${fileName}.json`);
          log("READ %s", filePath);
          return fs.readFileSync(filePath);
        }
        async loadRoot() {
          const rootVersion = this.trustedSet.root.signed.version;
          const lowerBound = rootVersion + 1;
          const upperBound = lowerBound + this.config.maxRootRotations;
          for (let version = lowerBound; version <= upperBound; version++) {
            const rootUrl = url.join(
              this.metadataBaseUrl,
              `${version}.root.json`,
            );
            try {
              const bytesData = await this.fetcher.downloadBytes(
                rootUrl,
                this.config.rootMaxLength,
              );
              this.trustedSet.updateRoot(bytesData);
              this.persistMetadata(models_1.MetadataKind.Root, bytesData);
            } catch (error) {
              break;
            }
          }
        }
        async loadTimestamp({ checkRemote } = { checkRemote: true }) {
          try {
            const data = this.loadLocalMetadata(
              models_1.MetadataKind.Timestamp,
            );
            this.trustedSet.updateTimestamp(data);
            if (!checkRemote) {
              return;
            }
          } catch (error) {}
          const timestampUrl = url.join(this.metadataBaseUrl, "timestamp.json");
          const bytesData = await this.fetcher.downloadBytes(
            timestampUrl,
            this.config.timestampMaxLength,
          );
          try {
            this.trustedSet.updateTimestamp(bytesData);
          } catch (error) {
            if (error instanceof error_1.EqualVersionError) {
              return;
            }
            throw error;
          }
          this.persistMetadata(models_1.MetadataKind.Timestamp, bytesData);
        }
        async loadSnapshot() {
          try {
            const data = this.loadLocalMetadata(models_1.MetadataKind.Snapshot);
            this.trustedSet.updateSnapshot(data, true);
          } catch (error) {
            if (!this.trustedSet.timestamp) {
              throw new ReferenceError("No timestamp metadata");
            }
            const snapshotMeta = this.trustedSet.timestamp.signed.snapshotMeta;
            const maxLength =
              snapshotMeta.length || this.config.snapshotMaxLength;
            const version = this.trustedSet.root.signed.consistentSnapshot
              ? snapshotMeta.version
              : undefined;
            const snapshotUrl = url.join(
              this.metadataBaseUrl,
              version ? `${version}.snapshot.json` : "snapshot.json",
            );
            try {
              const bytesData = await this.fetcher.downloadBytes(
                snapshotUrl,
                maxLength,
              );
              this.trustedSet.updateSnapshot(bytesData);
              this.persistMetadata(models_1.MetadataKind.Snapshot, bytesData);
            } catch (error) {
              throw new error_1.RuntimeError(
                `Unable to load snapshot metadata error ${error}`,
              );
            }
          }
        }
        async loadTargets(role, parentRole) {
          if (this.trustedSet.getRole(role)) {
            return this.trustedSet.getRole(role);
          }
          try {
            const buffer = this.loadLocalMetadata(role);
            this.trustedSet.updateDelegatedTargets(buffer, role, parentRole);
          } catch (error) {
            if (!this.trustedSet.snapshot) {
              throw new ReferenceError("No snapshot metadata");
            }
            const metaInfo =
              this.trustedSet.snapshot.signed.meta[`${role}.json`];
            const maxLength = metaInfo.length || this.config.targetsMaxLength;
            const version = this.trustedSet.root.signed.consistentSnapshot
              ? metaInfo.version
              : undefined;
            const metadataUrl = url.join(
              this.metadataBaseUrl,
              version ? `${version}.${role}.json` : `${role}.json`,
            );
            try {
              const bytesData = await this.fetcher.downloadBytes(
                metadataUrl,
                maxLength,
              );
              this.trustedSet.updateDelegatedTargets(
                bytesData,
                role,
                parentRole,
              );
              this.persistMetadata(role, bytesData);
            } catch (error) {
              throw new error_1.RuntimeError(
                `Unable to load targets error ${error}`,
              );
            }
          }
          return this.trustedSet.getRole(role);
        }
        async preorderDepthFirstWalk(targetPath) {
          const delegationsToVisit = [
            {
              roleName: models_1.MetadataKind.Targets,
              parentRoleName: models_1.MetadataKind.Root,
            },
          ];
          const visitedRoleNames = new Set();
          while (
            visitedRoleNames.size <= this.config.maxDelegations &&
            delegationsToVisit.length > 0
          ) {
            const { roleName, parentRoleName } = delegationsToVisit.pop();
            if (visitedRoleNames.has(roleName)) {
              continue;
            }
            const targets = (await this.loadTargets(roleName, parentRoleName))
              ?.signed;
            if (!targets) {
              continue;
            }
            const target = targets.targets?.[targetPath];
            if (target) {
              return target;
            }
            visitedRoleNames.add(roleName);
            if (targets.delegations) {
              const childRolesToVisit = [];
              const rolesForTarget =
                targets.delegations.rolesForTarget(targetPath);
              for (const { role: childName, terminating } of rolesForTarget) {
                childRolesToVisit.push({
                  roleName: childName,
                  parentRoleName: roleName,
                });
                if (terminating) {
                  delegationsToVisit.splice(0);
                  break;
                }
              }
              childRolesToVisit.reverse();
              delegationsToVisit.push(...childRolesToVisit);
            }
          }
          return;
        }
        generateTargetPath(targetInfo) {
          if (!this.targetDir) {
            throw new error_1.ValueError("Target directory not set");
          }
          const filePath = encodeURIComponent(targetInfo.path);
          return path.join(this.targetDir, filePath);
        }
        persistMetadata(metaDataName, bytesData) {
          try {
            const filePath = path.join(this.dir, `${metaDataName}.json`);
            log("WRITE %s", filePath);
            fs.writeFileSync(filePath, bytesData.toString("utf8"));
          } catch (error) {
            throw new error_1.PersistError(
              `Failed to persist metadata ${metaDataName} error: ${error}`,
            );
          }
        }
      }
      exports.Updater = Updater;
    },
    6400: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.withTempFile = void 0;
      const promises_1 = __importDefault(__nccwpck_require__(3292));
      const os_1 = __importDefault(__nccwpck_require__(2037));
      const path_1 = __importDefault(__nccwpck_require__(1017));
      const withTempFile = async (handler) =>
        withTempDir(async (dir) =>
          handler(path_1.default.join(dir, "tempfile")),
        );
      exports.withTempFile = withTempFile;
      const withTempDir = async (handler) => {
        const tmpDir = await promises_1.default.realpath(os_1.default.tmpdir());
        const dir = await promises_1.default.mkdtemp(
          tmpDir + path_1.default.sep,
        );
        try {
          return await handler(dir);
        } finally {
          await promises_1.default.rm(dir, {
            force: true,
            recursive: true,
            maxRetries: 3,
          });
        }
      };
    },
    5961: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.join = void 0;
      const url_1 = __nccwpck_require__(7310);
      function join(base, path) {
        return new url_1.URL(
          ensureTrailingSlash(base) + removeLeadingSlash(path),
        ).toString();
      }
      exports.join = join;
      function ensureTrailingSlash(path) {
        return path.endsWith("/") ? path : path + "/";
      }
      function removeLeadingSlash(path) {
        return path.startsWith("/") ? path.slice(1) : path;
      }
    },
    2524: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var parse = __nccwpck_require__(1620);
      var correct = __nccwpck_require__(2372);
      var genericWarning =
        "license should be " +
        'a valid SPDX license expression (without "LicenseRef"), ' +
        '"UNLICENSED", or ' +
        '"SEE LICENSE IN <filename>"';
      var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
      function startsWith(prefix, string) {
        return string.slice(0, prefix.length) === prefix;
      }
      function usesLicenseRef(ast) {
        if (ast.hasOwnProperty("license")) {
          var license = ast.license;
          return (
            startsWith("LicenseRef", license) ||
            startsWith("DocumentRef", license)
          );
        } else {
          return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
        }
      }
      module.exports = function (argument) {
        var ast;
        try {
          ast = parse(argument);
        } catch (e) {
          var match;
          if (argument === "UNLICENSED" || argument === "UNLICENCED") {
            return {
              validForOldPackages: true,
              validForNewPackages: true,
              unlicensed: true,
            };
          } else if ((match = fileReferenceRE.exec(argument))) {
            return {
              validForOldPackages: true,
              validForNewPackages: true,
              inFile: match[1],
            };
          } else {
            var result = {
              validForOldPackages: false,
              validForNewPackages: false,
              warnings: [genericWarning],
            };
            if (argument.trim().length !== 0) {
              var corrected = correct(argument);
              if (corrected) {
                result.warnings.push(
                  'license is similar to the valid expression "' +
                    corrected +
                    '"',
                );
              }
            }
            return result;
          }
        }
        if (usesLicenseRef(ast)) {
          return {
            validForNewPackages: false,
            validForOldPackages: false,
            spdx: true,
            warnings: [genericWarning],
          };
        } else {
          return {
            validForNewPackages: true,
            validForOldPackages: true,
            spdx: true,
          };
        }
      };
    },
    4006: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { builtinModules: builtins } = __nccwpck_require__(8188);
      var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$");
      var blacklist = ["node_modules", "favicon.ico"];
      function validate(name) {
        var warnings = [];
        var errors = [];
        if (name === null) {
          errors.push("name cannot be null");
          return done(warnings, errors);
        }
        if (name === undefined) {
          errors.push("name cannot be undefined");
          return done(warnings, errors);
        }
        if (typeof name !== "string") {
          errors.push("name must be a string");
          return done(warnings, errors);
        }
        if (!name.length) {
          errors.push("name length must be greater than zero");
        }
        if (name.match(/^\./)) {
          errors.push("name cannot start with a period");
        }
        if (name.match(/^_/)) {
          errors.push("name cannot start with an underscore");
        }
        if (name.trim() !== name) {
          errors.push("name cannot contain leading or trailing spaces");
        }
        blacklist.forEach(function (blacklistedName) {
          if (name.toLowerCase() === blacklistedName) {
            errors.push(blacklistedName + " is a blacklisted name");
          }
        });
        if (builtins.includes(name.toLowerCase())) {
          warnings.push(name + " is a core module name");
        }
        if (name.length > 214) {
          warnings.push("name can no longer contain more than 214 characters");
        }
        if (name.toLowerCase() !== name) {
          warnings.push("name can no longer contain capital letters");
        }
        if (/[~'!()*]/.test(name.split("/").slice(-1)[0])) {
          warnings.push(
            'name can no longer contain special characters ("~\'!()*")',
          );
        }
        if (encodeURIComponent(name) !== name) {
          var nameMatch = name.match(scopedPackagePattern);
          if (nameMatch) {
            var user = nameMatch[1];
            var pkg = nameMatch[2];
            if (
              encodeURIComponent(user) === user &&
              encodeURIComponent(pkg) === pkg
            ) {
              return done(warnings, errors);
            }
          }
          errors.push("name can only contain URL-friendly characters");
        }
        return done(warnings, errors);
      }
      var done = function (warnings, errors) {
        var result = {
          validForNewPackages: errors.length === 0 && warnings.length === 0,
          validForOldPackages: errors.length === 0,
          warnings,
          errors,
        };
        if (!result.warnings.length) {
          delete result.warnings;
        }
        if (!result.errors.length) {
          delete result.errors;
        }
        return result;
      };
      module.exports = validate;
    },
    132: (module) => {
      module.exports = eval("require")("supports-color");
    },
    7129: (module) => {
      "use strict";
      module.exports = require("../cacache/index.js");
    },
    4541: (module) => {
      "use strict";
      module.exports = require("../semver/index.js");
    },
    3684: (module) => {
      "use strict";
      module.exports = require("./package.json");
    },
    9491: (module) => {
      "use strict";
      module.exports = require("assert");
    },
    4300: (module) => {
      "use strict";
      module.exports = require("buffer");
    },
    6113: (module) => {
      "use strict";
      module.exports = require("crypto");
    },
    7578: (module) => {
      "use strict";
      module.exports = require("dns");
    },
    2361: (module) => {
      "use strict";
      module.exports = require("events");
    },
    7147: (module) => {
      "use strict";
      module.exports = require("fs");
    },
    3292: (module) => {
      "use strict";
      module.exports = require("fs/promises");
    },
    3685: (module) => {
      "use strict";
      module.exports = require("http");
    },
    5158: (module) => {
      "use strict";
      module.exports = require("http2");
    },
    5687: (module) => {
      "use strict";
      module.exports = require("https");
    },
    8188: (module) => {
      "use strict";
      module.exports = require("module");
    },
    1808: (module) => {
      "use strict";
      module.exports = require("net");
    },
    5673: (module) => {
      "use strict";
      module.exports = require("node:events");
    },
    3977: (module) => {
      "use strict";
      module.exports = require("node:fs/promises");
    },
    2033: (module) => {
      "use strict";
      module.exports = require("node:module");
    },
    4492: (module) => {
      "use strict";
      module.exports = require("node:stream");
    },
    6915: (module) => {
      "use strict";
      module.exports = require("node:string_decoder");
    },
    1041: (module) => {
      "use strict";
      module.exports = require("node:url");
    },
    2037: (module) => {
      "use strict";
      module.exports = require("os");
    },
    1017: (module) => {
      "use strict";
      module.exports = require("path");
    },
    3477: (module) => {
      "use strict";
      module.exports = require("querystring");
    },
    2781: (module) => {
      "use strict";
      module.exports = require("stream");
    },
    1576: (module) => {
      "use strict";
      module.exports = require("string_decoder");
    },
    8670: (module) => {
      "use strict";
      module.exports = require("timers/promises");
    },
    4404: (module) => {
      "use strict";
      module.exports = require("tls");
    },
    6224: (module) => {
      "use strict";
      module.exports = require("tty");
    },
    7310: (module) => {
      "use strict";
      module.exports = require("url");
    },
    3837: (module) => {
      "use strict";
      module.exports = require("util");
    },
    9796: (module) => {
      "use strict";
      module.exports = require("zlib");
    },
    3866: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = void 0;
      const perf =
        typeof performance === "object" &&
        performance &&
        typeof performance.now === "function"
          ? performance
          : Date;
      const warned = new Set();
      const PROCESS = typeof process === "object" && !!process ? process : {};
      const emitWarning = (msg, type, code, fn) => {
        typeof PROCESS.emitWarning === "function"
          ? PROCESS.emitWarning(msg, type, code, fn)
          : console.error(`[${code}] ${type}: ${msg}`);
      };
      let AC = globalThis.AbortController;
      let AS = globalThis.AbortSignal;
      if (typeof AC === "undefined") {
        AS = class AbortSignal {
          onabort;
          _onabort = [];
          reason;
          aborted = false;
          addEventListener(_, fn) {
            this._onabort.push(fn);
          }
        };
        AC = class AbortController {
          constructor() {
            warnACPolyfill();
          }
          signal = new AS();
          abort(reason) {
            if (this.signal.aborted) return;
            this.signal.reason = reason;
            this.signal.aborted = true;
            for (const fn of this.signal._onabort) {
              fn(reason);
            }
            this.signal.onabort?.(reason);
          }
        };
        let printACPolyfillWarning =
          PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
        const warnACPolyfill = () => {
          if (!printACPolyfillWarning) return;
          printACPolyfillWarning = false;
          emitWarning(
            "AbortController is not defined. If using lru-cache in " +
              "node 14, load an AbortController polyfill from the " +
              "`node-abort-controller` package. A minimal polyfill is " +
              "provided for use by LRUCache.fetch(), but it should not be " +
              "relied upon in other contexts (eg, passing it to other APIs that " +
              "use AbortController/AbortSignal might have undesirable effects). " +
              "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",
            "NO_ABORT_CONTROLLER",
            "ENOTSUP",
            warnACPolyfill,
          );
        };
      }
      const shouldWarn = (code) => !warned.has(code);
      const TYPE = Symbol("type");
      const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
      const getUintArray = (max) =>
        !isPosInt(max)
          ? null
          : max <= Math.pow(2, 8)
            ? Uint8Array
            : max <= Math.pow(2, 16)
              ? Uint16Array
              : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                  ? ZeroArray
                  : null;
      class ZeroArray extends Array {
        constructor(size) {
          super(size);
          this.fill(0);
        }
      }
      class Stack {
        heap;
        length;
        static #constructing = false;
        static create(max) {
          const HeapCls = getUintArray(max);
          if (!HeapCls) return [];
          Stack.#constructing = true;
          const s = new Stack(max, HeapCls);
          Stack.#constructing = false;
          return s;
        }
        constructor(max, HeapCls) {
          if (!Stack.#constructing) {
            throw new TypeError("instantiate Stack using Stack.create(n)");
          }
          this.heap = new HeapCls(max);
          this.length = 0;
        }
        push(n) {
          this.heap[this.length++] = n;
        }
        pop() {
          return this.heap[--this.length];
        }
      }
      class LRUCache {
        #max;
        #maxSize;
        #dispose;
        #disposeAfter;
        #fetchMethod;
        #memoMethod;
        ttl;
        ttlResolution;
        ttlAutopurge;
        updateAgeOnGet;
        updateAgeOnHas;
        allowStale;
        noDisposeOnSet;
        noUpdateTTL;
        maxEntrySize;
        sizeCalculation;
        noDeleteOnFetchRejection;
        noDeleteOnStaleGet;
        allowStaleOnFetchAbort;
        allowStaleOnFetchRejection;
        ignoreFetchAbort;
        #size;
        #calculatedSize;
        #keyMap;
        #keyList;
        #valList;
        #next;
        #prev;
        #head;
        #tail;
        #free;
        #disposed;
        #sizes;
        #starts;
        #ttls;
        #hasDispose;
        #hasFetchMethod;
        #hasDisposeAfter;
        static unsafeExposeInternals(c) {
          return {
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
              return c.#head;
            },
            get tail() {
              return c.#tail;
            },
            free: c.#free,
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) =>
              c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
          };
        }
        get max() {
          return this.#max;
        }
        get maxSize() {
          return this.#maxSize;
        }
        get calculatedSize() {
          return this.#calculatedSize;
        }
        get size() {
          return this.#size;
        }
        get fetchMethod() {
          return this.#fetchMethod;
        }
        get memoMethod() {
          return this.#memoMethod;
        }
        get dispose() {
          return this.#dispose;
        }
        get disposeAfter() {
          return this.#disposeAfter;
        }
        constructor(options) {
          const {
            max = 0,
            ttl,
            ttlResolution = 1,
            ttlAutopurge,
            updateAgeOnGet,
            updateAgeOnHas,
            allowStale,
            dispose,
            disposeAfter,
            noDisposeOnSet,
            noUpdateTTL,
            maxSize = 0,
            maxEntrySize = 0,
            sizeCalculation,
            fetchMethod,
            memoMethod,
            noDeleteOnFetchRejection,
            noDeleteOnStaleGet,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
          } = options;
          if (max !== 0 && !isPosInt(max)) {
            throw new TypeError("max option must be a nonnegative integer");
          }
          const UintArray = max ? getUintArray(max) : Array;
          if (!UintArray) {
            throw new Error("invalid max value: " + max);
          }
          this.#max = max;
          this.#maxSize = maxSize;
          this.maxEntrySize = maxEntrySize || this.#maxSize;
          this.sizeCalculation = sizeCalculation;
          if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
              throw new TypeError(
                "cannot set sizeCalculation without setting maxSize or maxEntrySize",
              );
            }
            if (typeof this.sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation set to non-function");
            }
          }
          if (memoMethod !== undefined && typeof memoMethod !== "function") {
            throw new TypeError("memoMethod must be a function if defined");
          }
          this.#memoMethod = memoMethod;
          if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
            throw new TypeError("fetchMethod must be a function if specified");
          }
          this.#fetchMethod = fetchMethod;
          this.#hasFetchMethod = !!fetchMethod;
          this.#keyMap = new Map();
          this.#keyList = new Array(max).fill(undefined);
          this.#valList = new Array(max).fill(undefined);
          this.#next = new UintArray(max);
          this.#prev = new UintArray(max);
          this.#head = 0;
          this.#tail = 0;
          this.#free = Stack.create(max);
          this.#size = 0;
          this.#calculatedSize = 0;
          if (typeof dispose === "function") {
            this.#dispose = dispose;
          }
          if (typeof disposeAfter === "function") {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
          } else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
          }
          this.#hasDispose = !!this.#dispose;
          this.#hasDisposeAfter = !!this.#disposeAfter;
          this.noDisposeOnSet = !!noDisposeOnSet;
          this.noUpdateTTL = !!noUpdateTTL;
          this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
          this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
          this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
          this.ignoreFetchAbort = !!ignoreFetchAbort;
          if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
              if (!isPosInt(this.#maxSize)) {
                throw new TypeError(
                  "maxSize must be a positive integer if specified",
                );
              }
            }
            if (!isPosInt(this.maxEntrySize)) {
              throw new TypeError(
                "maxEntrySize must be a positive integer if specified",
              );
            }
            this.#initializeSizeTracking();
          }
          this.allowStale = !!allowStale;
          this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
          this.updateAgeOnGet = !!updateAgeOnGet;
          this.updateAgeOnHas = !!updateAgeOnHas;
          this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
          this.ttlAutopurge = !!ttlAutopurge;
          this.ttl = ttl || 0;
          if (this.ttl) {
            if (!isPosInt(this.ttl)) {
              throw new TypeError(
                "ttl must be a positive integer if specified",
              );
            }
            this.#initializeTTLTracking();
          }
          if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError(
              "At least one of max, maxSize, or ttl is required",
            );
          }
          if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code)) {
              warned.add(code);
              const msg =
                "TTL caching without ttlAutopurge, max, or maxSize can " +
                "result in unbounded memory consumption.";
              emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
            }
          }
        }
        getRemainingTTL(key) {
          return this.#keyMap.has(key) ? Infinity : 0;
        }
        #initializeTTLTracking() {
          const ttls = new ZeroArray(this.#max);
          const starts = new ZeroArray(this.#max);
          this.#ttls = ttls;
          this.#starts = starts;
          this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
              const t = setTimeout(() => {
                if (this.#isStale(index)) {
                  this.#delete(this.#keyList[index], "expire");
                }
              }, ttl + 1);
              if (t.unref) {
                t.unref();
              }
            }
          };
          this.#updateItemAge = (index) => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
          };
          this.#statusTTL = (status, index) => {
            if (ttls[index]) {
              const ttl = ttls[index];
              const start = starts[index];
              if (!ttl || !start) return;
              status.ttl = ttl;
              status.start = start;
              status.now = cachedNow || getNow();
              const age = status.now - start;
              status.remainingTTL = ttl - age;
            }
          };
          let cachedNow = 0;
          const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
              cachedNow = n;
              const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
              if (t.unref) {
                t.unref();
              }
            }
            return n;
          };
          this.getRemainingTTL = (key) => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
              return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
              return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
          };
          this.#isStale = (index) => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
          };
        }
        #updateItemAge = () => {};
        #statusTTL = () => {};
        #setItemTTL = () => {};
        #isStale = () => false;
        #initializeSizeTracking() {
          const sizes = new ZeroArray(this.#max);
          this.#calculatedSize = 0;
          this.#sizes = sizes;
          this.#removeItemSize = (index) => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
          };
          this.#requireSize = (k, v, size, sizeCalculation) => {
            if (this.#isBackgroundFetch(v)) {
              return 0;
            }
            if (!isPosInt(size)) {
              if (sizeCalculation) {
                if (typeof sizeCalculation !== "function") {
                  throw new TypeError("sizeCalculation must be a function");
                }
                size = sizeCalculation(v, k);
                if (!isPosInt(size)) {
                  throw new TypeError(
                    "sizeCalculation return invalid (expect positive integer)",
                  );
                }
              } else {
                throw new TypeError(
                  "invalid size value (must be positive integer). " +
                    "When maxSize or maxEntrySize is used, sizeCalculation " +
                    "or size must be set.",
                );
              }
            }
            return size;
          };
          this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
              const maxSize = this.#maxSize - sizes[index];
              while (this.#calculatedSize > maxSize) {
                this.#evict(true);
              }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
              status.entrySize = size;
              status.totalCalculatedSize = this.#calculatedSize;
            }
          };
        }
        #removeItemSize = (_i) => {};
        #addItemSize = (_i, _s, _st) => {};
        #requireSize = (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError(
              "cannot set size without setting maxSize or maxEntrySize on cache",
            );
          }
          return 0;
        };
        *#indexes({ allowStale = this.allowStale } = {}) {
          if (this.#size) {
            for (let i = this.#tail; true; ) {
              if (!this.#isValidIndex(i)) {
                break;
              }
              if (allowStale || !this.#isStale(i)) {
                yield i;
              }
              if (i === this.#head) {
                break;
              } else {
                i = this.#prev[i];
              }
            }
          }
        }
        *#rindexes({ allowStale = this.allowStale } = {}) {
          if (this.#size) {
            for (let i = this.#head; true; ) {
              if (!this.#isValidIndex(i)) {
                break;
              }
              if (allowStale || !this.#isStale(i)) {
                yield i;
              }
              if (i === this.#tail) {
                break;
              } else {
                i = this.#next[i];
              }
            }
          }
        }
        #isValidIndex(index) {
          return (
            index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index
          );
        }
        *entries() {
          for (const i of this.#indexes()) {
            if (
              this.#valList[i] !== undefined &&
              this.#keyList[i] !== undefined &&
              !this.#isBackgroundFetch(this.#valList[i])
            ) {
              yield [this.#keyList[i], this.#valList[i]];
            }
          }
        }
        *rentries() {
          for (const i of this.#rindexes()) {
            if (
              this.#valList[i] !== undefined &&
              this.#keyList[i] !== undefined &&
              !this.#isBackgroundFetch(this.#valList[i])
            ) {
              yield [this.#keyList[i], this.#valList[i]];
            }
          }
        }
        *keys() {
          for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield k;
            }
          }
        }
        *rkeys() {
          for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield k;
            }
          }
        }
        *values() {
          for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield this.#valList[i];
            }
          }
        }
        *rvalues() {
          for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield this.#valList[i];
            }
          }
        }
        [Symbol.iterator]() {
          return this.entries();
        }
        [Symbol.toStringTag] = "LRUCache";
        find(fn, getOptions = {}) {
          for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined) continue;
            if (fn(value, this.#keyList[i], this)) {
              return this.get(this.#keyList[i], getOptions);
            }
          }
        }
        forEach(fn, thisp = this) {
          for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
          }
        }
        rforEach(fn, thisp = this) {
          for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
          }
        }
        purgeStale() {
          let deleted = false;
          for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
              this.#delete(this.#keyList[i], "expire");
              deleted = true;
            }
          }
          return deleted;
        }
        info(key) {
          const i = this.#keyMap.get(key);
          if (i === undefined) return undefined;
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === undefined) return undefined;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
              const remain = ttl - (perf.now() - start);
              entry.ttl = remain;
              entry.start = Date.now();
            }
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          return entry;
        }
        dump() {
          const arr = [];
          for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined || key === undefined) continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
              entry.ttl = this.#ttls[i];
              const age = perf.now() - this.#starts[i];
              entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
              entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
          }
          return arr;
        }
        load(arr) {
          this.clear();
          for (const [key, entry] of arr) {
            if (entry.start) {
              const age = Date.now() - entry.start;
              entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
          }
        }
        set(k, v, setOptions = {}) {
          if (v === undefined) {
            this.delete(k);
            return this;
          }
          const {
            ttl = this.ttl,
            start,
            noDisposeOnSet = this.noDisposeOnSet,
            sizeCalculation = this.sizeCalculation,
            status,
          } = setOptions;
          let { noUpdateTTL = this.noUpdateTTL } = setOptions;
          const size = this.#requireSize(
            k,
            v,
            setOptions.size || 0,
            sizeCalculation,
          );
          if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
              status.set = "miss";
              status.maxEntrySizeExceeded = true;
            }
            this.#delete(k, "set");
            return this;
          }
          let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
          if (index === undefined) {
            index =
              this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                  ? this.#free.pop()
                  : this.#size === this.#max
                    ? this.#evict(false)
                    : this.#size;
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status) status.set = "add";
            noUpdateTTL = false;
          } else {
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
              if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                oldVal.__abortController.abort(new Error("replaced"));
                const { __staleWhileFetching: s } = oldVal;
                if (s !== undefined && !noDisposeOnSet) {
                  if (this.#hasDispose) {
                    this.#dispose?.(s, k, "set");
                  }
                  if (this.#hasDisposeAfter) {
                    this.#disposed?.push([s, k, "set"]);
                  }
                }
              } else if (!noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(oldVal, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([oldVal, k, "set"]);
                }
              }
              this.#removeItemSize(index);
              this.#addItemSize(index, size, status);
              this.#valList[index] = v;
              if (status) {
                status.set = "replace";
                const oldValue =
                  oldVal && this.#isBackgroundFetch(oldVal)
                    ? oldVal.__staleWhileFetching
                    : oldVal;
                if (oldValue !== undefined) status.oldValue = oldValue;
              }
            } else if (status) {
              status.set = "update";
            }
          }
          if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
          }
          if (this.#ttls) {
            if (!noUpdateTTL) {
              this.#setItemTTL(index, ttl, start);
            }
            if (status) this.#statusTTL(status, index);
          }
          if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
              this.#disposeAfter?.(...task);
            }
          }
          return this;
        }
        pop() {
          try {
            while (this.#size) {
              const val = this.#valList[this.#head];
              this.#evict(true);
              if (this.#isBackgroundFetch(val)) {
                if (val.__staleWhileFetching) {
                  return val.__staleWhileFetching;
                }
              } else if (val !== undefined) {
                return val;
              }
            }
          } finally {
            if (this.#hasDisposeAfter && this.#disposed) {
              const dt = this.#disposed;
              let task;
              while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
              }
            }
          }
        }
        #evict(free) {
          const head = this.#head;
          const k = this.#keyList[head];
          const v = this.#valList[head];
          if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("evicted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "evict");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "evict"]);
            }
          }
          this.#removeItemSize(head);
          if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
          }
          if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
          } else {
            this.#head = this.#next[head];
          }
          this.#keyMap.delete(k);
          this.#size--;
          return head;
        }
        has(k, hasOptions = {}) {
          const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
          const index = this.#keyMap.get(k);
          if (index !== undefined) {
            const v = this.#valList[index];
            if (
              this.#isBackgroundFetch(v) &&
              v.__staleWhileFetching === undefined
            ) {
              return false;
            }
            if (!this.#isStale(index)) {
              if (updateAgeOnHas) {
                this.#updateItemAge(index);
              }
              if (status) {
                status.has = "hit";
                this.#statusTTL(status, index);
              }
              return true;
            } else if (status) {
              status.has = "stale";
              this.#statusTTL(status, index);
            }
          } else if (status) {
            status.has = "miss";
          }
          return false;
        }
        peek(k, peekOptions = {}) {
          const { allowStale = this.allowStale } = peekOptions;
          const index = this.#keyMap.get(k);
          if (index === undefined || (!allowStale && this.#isStale(index))) {
            return;
          }
          const v = this.#valList[index];
          return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
        #backgroundFetch(k, index, options, context) {
          const v = index === undefined ? undefined : this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            return v;
          }
          const ac = new AC();
          const { signal } = options;
          signal?.addEventListener("abort", () => ac.abort(signal.reason), {
            signal: ac.signal,
          });
          const fetchOpts = { signal: ac.signal, options, context };
          const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
              if (aborted && !updateCache) {
                options.status.fetchAborted = true;
                options.status.fetchError = ac.signal.reason;
                if (ignoreAbort) options.status.fetchAbortIgnored = true;
              } else {
                options.status.fetchResolved = true;
              }
            }
            if (aborted && !ignoreAbort && !updateCache) {
              return fetchFail(ac.signal.reason);
            }
            const bf = p;
            if (this.#valList[index] === p) {
              if (v === undefined) {
                if (bf.__staleWhileFetching) {
                  this.#valList[index] = bf.__staleWhileFetching;
                } else {
                  this.#delete(k, "fetch");
                }
              } else {
                if (options.status) options.status.fetchUpdated = true;
                this.set(k, v, fetchOpts.options);
              }
            }
            return v;
          };
          const eb = (er) => {
            if (options.status) {
              options.status.fetchRejected = true;
              options.status.fetchError = er;
            }
            return fetchFail(er);
          };
          const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale =
              allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
              const del = !noDelete || bf.__staleWhileFetching === undefined;
              if (del) {
                this.#delete(k, "fetch");
              } else if (!allowStaleAborted) {
                this.#valList[index] = bf.__staleWhileFetching;
              }
            }
            if (allowStale) {
              if (options.status && bf.__staleWhileFetching !== undefined) {
                options.status.returnedStale = true;
              }
              return bf.__staleWhileFetching;
            } else if (bf.__returned === bf) {
              throw er;
            }
          };
          const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
              fmp.then((v) => res(v === undefined ? undefined : v), rej);
            }
            ac.signal.addEventListener("abort", () => {
              if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                res(undefined);
                if (options.allowStaleOnFetchAbort) {
                  res = (v) => cb(v, true);
                }
              }
            });
          };
          if (options.status) options.status.fetchDispatched = true;
          const p = new Promise(pcall).then(cb, eb);
          const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
          });
          if (index === undefined) {
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
          } else {
            this.#valList[index] = bf;
          }
          return bf;
        }
        #isBackgroundFetch(p) {
          if (!this.#hasFetchMethod) return false;
          const b = p;
          return (
            !!b &&
            b instanceof Promise &&
            b.hasOwnProperty("__staleWhileFetching") &&
            b.__abortController instanceof AC
          );
        }
        async fetch(k, fetchOptions = {}) {
          const {
            allowStale = this.allowStale,
            updateAgeOnGet = this.updateAgeOnGet,
            noDeleteOnStaleGet = this.noDeleteOnStaleGet,
            ttl = this.ttl,
            noDisposeOnSet = this.noDisposeOnSet,
            size = 0,
            sizeCalculation = this.sizeCalculation,
            noUpdateTTL = this.noUpdateTTL,
            noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
            allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
            ignoreFetchAbort = this.ignoreFetchAbort,
            allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
            context,
            forceRefresh = false,
            status,
            signal,
          } = fetchOptions;
          if (!this.#hasFetchMethod) {
            if (status) status.fetch = "get";
            return this.get(k, {
              allowStale,
              updateAgeOnGet,
              noDeleteOnStaleGet,
              status,
            });
          }
          const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
          };
          let index = this.#keyMap.get(k);
          if (index === undefined) {
            if (status) status.fetch = "miss";
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
          } else {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              const stale = allowStale && v.__staleWhileFetching !== undefined;
              if (status) {
                status.fetch = "inflight";
                if (stale) status.returnedStale = true;
              }
              return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
              if (status) status.fetch = "hit";
              this.#moveToTail(index);
              if (updateAgeOnGet) {
                this.#updateItemAge(index);
              }
              if (status) this.#statusTTL(status, index);
              return v;
            }
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
              status.fetch = isStale ? "stale" : "refresh";
              if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
          }
        }
        async forceFetch(k, fetchOptions = {}) {
          const v = await this.fetch(k, fetchOptions);
          if (v === undefined) throw new Error("fetch() returned undefined");
          return v;
        }
        memo(k, memoOptions = {}) {
          const memoMethod = this.#memoMethod;
          if (!memoMethod) {
            throw new Error("no memoMethod provided to constructor");
          }
          const { context, forceRefresh, ...options } = memoOptions;
          const v = this.get(k, options);
          if (!forceRefresh && v !== undefined) return v;
          const vv = memoMethod(k, v, { options, context });
          this.set(k, vv, options);
          return vv;
        }
        get(k, getOptions = {}) {
          const {
            allowStale = this.allowStale,
            updateAgeOnGet = this.updateAgeOnGet,
            noDeleteOnStaleGet = this.noDeleteOnStaleGet,
            status,
          } = getOptions;
          const index = this.#keyMap.get(k);
          if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status) this.#statusTTL(status, index);
            if (this.#isStale(index)) {
              if (status) status.get = "stale";
              if (!fetching) {
                if (!noDeleteOnStaleGet) {
                  this.#delete(k, "expire");
                }
                if (status && allowStale) status.returnedStale = true;
                return allowStale ? value : undefined;
              } else {
                if (
                  status &&
                  allowStale &&
                  value.__staleWhileFetching !== undefined
                ) {
                  status.returnedStale = true;
                }
                return allowStale ? value.__staleWhileFetching : undefined;
              }
            } else {
              if (status) status.get = "hit";
              if (fetching) {
                return value.__staleWhileFetching;
              }
              this.#moveToTail(index);
              if (updateAgeOnGet) {
                this.#updateItemAge(index);
              }
              return value;
            }
          } else if (status) {
            status.get = "miss";
          }
        }
        #connect(p, n) {
          this.#prev[n] = p;
          this.#next[p] = n;
        }
        #moveToTail(index) {
          if (index !== this.#tail) {
            if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
          }
        }
        delete(k) {
          return this.#delete(k, "delete");
        }
        #delete(k, reason) {
          let deleted = false;
          if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
              deleted = true;
              if (this.#size === 1) {
                this.#clear(reason);
              } else {
                this.#removeItemSize(index);
                const v = this.#valList[index];
                if (this.#isBackgroundFetch(v)) {
                  v.__abortController.abort(new Error("deleted"));
                } else if (this.#hasDispose || this.#hasDisposeAfter) {
                  if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                  }
                  if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                  }
                }
                this.#keyMap.delete(k);
                this.#keyList[index] = undefined;
                this.#valList[index] = undefined;
                if (index === this.#tail) {
                  this.#tail = this.#prev[index];
                } else if (index === this.#head) {
                  this.#head = this.#next[index];
                } else {
                  const pi = this.#prev[index];
                  this.#next[pi] = this.#next[index];
                  const ni = this.#next[index];
                  this.#prev[ni] = this.#prev[index];
                }
                this.#size--;
                this.#free.push(index);
              }
            }
          }
          if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
              this.#disposeAfter?.(...task);
            }
          }
          return deleted;
        }
        clear() {
          return this.#clear("delete");
        }
        #clear(reason) {
          for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else {
              const k = this.#keyList[index];
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
          }
          this.#keyMap.clear();
          this.#valList.fill(undefined);
          this.#keyList.fill(undefined);
          if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
          }
          if (this.#sizes) {
            this.#sizes.fill(0);
          }
          this.#head = 0;
          this.#tail = 0;
          this.#free.length = 0;
          this.#calculatedSize = 0;
          this.#size = 0;
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      exports.LRUCache = LRUCache;
    },
    4149: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assertValidPattern = void 0;
      const MAX_PATTERN_LENGTH = 1024 * 64;
      const assertValidPattern = (pattern) => {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };
      exports.assertValidPattern = assertValidPattern;
    },
    5136: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AST = void 0;
      const brace_expressions_js_1 = __nccwpck_require__(1812);
      const unescape_js_1 = __nccwpck_require__(5698);
      const types = new Set(["!", "?", "+", "*", "@"]);
      const isExtglobType = (c) => types.has(c);
      const startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
      const startNoDot = "(?!\\.)";
      const addPatternStart = new Set(["[", "."]);
      const justDots = new Set(["..", "."]);
      const reSpecials = new Set("().*{}+?[]^$\\!");
      const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      const qmark = "[^/]";
      const star = qmark + "*?";
      const starNoEmpty = qmark + "+?";
      class AST {
        type;
        #root;
        #hasMagic;
        #uflag = false;
        #parts = [];
        #parent;
        #parentIndex;
        #negs;
        #filledNegs = false;
        #options;
        #toString;
        #emptyExt = false;
        constructor(type, parent, options = {}) {
          this.type = type;
          if (type) this.#hasMagic = true;
          this.#parent = parent;
          this.#root = this.#parent ? this.#parent.#root : this;
          this.#options = this.#root === this ? options : this.#root.#options;
          this.#negs = this.#root === this ? [] : this.#root.#negs;
          if (type === "!" && !this.#root.#filledNegs) this.#negs.push(this);
          this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
        }
        get hasMagic() {
          if (this.#hasMagic !== undefined) return this.#hasMagic;
          for (const p of this.#parts) {
            if (typeof p === "string") continue;
            if (p.type || p.hasMagic) return (this.#hasMagic = true);
          }
          return this.#hasMagic;
        }
        toString() {
          if (this.#toString !== undefined) return this.#toString;
          if (!this.type) {
            return (this.#toString = this.#parts
              .map((p) => String(p))
              .join(""));
          } else {
            return (this.#toString =
              this.type +
              "(" +
              this.#parts.map((p) => String(p)).join("|") +
              ")");
          }
        }
        #fillNegs() {
          if (this !== this.#root) throw new Error("should only call on root");
          if (this.#filledNegs) return this;
          this.toString();
          this.#filledNegs = true;
          let n;
          while ((n = this.#negs.pop())) {
            if (n.type !== "!") continue;
            let p = n;
            let pp = p.#parent;
            while (pp) {
              for (
                let i = p.#parentIndex + 1;
                !pp.type && i < pp.#parts.length;
                i++
              ) {
                for (const part of n.#parts) {
                  if (typeof part === "string") {
                    throw new Error("string part in extglob AST??");
                  }
                  part.copyIn(pp.#parts[i]);
                }
              }
              p = pp;
              pp = p.#parent;
            }
          }
          return this;
        }
        push(...parts) {
          for (const p of parts) {
            if (p === "") continue;
            if (
              typeof p !== "string" &&
              !(p instanceof AST && p.#parent === this)
            ) {
              throw new Error("invalid part: " + p);
            }
            this.#parts.push(p);
          }
        }
        toJSON() {
          const ret =
            this.type === null
              ? this.#parts
                  .slice()
                  .map((p) => (typeof p === "string" ? p : p.toJSON()))
              : [this.type, ...this.#parts.map((p) => p.toJSON())];
          if (this.isStart() && !this.type) ret.unshift([]);
          if (
            this.isEnd() &&
            (this === this.#root ||
              (this.#root.#filledNegs && this.#parent?.type === "!"))
          ) {
            ret.push({});
          }
          return ret;
        }
        isStart() {
          if (this.#root === this) return true;
          if (!this.#parent?.isStart()) return false;
          if (this.#parentIndex === 0) return true;
          const p = this.#parent;
          for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === "!")) {
              return false;
            }
          }
          return true;
        }
        isEnd() {
          if (this.#root === this) return true;
          if (this.#parent?.type === "!") return true;
          if (!this.#parent?.isEnd()) return false;
          if (!this.type) return this.#parent?.isEnd();
          const pl = this.#parent ? this.#parent.#parts.length : 0;
          return this.#parentIndex === pl - 1;
        }
        copyIn(part) {
          if (typeof part === "string") this.push(part);
          else this.push(part.clone(this));
        }
        clone(parent) {
          const c = new AST(this.type, parent);
          for (const p of this.#parts) {
            c.copyIn(p);
          }
          return c;
        }
        static #parseAST(str, ast, pos, opt) {
          let escaping = false;
          let inBrace = false;
          let braceStart = -1;
          let braceNeg = false;
          if (ast.type === null) {
            let i = pos;
            let acc = "";
            while (i < str.length) {
              const c = str.charAt(i++);
              if (escaping || c === "\\") {
                escaping = !escaping;
                acc += c;
                continue;
              }
              if (inBrace) {
                if (i === braceStart + 1) {
                  if (c === "^" || c === "!") {
                    braceNeg = true;
                  }
                } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
                  inBrace = false;
                }
                acc += c;
                continue;
              } else if (c === "[") {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
              }
              if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
                ast.push(acc);
                acc = "";
                const ext = new AST(c, ast);
                i = AST.#parseAST(str, ext, i, opt);
                ast.push(ext);
                continue;
              }
              acc += c;
            }
            ast.push(acc);
            return i;
          }
          let i = pos + 1;
          let part = new AST(null, ast);
          const parts = [];
          let acc = "";
          while (i < str.length) {
            const c = str.charAt(i++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc += c;
              continue;
            }
            if (inBrace) {
              if (i === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i;
              braceNeg = false;
              acc += c;
              continue;
            }
            if (isExtglobType(c) && str.charAt(i) === "(") {
              part.push(acc);
              acc = "";
              const ext = new AST(c, part);
              part.push(ext);
              i = AST.#parseAST(str, ext, i, opt);
              continue;
            }
            if (c === "|") {
              part.push(acc);
              acc = "";
              parts.push(part);
              part = new AST(null, ast);
              continue;
            }
            if (c === ")") {
              if (acc === "" && ast.#parts.length === 0) {
                ast.#emptyExt = true;
              }
              part.push(acc);
              acc = "";
              ast.push(...parts, part);
              return i;
            }
            acc += c;
          }
          ast.type = null;
          ast.#hasMagic = undefined;
          ast.#parts = [str.substring(pos - 1)];
          return i;
        }
        static fromGlob(pattern, options = {}) {
          const ast = new AST(null, undefined, options);
          AST.#parseAST(pattern, ast, 0, options);
          return ast;
        }
        toMMPattern() {
          if (this !== this.#root) return this.#root.toMMPattern();
          const glob = this.toString();
          const [re, body, hasMagic, uflag] = this.toRegExpSource();
          const anyMagic =
            hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
              !this.#options.nocaseMagicOnly &&
              glob.toUpperCase() !== glob.toLowerCase());
          if (!anyMagic) {
            return body;
          }
          const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
          return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
          });
        }
        get options() {
          return this.#options;
        }
        toRegExpSource(allowDot) {
          const dot = allowDot ?? !!this.#options.dot;
          if (this.#root === this) this.#fillNegs();
          if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
              .map((p) => {
                const [re, _, hasMagic, uflag] =
                  typeof p === "string"
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
              })
              .join("");
            let start = "";
            if (this.isStart()) {
              if (typeof this.#parts[0] === "string") {
                const dotTravAllowed =
                  this.#parts.length === 1 && justDots.has(this.#parts[0]);
                if (!dotTravAllowed) {
                  const aps = addPatternStart;
                  const needNoTrav =
                    (dot && aps.has(src.charAt(0))) ||
                    (src.startsWith("\\.") && aps.has(src.charAt(2))) ||
                    (src.startsWith("\\.\\.") && aps.has(src.charAt(4)));
                  const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                  start = needNoTrav
                    ? startNoTraversal
                    : needNoDot
                      ? startNoDot
                      : "";
                }
              }
            }
            let end = "";
            if (
              this.isEnd() &&
              this.#root.#filledNegs &&
              this.#parent?.type === "!"
            ) {
              end = "(?:$|\\/)";
            }
            const final = start + src + end;
            return [
              final,
              (0, unescape_js_1.unescape)(src),
              (this.#hasMagic = !!this.#hasMagic),
              this.#uflag,
            ];
          }
          const repeated = this.type === "*" || this.type === "+";
          const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
          let body = this.#partsToRegExp(dot);
          if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [
              s,
              (0, unescape_js_1.unescape)(this.toString()),
              false,
              false,
            ];
          }
          let bodyDotAllowed =
            !repeated || allowDot || dot || !startNoDot
              ? ""
              : this.#partsToRegExp(true);
          if (bodyDotAllowed === body) {
            bodyDotAllowed = "";
          }
          if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
          }
          let final = "";
          if (this.type === "!" && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
          } else {
            const close =
              this.type === "!"
                ? "))" +
                  (this.isStart() && !dot && !allowDot ? startNoDot : "") +
                  star +
                  ")"
                : this.type === "@"
                  ? ")"
                  : this.type === "?"
                    ? ")?"
                    : this.type === "+" && bodyDotAllowed
                      ? ")"
                      : this.type === "*" && bodyDotAllowed
                        ? `)?`
                        : `)${this.type}`;
            final = start + body + close;
          }
          return [
            final,
            (0, unescape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
          ];
        }
        #partsToRegExp(dot) {
          return this.#parts
            .map((p) => {
              if (typeof p === "string") {
                throw new Error("string type in extglob ast??");
              }
              const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
              this.#uflag = this.#uflag || uflag;
              return re;
            })
            .filter((p) => !(this.isStart() && this.isEnd()) || !!p)
            .join("|");
        }
        static #parseGlob(glob, hasMagic, noEmpty = false) {
          let escaping = false;
          let re = "";
          let uflag = false;
          for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
              escaping = false;
              re += (reSpecials.has(c) ? "\\" : "") + c;
              continue;
            }
            if (c === "\\") {
              if (i === glob.length - 1) {
                re += "\\\\";
              } else {
                escaping = true;
              }
              continue;
            }
            if (c === "[") {
              const [src, needUflag, consumed, magic] = (0,
              brace_expressions_js_1.parseClass)(glob, i);
              if (consumed) {
                re += src;
                uflag = uflag || needUflag;
                i += consumed - 1;
                hasMagic = hasMagic || magic;
                continue;
              }
            }
            if (c === "*") {
              if (noEmpty && glob === "*") re += starNoEmpty;
              else re += star;
              hasMagic = true;
              continue;
            }
            if (c === "?") {
              re += qmark;
              hasMagic = true;
              continue;
            }
            re += regExpEscape(c);
          }
          return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
        }
      }
      exports.AST = AST;
    },
    1812: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseClass = void 0;
      const posixClasses = {
        "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
        "[:alpha:]": ["\\p{L}\\p{Nl}", true],
        "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
        "[:blank:]": ["\\p{Zs}\\t", true],
        "[:cntrl:]": ["\\p{Cc}", true],
        "[:digit:]": ["\\p{Nd}", true],
        "[:graph:]": ["\\p{Z}\\p{C}", true, true],
        "[:lower:]": ["\\p{Ll}", true],
        "[:print:]": ["\\p{C}", true],
        "[:punct:]": ["\\p{P}", true],
        "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
        "[:upper:]": ["\\p{Lu}", true],
        "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
        "[:xdigit:]": ["A-Fa-f0-9", false],
      };
      const braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
      const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      const rangesToString = (ranges) => ranges.join("");
      const parseClass = (glob, position) => {
        const pos = position;
        if (glob.charAt(pos) !== "[") {
          throw new Error("not in a brace expression");
        }
        const ranges = [];
        const negs = [];
        let i = pos + 1;
        let sawStart = false;
        let uflag = false;
        let escaping = false;
        let negate = false;
        let endPos = pos;
        let rangeStart = "";
        WHILE: while (i < glob.length) {
          const c = glob.charAt(i);
          if ((c === "!" || c === "^") && i === pos + 1) {
            negate = true;
            i++;
            continue;
          }
          if (c === "]" && sawStart && !escaping) {
            endPos = i + 1;
            break;
          }
          sawStart = true;
          if (c === "\\") {
            if (!escaping) {
              escaping = true;
              i++;
              continue;
            }
          }
          if (c === "[" && !escaping) {
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
              if (glob.startsWith(cls, i)) {
                if (rangeStart) {
                  return ["$.", false, glob.length - pos, true];
                }
                i += cls.length;
                if (neg) negs.push(unip);
                else ranges.push(unip);
                uflag = uflag || u;
                continue WHILE;
              }
            }
          }
          escaping = false;
          if (rangeStart) {
            if (c > rangeStart) {
              ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
            } else if (c === rangeStart) {
              ranges.push(braceEscape(c));
            }
            rangeStart = "";
            i++;
            continue;
          }
          if (glob.startsWith("-]", i + 1)) {
            ranges.push(braceEscape(c + "-"));
            i += 2;
            continue;
          }
          if (glob.startsWith("-", i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
          }
          ranges.push(braceEscape(c));
          i++;
        }
        if (endPos < i) {
          return ["", false, 0, false];
        }
        if (!ranges.length && !negs.length) {
          return ["$.", false, glob.length - pos, true];
        }
        if (
          negs.length === 0 &&
          ranges.length === 1 &&
          /^\\?.$/.test(ranges[0]) &&
          !negate
        ) {
          const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
          return [regexpEscape(r), false, endPos - pos, false];
        }
        const sranges =
          "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
        const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
        const comb =
          ranges.length && negs.length
            ? "(" + sranges + "|" + snegs + ")"
            : ranges.length
              ? sranges
              : snegs;
        return [comb, uflag, endPos - pos, true];
      };
      exports.parseClass = parseClass;
    },
    2804: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.escape = void 0;
      const escape = (s, { windowsPathsNoEscape = false } = {}) =>
        windowsPathsNoEscape
          ? s.replace(/[?*()[\]]/g, "[$&]")
          : s.replace(/[?*()[\]\\]/g, "\\$&");
      exports.escape = escape;
    },
    4501: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unescape =
        exports.escape =
        exports.AST =
        exports.Minimatch =
        exports.match =
        exports.makeRe =
        exports.braceExpand =
        exports.defaults =
        exports.filter =
        exports.GLOBSTAR =
        exports.sep =
        exports.minimatch =
          void 0;
      const brace_expansion_1 = __importDefault(__nccwpck_require__(8184));
      const assert_valid_pattern_js_1 = __nccwpck_require__(4149);
      const ast_js_1 = __nccwpck_require__(5136);
      const escape_js_1 = __nccwpck_require__(2804);
      const unescape_js_1 = __nccwpck_require__(5698);
      const minimatch = (p, pattern, options = {}) => {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch(pattern, options).match(p);
      };
      exports.minimatch = minimatch;
      const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
      const starDotExtTest = (ext) => (f) =>
        !f.startsWith(".") && f.endsWith(ext);
      const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
      const starDotExtTestNocase = (ext) => {
        ext = ext.toLowerCase();
        return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext);
      };
      const starDotExtTestNocaseDot = (ext) => {
        ext = ext.toLowerCase();
        return (f) => f.toLowerCase().endsWith(ext);
      };
      const starDotStarRE = /^\*+\.\*+$/;
      const starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
      const starDotStarTestDot = (f) =>
        f !== "." && f !== ".." && f.includes(".");
      const dotStarRE = /^\.\*+$/;
      const dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
      const starRE = /^\*+$/;
      const starTest = (f) => f.length !== 0 && !f.startsWith(".");
      const starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
      const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
      const qmarksTestNocase = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExt([$0]);
        if (!ext) return noext;
        ext = ext.toLowerCase();
        return (f) => noext(f) && f.toLowerCase().endsWith(ext);
      };
      const qmarksTestNocaseDot = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExtDot([$0]);
        if (!ext) return noext;
        ext = ext.toLowerCase();
        return (f) => noext(f) && f.toLowerCase().endsWith(ext);
      };
      const qmarksTestDot = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExtDot([$0]);
        return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
      };
      const qmarksTest = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExt([$0]);
        return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
      };
      const qmarksTestNoExt = ([$0]) => {
        const len = $0.length;
        return (f) => f.length === len && !f.startsWith(".");
      };
      const qmarksTestNoExtDot = ([$0]) => {
        const len = $0.length;
        return (f) => f.length === len && f !== "." && f !== "..";
      };
      const defaultPlatform =
        typeof process === "object" && process
          ? (typeof process.env === "object" &&
              process.env &&
              process.env.__MINIMATCH_TESTING_PLATFORM__) ||
            process.platform
          : "posix";
      const path = { win32: { sep: "\\" }, posix: { sep: "/" } };
      exports.sep =
        defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
      exports.minimatch.sep = exports.sep;
      exports.GLOBSTAR = Symbol("globstar **");
      exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
      const qmark = "[^/]";
      const star = qmark + "*?";
      const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      const filter =
        (pattern, options = {}) =>
        (p) =>
          (0, exports.minimatch)(p, pattern, options);
      exports.filter = filter;
      exports.minimatch.filter = exports.filter;
      const ext = (a, b = {}) => Object.assign({}, a, b);
      const defaults = (def) => {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return exports.minimatch;
        }
        const orig = exports.minimatch;
        const m = (p, pattern, options = {}) =>
          orig(p, pattern, ext(def, options));
        return Object.assign(m, {
          Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
              super(pattern, ext(def, options));
            }
            static defaults(options) {
              return orig.defaults(ext(def, options)).Minimatch;
            }
          },
          AST: class AST extends orig.AST {
            constructor(type, parent, options = {}) {
              super(type, parent, ext(def, options));
            }
            static fromGlob(pattern, options = {}) {
              return orig.AST.fromGlob(pattern, ext(def, options));
            }
          },
          unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
          escape: (s, options = {}) => orig.escape(s, ext(def, options)),
          filter: (pattern, options = {}) =>
            orig.filter(pattern, ext(def, options)),
          defaults: (options) => orig.defaults(ext(def, options)),
          makeRe: (pattern, options = {}) =>
            orig.makeRe(pattern, ext(def, options)),
          braceExpand: (pattern, options = {}) =>
            orig.braceExpand(pattern, ext(def, options)),
          match: (list, pattern, options = {}) =>
            orig.match(list, pattern, ext(def, options)),
          sep: orig.sep,
          GLOBSTAR: exports.GLOBSTAR,
        });
      };
      exports.defaults = defaults;
      exports.minimatch.defaults = exports.defaults;
      const braceExpand = (pattern, options = {}) => {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return (0, brace_expansion_1.default)(pattern);
      };
      exports.braceExpand = braceExpand;
      exports.minimatch.braceExpand = exports.braceExpand;
      const makeRe = (pattern, options = {}) =>
        new Minimatch(pattern, options).makeRe();
      exports.makeRe = makeRe;
      exports.minimatch.makeRe = exports.makeRe;
      const match = (list, pattern, options = {}) => {
        const mm = new Minimatch(pattern, options);
        list = list.filter((f) => mm.match(f));
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      exports.match = match;
      exports.minimatch.match = exports.match;
      const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
      const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      class Minimatch {
        options;
        set;
        pattern;
        windowsPathsNoEscape;
        nonegate;
        negate;
        comment;
        empty;
        preserveMultipleSlashes;
        partial;
        globSet;
        globParts;
        nocase;
        isWindows;
        platform;
        windowsNoMagicRoot;
        regexp;
        constructor(pattern, options = {}) {
          (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
          options = options || {};
          this.options = options;
          this.pattern = pattern;
          this.platform = options.platform || defaultPlatform;
          this.isWindows = this.platform === "win32";
          this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape ||
            options.allowWindowsEscape === false;
          if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, "/");
          }
          this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
          this.regexp = null;
          this.negate = false;
          this.nonegate = !!options.nonegate;
          this.comment = false;
          this.empty = false;
          this.partial = !!options.partial;
          this.nocase = !!this.options.nocase;
          this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
              ? options.windowsNoMagicRoot
              : !!(this.isWindows && this.nocase);
          this.globSet = [];
          this.globParts = [];
          this.set = [];
          this.make();
        }
        hasMagic() {
          if (this.options.magicalBraces && this.set.length > 1) {
            return true;
          }
          for (const pattern of this.set) {
            for (const part of pattern) {
              if (typeof part !== "string") return true;
            }
          }
          return false;
        }
        debug(..._) {}
        make() {
          const pattern = this.pattern;
          const options = this.options;
          if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
          }
          if (!pattern) {
            this.empty = true;
            return;
          }
          this.parseNegate();
          this.globSet = [...new Set(this.braceExpand())];
          if (options.debug) {
            this.debug = (...args) => console.error(...args);
          }
          this.debug(this.pattern, this.globSet);
          const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
          this.globParts = this.preprocess(rawGlobParts);
          this.debug(this.pattern, this.globParts);
          let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
              const isUNC =
                s[0] === "" &&
                s[1] === "" &&
                (s[2] === "?" || !globMagic.test(s[2])) &&
                !globMagic.test(s[3]);
              const isDrive = /^[a-z]:/i.test(s[0]);
              if (isUNC) {
                return [
                  ...s.slice(0, 4),
                  ...s.slice(4).map((ss) => this.parse(ss)),
                ];
              } else if (isDrive) {
                return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
              }
            }
            return s.map((ss) => this.parse(ss));
          });
          this.debug(this.pattern, set);
          this.set = set.filter((s) => s.indexOf(false) === -1);
          if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
              const p = this.set[i];
              if (
                p[0] === "" &&
                p[1] === "" &&
                this.globParts[i][2] === "?" &&
                typeof p[3] === "string" &&
                /^[a-z]:$/i.test(p[3])
              ) {
                p[2] = "?";
              }
            }
          }
          this.debug(this.pattern, this.set);
        }
        preprocess(globParts) {
          if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
              for (let j = 0; j < globParts[i].length; j++) {
                if (globParts[i][j] === "**") {
                  globParts[i][j] = "*";
                }
              }
            }
          }
          const { optimizationLevel = 1 } = this.options;
          if (optimizationLevel >= 2) {
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
          } else if (optimizationLevel >= 1) {
            globParts = this.levelOneOptimize(globParts);
          } else {
            globParts = this.adjascentGlobstarOptimize(globParts);
          }
          return globParts;
        }
        adjascentGlobstarOptimize(globParts) {
          return globParts.map((parts) => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let i = gs;
              while (parts[i + 1] === "**") {
                i++;
              }
              if (i !== gs) {
                parts.splice(gs, i - gs);
              }
            }
            return parts;
          });
        }
        levelOneOptimize(globParts) {
          return globParts.map((parts) => {
            parts = parts.reduce((set, part) => {
              const prev = set[set.length - 1];
              if (part === "**" && prev === "**") {
                return set;
              }
              if (part === "..") {
                if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                  set.pop();
                  return set;
                }
              }
              set.push(part);
              return set;
            }, []);
            return parts.length === 0 ? [""] : parts;
          });
        }
        levelTwoFileOptimize(parts) {
          if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
          }
          let didSomething = false;
          do {
            didSomething = false;
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "") continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (
                parts[0] === "." &&
                parts.length === 2 &&
                (parts[1] === "." || parts[1] === "")
              ) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                parts.splice(dd - 1, 2);
                dd -= 2;
              }
            }
          } while (didSomething);
          return parts.length === 0 ? [""] : parts;
        }
        firstPhasePreProcess(globParts) {
          let didSomething = false;
          do {
            didSomething = false;
            for (let parts of globParts) {
              let gs = -1;
              while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
                let gss = gs;
                while (parts[gss + 1] === "**") {
                  gss++;
                }
                if (gss > gs) {
                  parts.splice(gs + 1, gss - gs);
                }
                let next = parts[gs + 1];
                const p = parts[gs + 2];
                const p2 = parts[gs + 3];
                if (next !== "..") continue;
                if (
                  !p ||
                  p === "." ||
                  p === ".." ||
                  !p2 ||
                  p2 === "." ||
                  p2 === ".."
                ) {
                  continue;
                }
                didSomething = true;
                parts.splice(gs, 1);
                const other = parts.slice(0);
                other[gs] = "**";
                globParts.push(other);
                gs--;
              }
              if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                  const p = parts[i];
                  if (i === 1 && p === "" && parts[0] === "") continue;
                  if (p === "." || p === "") {
                    didSomething = true;
                    parts.splice(i, 1);
                    i--;
                  }
                }
                if (
                  parts[0] === "." &&
                  parts.length === 2 &&
                  (parts[1] === "." || parts[1] === "")
                ) {
                  didSomething = true;
                  parts.pop();
                }
              }
              let dd = 0;
              while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== "." && p !== ".." && p !== "**") {
                  didSomething = true;
                  const needDot = dd === 1 && parts[dd + 1] === "**";
                  const splin = needDot ? ["."] : [];
                  parts.splice(dd - 1, 2, ...splin);
                  if (parts.length === 0) parts.push("");
                  dd -= 2;
                }
              }
            }
          } while (didSomething);
          return globParts;
        }
        secondPhasePreProcess(globParts) {
          for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
              const matched = this.partsMatch(
                globParts[i],
                globParts[j],
                !this.preserveMultipleSlashes,
              );
              if (matched) {
                globParts[i] = [];
                globParts[j] = matched;
                break;
              }
            }
          }
          return globParts.filter((gs) => gs.length);
        }
        partsMatch(a, b, emptyGSMatch = false) {
          let ai = 0;
          let bi = 0;
          let result = [];
          let which = "";
          while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
              result.push(which === "b" ? b[bi] : a[ai]);
              ai++;
              bi++;
            } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
              result.push(a[ai]);
              ai++;
            } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
              result.push(b[bi]);
              bi++;
            } else if (
              a[ai] === "*" &&
              b[bi] &&
              (this.options.dot || !b[bi].startsWith(".")) &&
              b[bi] !== "**"
            ) {
              if (which === "b") return false;
              which = "a";
              result.push(a[ai]);
              ai++;
              bi++;
            } else if (
              b[bi] === "*" &&
              a[ai] &&
              (this.options.dot || !a[ai].startsWith(".")) &&
              a[ai] !== "**"
            ) {
              if (which === "a") return false;
              which = "b";
              result.push(b[bi]);
              ai++;
              bi++;
            } else {
              return false;
            }
          }
          return a.length === b.length && result;
        }
        parseNegate() {
          if (this.nonegate) return;
          const pattern = this.pattern;
          let negate = false;
          let negateOffset = 0;
          for (
            let i = 0;
            i < pattern.length && pattern.charAt(i) === "!";
            i++
          ) {
            negate = !negate;
            negateOffset++;
          }
          if (negateOffset) this.pattern = pattern.slice(negateOffset);
          this.negate = negate;
        }
        matchOne(file, pattern, partial = false) {
          const options = this.options;
          if (this.isWindows) {
            const fileDrive =
              typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
            const fileUNC =
              !fileDrive &&
              file[0] === "" &&
              file[1] === "" &&
              file[2] === "?" &&
              /^[a-z]:$/i.test(file[3]);
            const patternDrive =
              typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC =
              !patternDrive &&
              pattern[0] === "" &&
              pattern[1] === "" &&
              pattern[2] === "?" &&
              typeof pattern[3] === "string" &&
              /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === "number" && typeof pdi === "number") {
              const [fd, pd] = [file[fdi], pattern[pdi]];
              if (fd.toLowerCase() === pd.toLowerCase()) {
                pattern[pdi] = fd;
                if (pdi > fdi) {
                  pattern = pattern.slice(pdi);
                } else if (fdi > pdi) {
                  file = file.slice(fdi);
                }
              }
            }
          }
          const { optimizationLevel = 1 } = this.options;
          if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
          }
          this.debug("matchOne", this, { file, pattern });
          this.debug("matchOne", file.length, pattern.length);
          for (
            var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
            fi < fl && pi < pl;
            fi++, pi++
          ) {
            this.debug("matchOne loop");
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            if (p === false) {
              return false;
            }
            if (p === exports.GLOBSTAR) {
              this.debug("GLOBSTAR", [pattern, p, f]);
              var fr = fi;
              var pr = pi + 1;
              if (pr === pl) {
                this.debug("** at the end");
                for (; fi < fl; fi++) {
                  if (
                    file[fi] === "." ||
                    file[fi] === ".." ||
                    (!options.dot && file[fi].charAt(0) === ".")
                  )
                    return false;
                }
                return true;
              }
              while (fr < fl) {
                var swallowee = file[fr];
                this.debug(
                  "\nglobstar while",
                  file,
                  fr,
                  pattern,
                  pr,
                  swallowee,
                );
                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                  this.debug("globstar found match!", fr, fl, swallowee);
                  return true;
                } else {
                  if (
                    swallowee === "." ||
                    swallowee === ".." ||
                    (!options.dot && swallowee.charAt(0) === ".")
                  ) {
                    this.debug("dot detected!", file, fr, pattern, pr);
                    break;
                  }
                  this.debug("globstar swallow a segment, and continue");
                  fr++;
                }
              }
              if (partial) {
                this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                if (fr === fl) {
                  return true;
                }
              }
              return false;
            }
            let hit;
            if (typeof p === "string") {
              hit = f === p;
              this.debug("string match", p, f, hit);
            } else {
              hit = p.test(f);
              this.debug("pattern match", p, f, hit);
            }
            if (!hit) return false;
          }
          if (fi === fl && pi === pl) {
            return true;
          } else if (fi === fl) {
            return partial;
          } else if (pi === pl) {
            return fi === fl - 1 && file[fi] === "";
          } else {
            throw new Error("wtf?");
          }
        }
        braceExpand() {
          return (0, exports.braceExpand)(this.pattern, this.options);
        }
        parse(pattern) {
          (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
          const options = this.options;
          if (pattern === "**") return exports.GLOBSTAR;
          if (pattern === "") return "";
          let m;
          let fastTest = null;
          if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
          } else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (
              options.nocase
                ? options.dot
                  ? starDotExtTestNocaseDot
                  : starDotExtTestNocase
                : options.dot
                  ? starDotExtTestDot
                  : starDotExtTest
            )(m[1]);
          } else if ((m = pattern.match(qmarksRE))) {
            fastTest = (
              options.nocase
                ? options.dot
                  ? qmarksTestNocaseDot
                  : qmarksTestNocase
                : options.dot
                  ? qmarksTestDot
                  : qmarksTest
            )(m);
          } else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
          } else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
          }
          const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
          if (fastTest && typeof re === "object") {
            Reflect.defineProperty(re, "test", { value: fastTest });
          }
          return re;
        }
        makeRe() {
          if (this.regexp || this.regexp === false) return this.regexp;
          const set = this.set;
          if (!set.length) {
            this.regexp = false;
            return this.regexp;
          }
          const options = this.options;
          const twoStar = options.noglobstar
            ? star
            : options.dot
              ? twoStarDot
              : twoStarNoDot;
          const flags = new Set(options.nocase ? ["i"] : []);
          let re = set
            .map((pattern) => {
              const pp = pattern.map((p) => {
                if (p instanceof RegExp) {
                  for (const f of p.flags.split("")) flags.add(f);
                }
                return typeof p === "string"
                  ? regExpEscape(p)
                  : p === exports.GLOBSTAR
                    ? exports.GLOBSTAR
                    : p._src;
              });
              pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                  return;
                }
                if (prev === undefined) {
                  if (next !== undefined && next !== exports.GLOBSTAR) {
                    pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
                  } else {
                    pp[i] = twoStar;
                  }
                } else if (next === undefined) {
                  pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
                } else if (next !== exports.GLOBSTAR) {
                  pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
                  pp[i + 1] = exports.GLOBSTAR;
                }
              });
              return pp.filter((p) => p !== exports.GLOBSTAR).join("/");
            })
            .join("|");
          const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
          re = "^" + open + re + close + "$";
          if (this.negate) re = "^(?!" + re + ").+$";
          try {
            this.regexp = new RegExp(re, [...flags].join(""));
          } catch (ex) {
            this.regexp = false;
          }
          return this.regexp;
        }
        slashSplit(p) {
          if (this.preserveMultipleSlashes) {
            return p.split("/");
          } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            return ["", ...p.split(/\/+/)];
          } else {
            return p.split(/\/+/);
          }
        }
        match(f, partial = this.partial) {
          this.debug("match", f, this.pattern);
          if (this.comment) {
            return false;
          }
          if (this.empty) {
            return f === "";
          }
          if (f === "/" && partial) {
            return true;
          }
          const options = this.options;
          if (this.isWindows) {
            f = f.split("\\").join("/");
          }
          const ff = this.slashSplit(f);
          this.debug(this.pattern, "split", ff);
          const set = this.set;
          this.debug(this.pattern, "set", set);
          let filename = ff[ff.length - 1];
          if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
              filename = ff[i];
            }
          }
          for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
              file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
              if (options.flipNegate) {
                return true;
              }
              return !this.negate;
            }
          }
          if (options.flipNegate) {
            return false;
          }
          return this.negate;
        }
        static defaults(def) {
          return exports.minimatch.defaults(def).Minimatch;
        }
      }
      exports.Minimatch = Minimatch;
      var ast_js_2 = __nccwpck_require__(5136);
      Object.defineProperty(exports, "AST", {
        enumerable: true,
        get: function () {
          return ast_js_2.AST;
        },
      });
      var escape_js_2 = __nccwpck_require__(2804);
      Object.defineProperty(exports, "escape", {
        enumerable: true,
        get: function () {
          return escape_js_2.escape;
        },
      });
      var unescape_js_2 = __nccwpck_require__(5698);
      Object.defineProperty(exports, "unescape", {
        enumerable: true,
        get: function () {
          return unescape_js_2.unescape;
        },
      });
      exports.minimatch.AST = ast_js_1.AST;
      exports.minimatch.Minimatch = Minimatch;
      exports.minimatch.escape = escape_js_1.escape;
      exports.minimatch.unescape = unescape_js_1.unescape;
    },
    5698: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unescape = void 0;
      const unescape = (s, { windowsPathsNoEscape = false } = {}) =>
        windowsPathsNoEscape
          ? s.replace(/\[([^\/\\])\]/g, "$1")
          : s
              .replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2")
              .replace(/\\([^\/])/g, "$1");
      exports.unescape = unescape;
    },
    4968: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Minipass =
        exports.isWritable =
        exports.isReadable =
        exports.isStream =
          void 0;
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const node_events_1 = __nccwpck_require__(5673);
      const node_stream_1 = __importDefault(__nccwpck_require__(4492));
      const node_string_decoder_1 = __nccwpck_require__(6915);
      const isStream = (s) =>
        !!s &&
        typeof s === "object" &&
        (s instanceof Minipass ||
          s instanceof node_stream_1.default ||
          (0, exports.isReadable)(s) ||
          (0, exports.isWritable)(s));
      exports.isStream = isStream;
      const isReadable = (s) =>
        !!s &&
        typeof s === "object" &&
        s instanceof node_events_1.EventEmitter &&
        typeof s.pipe === "function" &&
        s.pipe !== node_stream_1.default.Writable.prototype.pipe;
      exports.isReadable = isReadable;
      const isWritable = (s) =>
        !!s &&
        typeof s === "object" &&
        s instanceof node_events_1.EventEmitter &&
        typeof s.write === "function" &&
        typeof s.end === "function";
      exports.isWritable = isWritable;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFER = Symbol("buffer");
      const PIPES = Symbol("pipes");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const ERROR = Symbol("error");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const ABORT = Symbol("abort");
      const ABORTED = Symbol("aborted");
      const SIGNAL = Symbol("signal");
      const DATALISTENERS = Symbol("dataListeners");
      const DISCARDED = Symbol("discarded");
      const defer = (fn) => Promise.resolve().then(fn);
      const nodefer = (fn) => fn();
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBufferLike = (b) =>
        b instanceof ArrayBuffer ||
        (!!b &&
          typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        src;
        dest;
        opts;
        ondrain;
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          this.dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors(_er) {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      const isObjectModeOptions = (o) => !!o.objectMode;
      const isEncodingOptions = (o) =>
        !o.objectMode && !!o.encoding && o.encoding !== "buffer";
      class Minipass extends node_events_1.EventEmitter {
        [FLOWING] = false;
        [PAUSED] = false;
        [PIPES] = [];
        [BUFFER] = [];
        [OBJECTMODE];
        [ENCODING];
        [ASYNC];
        [DECODER];
        [EOF] = false;
        [EMITTED_END] = false;
        [EMITTING_END] = false;
        [CLOSED] = false;
        [EMITTED_ERROR] = null;
        [BUFFERLENGTH] = 0;
        [DESTROYED] = false;
        [SIGNAL];
        [ABORTED] = false;
        [DATALISTENERS] = 0;
        [DISCARDED] = false;
        writable = true;
        readable = true;
        constructor(...args) {
          const options = args[0] || {};
          super();
          if (options.objectMode && typeof options.encoding === "string") {
            throw new TypeError(
              "Encoding and objectMode may not be used together",
            );
          }
          if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
          } else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
          } else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
          }
          this[ASYNC] = !!options.async;
          this[DECODER] = this[ENCODING]
            ? new node_string_decoder_1.StringDecoder(this[ENCODING])
            : null;
          if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
          }
          if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
          }
          const { signal } = options;
          if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
              this[ABORT]();
            } else {
              signal.addEventListener("abort", () => this[ABORT]());
            }
          }
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(_enc) {
          throw new Error("Encoding must be set at instantiation time");
        }
        setEncoding(_enc) {
          throw new Error("Encoding must be set at instantiation time");
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(_om) {
          throw new Error("objectMode must be set at instantiation time");
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        [ABORT]() {
          this[ABORTED] = true;
          this.emit("abort", this[SIGNAL]?.reason);
          this.destroy(this[SIGNAL]?.reason);
        }
        get aborted() {
          return this[ABORTED];
        }
        set aborted(_) {}
        write(chunk, encoding, cb) {
          if (this[ABORTED]) return false;
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = "utf8";
          }
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : nodefer;
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            } else if (isArrayBufferLike(chunk)) {
              chunk = Buffer.from(chunk);
            } else if (typeof chunk !== "string") {
              throw new Error(
                "Non-contiguous data written to non-objectMode stream",
              );
            }
          }
          if (this[OBJECTMODE]) {
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this[FLOWING]) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this[FLOWING];
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this[FLOWING];
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            chunk = this[DECODER].write(chunk);
          }
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this[FLOWING]) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this[FLOWING];
        }
        read(n) {
          if (this[DESTROYED]) return null;
          this[DISCARDED] = false;
          if (
            this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])
          ) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            this[BUFFER] = [
              this[ENCODING]
                ? this[BUFFER].join("")
                : Buffer.concat(this[BUFFER], this[BUFFERLENGTH]),
            ];
          }
          const ret = this[READ](n || null, this[BUFFER][0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (this[OBJECTMODE]) this[BUFFERSHIFT]();
          else {
            const c = chunk;
            if (n === c.length || n === null) this[BUFFERSHIFT]();
            else if (typeof c === "string") {
              this[BUFFER][0] = c.slice(n);
              chunk = c.slice(0, n);
              this[BUFFERLENGTH] -= n;
            } else {
              this[BUFFER][0] = c.subarray(n);
              chunk = c.subarray(0, n);
              this[BUFFERLENGTH] -= n;
            }
          }
          this.emit("data", chunk);
          if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") {
            cb = chunk;
            chunk = undefined;
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = "utf8";
          }
          if (chunk !== undefined) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
          }
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this[BUFFER].length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
          this[DISCARDED] = false;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this[BUFFER].push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
          else this[BUFFERLENGTH] -= this[BUFFER][0].length;
          return this[BUFFER].shift();
        }
        [FLUSH](noDrain = false) {
          do {} while (
            this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length
          );
          if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          this.emit("data", chunk);
          return this[FLOWING];
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return dest;
          this[DISCARDED] = false;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this[PIPES].push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this[PIPES].find((p) => p.dest === dest);
          if (p) {
            if (this[PIPES].length === 1) {
              if (this[FLOWING] && this[DATALISTENERS] === 0) {
                this[FLOWING] = false;
              }
              this[PIPES] = [];
            } else this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, handler) {
          return this.on(ev, handler);
        }
        on(ev, handler) {
          const ret = super.on(ev, handler);
          if (ev === "data") {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
              this[RESUME]();
            }
          } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
            super.emit("readable");
          } else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]));
            else h.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        removeListener(ev, handler) {
          return this.off(ev, handler);
        }
        off(ev, handler) {
          const ret = super.off(ev, handler);
          if (ev === "data") {
            this[DATALISTENERS] = this.listeners("data").length;
            if (
              this[DATALISTENERS] === 0 &&
              !this[DISCARDED] &&
              !this[PIPES].length
            ) {
              this[FLOWING] = false;
            }
          }
          return ret;
        }
        removeAllListeners(ev) {
          const ret = super.removeAllListeners(ev);
          if (ev === "data" || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
              this[FLOWING] = false;
            }
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, ...args) {
          const data = args[0];
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          ) {
            return false;
          } else if (ev === "data") {
            return !this[OBJECTMODE] && !data
              ? false
              : this[ASYNC]
                ? (defer(() => this[EMITDATA](data)), true)
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return false;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret =
              !this[SIGNAL] || this.listeners("error").length
                ? super.emit("error", data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, ...args);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this[PIPES]) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = this[DISCARDED] ? false : super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return false;
          this[EMITTED_END] = true;
          this.readable = false;
          return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this[PIPES]) {
                p.dest.write(data);
              }
              if (!this[DISCARDED]) super.emit("data", data);
            }
          }
          for (const p of this[PIPES]) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        async collect() {
          const buf = Object.assign([], { dataLength: 0 });
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          await p;
          return buf;
        }
        async concat() {
          if (this[OBJECTMODE]) {
            throw new Error("cannot concat in objectMode");
          }
          const buf = await this.collect();
          return this[ENCODING]
            ? buf.join("")
            : Buffer.concat(buf, buf.dataLength);
        }
        async promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [Symbol.asyncIterator]() {
          this[DISCARDED] = false;
          let stopped = false;
          const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
          };
          const next = () => {
            if (stopped) return stop();
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
              this.off("data", ondata);
              this.off("end", onend);
              this.off(DESTROYED, ondestroy);
              stop();
              reject(er);
            };
            const ondata = (value) => {
              this.off("error", onerr);
              this.off("end", onend);
              this.off(DESTROYED, ondestroy);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.off("error", onerr);
              this.off("data", ondata);
              this.off(DESTROYED, ondestroy);
              stop();
              resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
              return this;
            },
          };
        }
        [Symbol.iterator]() {
          this[DISCARDED] = false;
          let stopped = false;
          const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off("end", stop);
            stopped = true;
            return { done: true, value: undefined };
          };
          const next = () => {
            if (stopped) return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
          };
          this.once("end", stop);
          this.once(ERROR, stop);
          this.once(DESTROYED, stop);
          return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
              return this;
            },
          };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this[DISCARDED] = true;
          this[BUFFER].length = 0;
          this[BUFFERLENGTH] = 0;
          const wc = this;
          if (typeof wc.close === "function" && !this[CLOSED]) wc.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static get isStream() {
          return exports.isStream;
        }
      }
      exports.Minipass = Minipass;
    },
    4998: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"https://tuf-repo-cdn.sigstore.dev":{"root.json":"ewoJInNpZ25lZCI6IHsKCQkiX3R5cGUiOiAicm9vdCIsCgkJInNwZWNfdmVyc2lvbiI6ICIxLjAiLAoJCSJ2ZXJzaW9uIjogOSwKCQkiZXhwaXJlcyI6ICIyMDI0LTA5LTEyVDA2OjUzOjEwWiIsCgkJImtleXMiOiB7CgkJCSIxZTFkNjVjZTk4YjEwYWRkYWQ0NzY0ZmViZjdkZGEyZDA0MzZiM2QzYTM4OTM1NzljMGRkZGFlYTIwZTU0ODQ5IjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXpCelZPbUhDUG9qTVZMU0kzNjRXaWlWOE5QckRcbjZJZ1J4Vmxpc2t6L3YreTNKRVI1bWNWR2NPTmxpRGNXTUM1SjJsZkhtalBOUGhiNEg3eG04THpmU0E9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSIyMzBlMjEyNjE2Mjc0YTQxOTVjZGMyOGU5ZmNlNzgyYzIwZTZjNzIwZjFhODExYjQwZjk4MjI4Mzc2YmRkM2FjIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRUxyV3ZOdDk0djRSMDg1RUxlZUNNeEhwN1BsZEZcbjAvVDFHeHVrVWgyT0R1Z2dMR0pFMHBjMWU4Q1NCZjZDUzkxRndvOUZVT3VSc2pCVWxkK1ZxU3lDZFE9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSIzYzM0NGFhMDY4ZmQ0Y2M0ZTg3ZGM1MGI2MTJjMDI0MzFmYmM3NzFlOTUwMDM5OTM2ODNhMmIwYmYyNjBjZjBlIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXk4WEtzbWhCWURJOEpjMEd3ekJ4ZUtheDBjbTVcblNUS0VVNjVIUEZ1blVuNDFzVDhwaTBGak00SWtIei9ZVW13bUxVTzBXdDdseGhqNkJrTElLNHFZQXc9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSI5MjNiYjM5ZTYwZGQ2ZmEyYzMxZTZlYTU1NDczYWE5M2I2NGRkNGU1M2UxNmZiZTQyZjZhMjA3ZDNmOTdkZTJkIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRVdSaUdyNStqKzNKNVNzSCtadHI1bkUySDJ3TzdcbkJWK25PM3M5M2dMY2ExOHFUT3pIWTFvV3lBR0R5a01Tc0dUVUJTdDlEK0FuMEtmS3NEMm1mU000MlE9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSJlMmY1OWFjYjk0ODg1MTk0MDdlMThjYmZjOTMyOTUxMGJlMDNjMDRhY2E5OTI5ZDJmMDMwMTM0M2ZlYzg1NTIzIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRWluaWtTc0FRbVlrTmVINWVZcS9Dbkl6TGFhY09cbnhsU2Fhd1FET3dxS3kvdENxeHE1eHhQU0pjMjFLNFdJaHM5R3lPa0tmenVlWTNHSUx6Y01KWjRjV3c9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSJlYzgxNjY5NzM0ZTAxNzk5NmM1Yjg1ZjNkMDJjM2RlMWRkNDYzN2ExNTIwMTlmZTFhZjEyNWQyZjkzNjhiOTVlIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRUVYc3ozU1pYRmI4ak1WNDJqNnBKbHlqYmpSOEtcbk4zQndvY2V4cTZMTUliNXFzV0tPUXZMTjE2TlVlZkxjNEhzd09vdW1Sc1ZWYWFqU3BRUzZmb2JrUnc9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSJmZGZhODNhMDdiNWE4MzU4OWI4N2RlZDQxZjc3ZjM5ZDIzMmFkOTFmN2NjZTUyODY4ZGFjZDA2YmEwODk4NDlmIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTBnaHJoOTJMdzFZcjNpZEdWNVdxQ3RNREI4Q3hcbitEOGhkQzR3MlpMTklwbFZSb1ZHTHNrWWEzZ2hlTXlPamlKOGtQaTE1YVEyLy83UCtvajdVdkpQR3c9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0KCQl9LAoJCSJyb2xlcyI6IHsKCQkJInJvb3QiOiB7CgkJCQkia2V5aWRzIjogWwoJCQkJCSIzYzM0NGFhMDY4ZmQ0Y2M0ZTg3ZGM1MGI2MTJjMDI0MzFmYmM3NzFlOTUwMDM5OTM2ODNhMmIwYmYyNjBjZjBlIiwKCQkJCQkiZWM4MTY2OTczNGUwMTc5OTZjNWI4NWYzZDAyYzNkZTFkZDQ2MzdhMTUyMDE5ZmUxYWYxMjVkMmY5MzY4Yjk1ZSIsCgkJCQkJIjFlMWQ2NWNlOThiMTBhZGRhZDQ3NjRmZWJmN2RkYTJkMDQzNmIzZDNhMzg5MzU3OWMwZGRkYWVhMjBlNTQ4NDkiLAoJCQkJCSJlMmY1OWFjYjk0ODg1MTk0MDdlMThjYmZjOTMyOTUxMGJlMDNjMDRhY2E5OTI5ZDJmMDMwMTM0M2ZlYzg1NTIzIiwKCQkJCQkiZmRmYTgzYTA3YjVhODM1ODliODdkZWQ0MWY3N2YzOWQyMzJhZDkxZjdjY2U1Mjg2OGRhY2QwNmJhMDg5ODQ5ZiIKCQkJCV0sCgkJCQkidGhyZXNob2xkIjogMwoJCQl9LAoJCQkic25hcHNob3QiOiB7CgkJCQkia2V5aWRzIjogWwoJCQkJCSIyMzBlMjEyNjE2Mjc0YTQxOTVjZGMyOGU5ZmNlNzgyYzIwZTZjNzIwZjFhODExYjQwZjk4MjI4Mzc2YmRkM2FjIgoJCQkJXSwKCQkJCSJ0aHJlc2hvbGQiOiAxCgkJCX0sCgkJCSJ0YXJnZXRzIjogewoJCQkJImtleWlkcyI6IFsKCQkJCQkiM2MzNDRhYTA2OGZkNGNjNGU4N2RjNTBiNjEyYzAyNDMxZmJjNzcxZTk1MDAzOTkzNjgzYTJiMGJmMjYwY2YwZSIsCgkJCQkJImVjODE2Njk3MzRlMDE3OTk2YzViODVmM2QwMmMzZGUxZGQ0NjM3YTE1MjAxOWZlMWFmMTI1ZDJmOTM2OGI5NWUiLAoJCQkJCSIxZTFkNjVjZTk4YjEwYWRkYWQ0NzY0ZmViZjdkZGEyZDA0MzZiM2QzYTM4OTM1NzljMGRkZGFlYTIwZTU0ODQ5IiwKCQkJCQkiZTJmNTlhY2I5NDg4NTE5NDA3ZTE4Y2JmYzkzMjk1MTBiZTAzYzA0YWNhOTkyOWQyZjAzMDEzNDNmZWM4NTUyMyIsCgkJCQkJImZkZmE4M2EwN2I1YTgzNTg5Yjg3ZGVkNDFmNzdmMzlkMjMyYWQ5MWY3Y2NlNTI4NjhkYWNkMDZiYTA4OTg0OWYiCgkJCQldLAoJCQkJInRocmVzaG9sZCI6IDMKCQkJfSwKCQkJInRpbWVzdGFtcCI6IHsKCQkJCSJrZXlpZHMiOiBbCgkJCQkJIjkyM2JiMzllNjBkZDZmYTJjMzFlNmVhNTU0NzNhYTkzYjY0ZGQ0ZTUzZTE2ZmJlNDJmNmEyMDdkM2Y5N2RlMmQiCgkJCQldLAoJCQkJInRocmVzaG9sZCI6IDEKCQkJfQoJCX0sCgkJImNvbnNpc3RlbnRfc25hcHNob3QiOiB0cnVlCgl9LAoJInNpZ25hdHVyZXMiOiBbCgkJewoJCQkia2V5aWQiOiAiZmY1MWUxN2ZjZjI1MzExOWI3MDMzZjZmNTc1MTI2MzFkYTRhMDk2OTQ0MmFmY2Y5ZmM4YjE0MWM3ZjJiZTk5YyIsCgkJCSJzaWciOiAiMzA0NTAyMjEwMDhiNzhmODk0YzNjZmVkM2JkNDg2Mzc5YzRlMGUwZGZiM2U3ZGQ4Y2JjNGQ1NTk4ZDI4MThlZWExYmEzYzc1NTAwMjIwMjlkM2QwNmU4OWQwNGQzNzg0OTk4NWRjNDZjMGUxMGRjNWIxZmM2OGRjNzBhZjFlYzk5MTAzMDNhMWYzZWUyZiIKCQl9LAoJCXsKCQkJImtleWlkIjogIjI1YTBlYjQ1MGZkM2VlMmJkNzkyMThjOTYzZGNlM2YxY2M2MTE4YmFkZjI1MWJmMTQ5ZjBiZDA3ZDVjYWJlOTkiLAoJCQkic2lnIjogIjMwNDUwMjIxMDA5ZTZiOTBiOTM1ZTA5YjgzN2E5MGQ0NDAyZWFhMjdkNWVhMjZlYjc4OTE5NDhiYTBlZDcwOTA4NDEyNDhmNDM2MDIyMDAzZGMyMjUxYzRkNGE3OTk5YjkxZTlhZDA4Njg3NjVhZTA5YWM3MjY5Mjc5ZjJhNzg5OWJhZmVmN2EyZDkyNjAiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICJmNTMxMmY1NDJjMjEyNzNkOTQ4NWE0OTM5NDM4NmM0NTc1ODA0NzcwNjY3ZjJkZGI1OWIzYmYwNjY5ZmRkZDJmIiwKCQkJInNpZyI6ICIzMDQ0MDIyMDA5OWU5MDdkY2Y5MGI3YjZlMTA5ZmQxZDZlNDQyMDA2ZmNjYmI0ODg5NGFhYWZmNDdhYjgyNGIwM2ZiMzVkMGQwMjIwMmFhMGEwNmMyMWE0MjMzZjM3OTAwYTQ4YmM4Nzc3ZDNiNDdmNTllM2EzODYxNmNlNjMxYTA0ZGY1N2Y5NjczNiIKCQl9LAoJCXsKCQkJImtleWlkIjogIjNjMzQ0YWEwNjhmZDRjYzRlODdkYzUwYjYxMmMwMjQzMWZiYzc3MWU5NTAwMzk5MzY4M2EyYjBiZjI2MGNmMGUiLAoJCQkic2lnIjogIjMwNDUwMjIxMDA4Yjc4Zjg5NGMzY2ZlZDNiZDQ4NjM3OWM0ZTBlMGRmYjNlN2RkOGNiYzRkNTU5OGQyODE4ZWVhMWJhM2M3NTUwMDIyMDI5ZDNkMDZlODlkMDRkMzc4NDk5ODVkYzQ2YzBlMTBkYzViMWZjNjhkYzcwYWYxZWM5OTEwMzAzYTFmM2VlMmYiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICJlYzgxNjY5NzM0ZTAxNzk5NmM1Yjg1ZjNkMDJjM2RlMWRkNDYzN2ExNTIwMTlmZTFhZjEyNWQyZjkzNjhiOTVlIiwKCQkJInNpZyI6ICIzMDQ1MDIyMTAwOWU2YjkwYjkzNWUwOWI4MzdhOTBkNDQwMmVhYTI3ZDVlYTI2ZWI3ODkxOTQ4YmEwZWQ3MDkwODQxMjQ4ZjQzNjAyMjAwM2RjMjI1MWM0ZDRhNzk5OWI5MWU5YWQwODY4NzY1YWUwOWFjNzI2OTI3OWYyYTc4OTliYWZlZjdhMmQ5MjYwIgoJCX0sCgkJewoJCQkia2V5aWQiOiAiZTJmNTlhY2I5NDg4NTE5NDA3ZTE4Y2JmYzkzMjk1MTBiZTAzYzA0YWNhOTkyOWQyZjAzMDEzNDNmZWM4NTUyMyIsCgkJCSJzaWciOiAiMzA0NTAyMjAwZTU2MTNiOTAxZTBmM2UwOGVjZWFiZGRjNzNmOThiNTBkZGY4OTJlOTk4ZDBiMzY5YzZlM2Q0NTFhYzQ4ODc1MDIyMTAwOTQwY2Y5MmQxZjQzZWUyZTVjZGJiMjI1NzJiYjUyOTI1ZWQzODYzYTY4OGY3ZmZkZDRiZDJlMmU1NmYwMjhiMyIKCQl9LAoJCXsKCQkJImtleWlkIjogIjJlNjFjZDBjYmY0YThmNDU4MDliZGE5ZjdmNzhjMGQzM2FkMTE4NDJmZjk0YWUzNDA4NzNlMjY2NGRjODQzZGUiLAoJCQkic2lnIjogIjMwNDUwMjIwMmNmZjQ0ZjIyMTVkN2E0N2IyOGI4ZjVmNTgwYzJjZmJiZDFiZmNmY2JiZTc4ZGUzMjMwNDViMmMwYmFkYzVlOTAyMjEwMGM3NDM5NDllYjNmNGVhNWE0YjlhZTI3YWM2ZWRkZWExZjBmZjliZmQwMDRmOGE5YTlkMThjNmU0MTQyYjZlNzUiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICIxZTFkNjVjZTk4YjEwYWRkYWQ0NzY0ZmViZjdkZGEyZDA0MzZiM2QzYTM4OTM1NzljMGRkZGFlYTIwZTU0ODQ5IiwKCQkJInNpZyI6ICIzMDQ0MDIyMDA5OWU5MDdkY2Y5MGI3YjZlMTA5ZmQxZDZlNDQyMDA2ZmNjYmI0ODg5NGFhYWZmNDdhYjgyNGIwM2ZiMzVkMGQwMjIwMmFhMGEwNmMyMWE0MjMzZjM3OTAwYTQ4YmM4Nzc3ZDNiNDdmNTllM2EzODYxNmNlNjMxYTA0ZGY1N2Y5NjczNiIKCQl9LAoJCXsKCQkJImtleWlkIjogImZkZmE4M2EwN2I1YTgzNTg5Yjg3ZGVkNDFmNzdmMzlkMjMyYWQ5MWY3Y2NlNTI4NjhkYWNkMDZiYTA4OTg0OWYiLAoJCQkic2lnIjogIjMwNDUwMjIwMmNmZjQ0ZjIyMTVkN2E0N2IyOGI4ZjVmNTgwYzJjZmJiZDFiZmNmY2JiZTc4ZGUzMjMwNDViMmMwYmFkYzVlOTAyMjEwMGM3NDM5NDllYjNmNGVhNWE0YjlhZTI3YWM2ZWRkZWExZjBmZjliZmQwMDRmOGE5YTlkMThjNmU0MTQyYjZlNzUiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICI3Zjc1MTNiMjU0MjlhNjQ0NzNlMTBjZTNhZDJmM2RhMzcyYmJkZDE0YjY1ZDA3YmJhZjU0N2U3YzhiYmJlNjJiIiwKCQkJInNpZyI6ICIzMDQ1MDIyMDBlNTYxM2I5MDFlMGYzZTA4ZWNlYWJkZGM3M2Y5OGI1MGRkZjg5MmU5OThkMGIzNjljNmUzZDQ1MWFjNDg4NzUwMjIxMDA5NDBjZjkyZDFmNDNlZTJlNWNkYmIyMjU3MmJiNTI5MjVlZDM4NjNhNjg4ZjdmZmRkNGJkMmUyZTU2ZjAyOGIzIgoJCX0KCV0KfQ==","targets":{"trusted_root.json":"ewogICJtZWRpYVR5cGUiOiAiYXBwbGljYXRpb24vdm5kLmRldi5zaWdzdG9yZS50cnVzdGVkcm9vdCtqc29uO3ZlcnNpb249MC4xIiwKICAidGxvZ3MiOiBbCiAgICB7CiAgICAgICJiYXNlVXJsIjogImh0dHBzOi8vcmVrb3Iuc2lnc3RvcmUuZGV2IiwKICAgICAgImhhc2hBbGdvcml0aG0iOiAiU0hBMl8yNTYiLAogICAgICAicHVibGljS2V5IjogewogICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUUyRzJZKzJ0YWJkVFY1QmNHaUJJeDBhOWZBRndya0JibUxTR3RrczRMM3FYNnlZWTB6dWZCbmhDOFVyL2l5NTVHaFdQLzlBL2JZMkxoQzMwTTkrUll0dz09IiwKICAgICAgICAia2V5RGV0YWlscyI6ICJQS0lYX0VDRFNBX1AyNTZfU0hBXzI1NiIsCiAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgInN0YXJ0IjogIjIwMjEtMDEtMTJUMTE6NTM6MjcuMDAwWiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJsb2dJZCI6IHsKICAgICAgICAia2V5SWQiOiAid05JOWF0UUdseitWV2ZPNkxSeWdINFFVZlkvOFc0UkZ3aVQ1aTVXUmdCMD0iCiAgICAgIH0KICAgIH0KICBdLAogICJjZXJ0aWZpY2F0ZUF1dGhvcml0aWVzIjogWwogICAgewogICAgICAic3ViamVjdCI6IHsKICAgICAgICAib3JnYW5pemF0aW9uIjogInNpZ3N0b3JlLmRldiIsCiAgICAgICAgImNvbW1vbk5hbWUiOiAic2lnc3RvcmUiCiAgICAgIH0sCiAgICAgICJ1cmkiOiAiaHR0cHM6Ly9mdWxjaW8uc2lnc3RvcmUuZGV2IiwKICAgICAgImNlcnRDaGFpbiI6IHsKICAgICAgICAiY2VydGlmaWNhdGVzIjogWwogICAgICAgICAgewogICAgICAgICAgICAicmF3Qnl0ZXMiOiAiTUlJQitEQ0NBWDZnQXdJQkFnSVROVmtEWm9DaW9mUERzeTdkZm02Z2VMYnVoekFLQmdncWhrak9QUVFEQXpBcU1SVXdFd1lEVlFRS0V3eHphV2R6ZEc5eVpTNWtaWFl4RVRBUEJnTlZCQU1UQ0hOcFozTjBiM0psTUI0WERUSXhNRE13TnpBek1qQXlPVm9YRFRNeE1ESXlNekF6TWpBeU9Wb3dLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQjJNQkFHQnlxR1NNNDlBZ0VHQlN1QkJBQWlBMklBQkxTeUE3SWk1aytwTk84WkVXWTB5bGVtV0Rvd09rTmEza0wrR1pFNVo1R1dlaEw5L0E5YlJOQTNSYnJzWjVpMEpjYXN0YVJMN1NwNWZwL2pENWR4cWMvVWRUVm5sdlMxNmFuKzJZZnN3ZS9RdUxvbFJVQ3JjT0UyKzJpQTUrdHpkNk5tTUdRd0RnWURWUjBQQVFIL0JBUURBZ0VHTUJJR0ExVWRFd0VCL3dRSU1BWUJBZjhDQVFFd0hRWURWUjBPQkJZRUZNakZIUUJCbWlRcE1sRWs2dzJ1U3UxS0J0UHNNQjhHQTFVZEl3UVlNQmFBRk1qRkhRQkJtaVFwTWxFazZ3MnVTdTFLQnRQc01Bb0dDQ3FHU000OUJBTURBMmdBTUdVQ01IOGxpV0pmTXVpNnZYWEJoakRnWTRNd3NsbU4vVEp4VmUvODNXckZvbXdtTmYwNTZ5MVg0OEY5YzRtM2Ezb3pYQUl4QUtqUmF5NS9hai9qc0tLR0lrbVFhdGpJOHV1cEhyLytDeEZ2YUpXbXBZcU5rTERHUlUrOW9yemg1aEkyUnJjdWFRPT0iCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAidmFsaWRGb3IiOiB7CiAgICAgICAgInN0YXJ0IjogIjIwMjEtMDMtMDdUMDM6MjA6MjkuMDAwWiIsCiAgICAgICAgImVuZCI6ICIyMDIyLTEyLTMxVDIzOjU5OjU5Ljk5OVoiCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJzdWJqZWN0IjogewogICAgICAgICJvcmdhbml6YXRpb24iOiAic2lnc3RvcmUuZGV2IiwKICAgICAgICAiY29tbW9uTmFtZSI6ICJzaWdzdG9yZSIKICAgICAgfSwKICAgICAgInVyaSI6ICJodHRwczovL2Z1bGNpby5zaWdzdG9yZS5kZXYiLAogICAgICAiY2VydENoYWluIjogewogICAgICAgICJjZXJ0aWZpY2F0ZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNSUlDR2pDQ0FhR2dBd0lCQWdJVUFMblZpVmZuVTBickphc21Sa0hybi9VbmZhUXdDZ1lJS29aSXpqMEVBd013S2pFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUkV3RHdZRFZRUURFd2h6YVdkemRHOXlaVEFlRncweU1qQTBNVE15TURBMk1UVmFGdzB6TVRFd01EVXhNelUyTlRoYU1EY3hGVEFUQmdOVkJBb1RESE5wWjNOMGIzSmxMbVJsZGpFZU1Cd0dBMVVFQXhNVmMybG5jM1J2Y21VdGFXNTBaWEp0WldScFlYUmxNSFl3RUFZSEtvWkl6ajBDQVFZRks0RUVBQ0lEWWdBRThSVlMveXNIK05PdnVEWnlQSVp0aWxnVUY5TmxhcllwQWQ5SFAxdkJCSDFVNUNWNzdMU1M3czBaaUg0bkU3SHY3cHRTNkx2dlIvU1RrNzk4TFZnTXpMbEo0SGVJZkYzdEhTYWV4TGNZcFNBU3Ixa1MwTi9SZ0JKei85aldDaVhubzNzd2VUQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0V3WURWUjBsQkF3d0NnWUlLd1lCQlFVSEF3TXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUJBREFkQmdOVkhRNEVGZ1FVMzlQcHoxWWtFWmI1cU5qcEtGV2l4aTRZWkQ4d0h3WURWUjBqQkJnd0ZvQVVXTUFlWDVGRnBXYXBlc3lRb1pNaTBDckZ4Zm93Q2dZSUtvWkl6ajBFQXdNRFp3QXdaQUl3UENzUUs0RFlpWllEUElhRGk1SEZLbmZ4WHg2QVNTVm1FUmZzeW5ZQmlYMlg2U0pSblpVODQvOURaZG5GdnZ4bUFqQk90NlFwQmxjNEovMER4dmtUQ3FwY2x2emlMNkJDQ1BuamRsSUIzUHUzQnhzUG15Z1VZN0lpMnpiZENkbGlpb3c9IgogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgInJhd0J5dGVzIjogIk1JSUI5ekNDQVh5Z0F3SUJBZ0lVQUxaTkFQRmR4SFB3amVEbG9Ed3lZQ2hBTy80d0NnWUlLb1pJemowRUF3TXdLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQWVGdzB5TVRFd01EY3hNelUyTlRsYUZ3MHpNVEV3TURVeE16VTJOVGhhTUNveEZUQVRCZ05WQkFvVERITnBaM04wYjNKbExtUmxkakVSTUE4R0ExVUVBeE1JYzJsbmMzUnZjbVV3ZGpBUUJnY3Foa2pPUFFJQkJnVXJnUVFBSWdOaUFBVDdYZUZUNHJiM1BRR3dTNElhanRMazMvT2xucGdhbmdhQmNsWXBzWUJyNWkrNHluQjA3Y2ViM0xQME9JT1pkeGV4WDY5YzVpVnV5SlJRK0h6MDV5aStVRjN1QldBbEhwaVM1c2gwK0gyR0hFN1NYcmsxRUM1bTFUcjE5TDlnZzkyall6QmhNQTRHQTFVZER3RUIvd1FFQXdJQkJqQVBCZ05WSFJNQkFmOEVCVEFEQVFIL01CMEdBMVVkRGdRV0JCUll3QjVma1VXbFpxbDZ6SkNoa3lMUUtzWEYrakFmQmdOVkhTTUVHREFXZ0JSWXdCNWZrVVdsWnFsNnpKQ2hreUxRS3NYRitqQUtCZ2dxaGtqT1BRUURBd05wQURCbUFqRUFqMW5IZVhacCsxM05XQk5hK0VEc0RQOEcxV1dnMXRDTVdQL1dIUHFwYVZvMGpoc3dlTkZaZ1NzMGVFN3dZSTRxQWpFQTJXQjlvdDk4c0lrb0YzdlpZZGQzL1Z0V0I1YjlUTk1lYTdJeC9zdEo1VGZjTExlQUJMRTRCTkpPc1E0dm5CSEoiCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAidmFsaWRGb3IiOiB7CiAgICAgICAgInN0YXJ0IjogIjIwMjItMDQtMTNUMjA6MDY6MTUuMDAwWiIKICAgICAgfQogICAgfQogIF0sCiAgImN0bG9ncyI6IFsKICAgIHsKICAgICAgImJhc2VVcmwiOiAiaHR0cHM6Ly9jdGZlLnNpZ3N0b3JlLmRldi90ZXN0IiwKICAgICAgImhhc2hBbGdvcml0aG0iOiAiU0hBMl8yNTYiLAogICAgICAicHVibGljS2V5IjogewogICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUViZndSK1JKdWRYc2NnUkJScEtYMVhGRHkzUHl1ZER4ei9TZm5SaTFmVDhla3BmQmQyTzF1b3o3anIzWjhuS3p4QTY5RVVRK2VGQ0ZJM3pldWJQV1U3dz09IiwKICAgICAgICAia2V5RGV0YWlscyI6ICJQS0lYX0VDRFNBX1AyNTZfU0hBXzI1NiIsCiAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgInN0YXJ0IjogIjIwMjEtMDMtMTRUMDA6MDA6MDAuMDAwWiIsCiAgICAgICAgICAiZW5kIjogIjIwMjItMTAtMzFUMjM6NTk6NTkuOTk5WiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJsb2dJZCI6IHsKICAgICAgICAia2V5SWQiOiAiQ0dDUzhDaFMvMmhGMGRGcko0U2NSV2NZckJZOXd6alNiZWE4SWdZMmIzST0iCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJiYXNlVXJsIjogImh0dHBzOi8vY3RmZS5zaWdzdG9yZS5kZXYvMjAyMiIsCiAgICAgICJoYXNoQWxnb3JpdGhtIjogIlNIQTJfMjU2IiwKICAgICAgInB1YmxpY0tleSI6IHsKICAgICAgICAicmF3Qnl0ZXMiOiAiTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFaVBTbEZpMENtRlRmRWpDVXFGOUh1Q0VjWVhOS0FhWWFsSUptQlo4eXllelBqVHFoeHJLQnBNbmFvY1Z0TEpCSTFlTTN1WG5RelFHQUpkSjRnczlGeXc9PSIsCiAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICJ2YWxpZEZvciI6IHsKICAgICAgICAgICJzdGFydCI6ICIyMDIyLTEwLTIwVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgfQogICAgICB9LAogICAgICAibG9nSWQiOiB7CiAgICAgICAgImtleUlkIjogIjNUMHdhc2JIRVRKakdSNGNtV2MzQXFKS1hyamVQSzMvaDRweWdDOHA3bzQ9IgogICAgICB9CiAgICB9CiAgXSwKICAidGltZXN0YW1wQXV0aG9yaXRpZXMiOiBbCiAgICB7CiAgICAgICJzdWJqZWN0IjogewogICAgICAgICJvcmdhbml6YXRpb24iOiAiR2l0SHViLCBJbmMuIiwKICAgICAgICAiY29tbW9uTmFtZSI6ICJJbnRlcm5hbCBTZXJ2aWNlcyBSb290IgogICAgICB9LAogICAgICAiY2VydENoYWluIjogewogICAgICAgICJjZXJ0aWZpY2F0ZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNSUlCM0RDQ0FXS2dBd0lCQWdJVWNoa05zSDM2WGEwNGIxTHFJYytxcjlEVmVjTXdDZ1lJS29aSXpqMEVBd013TWpFVk1CTUdBMVVFQ2hNTVIybDBTSFZpTENCSmJtTXVNUmt3RndZRFZRUURFeEJVVTBFZ2FXNTBaWEp0WldScFlYUmxNQjRYRFRJek1EUXhOREF3TURBd01Gb1hEVEkwTURReE16QXdNREF3TUZvd01qRVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVJrd0Z3WURWUVFERXhCVVUwRWdWR2x0WlhOMFlXMXdhVzVuTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFVUQ1Wk5iU3FZTWQ2cjhxcE9PRVg5aWJHblpUOUdzdVhPaHIvZjhVOUZKdWdCR0V4S1lwNDBPVUxTMGVyalpXN3hWOXhWNTJObkpmNU9lRHE0ZTVaS3FOV01GUXdEZ1lEVlIwUEFRSC9CQVFEQWdlQU1CTUdBMVVkSlFRTU1Bb0dDQ3NHQVFVRkJ3TUlNQXdHQTFVZEV3RUIvd1FDTUFBd0h3WURWUjBqQkJnd0ZvQVVhVzFSdWRPZ1Z0MGxlcVkwV0tZYnVQcjQ3d0F3Q2dZSUtvWkl6ajBFQXdNRGFBQXdaUUl3YlVIOUh2RDRlakNaSk9XUW5xQWxrcVVSbGx2dTlNOCtWcUxiaVJLK3pTZlpDWndzaWxqUm44TVFRUlNrWEVFNUFqRUFnK1Z4cXRvamZWZnU4RGh6emhDeDlHS0VUYkpIYjE5aVY3Mm1NS1ViREFGbXpaNmJROGI1NFpiOHRpZHk1YVdlIgogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgInJhd0J5dGVzIjogIk1JSUNFRENDQVpXZ0F3SUJBZ0lVWDhaTzVRWFA3dk40ZE1RNWU5c1UzbnViOE9nd0NnWUlLb1pJemowRUF3TXdPREVWTUJNR0ExVUVDaE1NUjJsMFNIVmlMQ0JKYm1NdU1SOHdIUVlEVlFRREV4WkpiblJsY201aGJDQlRaWEoyYVdObGN5QlNiMjkwTUI0WERUSXpNRFF4TkRBd01EQXdNRm9YRFRJNE1EUXhNakF3TURBd01Gb3dNakVWTUJNR0ExVUVDaE1NUjJsMFNIVmlMQ0JKYm1NdU1Sa3dGd1lEVlFRREV4QlVVMEVnYVc1MFpYSnRaV1JwWVhSbE1IWXdFQVlIS29aSXpqMENBUVlGSzRFRUFDSURZZ0FFdk1MWS9kVFZidklKWUFOQXVzekV3Sm5RRTFsbGZ0eW55TUtJTWhoNDhIbXFiVnI1eWd5YnpzTFJMVktiQldPZFoyMWFlSnorZ1ppeXRaZXRxY3lGOVdsRVI1TkVNZjZKVjdaTm9qUXB4SHE0UkhHb0dTY2VRdi9xdlRpWnhFREtvMll3WkRBT0JnTlZIUThCQWY4RUJBTUNBUVl3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCQURBZEJnTlZIUTRFRmdRVWFXMVJ1ZE9nVnQwbGVxWTBXS1lidVByNDd3QXdId1lEVlIwakJCZ3dGb0FVOU5ZWWxvYm5BRzRjMC9xanh5SC9scS93eitRd0NnWUlLb1pJemowRUF3TURhUUF3WmdJeEFLMUIxODV5Z0NySVlGbElzM0dqc3dqbndTTUc2TFk4d29MVmRha0tEWnhWYThmOGNxTXMxRGhjeEowKzA5dzk1UUl4QU8rdEJ6Wms3dmpVSjlpSmdENFI2WldUeFFXS3FObTc0ak85OW8rbzlzdjRGSS9TWlRaVEZ5TW4wSUpFSGRObXlBPT0iCiAgICAgICAgICB9LAogICAgICAgICAgewogICAgICAgICAgICAicmF3Qnl0ZXMiOiAiTUlJQjlEQ0NBWHFnQXdJQkFnSVVhL0pBa2RVaks0SlV3c3F0YWlSSkdXaHFMU293Q2dZSUtvWkl6ajBFQXdNd09ERVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVI4d0hRWURWUVFERXhaSmJuUmxjbTVoYkNCVFpYSjJhV05sY3lCU2IyOTBNQjRYRFRJek1EUXhOREF3TURBd01Gb1hEVE16TURReE1UQXdNREF3TUZvd09ERVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVI4d0hRWURWUVFERXhaSmJuUmxjbTVoYkNCVFpYSjJhV05sY3lCU2IyOTBNSFl3RUFZSEtvWkl6ajBDQVFZRks0RUVBQ0lEWWdBRWY5akZBWHh6NGt4NjhBSFJNT2tGQmhmbERjTVR2emFYejR4L0ZDY1hqSi8xcUVLb24vcVBJR25hVVJza0R0eU5iTkRPcGVKVERERnF0NDhpTVBybnpweDZJWndxZW1mVUpONHhCRVpmemErcFl0L2l5b2QrOXRacjIwUlJXU3YvbzBVd1F6QU9CZ05WSFE4QkFmOEVCQU1DQVFZd0VnWURWUjBUQVFIL0JBZ3dCZ0VCL3dJQkFqQWRCZ05WSFE0RUZnUVU5TllZbG9ibkFHNGMwL3FqeHlIL2xxL3d6K1F3Q2dZSUtvWkl6ajBFQXdNRGFBQXdaUUl4QUxaTFo4QmdSWHpLeExNTU45VklsTytlNGhyQm5OQmdGN3R6N0hucm93djJOZXRaRXJJQUNLRnltQmx2V0R2dE1BSXdaTytraTZzc1ExYnNabzk4TzhtRUFmMk5aN2lpQ2dERFUwVndqZWNvNnp5ZWgwekJUczkvN2dWNkFITlE1M3hEIgogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfSwKICAgICAgInZhbGlkRm9yIjogewogICAgICAgICJzdGFydCI6ICIyMDIzLTA0LTE0VDAwOjAwOjAwLjAwMFoiCiAgICAgIH0KICAgIH0KICBdCn0K","registry.npmjs.org%2Fkeys.json":"ewogICAgImtleXMiOiBbCiAgICAgICAgewogICAgICAgICAgICAia2V5SWQiOiAiU0hBMjU2OmpsM2J3c3d1ODBQampva0NnaDBvMnc1YzJVNExoUUFFNTdnajljejFrekEiLAogICAgICAgICAgICAia2V5VXNhZ2UiOiAibnBtOnNpZ25hdHVyZXMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTFPbGIzek1BRkZ4WEtIaUlrUU81Y0ozWWhsNWk2VVBwK0lodXRlQkpidUhjQTVVb2dLbzBFV3RsV3dXNktTYUtvVE5FWUw3SmxDUWlWbmtoQmt0VWdnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIxOTk5LTAxLTAxVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICAgImtleUlkIjogIlNIQTI1NjpqbDNid3N3dTgwUGpqb2tDZ2gwbzJ3NWMyVTRMaFFBRTU3Z2o5Y3oxa3pBIiwKICAgICAgICAgICAgImtleVVzYWdlIjogIm5wbTphdHRlc3RhdGlvbnMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTFPbGIzek1BRkZ4WEtIaUlrUU81Y0ozWWhsNWk2VVBwK0lodXRlQkpidUhjQTVVb2dLbzBFV3RsV3dXNktTYUtvVE5FWUw3SmxDUWlWbmtoQmt0VWdnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIyMDIyLTEyLTAxVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICBdCn0K"}}}',
      );
    },
    3236: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[{"name":"Agola CI","constant":"AGOLA","env":"AGOLA_GIT_REF","pr":"AGOLA_PULL_REQUEST_ID"},{"name":"Appcircle","constant":"APPCIRCLE","env":"AC_APPCIRCLE"},{"name":"AppVeyor","constant":"APPVEYOR","env":"APPVEYOR","pr":"APPVEYOR_PULL_REQUEST_NUMBER"},{"name":"AWS CodeBuild","constant":"CODEBUILD","env":"CODEBUILD_BUILD_ARN"},{"name":"Azure Pipelines","constant":"AZURE_PIPELINES","env":"TF_BUILD","pr":{"BUILD_REASON":"PullRequest"}},{"name":"Bamboo","constant":"BAMBOO","env":"bamboo_planKey"},{"name":"Bitbucket Pipelines","constant":"BITBUCKET","env":"BITBUCKET_COMMIT","pr":"BITBUCKET_PR_ID"},{"name":"Bitrise","constant":"BITRISE","env":"BITRISE_IO","pr":"BITRISE_PULL_REQUEST"},{"name":"Buddy","constant":"BUDDY","env":"BUDDY_WORKSPACE_ID","pr":"BUDDY_EXECUTION_PULL_REQUEST_ID"},{"name":"Buildkite","constant":"BUILDKITE","env":"BUILDKITE","pr":{"env":"BUILDKITE_PULL_REQUEST","ne":"false"}},{"name":"CircleCI","constant":"CIRCLE","env":"CIRCLECI","pr":"CIRCLE_PULL_REQUEST"},{"name":"Cirrus CI","constant":"CIRRUS","env":"CIRRUS_CI","pr":"CIRRUS_PR"},{"name":"Codefresh","constant":"CODEFRESH","env":"CF_BUILD_ID","pr":{"any":["CF_PULL_REQUEST_NUMBER","CF_PULL_REQUEST_ID"]}},{"name":"Codemagic","constant":"CODEMAGIC","env":"CM_BUILD_ID","pr":"CM_PULL_REQUEST"},{"name":"Codeship","constant":"CODESHIP","env":{"CI_NAME":"codeship"}},{"name":"Drone","constant":"DRONE","env":"DRONE","pr":{"DRONE_BUILD_EVENT":"pull_request"}},{"name":"dsari","constant":"DSARI","env":"DSARI"},{"name":"Earthly","constant":"EARTHLY","env":"EARTHLY_CI"},{"name":"Expo Application Services","constant":"EAS","env":"EAS_BUILD"},{"name":"Gerrit","constant":"GERRIT","env":"GERRIT_PROJECT"},{"name":"Gitea Actions","constant":"GITEA_ACTIONS","env":"GITEA_ACTIONS"},{"name":"GitHub Actions","constant":"GITHUB_ACTIONS","env":"GITHUB_ACTIONS","pr":{"GITHUB_EVENT_NAME":"pull_request"}},{"name":"GitLab CI","constant":"GITLAB","env":"GITLAB_CI","pr":"CI_MERGE_REQUEST_ID"},{"name":"GoCD","constant":"GOCD","env":"GO_PIPELINE_LABEL"},{"name":"Google Cloud Build","constant":"GOOGLE_CLOUD_BUILD","env":"BUILDER_OUTPUT"},{"name":"Harness CI","constant":"HARNESS","env":"HARNESS_BUILD_ID"},{"name":"Heroku","constant":"HEROKU","env":{"env":"NODE","includes":"/app/.heroku/node/bin/node"}},{"name":"Hudson","constant":"HUDSON","env":"HUDSON_URL"},{"name":"Jenkins","constant":"JENKINS","env":["JENKINS_URL","BUILD_ID"],"pr":{"any":["ghprbPullId","CHANGE_ID"]}},{"name":"LayerCI","constant":"LAYERCI","env":"LAYERCI","pr":"LAYERCI_PULL_REQUEST"},{"name":"Magnum CI","constant":"MAGNUM","env":"MAGNUM"},{"name":"Netlify CI","constant":"NETLIFY","env":"NETLIFY","pr":{"env":"PULL_REQUEST","ne":"false"}},{"name":"Nevercode","constant":"NEVERCODE","env":"NEVERCODE","pr":{"env":"NEVERCODE_PULL_REQUEST","ne":"false"}},{"name":"Prow","constant":"PROW","env":"PROW_JOB_ID"},{"name":"ReleaseHub","constant":"RELEASEHUB","env":"RELEASE_BUILD_ID"},{"name":"Render","constant":"RENDER","env":"RENDER","pr":{"IS_PULL_REQUEST":"true"}},{"name":"Sail CI","constant":"SAIL","env":"SAILCI","pr":"SAIL_PULL_REQUEST_NUMBER"},{"name":"Screwdriver","constant":"SCREWDRIVER","env":"SCREWDRIVER","pr":{"env":"SD_PULL_REQUEST","ne":"false"}},{"name":"Semaphore","constant":"SEMAPHORE","env":"SEMAPHORE","pr":"PULL_REQUEST_NUMBER"},{"name":"Sourcehut","constant":"SOURCEHUT","env":{"CI_NAME":"sourcehut"}},{"name":"Strider CD","constant":"STRIDER","env":"STRIDER"},{"name":"TaskCluster","constant":"TASKCLUSTER","env":["TASK_ID","RUN_ID"]},{"name":"TeamCity","constant":"TEAMCITY","env":"TEAMCITY_VERSION"},{"name":"Travis CI","constant":"TRAVIS","env":"TRAVIS","pr":{"env":"TRAVIS_PULL_REQUEST","ne":"false"}},{"name":"Vela","constant":"VELA","env":"VELA","pr":{"VELA_PULL_REQUEST":"1"}},{"name":"Vercel","constant":"VERCEL","env":{"any":["NOW_BUILDER","VERCEL"]},"pr":"VERCEL_GIT_PULL_REQUEST_ID"},{"name":"Visual Studio App Center","constant":"APPCENTER","env":"APPCENTER_BUILD_ID"},{"name":"Woodpecker","constant":"WOODPECKER","env":{"CI":"woodpecker"},"pr":{"CI_BUILD_EVENT":"pull_request"}},{"name":"Xcode Cloud","constant":"XCODE_CLOUD","env":"CI_XCODE_PROJECT","pr":"CI_PULL_REQUEST_NUMBER"},{"name":"Xcode Server","constant":"XCODE_SERVER","env":"XCS"}]',
      );
    },
    3480: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["8740",""],["8767",""],["87a1",""],["8840","",4,""],["88a1",""],["8940",""],["8943",""],["8946",""],["894c",""],["89a1",""],["89ab",""],["89b0",""],["89b5",""],["89c1",""],["89c5",""],["8a40",""],["8a43",""],["8a64",""],["8a76",""],["8aa1",""],["8aac",""],["8ab2",""],["8abb",""],["8ac9",""],["8ace",""],["8adf",""],["8af6",""],["8b40",""],["8b55",""],["8ba1",""],["8bde",""],["8c40",""],["8ca1",""],["8ca7",""],["8cc9",""],["8cce",""],["8ce6",""],["8d40",""],["8d42",""],["8da1",""],["8e40",""],["8ea1",""],["8f40",""],["8fa1",""],["9040",""],["90a1",""],["9140",""],["91a1",""],["9240",""],["92a1",""],["9340",""],["93a1",""],["9440",""],["94a1",""],["9540",""],["95a1",""],["9640",""],["96a1",""],["9740",""],["97a1",""],["9840",""],["98a1",""],["9940",""],["99a1",""],["9a40",""],["9aa1",""],["9b40",""],["9b62",""],["9ba1",""],["9c40",""],["9ca1",""],["9d40",""],["9da1",""],["9e40",""],["9ea1",""],["9ead",""],["9ec5",""],["9ef5",""],["9f40",""],["9f4f",""],["9fa1",""],["9fae",""],["9fb2",""],["9fc1",""],["9fc9",""],["9fdb",""],["9fe7",""],["9feb",""],["9ff0",""],["a040",""],["a055",""],["a058",""],["a05b",""],["a063",""],["a073",""],["a0a1",""],["a0a6",""],["a0ae",""],["a0b0",""],["a0d4",""],["a0e2",""],["a3c0","",31,""],["c6a1","",9,"",9,"",9,"",23],["c740","",58,""],["c7a1","",81,"",5,"",4],["c840","",26,"",25,""],["c8a1",""],["c8cd",""],["c8f5",""],["f9fe",""],["fa40",""],["faa1",""],["fb40",""],["fba1",""],["fc40",""],["fca1",""],["fd40",""],["fda1",""],["fe40",""],["fea1",""]]',
      );
    },
    3336: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127,""],["8140","",5,"",9,"",6,""],["8180","",6,"",4,"",4,"",5,""],["8240","",4,"",8,"",4,"",11],["8280","",10,"",4,"",7,"",5,"",8,"",20,"",4,"",6,""],["8340","",17,"",5,"",10,"",4,"",9,""],["8380","",5,"",13,"",28,"",4,"",4,"",5],["8440","",5,"",5,""],["8480","",9,"",4,"",6,"",6,"",9,"",5,"",10,"",7,""],["8540","",9,""],["8580","",4,"",6,"",4,"",4,"",7,""],["8640","",4,"",5,"",4,"",5,""],["8680","",4,"",4,"",5,"",6,"",8,"",4,"",4,"",4,""],["8740","",7,"",11,"",4,"",4],["8780","",7,"",6,"",14,"",10,"",6,"",12,"",8,"",5,"",6],["8840","",9,"",4,"",4,""],["8880","",4,"",6,"",8,"",6,"",7,"",4,"",4,"",7],["8940","",5,"",6,"",4,"",5,"",4,"",16,""],["8980","",4,"",4,"",7,"",17,"",10,"",13,"",5,"",7,"",4,""],["8a40","",4,"",12,""],["8a80","",5,"",6,"",4,"",11,"",6,"",4,"",4,"",9,"",5],["8b40","",8,"",17,"",6,"",13,""],["8b80","",4,"",4,"",5,"",4,"",4,"",22,"",11,"",25,"",7,"",6],["8c40","",7,""],["8c80","",8,"",4,"",6,"",6,"",6,"",4,"",4,"",4],["8d40","",5,"",5,"",5,"",6,"",9,"",4],["8d80","",5,"",4,"",4,"",4,"",7,"",7,"",10,"",10,"",12,"",21,""],["8e40","",21,"",12,"",6,"",12,""],["8e80","",4,"",7,"",4,"",4,"",5,"",6,"",4,"",14,"",4,"",4,"",6],["8f40","",5,"",11,"",8,""],["8f80","",6,"",14,"",5,"",5,"",4,""],["9040","",4,"",4,"",6,""],["9080","",7,"",4,"",4,"",4,"",4,"",18,"",6],["9140","",6,"",6,"",18,"",4,""],["9180","",6,"",8,"",9,"",5,"",4,"",4,"",16,"",13,"",8,"",5,"",4,""],["9240","",6,"",5,""],["9280","",5,"",7,"",6,""],["9340","",6,"",4,"",4,"",5,""],["9380","",5,"",4,"",6,"",4,"",7,"",9,"",6,"",8,"",4,"",6,""],["9440","",24,"",7,"",7,"",4,"",8],["9480","",4,"",4,"",14,"",7,"",7,""],["9540","",4,"",4,"",6,""],["9580","",4,"",4,"",8,"",4,"",4,"",25,"",7,"",5,""],["9640","",5,"",4,""],["9680","",7,"",9,"",7,"",4,"",6,"",6,"",5],["9740","",7,"",8,"",7,"",9,""],["9780","",6,"",5,"",4,"",9,"",4,"",11,"",7,"",16,""],["9840","",4,"",5,"",9,""],["9880","",7,"",5,"",11,"",9,"",9,"",11,"",5,"",5,"",6,"",4,"",7,"",6,""],["9940","",4,"",10,"",6,"",8,"",4,"",7,"",5],["9980","",114,"",6],["9a40","",11,"",7,"",13,""],["9a80","",4,"",7,"",7,"",6,"",4,"",4,"",7,"",6,"",4,"",4,""],["9b40","",4,""],["9b80","",5,"",4,"",4,"",5,""],["9c40","",7,""],["9c80","",7,"",7,"",10,"",14,"",4,"",6,"",5],["9d40","",7,"",4,"",9,"",6,""],["9d80","",9,"",5,"",6,"",12,"",4,"",10,"",5,"",5,"",6,"",10,""],["9e40","",7,"",32,"",7,"",6,"",6],["9e80","",9,"",17,"",13,"",11,"",12,"",12,""],["9f40","",6,"",10,"",4,"",10,"",7,""],["9f80","",13,"",12,"",4,"",4,"",5,"",4,"",4,"",6,"",5,"",8,"",9,"",4],["a040","",9,"",5,"",9,"",11,"",19],["a080","",9,"",6,"",4,"",11,"",11,"",6,""],["a1a1","",7,""],["a2a1","",9],["a2b1","",19,"",19,"",9],["a2e5","",9],["a2f1","",11],["a3a1","",88,""],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a6e0",""],["a6ee",""],["a6f4",""],["a7a1","",5,"",25],["a7d1","",5,"",25],["a840","",35,"",6],["a880","",7,""],["a8a1",""],["a8bd",""],["a8c0",""],["a8c5","",36],["a940","",8,""],["a959",""],["a95c",""],["a960","",9,"",8],["a980","",4,""],["a996",""],["a9a4","",75],["aa40","",5,"",5,"",8],["aa80","",7,"",10,""],["ab40","",11,"",4,"",5,"",4],["ab80","",6,"",4],["ac40","",10,"",8,"",5,"",4,"",11],["ac80","",6,"",12,"",4,""],["ad40","",10,"",7,"",15,"",12],["ad80","",9,"",8,"",6,""],["ae40","",6,"",7,"",4,""],["ae80","",7,"",6,"",4,""],["af40","",4,""],["af80",""],["b040","",6,"",5,"",4,"",6,"",7,""],["b080","",7,"",8,"",9,""],["b140","",4,"",7,"",10,""],["b180","",4,"",7,"",7,""],["b240","",11,"",5,"",11,"",4],["b280","",12,"",8,"",4,""],["b340","",5,""],["b380","",11,"",7,"",6,""],["b440","",7,"",9],["b480","",4,"",5,"",6,""],["b540","",5,"",9,"",4,"",14,"",4,"",8,""],["b580","",6,"",4,""],["b640","",6,"",11,"",10,"",4,"",5,""],["b680","",6,"",4,""],["b740","",14,"",5,"",9,"",4,"",16],["b780","",6,""],["b840","",4,"",10,"",10,"",9,"",5,""],["b880","",4,""],["b940","",5,"",10,"",6,""],["b980","",7,""],["ba40","",4,"",4,"",7,"",5,""],["ba80","",4,"",5,"",12,"",5,""],["bb40","",9,"",36,"",5,"",9],["bb80","",6,"",4,""],["bc40","",6,"",6,"",5,"",7,"",13,"",5],["bc80","",14,"",6,""],["bd40","",54,"",7],["bd80","",32,""],["be40","",12,"",6,"",42],["be80","",32,""],["bf40","",62],["bf80","",4,"",4,"",21,""],["c040","",35,"",23,""],["c080","",6,"",9,""],["c140","",4,"",7,"",4,"",4,"",6,""],["c180","",4,"",4,"",5,""],["c240","",6,"",5,""],["c280","",13,"",5,"",11,""],["c340","",5,"",4,"",6,""],["c380","",12,"",4,""],["c440","",5,"",4,"",4,"",5,"",4,""],["c480","",7,"",5,"",6,""],["c540","",14,"",4,"",5,"",4,"",5,""],["c580","",7,"",7,""],["c640",""],["c680","",4,"",9,""],["c740","",4,"",4,"",6,"",6,"",6,""],["c780",""],["c840","",4,"",5,"",5,"",7,"",5,"",7,""],["c880","",6,"",4,"",4,""],["c940","",4,"",7,"",12,""],["c980","",4,"",4,"",10,""],["ca40","",8,"",8,"",9,"",4,"",10],["ca80","",4,"",8,""],["cb40","",6,"",10,"",6,"",5,"",6,"",6,"",4,""],["cb80","",5,"",6,"",14,""],["cc40","",4,"",10,"",15,"",13,""],["cc80","",11,"",4,"",7,""],["cd40","",6,"",6,"",4,"",5,"",4,"",4,""],["cd80",""],["ce40","",6,"",5,"",7,""],["ce80","",4,"",6,"",4,""],["cf40","",4,"",4,"",6,"",9],["cf80","",5,"",7,"",4,""],["d040","",13,"",5,"",5,"",5,"",6,""],["d080","",4,"",4,"",5,""],["d140","",4,"",4,"",6,"",5],["d180","",4,"",4,"",4,""],["d240","",8,"",24,"",5,"",19,""],["d280","",26,""],["d340","",30,"",6],["d380","",4,"",5,"",21,""],["d440","",31,"",8,"",21],["d480","",25,"",6,""],["d540","",7,"",7,"",46],["d580","",32,""],["d640","",34,"",27],["d680","",30,""],["d740","",31,"",4,"",25],["d780","",24,""],["d840","",8,"",7,"",5,"",6,"",6,"",6,""],["d880","",6,"",20,""],["d940","",62],["d980","",32,""],["da40","",14,"",8,"",4,"",9,""],["da80","",12,""],["db40","",6,"",7,"",4,""],["db80","",4,"",5,"",11,""],["dc40","",4,"",6,"",6,"",11,"",6,"",7],["dc80","",10,"",21,""],["dd40","",62],["dd80","",32,""],["de40","",32,""],["de80","",4,""],["df40","",5,"",4,"",4,"",5,"",4,"",6,""],["df80","",4,""],["e040","",19,""],["e080","",10,"",6,"",8,""],["e140","",4,"",6,"",5,"",5,""],["e180","",10,"",9,"",8,""],["e240","",62],["e280","",32,"",5,""],["e340","",45,"",16],["e380","",7,"",24,""],["e440","",5,"",24,"",31],["e480","",32,""],["e540","",51,"",10],["e580","",31,""],["e640","",34,"",27],["e680","",29,""],["e740","",7,"",54],["e780","",32,"",6,"",4,""],["e840","",14,"",43,""],["e880","",20,""],["e940","",7,"",42],["e980","",32,""],["ea40","",27,"",6,""],["ea80","",4,"",12,""],["eb40","",9,"",7,"",9,"",6,""],["eb80","",4,""],["ec40","",8,"",4,"",18,"",7],["ec80","",4,"",7,"",4,"",4,""],["ed40","",6,"",46],["ed80","",4,"",23,""],["ee40","",62],["ee80","",32,"",4,"",6,""],["ef40","",5,"",37,"",4],["ef80","",30,"",4,"",8,""],["f040","",4,"",28,"",26],["f080","",9,"",12,"",4,"",6,""],["f140","",10,"",47],["f180","",32,""],["f240","",62],["f280","",32,""],["f340","",17,"",6,"",4,""],["f380","",8,"",6,""],["f440","",5,"",10,"",10,"",7,"",5],["f480","",32,""],["f540","",62],["f580","",32,""],["f640","",62],["f680","",32,"",5,"",5,"",4,"",7,""],["f740","",62],["f780","",4,"",4,""],["f840","",62],["f880","",32],["f940","",62],["f980","",32],["fa40","",62],["fa80","",32],["fb40","",27,"",9,""],["fb80","",5,"",8,"",5,""],["fc40","",8,"",4,"",8,"",6],["fc80","",4,"",5,"",8,""],["fd40","",4,"",4,"",10,"",38],["fd80","",5,"",11,"",4,""],["fe40",""]]',
      );
    },
    7348: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["8141","",4,"",6,""],["8161","",9,"",5,""],["8181","",18,"",4,"",6,"",5,"",6,"",7,"",7,"",4,"",4,""],["8241","",7,"",5],["8261","",6,"",5,""],["8281","",7,"",7,"",4,"",10,"",5,"",17,"",7,"",6,"",7,"",18],["8341","",5,"",5,"",7],["8361","",18,""],["8381","",4,"",6,"",5,"",5,"",46,"",6,"",5,"",8],["8441","",5,"",8],["8461","",18],["8481","",7,"",6,"",5,"",10,"",5,"",18,"",5,"",6,"",5,"",26,""],["8541","",5,"",4,"",6,"",4],["8561","",5,"",5,"",6,""],["8581","",6,"",6,"",9,"",26,"",29,"",6,"",5,""],["8641","",6,"",5,""],["8661","",6,"",10],["8681","",22,"",4,"",6,"",5,"",6,"",22,"",4,""],["8741","",9,"",15],["8761","",18,""],["8781","",5,"",7,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",4],["8841","",4,"",5,"",6,"",4],["8861","",4,""],["8881","",15,"",4,"",6,"",5,"",54,""],["8941","",6,"",5,""],["8961","",10,"",5,""],["8981","",21,"",18,"",18,"",6,"",6,"",7,"",15],["8a41","",10,"",6,""],["8a61","",4,"",18,""],["8a81","",4,"",19,"",5,"",7,"",5,"",6,"",5,"",4,"",5,"",26,""],["8b41","",5,"",4,"",6,""],["8b61","",6,"",8],["8b81","",52,"",4,"",6,"",5,"",18,"",18],["8c41","",15,"",4],["8c61","",6,"",5,"",6,"",5],["8c81","",12,"",26,"",50,"",5,"",16],["8d41","",16,"",8],["8d61","",17,""],["8d81","",4,"",33,"",6,"",7,"",6,"",9,"",6,"",5,"",6,""],["8e41","",6,"",5,"",8],["8e61","",4,"",19],["8e81","",13,"",6,"",4,"",6,"",5,"",6,"",5,"",11,"",7,"",6,"",5,"",7],["8f41","",7,"",17],["8f61","",7,"",6,"",4],["8f81","",5,"",7,"",5,"",6,"",5,"",18,"",6,"",26,"",6,"",5],["9041","",6,"",5,""],["9061","",5,"",15],["9081","",12,"",6,"",5,"",4,"",6,"",4,"",5,"",11,"",33,""],["9141","",6,"",5],["9161","",9,"",5],["9181","",20,"",4,"",5,"",14,"",33,"",7,"",5,"",6],["9241","",7,"",4,""],["9261","",7,"",7,"",4],["9281","",21,"",18,"",6,"",7,"",6,"",35,""],["9341","",4,""],["9361","",6,"",8],["9381","",37,"",4,"",4,"",6,"",5,"",7,"",22,""],["9441","",5,"",5,"",8],["9461","",5,"",6,"",12],["9481","",5,"",6,"",6,"",9,"",22,"",4,"",6,"",10,"",6,"",24],["9541","",11,"",5,""],["9561","",6,"",5,""],["9581","",6,"",35,"",4,"",4,"",4,"",6,"",5,"",13,"",14],["9641","",23,""],["9661","",6,"",5,"",8],["9681","",10,"",5,"",13,"",33,"",6,"",44],["9741","",16,"",8],["9761","",17,"",7],["9781","",11,"",5,"",6,"",89,""],["9841","",16,"",5,""],["9861","",6,"",15],["9881","",21,"",6,"",5,"",4,"",6,"",5,"",6,"",5,"",6,"",5,""],["9941","",6,"",5,""],["9961","",6,"",5,""],["9981","",8,"",5,"",4,"",11,"",5,"",6,"",6,"",6,"",7,"",6,"",5,""],["9a41","",16],["9a61","",6,"",6,""],["9a81","",4,"",6,"",5,"",5,"",6,"",5,"",5,"",33,"",5,"",6,""],["9b41","",6,"",8],["9b61","",17,"",7],["9b81","",25,"",4,"",5,"",50,"",22,""],["9c41","",4,"",5,"",5],["9c61","",8,"",6,"",9],["9c81","",8,"",6,"",6,"",9,"",26,"",6,"",5,"",18,"",6,"",12],["9d41","",13,"",8],["9d61","",25],["9d81","",8,"",5,"",9,"",6,"",10,"",6,"",5,"",6,"",5,""],["9e41","",7,"",9,""],["9e61","",4,"",6,""],["9e81","",6,"",6,"",6,"",5,"",10,"",5,"",6,"",5,"",6,""],["9f41","",5,"",4,"",5,""],["9f61","",6,"",5,""],["9f81","",4,"",5,"",6,"",5,"",6,"",4,"",6,"",7,"",4,"",4,""],["a041","",5,"",6,""],["a061","",5,"",13],["a081","",4,"",4,"",4,"",6,"",5,"",6,"",5,"",26,"",4,"",5,"",7,""],["a141","",18,""],["a161","",6,"",5,""],["a181","",14,"",5,"",4,"",9,""],["a241","",5,"",18],["a261","",6,"",18],["a281","",7,"",6,"",7,""],["a341","",6,"",10,""],["a361","",6,"",16],["a381","",16,"",4,"",58,"",32,""],["a441","",5,""],["a461","",5,"",12],["a481","",28,"",93],["a541","",4,"",6,"",5,""],["a561","",17,"",5,""],["a581","",16,"",14,"",9],["a5b0","",9],["a5c1","",16,"",6],["a5e1","",16,"",6],["a641","",19,""],["a661","",5,"",5,"",6],["a681","",6,"",18,"",7],["a741","",4,"",6,"",7],["a761","",22,""],["a781","",6,"",5,"",7,"",9,"",9,"",4,"",5,"",4,""],["a841","",10,"",14],["a861","",18,"",6],["a881","",19,"",11,""],["a8a6",""],["a8a8",""],["a8b1","",27,"",25,"",14,""],["a941","",14,"",10],["a961","",18],["a981","",14,"",6,"",27,"",25,"",14,""],["aa41","",6,"",4,""],["aa61","",4,"",5,"",6,""],["aa81","",29,"",82],["ab41","",6,"",5,""],["ab61","",6,"",5,"",5],["ab81","",8,"",6,"",12,"",85],["ac41","",5,"",6,""],["ac61","",11,"",4],["ac81","",28,"",5,"",25],["acd1","",5,"",25],["ad41","",6,"",5,"",7],["ad61","",6,"",10,""],["ad81","",5,"",18,""],["ae41","",5,"",16],["ae61","",5,"",6,"",4],["ae81","",6,"",5,""],["af41","",19],["af61","",13,"",5,""],["af81","",5,"",6,"",5,""],["b041","",5,"",5,"",12],["b061","",5,"",19],["b081","",13,"",6,"",5,"",7,"",4,""],["b141","",6,"",5,""],["b161","",6,"",5,"",11],["b181","",14,"",6,""],["b241","",6,"",5,""],["b261","",18,"",5,""],["b281","",5,"",18,"",6,""],["b341","",19,""],["b361","",5,"",5,"",5],["b381","",5,"",5,"",19,"",4,""],["b441","",5,"",6,"",5],["b461","",6,"",10,""],["b481","",6,"",18,"",4,"",4,""],["b541","",14,"",5],["b561","",5,"",5,"",4],["b581","",6,"",5,"",11,""],["b641","",7,"",17],["b661","",15,""],["b681","",5,"",6,"",5,""],["b741","",13,"",6,""],["b761","",20,""],["b781","",6,"",14,""],["b841","",7,"",17],["b861","",8,"",13],["b881","",5,"",24,"",4,""],["b941","",6,"",5,""],["b961","",14,"",6,""],["b981","",22,"",4,"",4,""],["ba41","",5,"",6,""],["ba61","",5,"",4,"",5],["ba81","",6,"",9,""],["bb41","",4,"",5,"",4,""],["bb61","",6,"",5,""],["bb81","",31,""],["bc41","",17,""],["bc61","",5,"",6,""],["bc81","",4,"",6,"",5,"",5,"",4,""],["bd41","",7,"",7,""],["bd61","",5,"",13],["bd81","",5,"",25,""],["be41","",7,"",14],["be61","",7,"",7,""],["be81","",4,"",4,"",5,"",8,"",6,""],["bf41","",10,"",14],["bf61","",18,""],["bf81","",5,"",7,"",6,"",5,""],["c041","",5,"",6,"",5],["c061","",25],["c081","",6,"",5,"",7,""],["c141","",5,"",6,""],["c161","",19,""],["c181","",31,""],["c241","",4,"",5,""],["c261","",4,"",5,"",6,""],["c281","",5,"",7,"",9,""],["c341","",4],["c361","",4,"",5,"",11],["c381","",5,"",7,"",5,""],["c441","",7,"",7,""],["c461","",5,"",4],["c481","",5,"",11,""],["c541","",6,"",5,""],["c561","",6,"",5,"",4],["c581","",6,"",5,""],["c641","",6,"",5],["c6a1",""],["c7a1",""],["c8a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1","",5,"",4,""],["d2a1","",4,"",5,"",10,"",7,"",5,""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f5a1",""],["f6a1",""],["f7a1",""],["f8a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fda1",""]]',
      );
    },
    4284: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["a140",""],["a1a1","",4,""],["a240","",7,""],["a2a1","",9,"",9,"",8,"",25,"",21],["a340","",16,"",6,"",16,"",6,"",10],["a3a1","",25,""],["a3e1",""],["a440",""],["a4a1",""],["a540",""],["a5a1",""],["a640",""],["a6a1",""],["a740",""],["a7a1",""],["a840",""],["a8a1",""],["a940",""],["a9a1",""],["aa40",""],["aaa1",""],["ab40",""],["aba1",""],["ac40",""],["aca1",""],["ad40",""],["ada1",""],["ae40",""],["aea1",""],["af40",""],["afa1",""],["b040",""],["b0a1",""],["b140",""],["b1a1",""],["b240",""],["b2a1",""],["b340",""],["b3a1",""],["b440",""],["b4a1",""],["b540",""],["b5a1",""],["b640",""],["b6a1",""],["b740",""],["b7a1",""],["b840",""],["b8a1",""],["b940",""],["b9a1",""],["ba40",""],["baa1",""],["bb40",""],["bba1",""],["bc40",""],["bca1",""],["bd40",""],["bda1",""],["be40",""],["bea1",""],["bf40",""],["bfa1",""],["c040",""],["c0a1",""],["c140",""],["c1a1",""],["c240",""],["c2a1",""],["c340",""],["c3a1",""],["c440",""],["c4a1",""],["c540",""],["c5a1",""],["c640",""],["c940",""],["c9a1",""],["ca40",""],["caa1",""],["cb40",""],["cba1",""],["cc40",""],["cca1",""],["cd40",""],["cda1",""],["ce40",""],["cea1",""],["cf40",""],["cfa1",""],["d040",""],["d0a1",""],["d140",""],["d1a1",""],["d240",""],["d2a1",""],["d340",""],["d3a1",""],["d440",""],["d4a1",""],["d540",""],["d5a1",""],["d640",""],["d6a1",""],["d740",""],["d7a1",""],["d840",""],["d8a1",""],["d940",""],["d9a1",""],["da40",""],["daa1",""],["db40",""],["dba1",""],["dc40",""],["dca1",""],["dd40",""],["dda1",""],["de40",""],["dea1",""],["df40",""],["dfa1",""],["e040",""],["e0a1",""],["e140",""],["e1a1",""],["e240",""],["e2a1",""],["e340",""],["e3a1",""],["e440",""],["e4a1",""],["e540",""],["e5a1",""],["e640",""],["e6a1",""],["e740",""],["e7a1",""],["e840",""],["e8a1",""],["e940",""],["e9a1",""],["ea40",""],["eaa1",""],["eb40",""],["eba1",""],["ec40",""],["eca1",""],["ed40",""],["eda1",""],["ee40",""],["eea1",""],["ef40",""],["efa1",""],["f040",""],["f0a1",""],["f140",""],["f1a1",""],["f240",""],["f2a1",""],["f340",""],["f3a1",""],["f440",""],["f4a1",""],["f540",""],["f5a1",""],["f640",""],["f6a1",""],["f740",""],["f7a1",""],["f840",""],["f8a1",""],["f940",""],["f9a1",""]]',
      );
    },
    1532: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["8ea1","",62],["a1a1","",9,""],["a2a1",""],["a2ba",""],["a2ca",""],["a2dc",""],["a2f2",""],["a2fe",""],["a3b0","",9],["a3c1","",25],["a3e1","",25],["a4a1","",82],["a5a1","",85],["a6a1","",16,"",6],["a6c1","",16,"",6],["a7a1","",5,"",25],["a7d1","",5,"",25],["a8a1",""],["ada1","",19,"",9],["adc0",""],["addf","",4,""],["b0a1",""],["b1a1",""],["b2a1",""],["b3a1",""],["b4a1",""],["b5a1",""],["b6a1",""],["b7a1",""],["b8a1",""],["b9a1",""],["baa1",""],["bba1",""],["bca1",""],["bda1",""],["bea1",""],["bfa1",""],["c0a1",""],["c1a1",""],["c2a1",""],["c3a1",""],["c4a1",""],["c5a1",""],["c6a1",""],["c7a1",""],["c8a1",""],["c9a1",""],["caa1",""],["cba1",""],["cca1",""],["cda1",""],["cea1",""],["cfa1",""],["d0a1",""],["d1a1",""],["d2a1",""],["d3a1",""],["d4a1",""],["d5a1",""],["d6a1",""],["d7a1",""],["d8a1",""],["d9a1",""],["daa1",""],["dba1",""],["dca1",""],["dda1",""],["dea1",""],["dfa1",""],["e0a1",""],["e1a1",""],["e2a1",""],["e3a1",""],["e4a1",""],["e5a1",""],["e6a1",""],["e7a1",""],["e8a1",""],["e9a1",""],["eaa1",""],["eba1",""],["eca1",""],["eda1",""],["eea1",""],["efa1",""],["f0a1",""],["f1a1",""],["f2a1",""],["f3a1",""],["f4a1",""],["f9a1",""],["faa1",""],["fba1",""],["fca1",""],["fcf1","",9,""],["8fa2af",""],["8fa2c2",""],["8fa2eb",""],["8fa6e1",""],["8fa6e7",""],["8fa6e9",""],["8fa6ec",""],["8fa6f1",""],["8fa7c2","",10,""],["8fa7f2","",10,""],["8fa9a1",""],["8fa9a4",""],["8fa9a6",""],["8fa9a8",""],["8fa9ab",""],["8fa9af",""],["8fa9c1",""],["8faaa1",""],["8faaba",""],["8faba1",""],["8fabbd",""],["8fabc5",""],["8fb0a1",""],["8fb1a1",""],["8fb2a1","",4,""],["8fb3a1",""],["8fb4a1",""],["8fb5a1",""],["8fb6a1","",5,"",4,""],["8fb7a1","",4,""],["8fb8a1",""],["8fb9a1",""],["8fbaa1","",4,""],["8fbba1",""],["8fbca1","",4,""],["8fbda1","",4,""],["8fbea1","",4,""],["8fbfa1",""],["8fc0a1",""],["8fc1a1",""],["8fc2a1",""],["8fc3a1","",4,""],["8fc4a1",""],["8fc5a1",""],["8fc6a1",""],["8fc7a1",""],["8fc8a1",""],["8fc9a1","",4,"",4,""],["8fcaa1",""],["8fcba1",""],["8fcca1","",9,""],["8fcda1","",5,""],["8fcea1","",6,""],["8fcfa1",""],["8fd0a1",""],["8fd1a1",""],["8fd2a1","",5],["8fd3a1",""],["8fd4a1","",4,""],["8fd5a1",""],["8fd6a1",""],["8fd7a1",""],["8fd8a1",""],["8fd9a1","",4,"",6,""],["8fdaa1","",4,""],["8fdba1","",6,""],["8fdca1","",4,""],["8fdda1","",4,""],["8fdea1","",4,""],["8fdfa1",""],["8fe0a1",""],["8fe1a1","",4,""],["8fe2a1",""],["8fe3a1","",5,"",4,""],["8fe4a1","",4,""],["8fe5a1","",4,""],["8fe6a1",""],["8fe7a1",""],["8fe8a1","",4,""],["8fe9a1","",4],["8feaa1","",4,""],["8feba1","",4,""],["8feca1",""],["8feda1","",4,"",4,""]]',
      );
    },
    6258: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}',
      );
    },
    4346: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3",""],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,""],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc",""],["a8bf",""],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50",""],["fe80","",6,"",93],["8135f437",""]]',
      );
    },
    7014: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",128],["a1","",62],["8140","",9,""],["8180",""],["81b8",""],["81c8",""],["81da",""],["81f0",""],["81fc",""],["824f","",9],["8260","",25],["8281","",25],["829f","",82],["8340","",62],["8380","",22],["839f","",16,"",6],["83bf","",16,"",6],["8440","",5,"",25],["8470","",5,"",7],["8480","",17],["849f",""],["8740","",19,"",9],["875f",""],["877e",""],["8780","",4,""],["889f",""],["8940",""],["8980",""],["8a40",""],["8a80",""],["8b40",""],["8b80",""],["8c40",""],["8c80",""],["8d40",""],["8d80",""],["8e40",""],["8e80",""],["8f40",""],["8f80",""],["9040",""],["9080",""],["9140",""],["9180",""],["9240",""],["9280",""],["9340",""],["9380",""],["9440",""],["9480",""],["9540",""],["9580",""],["9640",""],["9680",""],["9740",""],["9780",""],["9840",""],["989f",""],["9940",""],["9980",""],["9a40",""],["9a80",""],["9b40",""],["9b80",""],["9c40",""],["9c80",""],["9d40",""],["9d80",""],["9e40",""],["9e80",""],["9f40",""],["9f80",""],["e040",""],["e080",""],["e140",""],["e180",""],["e240",""],["e280",""],["e340",""],["e380",""],["e440",""],["e480",""],["e540",""],["e580",""],["e640",""],["e680",""],["e740",""],["e780",""],["e840",""],["e880",""],["e940",""],["e980",""],["ea40",""],["ea80",""],["ed40",""],["ed80",""],["ee40",""],["ee80",""],["eeef","",9,""],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","",9,"",9,""],["fa80",""],["fb40",""],["fb80",""],["fc40",""]]',
      );
    },
    1947: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"topLevel":{"dependancies":"dependencies","dependecies":"dependencies","depdenencies":"dependencies","devEependencies":"devDependencies","depends":"dependencies","dev-dependencies":"devDependencies","devDependences":"devDependencies","devDepenencies":"devDependencies","devdependencies":"devDependencies","repostitory":"repository","repo":"repository","prefereGlobal":"preferGlobal","hompage":"homepage","hampage":"homepage","autohr":"author","autor":"author","contributers":"contributors","publicationConfig":"publishConfig","script":"scripts"},"bugs":{"web":"url","name":"url"},"script":{"server":"start","tests":"test"}}',
      );
    },
    6271: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"repositories":"\'repositories\' (plural) Not supported. Please pick one as the \'repository\' field","missingRepository":"No repository field.","brokenGitUrl":"Probably broken git url: %s","nonObjectScripts":"scripts must be an object","nonStringScript":"script values must be string commands","nonArrayFiles":"Invalid \'files\' member","invalidFilename":"Invalid filename in \'files\' list: %s","nonArrayBundleDependencies":"Invalid \'bundleDependencies\' list. Must be array of package names","nonStringBundleDependency":"Invalid bundleDependencies member: %s","nonDependencyBundleDependency":"Non-dependency in bundleDependencies: %s","nonObjectDependencies":"%s field must be an object","nonStringDependency":"Invalid dependency: %s %s","deprecatedArrayDependencies":"specifying %s as array is deprecated","deprecatedModules":"modules field is deprecated","nonArrayKeywords":"keywords should be an array of strings","nonStringKeyword":"keywords should be an array of strings","conflictingName":"%s is also the name of a node core module.","nonStringDescription":"\'description\' field should be a string","missingDescription":"No description","missingReadme":"No README data","missingLicense":"No license field.","nonEmailUrlBugsString":"Bug string field must be url, email, or {email,url}","nonUrlBugsUrlField":"bugs.url field must be a string url. Deleted.","nonEmailBugsEmailField":"bugs.email field must be a string email. Deleted.","emptyNormalizedBugs":"Normalized value of bugs field is an empty object. Deleted.","nonUrlHomepage":"homepage field must be a string url. Deleted.","invalidLicense":"license should be a valid SPDX license expression","typo":"%s should probably be %s."}',
      );
    },
    238: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '["389-exception","Asterisk-exception","Autoconf-exception-2.0","Autoconf-exception-3.0","Autoconf-exception-generic","Autoconf-exception-generic-3.0","Autoconf-exception-macro","Bison-exception-1.24","Bison-exception-2.2","Bootloader-exception","Classpath-exception-2.0","CLISP-exception-2.0","cryptsetup-OpenSSL-exception","DigiRule-FOSS-exception","eCos-exception-2.0","Fawkes-Runtime-exception","FLTK-exception","fmt-exception","Font-exception-2.0","freertos-exception-2.0","GCC-exception-2.0","GCC-exception-2.0-note","GCC-exception-3.1","Gmsh-exception","GNAT-exception","GNOME-examples-exception","GNU-compiler-exception","gnu-javamail-exception","GPL-3.0-interface-exception","GPL-3.0-linking-exception","GPL-3.0-linking-source-exception","GPL-CC-1.0","GStreamer-exception-2005","GStreamer-exception-2008","i2p-gpl-java-exception","KiCad-libraries-exception","LGPL-3.0-linking-exception","libpri-OpenH323-exception","Libtool-exception","Linux-syscall-note","LLGPL","LLVM-exception","LZMA-exception","mif-exception","OCaml-LGPL-linking-exception","OCCT-exception-1.0","OpenJDK-assembly-exception-1.0","openvpn-openssl-exception","PS-or-PDF-font-exception-20170817","QPL-1.0-INRIA-2004-exception","Qt-GPL-exception-1.0","Qt-LGPL-exception-1.1","Qwt-exception-1.0","SANE-exception","SHL-2.0","SHL-2.1","stunnel-exception","SWI-exception","Swift-exception","Texinfo-exception","u-boot-exception-2.0","UBDL-exception","Universal-FOSS-exception-1.0","vsftpd-openssl-exception","WxWindows-exception-3.1","x11vnc-openssl-exception"]',
      );
    },
    6765: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '["AGPL-1.0","AGPL-3.0","BSD-2-Clause-FreeBSD","BSD-2-Clause-NetBSD","GFDL-1.1","GFDL-1.2","GFDL-1.3","GPL-1.0","GPL-2.0","GPL-2.0-with-GCC-exception","GPL-2.0-with-autoconf-exception","GPL-2.0-with-bison-exception","GPL-2.0-with-classpath-exception","GPL-2.0-with-font-exception","GPL-3.0","GPL-3.0-with-GCC-exception","GPL-3.0-with-autoconf-exception","LGPL-2.0","LGPL-2.1","LGPL-3.0","Net-SNMP","Nunit","StandardML-NJ","bzip2-1.0.5","eCos-2.0","wxWindows"]',
      );
    },
    6033: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '["0BSD","3D-Slicer-1.0","AAL","ADSL","AFL-1.1","AFL-1.2","AFL-2.0","AFL-2.1","AFL-3.0","AGPL-1.0-only","AGPL-1.0-or-later","AGPL-3.0-only","AGPL-3.0-or-later","AMD-newlib","AMDPLPA","AML","AML-glslang","AMPAS","ANTLR-PD","ANTLR-PD-fallback","APAFML","APL-1.0","APSL-1.0","APSL-1.1","APSL-1.2","APSL-2.0","ASWF-Digital-Assets-1.0","ASWF-Digital-Assets-1.1","Abstyles","AdaCore-doc","Adobe-2006","Adobe-Display-PostScript","Adobe-Glyph","Adobe-Utopia","Afmparse","Aladdin","Apache-1.0","Apache-1.1","Apache-2.0","App-s2p","Arphic-1999","Artistic-1.0","Artistic-1.0-Perl","Artistic-1.0-cl8","Artistic-2.0","BSD-1-Clause","BSD-2-Clause","BSD-2-Clause-Darwin","BSD-2-Clause-Patent","BSD-2-Clause-Views","BSD-2-Clause-first-lines","BSD-3-Clause","BSD-3-Clause-Attribution","BSD-3-Clause-Clear","BSD-3-Clause-HP","BSD-3-Clause-LBNL","BSD-3-Clause-Modification","BSD-3-Clause-No-Military-License","BSD-3-Clause-No-Nuclear-License","BSD-3-Clause-No-Nuclear-License-2014","BSD-3-Clause-No-Nuclear-Warranty","BSD-3-Clause-Open-MPI","BSD-3-Clause-Sun","BSD-3-Clause-acpica","BSD-3-Clause-flex","BSD-4-Clause","BSD-4-Clause-Shortened","BSD-4-Clause-UC","BSD-4.3RENO","BSD-4.3TAHOE","BSD-Advertising-Acknowledgement","BSD-Attribution-HPND-disclaimer","BSD-Inferno-Nettverk","BSD-Protection","BSD-Source-Code","BSD-Source-beginning-file","BSD-Systemics","BSD-Systemics-W3Works","BSL-1.0","BUSL-1.1","Baekmuk","Bahyph","Barr","Beerware","BitTorrent-1.0","BitTorrent-1.1","Bitstream-Charter","Bitstream-Vera","BlueOak-1.0.0","Boehm-GC","Borceux","Brian-Gladman-2-Clause","Brian-Gladman-3-Clause","C-UDA-1.0","CAL-1.0","CAL-1.0-Combined-Work-Exception","CATOSL-1.1","CC-BY-1.0","CC-BY-2.0","CC-BY-2.5","CC-BY-2.5-AU","CC-BY-3.0","CC-BY-3.0-AT","CC-BY-3.0-AU","CC-BY-3.0-DE","CC-BY-3.0-IGO","CC-BY-3.0-NL","CC-BY-3.0-US","CC-BY-4.0","CC-BY-NC-1.0","CC-BY-NC-2.0","CC-BY-NC-2.5","CC-BY-NC-3.0","CC-BY-NC-3.0-DE","CC-BY-NC-4.0","CC-BY-NC-ND-1.0","CC-BY-NC-ND-2.0","CC-BY-NC-ND-2.5","CC-BY-NC-ND-3.0","CC-BY-NC-ND-3.0-DE","CC-BY-NC-ND-3.0-IGO","CC-BY-NC-ND-4.0","CC-BY-NC-SA-1.0","CC-BY-NC-SA-2.0","CC-BY-NC-SA-2.0-DE","CC-BY-NC-SA-2.0-FR","CC-BY-NC-SA-2.0-UK","CC-BY-NC-SA-2.5","CC-BY-NC-SA-3.0","CC-BY-NC-SA-3.0-DE","CC-BY-NC-SA-3.0-IGO","CC-BY-NC-SA-4.0","CC-BY-ND-1.0","CC-BY-ND-2.0","CC-BY-ND-2.5","CC-BY-ND-3.0","CC-BY-ND-3.0-DE","CC-BY-ND-4.0","CC-BY-SA-1.0","CC-BY-SA-2.0","CC-BY-SA-2.0-UK","CC-BY-SA-2.1-JP","CC-BY-SA-2.5","CC-BY-SA-3.0","CC-BY-SA-3.0-AT","CC-BY-SA-3.0-DE","CC-BY-SA-3.0-IGO","CC-BY-SA-4.0","CC-PDDC","CC0-1.0","CDDL-1.0","CDDL-1.1","CDL-1.0","CDLA-Permissive-1.0","CDLA-Permissive-2.0","CDLA-Sharing-1.0","CECILL-1.0","CECILL-1.1","CECILL-2.0","CECILL-2.1","CECILL-B","CECILL-C","CERN-OHL-1.1","CERN-OHL-1.2","CERN-OHL-P-2.0","CERN-OHL-S-2.0","CERN-OHL-W-2.0","CFITSIO","CMU-Mach","CMU-Mach-nodoc","CNRI-Jython","CNRI-Python","CNRI-Python-GPL-Compatible","COIL-1.0","CPAL-1.0","CPL-1.0","CPOL-1.02","CUA-OPL-1.0","Caldera","Caldera-no-preamble","Catharon","ClArtistic","Clips","Community-Spec-1.0","Condor-1.1","Cornell-Lossless-JPEG","Cronyx","Crossword","CrystalStacker","Cube","D-FSL-1.0","DEC-3-Clause","DL-DE-BY-2.0","DL-DE-ZERO-2.0","DOC","DRL-1.0","DRL-1.1","DSDP","DocBook-Schema","DocBook-XML","Dotseqn","ECL-1.0","ECL-2.0","EFL-1.0","EFL-2.0","EPICS","EPL-1.0","EPL-2.0","EUDatagrid","EUPL-1.0","EUPL-1.1","EUPL-1.2","Elastic-2.0","Entessa","ErlPL-1.1","Eurosym","FBM","FDK-AAC","FSFAP","FSFAP-no-warranty-disclaimer","FSFUL","FSFULLR","FSFULLRWD","FTL","Fair","Ferguson-Twofish","Frameworx-1.0","FreeBSD-DOC","FreeImage","Furuseth","GCR-docs","GD","GFDL-1.1-invariants-only","GFDL-1.1-invariants-or-later","GFDL-1.1-no-invariants-only","GFDL-1.1-no-invariants-or-later","GFDL-1.1-only","GFDL-1.1-or-later","GFDL-1.2-invariants-only","GFDL-1.2-invariants-or-later","GFDL-1.2-no-invariants-only","GFDL-1.2-no-invariants-or-later","GFDL-1.2-only","GFDL-1.2-or-later","GFDL-1.3-invariants-only","GFDL-1.3-invariants-or-later","GFDL-1.3-no-invariants-only","GFDL-1.3-no-invariants-or-later","GFDL-1.3-only","GFDL-1.3-or-later","GL2PS","GLWTPL","GPL-1.0-only","GPL-1.0-or-later","GPL-2.0-only","GPL-2.0-or-later","GPL-3.0-only","GPL-3.0-or-later","Giftware","Glide","Glulxe","Graphics-Gems","Gutmann","HIDAPI","HP-1986","HP-1989","HPND","HPND-DEC","HPND-Fenneberg-Livingston","HPND-INRIA-IMAG","HPND-Intel","HPND-Kevlin-Henney","HPND-MIT-disclaimer","HPND-Markus-Kuhn","HPND-Netrek","HPND-Pbmplus","HPND-UC","HPND-UC-export-US","HPND-doc","HPND-doc-sell","HPND-export-US","HPND-export-US-acknowledgement","HPND-export-US-modify","HPND-export2-US","HPND-merchantability-variant","HPND-sell-MIT-disclaimer-xserver","HPND-sell-regexpr","HPND-sell-variant","HPND-sell-variant-MIT-disclaimer","HPND-sell-variant-MIT-disclaimer-rev","HTMLTIDY","HaskellReport","Hippocratic-2.1","IBM-pibs","ICU","IEC-Code-Components-EULA","IJG","IJG-short","IPA","IPL-1.0","ISC","ISC-Veillard","ImageMagick","Imlib2","Info-ZIP","Inner-Net-2.0","Intel","Intel-ACPI","Interbase-1.0","JPL-image","JPNIC","JSON","Jam","JasPer-2.0","Kastrup","Kazlib","Knuth-CTAN","LAL-1.2","LAL-1.3","LGPL-2.0-only","LGPL-2.0-or-later","LGPL-2.1-only","LGPL-2.1-or-later","LGPL-3.0-only","LGPL-3.0-or-later","LGPLLR","LOOP","LPD-document","LPL-1.0","LPL-1.02","LPPL-1.0","LPPL-1.1","LPPL-1.2","LPPL-1.3a","LPPL-1.3c","LZMA-SDK-9.11-to-9.20","LZMA-SDK-9.22","Latex2e","Latex2e-translated-notice","Leptonica","LiLiQ-P-1.1","LiLiQ-R-1.1","LiLiQ-Rplus-1.1","Libpng","Linux-OpenIB","Linux-man-pages-1-para","Linux-man-pages-copyleft","Linux-man-pages-copyleft-2-para","Linux-man-pages-copyleft-var","Lucida-Bitmap-Fonts","MIT","MIT-0","MIT-CMU","MIT-Festival","MIT-Khronos-old","MIT-Modern-Variant","MIT-Wu","MIT-advertising","MIT-enna","MIT-feh","MIT-open-group","MIT-testregex","MITNFA","MMIXware","MPEG-SSG","MPL-1.0","MPL-1.1","MPL-2.0","MPL-2.0-no-copyleft-exception","MS-LPL","MS-PL","MS-RL","MTLL","Mackerras-3-Clause","Mackerras-3-Clause-acknowledgment","MakeIndex","Martin-Birgmeier","McPhee-slideshow","Minpack","MirOS","Motosoto","MulanPSL-1.0","MulanPSL-2.0","Multics","Mup","NAIST-2003","NASA-1.3","NBPL-1.0","NCBI-PD","NCGL-UK-2.0","NCL","NCSA","NGPL","NICTA-1.0","NIST-PD","NIST-PD-fallback","NIST-Software","NLOD-1.0","NLOD-2.0","NLPL","NOSL","NPL-1.0","NPL-1.1","NPOSL-3.0","NRL","NTP","NTP-0","Naumen","NetCDF","Newsletr","Nokia","Noweb","O-UDA-1.0","OAR","OCCT-PL","OCLC-2.0","ODC-By-1.0","ODbL-1.0","OFFIS","OFL-1.0","OFL-1.0-RFN","OFL-1.0-no-RFN","OFL-1.1","OFL-1.1-RFN","OFL-1.1-no-RFN","OGC-1.0","OGDL-Taiwan-1.0","OGL-Canada-2.0","OGL-UK-1.0","OGL-UK-2.0","OGL-UK-3.0","OGTSL","OLDAP-1.1","OLDAP-1.2","OLDAP-1.3","OLDAP-1.4","OLDAP-2.0","OLDAP-2.0.1","OLDAP-2.1","OLDAP-2.2","OLDAP-2.2.1","OLDAP-2.2.2","OLDAP-2.3","OLDAP-2.4","OLDAP-2.5","OLDAP-2.6","OLDAP-2.7","OLDAP-2.8","OLFL-1.3","OML","OPL-1.0","OPL-UK-3.0","OPUBL-1.0","OSET-PL-2.1","OSL-1.0","OSL-1.1","OSL-2.0","OSL-2.1","OSL-3.0","OpenPBS-2.3","OpenSSL","OpenSSL-standalone","OpenVision","PADL","PDDL-1.0","PHP-3.0","PHP-3.01","PPL","PSF-2.0","Parity-6.0.0","Parity-7.0.0","Pixar","Plexus","PolyForm-Noncommercial-1.0.0","PolyForm-Small-Business-1.0.0","PostgreSQL","Python-2.0","Python-2.0.1","QPL-1.0","QPL-1.0-INRIA-2004","Qhull","RHeCos-1.1","RPL-1.1","RPL-1.5","RPSL-1.0","RSA-MD","RSCPL","Rdisc","Ruby","Ruby-pty","SAX-PD","SAX-PD-2.0","SCEA","SGI-B-1.0","SGI-B-1.1","SGI-B-2.0","SGI-OpenGL","SGP4","SHL-0.5","SHL-0.51","SISSL","SISSL-1.2","SL","SMLNJ","SMPPL","SNIA","SPL-1.0","SSH-OpenSSH","SSH-short","SSLeay-standalone","SSPL-1.0","SWL","Saxpath","SchemeReport","Sendmail","Sendmail-8.23","SimPL-2.0","Sleepycat","Soundex","Spencer-86","Spencer-94","Spencer-99","SugarCRM-1.1.3","Sun-PPP","Sun-PPP-2000","SunPro","Symlinks","TAPR-OHL-1.0","TCL","TCP-wrappers","TGPPL-1.0","TMate","TORQUE-1.1","TOSL","TPDL","TPL-1.0","TTWL","TTYP0","TU-Berlin-1.0","TU-Berlin-2.0","TermReadKey","UCAR","UCL-1.0","UMich-Merit","UPL-1.0","URT-RLE","Ubuntu-font-1.0","Unicode-3.0","Unicode-DFS-2015","Unicode-DFS-2016","Unicode-TOU","UnixCrypt","Unlicense","VOSTROM","VSL-1.0","Vim","W3C","W3C-19980720","W3C-20150513","WTFPL","Watcom-1.0","Widget-Workshop","Wsuipa","X11","X11-distribute-modifications-variant","X11-swapped","XFree86-1.1","XSkat","Xdebug-1.03","Xerox","Xfig","Xnet","YPL-1.0","YPL-1.1","ZPL-1.1","ZPL-2.0","ZPL-2.1","Zed","Zeeff","Zend-2.0","Zimbra-1.3","Zimbra-1.4","Zlib","any-OSI","bcrypt-Solar-Designer","blessing","bzip2-1.0.6","check-cvs","checkmk","copyleft-next-0.3.0","copyleft-next-0.3.1","curl","cve-tou","diffmark","dtoa","dvipdfm","eGenix","etalab-2.0","fwlw","gSOAP-1.3b","gnuplot","gtkbook","hdparm","iMatix","libpng-2.0","libselinux-1.0","libtiff","libutil-David-Nugent","lsof","magaz","mailprio","metamail","mpi-permissive","mpich2","mplus","pkgconf","pnmstitch","psfrag","psutils","python-ldap","radvd","snprintf","softSurfer","ssh-keyscan","swrule","threeparttable","ulem","w3m","xinetd","xkeyboard-config-Zinoviev","xlock","xpp","xzoom","zlib-acknowledgement"]',
      );
    },
  };
  var __webpack_module_cache__ = {};
  function __nccwpck_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (__webpack_module_cache__[moduleId] = { exports: {} });
    var threw = true;
    try {
      __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nccwpck_require__,
      );
      threw = false;
    } finally {
      if (threw) delete __webpack_module_cache__[moduleId];
    }
    return module.exports;
  }
  if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  var __webpack_exports__ = __nccwpck_require__(6763);
  module.exports = __webpack_exports__;
})();
