(() => {
  var __webpack_modules__ = {
    8520: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const net = __nccwpck_require__(1808);
      const tls = __nccwpck_require__(4404);
      const { once } = __nccwpck_require__(2361);
      const timers = __nccwpck_require__(8670);
      const { normalizeOptions, cacheOptions } = __nccwpck_require__(1709);
      const { getProxy, getProxyAgent, proxyCache } = __nccwpck_require__(8443);
      const Errors = __nccwpck_require__(4724);
      const { Agent: AgentBase } = __nccwpck_require__(694);
      module.exports = class Agent extends AgentBase {
        #options;
        #timeouts;
        #proxy;
        #noProxy;
        #ProxyAgent;
        constructor(options = {}) {
          const { timeouts, proxy, noProxy, ...normalizedOptions } =
            normalizeOptions(options);
          super(normalizedOptions);
          this.#options = normalizedOptions;
          this.#timeouts = timeouts;
          if (proxy) {
            this.#proxy = new URL(proxy);
            this.#noProxy = noProxy;
            this.#ProxyAgent = getProxyAgent(proxy);
          }
        }
        get proxy() {
          return this.#proxy ? { url: this.#proxy } : {};
        }
        #getProxy(options) {
          if (!this.#proxy) {
            return;
          }
          const proxy = getProxy(
            `${options.protocol}//${options.host}:${options.port}`,
            { proxy: this.#proxy, noProxy: this.#noProxy },
          );
          if (!proxy) {
            return;
          }
          const cacheKey = cacheOptions({
            ...options,
            ...this.#options,
            timeouts: this.#timeouts,
            proxy,
          });
          if (proxyCache.has(cacheKey)) {
            return proxyCache.get(cacheKey);
          }
          let ProxyAgent = this.#ProxyAgent;
          if (Array.isArray(ProxyAgent)) {
            ProxyAgent = this.isSecureEndpoint(options)
              ? ProxyAgent[1]
              : ProxyAgent[0];
          }
          const proxyAgent = new ProxyAgent(proxy, {
            ...this.#options,
            socketOptions: { family: this.#options.family },
          });
          proxyCache.set(cacheKey, proxyAgent);
          return proxyAgent;
        }
        async #timeoutConnection(
          { promises, options, timeout },
          ac = new AbortController(),
        ) {
          if (timeout) {
            const connectionTimeout = timers
              .setTimeout(timeout, null, { signal: ac.signal })
              .then(() => {
                throw new Errors.ConnectionTimeoutError(
                  `${options.host}:${options.port}`,
                );
              })
              .catch((err) => {
                if (err.name === "AbortError") {
                  return;
                }
                throw err;
              });
            promises.push(connectionTimeout);
          }
          let result;
          try {
            result = await Promise.race(promises);
            ac.abort();
          } catch (err) {
            ac.abort();
            throw err;
          }
          return result;
        }
        async connect(request, options) {
          options.lookup ??= this.#options.lookup;
          let socket;
          let timeout = this.#timeouts.connection;
          const isSecureEndpoint = this.isSecureEndpoint(options);
          const proxy = this.#getProxy(options);
          if (proxy) {
            const start = Date.now();
            socket = await this.#timeoutConnection({
              options,
              timeout,
              promises: [proxy.connect(request, options)],
            });
            if (timeout) {
              timeout = timeout - (Date.now() - start);
            }
          } else {
            socket = (isSecureEndpoint ? tls : net).connect(options);
          }
          socket.setKeepAlive(this.keepAlive, this.keepAliveMsecs);
          socket.setNoDelay(this.keepAlive);
          const abortController = new AbortController();
          const { signal } = abortController;
          const connectPromise = socket[
            isSecureEndpoint ? "secureConnecting" : "connecting"
          ]
            ? once(socket, isSecureEndpoint ? "secureConnect" : "connect", {
                signal,
              })
            : Promise.resolve();
          await this.#timeoutConnection(
            {
              options,
              timeout,
              promises: [
                connectPromise,
                once(socket, "error", { signal }).then((err) => {
                  throw err[0];
                }),
              ],
            },
            abortController,
          );
          if (this.#timeouts.idle) {
            socket.setTimeout(this.#timeouts.idle, () => {
              socket.destroy(
                new Errors.IdleTimeoutError(`${options.host}:${options.port}`),
              );
            });
          }
          return socket;
        }
        addRequest(request, options) {
          const proxy = this.#getProxy(options);
          if (proxy?.setRequestProps) {
            proxy.setRequestProps(request, options);
          }
          request.setHeader(
            "connection",
            this.keepAlive ? "keep-alive" : "close",
          );
          if (this.#timeouts.response) {
            let responseTimeout;
            request.once("finish", () => {
              setTimeout(() => {
                request.destroy(
                  new Errors.ResponseTimeoutError(request, this.#proxy),
                );
              }, this.#timeouts.response);
            });
            request.once("response", () => {
              clearTimeout(responseTimeout);
            });
          }
          if (this.#timeouts.transfer) {
            let transferTimeout;
            request.once("response", (res) => {
              setTimeout(() => {
                res.destroy(
                  new Errors.TransferTimeoutError(request, this.#proxy),
                );
              }, this.#timeouts.transfer);
              res.once("close", () => {
                clearTimeout(transferTimeout);
              });
            });
          }
          return super.addRequest(request, options);
        }
      };
    },
    2292: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { LRUCache } = __nccwpck_require__(3866);
      const dns = __nccwpck_require__(7578);
      const cache = new LRUCache({ max: 50 });
      const getOptions = ({
        family = 0,
        hints = dns.ADDRCONFIG,
        all = false,
        verbatim = undefined,
        ttl = 5 * 60 * 1e3,
        lookup = dns.lookup,
      }) => ({
        hints,
        lookup: (hostname, ...args) => {
          const callback = args.pop();
          const lookupOptions = args[0] ?? {};
          const options = {
            family,
            hints,
            all,
            verbatim,
            ...(typeof lookupOptions === "number"
              ? { family: lookupOptions }
              : lookupOptions),
          };
          const key = JSON.stringify({ hostname, ...options });
          if (cache.has(key)) {
            const cached = cache.get(key);
            return process.nextTick(callback, null, ...cached);
          }
          lookup(hostname, options, (err, ...result) => {
            if (err) {
              return callback(err);
            }
            cache.set(key, result, { ttl });
            return callback(null, ...result);
          });
        },
      });
      module.exports = { cache, getOptions };
    },
    4724: (module) => {
      "use strict";
      class InvalidProxyProtocolError extends Error {
        constructor(url) {
          super(
            `Invalid protocol \`${url.protocol}\` connecting to proxy \`${url.host}\``,
          );
          this.code = "EINVALIDPROXY";
          this.proxy = url;
        }
      }
      class ConnectionTimeoutError extends Error {
        constructor(host) {
          super(`Timeout connecting to host \`${host}\``);
          this.code = "ECONNECTIONTIMEOUT";
          this.host = host;
        }
      }
      class IdleTimeoutError extends Error {
        constructor(host) {
          super(`Idle timeout reached for host \`${host}\``);
          this.code = "EIDLETIMEOUT";
          this.host = host;
        }
      }
      class ResponseTimeoutError extends Error {
        constructor(request, proxy) {
          let msg = "Response timeout ";
          if (proxy) {
            msg += `from proxy \`${proxy.host}\` `;
          }
          msg += `connecting to host \`${request.host}\``;
          super(msg);
          this.code = "ERESPONSETIMEOUT";
          this.proxy = proxy;
          this.request = request;
        }
      }
      class TransferTimeoutError extends Error {
        constructor(request, proxy) {
          let msg = "Transfer timeout ";
          if (proxy) {
            msg += `from proxy \`${proxy.host}\` `;
          }
          msg += `for \`${request.host}\``;
          super(msg);
          this.code = "ETRANSFERTIMEOUT";
          this.proxy = proxy;
          this.request = request;
        }
      }
      module.exports = {
        InvalidProxyProtocolError,
        ConnectionTimeoutError,
        IdleTimeoutError,
        ResponseTimeoutError,
        TransferTimeoutError,
      };
    },
    9907: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { LRUCache } = __nccwpck_require__(3866);
      const { normalizeOptions, cacheOptions } = __nccwpck_require__(1709);
      const { getProxy, proxyCache } = __nccwpck_require__(8443);
      const dns = __nccwpck_require__(2292);
      const Agent = __nccwpck_require__(8520);
      const agentCache = new LRUCache({ max: 20 });
      const getAgent = (url, { agent, proxy, noProxy, ...options } = {}) => {
        if (agent != null) {
          return agent;
        }
        url = new URL(url);
        const proxyForUrl = getProxy(url, { proxy, noProxy });
        const normalizedOptions = {
          ...normalizeOptions(options),
          proxy: proxyForUrl,
        };
        const cacheKey = cacheOptions({
          ...normalizedOptions,
          secureEndpoint: url.protocol === "https:",
        });
        if (agentCache.has(cacheKey)) {
          return agentCache.get(cacheKey);
        }
        const newAgent = new Agent(normalizedOptions);
        agentCache.set(cacheKey, newAgent);
        return newAgent;
      };
      module.exports = {
        getAgent,
        Agent,
        HttpAgent: Agent,
        HttpsAgent: Agent,
        cache: {
          proxy: proxyCache,
          agent: agentCache,
          dns: dns.cache,
          clear: () => {
            proxyCache.clear();
            agentCache.clear();
            dns.cache.clear();
          },
        },
      };
    },
    1709: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const dns = __nccwpck_require__(2292);
      const normalizeOptions = (opts) => {
        const family = parseInt(opts.family ?? "0", 10);
        const keepAlive = opts.keepAlive ?? true;
        const normalized = {
          keepAliveMsecs: keepAlive ? 1e3 : undefined,
          maxSockets: opts.maxSockets ?? 15,
          maxTotalSockets: Infinity,
          maxFreeSockets: keepAlive ? 256 : undefined,
          scheduling: "fifo",
          ...opts,
          family,
          keepAlive,
          timeouts: {
            idle: opts.timeout ?? 0,
            connection: 0,
            response: 0,
            transfer: 0,
            ...opts.timeouts,
          },
          ...dns.getOptions({ family, ...opts.dns }),
        };
        delete normalized.timeout;
        return normalized;
      };
      const createKey = (obj) => {
        let key = "";
        const sorted = Object.entries(obj).sort((a, b) => a[0] - b[0]);
        for (let [k, v] of sorted) {
          if (v == null) {
            v = "null";
          } else if (v instanceof URL) {
            v = v.toString();
          } else if (typeof v === "object") {
            v = createKey(v);
          }
          key += `${k}:${v}:`;
        }
        return key;
      };
      const cacheOptions = ({ secureEndpoint, ...options }) =>
        createKey({
          secureEndpoint: !!secureEndpoint,
          family: options.family,
          hints: options.hints,
          localAddress: options.localAddress,
          strictSsl: secureEndpoint ? !!options.rejectUnauthorized : false,
          ca: secureEndpoint ? options.ca : null,
          cert: secureEndpoint ? options.cert : null,
          key: secureEndpoint ? options.key : null,
          keepAlive: options.keepAlive,
          keepAliveMsecs: options.keepAliveMsecs,
          maxSockets: options.maxSockets,
          maxTotalSockets: options.maxTotalSockets,
          maxFreeSockets: options.maxFreeSockets,
          scheduling: options.scheduling,
          timeouts: options.timeouts,
          proxy: options.proxy,
        });
      module.exports = { normalizeOptions, cacheOptions };
    },
    8443: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { HttpProxyAgent } = __nccwpck_require__(3764);
      const { HttpsProxyAgent } = __nccwpck_require__(7219);
      const { SocksProxyAgent } = __nccwpck_require__(5038);
      const { LRUCache } = __nccwpck_require__(3866);
      const { InvalidProxyProtocolError } = __nccwpck_require__(4724);
      const PROXY_CACHE = new LRUCache({ max: 20 });
      const SOCKS_PROTOCOLS = new Set(SocksProxyAgent.protocols);
      const PROXY_ENV_KEYS = new Set([
        "https_proxy",
        "http_proxy",
        "proxy",
        "no_proxy",
      ]);
      const PROXY_ENV = Object.entries(process.env).reduce(
        (acc, [key, value]) => {
          key = key.toLowerCase();
          if (PROXY_ENV_KEYS.has(key)) {
            acc[key] = value;
          }
          return acc;
        },
        {},
      );
      const getProxyAgent = (url) => {
        url = new URL(url);
        const protocol = url.protocol.slice(0, -1);
        if (SOCKS_PROTOCOLS.has(protocol)) {
          return SocksProxyAgent;
        }
        if (protocol === "https" || protocol === "http") {
          return [HttpProxyAgent, HttpsProxyAgent];
        }
        throw new InvalidProxyProtocolError(url);
      };
      const isNoProxy = (url, noProxy) => {
        if (typeof noProxy === "string") {
          noProxy = noProxy
            .split(",")
            .map((p) => p.trim())
            .filter(Boolean);
        }
        if (!noProxy || !noProxy.length) {
          return false;
        }
        const hostSegments = url.hostname.split(".").reverse();
        return noProxy.some((no) => {
          const noSegments = no.split(".").filter(Boolean).reverse();
          if (!noSegments.length) {
            return false;
          }
          for (let i = 0; i < noSegments.length; i++) {
            if (hostSegments[i] !== noSegments[i]) {
              return false;
            }
          }
          return true;
        });
      };
      const getProxy = (url, { proxy, noProxy }) => {
        url = new URL(url);
        if (!proxy) {
          proxy =
            url.protocol === "https:"
              ? PROXY_ENV.https_proxy
              : PROXY_ENV.https_proxy ||
                PROXY_ENV.http_proxy ||
                PROXY_ENV.proxy;
        }
        if (!noProxy) {
          noProxy = PROXY_ENV.no_proxy;
        }
        if (!proxy || isNoProxy(url, noProxy)) {
          return null;
        }
        return new URL(proxy);
      };
      module.exports = { getProxyAgent, getProxy, proxyCache: PROXY_CACHE };
    },
    8217: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const matchers = __nccwpck_require__(5131);
      const { redactUrlPassword } = __nccwpck_require__(766);
      const REPLACE = "***";
      const redact = (value) => {
        if (typeof value !== "string" || !value) {
          return value;
        }
        return redactUrlPassword(value, REPLACE)
          .replace(matchers.NPM_SECRET.pattern, `npm_${REPLACE}`)
          .replace(matchers.UUID.pattern, REPLACE);
      };
      const splitAndRedact = (str) => {
        const splitChars = /[\s=]/g;
        let match = null;
        let result = "";
        let index = 0;
        while ((match = splitChars.exec(str))) {
          result += redact(str.slice(index, match.index)) + match[0];
          index = splitChars.lastIndex;
        }
        return result + redact(str.slice(index));
      };
      const redactLog = (arg) => {
        if (typeof arg === "string") {
          return splitAndRedact(arg);
        } else if (Array.isArray(arg)) {
          return arg.map((a) =>
            typeof a === "string" ? splitAndRedact(a) : a,
          );
        }
        return arg;
      };
      module.exports = { redact, redactLog };
    },
    5131: (module) => {
      const TYPE_REGEX = "regex";
      const TYPE_URL = "url";
      const TYPE_PATH = "path";
      const NPM_SECRET = {
        type: TYPE_REGEX,
        pattern: /\b(npms?_)[a-zA-Z0-9]{36,48}\b/gi,
        replacement: `[REDACTED_NPM_SECRET]`,
      };
      const AUTH_HEADER = {
        type: TYPE_REGEX,
        pattern: /\b(Basic\s+|Bearer\s+)[\w+=\-.]+\b/gi,
        replacement: `[REDACTED_AUTH_HEADER]`,
      };
      const JSON_WEB_TOKEN = {
        type: TYPE_REGEX,
        pattern:
          /\b[A-Za-z0-9-_]{10,}(?!\.\d+\.)\.[A-Za-z0-9-_]{3,}\.[A-Za-z0-9-_]{20,}\b/gi,
        replacement: `[REDACTED_JSON_WEB_TOKEN]`,
      };
      const UUID = {
        type: TYPE_REGEX,
        pattern:
          /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/gi,
        replacement: `[REDACTED_UUID]`,
      };
      const URL_MATCHER = {
        type: TYPE_REGEX,
        pattern: /(?:https?|ftp):\/\/[^\s/"$.?#].[^\s"]*/gi,
        replacement: "[REDACTED_URL]",
      };
      const DEEP_HEADER_AUTHORIZATION = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".headers.authorization"),
        replacement: "[REDACTED_HEADER_AUTHORIZATION]",
      };
      const DEEP_HEADER_SET_COOKIE = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".headers.set-cookie"),
        replacement: "[REDACTED_HEADER_SET_COOKIE]",
      };
      const REWRITE_REQUEST = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".request"),
        replacement: (input) => ({
          method: input?.method,
          path: input?.path,
          headers: input?.headers,
          url: input?.url,
        }),
      };
      const REWRITE_RESPONSE = {
        type: TYPE_PATH,
        predicate: ({ path }) => path.endsWith(".response"),
        replacement: (input) => ({
          data: input?.data,
          status: input?.status,
          headers: input?.headers,
        }),
      };
      module.exports = {
        TYPE_REGEX,
        TYPE_URL,
        TYPE_PATH,
        NPM_SECRET,
        AUTH_HEADER,
        JSON_WEB_TOKEN,
        UUID,
        URL_MATCHER,
        DEEP_HEADER_AUTHORIZATION,
        DEEP_HEADER_SET_COOKIE,
        REWRITE_REQUEST,
        REWRITE_RESPONSE,
      };
    },
    766: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { URL_MATCHER, TYPE_URL, TYPE_REGEX, TYPE_PATH } =
        __nccwpck_require__(5131);
      const asterisk = (length = 0) => {
        length = typeof length === "string" ? length.length : length;
        if (length < 8) {
          return "*".repeat(8);
        }
        return "*".repeat(length);
      };
      const escapeRegExp = (text) =>
        text.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, `\\$&`);
      const urlEncodeRegexGroup = (value) => {
        const decoded = decodeURIComponent(value);
        const encoded = encodeURIComponent(value);
        const union = [...new Set([encoded, decoded, value])]
          .map(escapeRegExp)
          .join("|");
        return union;
      };
      const urlEncodeRegexTag = (strings, ...values) => {
        let pattern = "";
        for (let i = 0; i < values.length; i++) {
          pattern += strings[i] + `(${urlEncodeRegexGroup(values[i])})`;
        }
        pattern += strings[strings.length - 1];
        return new RegExp(pattern);
      };
      const redactUrlHostnameMatcher = ({ hostname, replacement } = {}) => ({
        type: TYPE_URL,
        predicate: ({ url }) => url.hostname === hostname,
        pattern: ({ url }) =>
          urlEncodeRegexTag`(^${url.protocol}//${url.username}:.+@)?${url.hostname}`,
        replacement: `$1${replacement || asterisk()}`,
      });
      const redactUrlSearchParamsMatcher = ({ param, replacement } = {}) => ({
        type: TYPE_URL,
        predicate: ({ url }) => url.searchParams.has(param),
        pattern: ({ url }) =>
          urlEncodeRegexTag`(${param}=)${url.searchParams.get(param)}`,
        replacement: `$1${replacement || asterisk()}`,
      });
      const redactUrlPasswordMatcher = ({ replacement } = {}) => ({
        type: TYPE_URL,
        predicate: ({ url }) => url.password,
        pattern: ({ url }) =>
          urlEncodeRegexTag`(^${url.protocol}//${url.username}:)${url.password}`,
        replacement: `$1${replacement || asterisk()}`,
      });
      const redactUrlReplacement =
        (...matchers) =>
        (subValue) => {
          try {
            const url = new URL(subValue);
            return redactMatchers(...matchers)(subValue, { url });
          } catch (err) {
            return subValue;
          }
        };
      const redactUrlMatcher = (...matchers) => ({
        ...URL_MATCHER,
        replacement: redactUrlReplacement(...matchers),
      });
      const matcherFunctions = {
        [TYPE_REGEX]: (matcher) => (value) => {
          if (typeof value === "string") {
            value = value.replace(matcher.pattern, matcher.replacement);
          }
          return value;
        },
        [TYPE_URL]: (matcher) => (value, ctx) => {
          if (typeof value === "string") {
            try {
              const url = ctx?.url || new URL(value);
              const { predicate, pattern } = matcher;
              const predicateValue = predicate({ url });
              if (predicateValue) {
                value = value.replace(pattern({ url }), matcher.replacement);
              }
            } catch (_e) {
              return value;
            }
          }
          return value;
        },
        [TYPE_PATH]: (matcher) => (value, ctx) => {
          const rawPath = ctx?.path;
          const path = rawPath.join(".").toLowerCase();
          const { predicate, replacement } = matcher;
          const replace =
            typeof replacement === "function" ? replacement : () => replacement;
          const shouldRun = predicate({ rawPath, path });
          if (shouldRun) {
            value = replace(value, { rawPath, path });
          }
          return value;
        },
      };
      const redactMatcher = (matcher) =>
        matcherFunctions[matcher.type](matcher);
      const redactMatchers =
        (...matchers) =>
        (value, ctx) => {
          const flatMatchers = matchers.flat();
          return flatMatchers.reduce((result, matcher) => {
            const fn =
              typeof matcher === "function" ? matcher : redactMatcher(matcher);
            return fn(result, ctx);
          }, value);
        };
      const redactDynamicReplacement = () => (value, start) => {
        if (typeof start === "number") {
          return asterisk(value);
        }
        return start + asterisk(value.substring(start.length).length);
      };
      const redactFixedReplacement = (length) => (_value, start) => {
        if (typeof start === "number") {
          return asterisk(length);
        }
        return start + asterisk(length);
      };
      const redactUrlPassword = (value, replacement) =>
        redactMatchers(redactUrlPasswordMatcher({ replacement }))(value);
      module.exports = {
        asterisk,
        escapeRegExp,
        urlEncodeRegexGroup,
        urlEncodeRegexTag,
        redactUrlHostnameMatcher,
        redactUrlSearchParamsMatcher,
        redactUrlPasswordMatcher,
        redactUrlMatcher,
        redactUrlReplacement,
        redactDynamicReplacement,
        redactFixedReplacement,
        redactMatchers,
        redactUrlPassword,
      };
    },
    6833: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toDSSEBundle = exports.toMessageSignatureBundle = void 0;
      const protobuf_specs_1 = __nccwpck_require__(530);
      const bundle_1 = __nccwpck_require__(2712);
      function toMessageSignatureBundle(options) {
        return {
          mediaType: options.singleCertificate
            ? bundle_1.BUNDLE_V03_MEDIA_TYPE
            : bundle_1.BUNDLE_V02_MEDIA_TYPE,
          content: {
            $case: "messageSignature",
            messageSignature: {
              messageDigest: {
                algorithm: protobuf_specs_1.HashAlgorithm.SHA2_256,
                digest: options.digest,
              },
              signature: options.signature,
            },
          },
          verificationMaterial: toVerificationMaterial(options),
        };
      }
      exports.toMessageSignatureBundle = toMessageSignatureBundle;
      function toDSSEBundle(options) {
        return {
          mediaType: options.singleCertificate
            ? bundle_1.BUNDLE_V03_MEDIA_TYPE
            : bundle_1.BUNDLE_V02_MEDIA_TYPE,
          content: { $case: "dsseEnvelope", dsseEnvelope: toEnvelope(options) },
          verificationMaterial: toVerificationMaterial(options),
        };
      }
      exports.toDSSEBundle = toDSSEBundle;
      function toEnvelope(options) {
        return {
          payloadType: options.artifactType,
          payload: options.artifact,
          signatures: [toSignature(options)],
        };
      }
      function toSignature(options) {
        return { keyid: options.keyHint || "", sig: options.signature };
      }
      function toVerificationMaterial(options) {
        return {
          content: toKeyContent(options),
          tlogEntries: [],
          timestampVerificationData: { rfc3161Timestamps: [] },
        };
      }
      function toKeyContent(options) {
        if (options.certificate) {
          if (options.singleCertificate) {
            return {
              $case: "certificate",
              certificate: { rawBytes: options.certificate },
            };
          } else {
            return {
              $case: "x509CertificateChain",
              x509CertificateChain: {
                certificates: [{ rawBytes: options.certificate }],
              },
            };
          }
        } else {
          return {
            $case: "publicKey",
            publicKey: { hint: options.keyHint || "" },
          };
        }
      }
    },
    2712: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBundleWithDsseEnvelope =
        exports.isBundleWithMessageSignature =
        exports.isBundleWithPublicKey =
        exports.isBundleWithCertificateChain =
        exports.BUNDLE_V03_MEDIA_TYPE =
        exports.BUNDLE_V03_LEGACY_MEDIA_TYPE =
        exports.BUNDLE_V02_MEDIA_TYPE =
        exports.BUNDLE_V01_MEDIA_TYPE =
          void 0;
      exports.BUNDLE_V01_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle+json;version=0.1";
      exports.BUNDLE_V02_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle+json;version=0.2";
      exports.BUNDLE_V03_LEGACY_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle+json;version=0.3";
      exports.BUNDLE_V03_MEDIA_TYPE =
        "application/vnd.dev.sigstore.bundle.v0.3+json";
      function isBundleWithCertificateChain(b) {
        return b.verificationMaterial.content.$case === "x509CertificateChain";
      }
      exports.isBundleWithCertificateChain = isBundleWithCertificateChain;
      function isBundleWithPublicKey(b) {
        return b.verificationMaterial.content.$case === "publicKey";
      }
      exports.isBundleWithPublicKey = isBundleWithPublicKey;
      function isBundleWithMessageSignature(b) {
        return b.content.$case === "messageSignature";
      }
      exports.isBundleWithMessageSignature = isBundleWithMessageSignature;
      function isBundleWithDsseEnvelope(b) {
        return b.content.$case === "dsseEnvelope";
      }
      exports.isBundleWithDsseEnvelope = isBundleWithDsseEnvelope;
    },
    3802: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ValidationError = void 0;
      class ValidationError extends Error {
        constructor(message, fields) {
          super(message);
          this.fields = fields;
        }
      }
      exports.ValidationError = ValidationError;
    },
    9715: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isBundleV01 =
        exports.assertBundleV02 =
        exports.assertBundleV01 =
        exports.assertBundleLatest =
        exports.assertBundle =
        exports.envelopeToJSON =
        exports.envelopeFromJSON =
        exports.bundleToJSON =
        exports.bundleFromJSON =
        exports.ValidationError =
        exports.isBundleWithPublicKey =
        exports.isBundleWithMessageSignature =
        exports.isBundleWithDsseEnvelope =
        exports.isBundleWithCertificateChain =
        exports.BUNDLE_V03_MEDIA_TYPE =
        exports.BUNDLE_V03_LEGACY_MEDIA_TYPE =
        exports.BUNDLE_V02_MEDIA_TYPE =
        exports.BUNDLE_V01_MEDIA_TYPE =
        exports.toMessageSignatureBundle =
        exports.toDSSEBundle =
          void 0;
      var build_1 = __nccwpck_require__(6833);
      Object.defineProperty(exports, "toDSSEBundle", {
        enumerable: true,
        get: function () {
          return build_1.toDSSEBundle;
        },
      });
      Object.defineProperty(exports, "toMessageSignatureBundle", {
        enumerable: true,
        get: function () {
          return build_1.toMessageSignatureBundle;
        },
      });
      var bundle_1 = __nccwpck_require__(2712);
      Object.defineProperty(exports, "BUNDLE_V01_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V01_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "BUNDLE_V02_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V02_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "BUNDLE_V03_LEGACY_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V03_LEGACY_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "BUNDLE_V03_MEDIA_TYPE", {
        enumerable: true,
        get: function () {
          return bundle_1.BUNDLE_V03_MEDIA_TYPE;
        },
      });
      Object.defineProperty(exports, "isBundleWithCertificateChain", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithCertificateChain;
        },
      });
      Object.defineProperty(exports, "isBundleWithDsseEnvelope", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithDsseEnvelope;
        },
      });
      Object.defineProperty(exports, "isBundleWithMessageSignature", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithMessageSignature;
        },
      });
      Object.defineProperty(exports, "isBundleWithPublicKey", {
        enumerable: true,
        get: function () {
          return bundle_1.isBundleWithPublicKey;
        },
      });
      var error_1 = __nccwpck_require__(3802);
      Object.defineProperty(exports, "ValidationError", {
        enumerable: true,
        get: function () {
          return error_1.ValidationError;
        },
      });
      var serialized_1 = __nccwpck_require__(9875);
      Object.defineProperty(exports, "bundleFromJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.bundleFromJSON;
        },
      });
      Object.defineProperty(exports, "bundleToJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.bundleToJSON;
        },
      });
      Object.defineProperty(exports, "envelopeFromJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.envelopeFromJSON;
        },
      });
      Object.defineProperty(exports, "envelopeToJSON", {
        enumerable: true,
        get: function () {
          return serialized_1.envelopeToJSON;
        },
      });
      var validate_1 = __nccwpck_require__(9599);
      Object.defineProperty(exports, "assertBundle", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundle;
        },
      });
      Object.defineProperty(exports, "assertBundleLatest", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundleLatest;
        },
      });
      Object.defineProperty(exports, "assertBundleV01", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundleV01;
        },
      });
      Object.defineProperty(exports, "assertBundleV02", {
        enumerable: true,
        get: function () {
          return validate_1.assertBundleV02;
        },
      });
      Object.defineProperty(exports, "isBundleV01", {
        enumerable: true,
        get: function () {
          return validate_1.isBundleV01;
        },
      });
    },
    9875: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.envelopeToJSON =
        exports.envelopeFromJSON =
        exports.bundleToJSON =
        exports.bundleFromJSON =
          void 0;
      const protobuf_specs_1 = __nccwpck_require__(530);
      const bundle_1 = __nccwpck_require__(2712);
      const validate_1 = __nccwpck_require__(9599);
      const bundleFromJSON = (obj) => {
        const bundle = protobuf_specs_1.Bundle.fromJSON(obj);
        switch (bundle.mediaType) {
          case bundle_1.BUNDLE_V01_MEDIA_TYPE:
            (0, validate_1.assertBundleV01)(bundle);
            break;
          case bundle_1.BUNDLE_V02_MEDIA_TYPE:
            (0, validate_1.assertBundleV02)(bundle);
            break;
          default:
            (0, validate_1.assertBundleLatest)(bundle);
            break;
        }
        return bundle;
      };
      exports.bundleFromJSON = bundleFromJSON;
      const bundleToJSON = (bundle) => protobuf_specs_1.Bundle.toJSON(bundle);
      exports.bundleToJSON = bundleToJSON;
      const envelopeFromJSON = (obj) => protobuf_specs_1.Envelope.fromJSON(obj);
      exports.envelopeFromJSON = envelopeFromJSON;
      const envelopeToJSON = (envelope) =>
        protobuf_specs_1.Envelope.toJSON(envelope);
      exports.envelopeToJSON = envelopeToJSON;
    },
    9599: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assertBundleLatest =
        exports.assertBundleV02 =
        exports.isBundleV01 =
        exports.assertBundleV01 =
        exports.assertBundle =
          void 0;
      const error_1 = __nccwpck_require__(3802);
      function assertBundle(b) {
        const invalidValues = validateBundleBase(b);
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError("invalid bundle", invalidValues);
        }
      }
      exports.assertBundle = assertBundle;
      function assertBundleV01(b) {
        const invalidValues = [];
        invalidValues.push(...validateBundleBase(b));
        invalidValues.push(...validateInclusionPromise(b));
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError(
            "invalid v0.1 bundle",
            invalidValues,
          );
        }
      }
      exports.assertBundleV01 = assertBundleV01;
      function isBundleV01(b) {
        try {
          assertBundleV01(b);
          return true;
        } catch (e) {
          return false;
        }
      }
      exports.isBundleV01 = isBundleV01;
      function assertBundleV02(b) {
        const invalidValues = [];
        invalidValues.push(...validateBundleBase(b));
        invalidValues.push(...validateInclusionProof(b));
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError(
            "invalid v0.2 bundle",
            invalidValues,
          );
        }
      }
      exports.assertBundleV02 = assertBundleV02;
      function assertBundleLatest(b) {
        const invalidValues = [];
        invalidValues.push(...validateBundleBase(b));
        invalidValues.push(...validateInclusionProof(b));
        invalidValues.push(...validateNoCertificateChain(b));
        if (invalidValues.length > 0) {
          throw new error_1.ValidationError("invalid bundle", invalidValues);
        }
      }
      exports.assertBundleLatest = assertBundleLatest;
      function validateBundleBase(b) {
        const invalidValues = [];
        if (
          b.mediaType === undefined ||
          (!b.mediaType.match(
            /^application\/vnd\.dev\.sigstore\.bundle\+json;version=\d\.\d/,
          ) &&
            !b.mediaType.match(
              /^application\/vnd\.dev\.sigstore\.bundle\.v\d\.\d\+json/,
            ))
        ) {
          invalidValues.push("mediaType");
        }
        if (b.content === undefined) {
          invalidValues.push("content");
        } else {
          switch (b.content.$case) {
            case "messageSignature":
              if (b.content.messageSignature.messageDigest === undefined) {
                invalidValues.push("content.messageSignature.messageDigest");
              } else {
                if (
                  b.content.messageSignature.messageDigest.digest.length === 0
                ) {
                  invalidValues.push(
                    "content.messageSignature.messageDigest.digest",
                  );
                }
              }
              if (b.content.messageSignature.signature.length === 0) {
                invalidValues.push("content.messageSignature.signature");
              }
              break;
            case "dsseEnvelope":
              if (b.content.dsseEnvelope.payload.length === 0) {
                invalidValues.push("content.dsseEnvelope.payload");
              }
              if (b.content.dsseEnvelope.signatures.length !== 1) {
                invalidValues.push("content.dsseEnvelope.signatures");
              } else {
                if (b.content.dsseEnvelope.signatures[0].sig.length === 0) {
                  invalidValues.push("content.dsseEnvelope.signatures[0].sig");
                }
              }
              break;
          }
        }
        if (b.verificationMaterial === undefined) {
          invalidValues.push("verificationMaterial");
        } else {
          if (b.verificationMaterial.content === undefined) {
            invalidValues.push("verificationMaterial.content");
          } else {
            switch (b.verificationMaterial.content.$case) {
              case "x509CertificateChain":
                if (
                  b.verificationMaterial.content.x509CertificateChain
                    .certificates.length === 0
                ) {
                  invalidValues.push(
                    "verificationMaterial.content.x509CertificateChain.certificates",
                  );
                }
                b.verificationMaterial.content.x509CertificateChain.certificates.forEach(
                  (cert, i) => {
                    if (cert.rawBytes.length === 0) {
                      invalidValues.push(
                        `verificationMaterial.content.x509CertificateChain.certificates[${i}].rawBytes`,
                      );
                    }
                  },
                );
                break;
              case "certificate":
                if (
                  b.verificationMaterial.content.certificate.rawBytes.length ===
                  0
                ) {
                  invalidValues.push(
                    "verificationMaterial.content.certificate.rawBytes",
                  );
                }
                break;
            }
          }
          if (b.verificationMaterial.tlogEntries === undefined) {
            invalidValues.push("verificationMaterial.tlogEntries");
          } else {
            if (b.verificationMaterial.tlogEntries.length > 0) {
              b.verificationMaterial.tlogEntries.forEach((entry, i) => {
                if (entry.logId === undefined) {
                  invalidValues.push(
                    `verificationMaterial.tlogEntries[${i}].logId`,
                  );
                }
                if (entry.kindVersion === undefined) {
                  invalidValues.push(
                    `verificationMaterial.tlogEntries[${i}].kindVersion`,
                  );
                }
              });
            }
          }
        }
        return invalidValues;
      }
      function validateInclusionPromise(b) {
        const invalidValues = [];
        if (
          b.verificationMaterial &&
          b.verificationMaterial.tlogEntries?.length > 0
        ) {
          b.verificationMaterial.tlogEntries.forEach((entry, i) => {
            if (entry.inclusionPromise === undefined) {
              invalidValues.push(
                `verificationMaterial.tlogEntries[${i}].inclusionPromise`,
              );
            }
          });
        }
        return invalidValues;
      }
      function validateInclusionProof(b) {
        const invalidValues = [];
        if (
          b.verificationMaterial &&
          b.verificationMaterial.tlogEntries?.length > 0
        ) {
          b.verificationMaterial.tlogEntries.forEach((entry, i) => {
            if (entry.inclusionProof === undefined) {
              invalidValues.push(
                `verificationMaterial.tlogEntries[${i}].inclusionProof`,
              );
            } else {
              if (entry.inclusionProof.checkpoint === undefined) {
                invalidValues.push(
                  `verificationMaterial.tlogEntries[${i}].inclusionProof.checkpoint`,
                );
              }
            }
          });
        }
        return invalidValues;
      }
      function validateNoCertificateChain(b) {
        const invalidValues = [];
        if (b.verificationMaterial?.content?.$case === "x509CertificateChain") {
          invalidValues.push("verificationMaterial.content.$case");
        }
        return invalidValues;
      }
    },
    6136: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1TypeError = exports.ASN1ParseError = void 0;
      class ASN1ParseError extends Error {}
      exports.ASN1ParseError = ASN1ParseError;
      class ASN1TypeError extends Error {}
      exports.ASN1TypeError = ASN1TypeError;
    },
    4095: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1Obj = void 0;
      var obj_1 = __nccwpck_require__(2988);
      Object.defineProperty(exports, "ASN1Obj", {
        enumerable: true,
        get: function () {
          return obj_1.ASN1Obj;
        },
      });
    },
    5088: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeLength = exports.decodeLength = void 0;
      const error_1 = __nccwpck_require__(6136);
      function decodeLength(stream) {
        const buf = stream.getUint8();
        if ((buf & 128) === 0) {
          return buf;
        }
        const byteCount = buf & 127;
        if (byteCount > 6) {
          throw new error_1.ASN1ParseError("length exceeds 6 byte limit");
        }
        let len = 0;
        for (let i = 0; i < byteCount; i++) {
          len = len * 256 + stream.getUint8();
        }
        if (len === 0) {
          throw new error_1.ASN1ParseError(
            "indefinite length encoding not supported",
          );
        }
        return len;
      }
      exports.decodeLength = decodeLength;
      function encodeLength(len) {
        if (len < 128) {
          return Buffer.from([len]);
        }
        let val = BigInt(len);
        const bytes = [];
        while (val > 0n) {
          bytes.unshift(Number(val & 255n));
          val = val >> 8n;
        }
        return Buffer.from([128 | bytes.length, ...bytes]);
      }
      exports.encodeLength = encodeLength;
    },
    2988: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1Obj = void 0;
      const stream_1 = __nccwpck_require__(2283);
      const error_1 = __nccwpck_require__(6136);
      const length_1 = __nccwpck_require__(5088);
      const parse_1 = __nccwpck_require__(3947);
      const tag_1 = __nccwpck_require__(3725);
      class ASN1Obj {
        constructor(tag, value, subs) {
          this.tag = tag;
          this.value = value;
          this.subs = subs;
        }
        static parseBuffer(buf) {
          return parseStream(new stream_1.ByteStream(buf));
        }
        toDER() {
          const valueStream = new stream_1.ByteStream();
          if (this.subs.length > 0) {
            for (const sub of this.subs) {
              valueStream.appendView(sub.toDER());
            }
          } else {
            valueStream.appendView(this.value);
          }
          const value = valueStream.buffer;
          const obj = new stream_1.ByteStream();
          obj.appendChar(this.tag.toDER());
          obj.appendView((0, length_1.encodeLength)(value.length));
          obj.appendView(value);
          return obj.buffer;
        }
        toBoolean() {
          if (!this.tag.isBoolean()) {
            throw new error_1.ASN1TypeError("not a boolean");
          }
          return (0, parse_1.parseBoolean)(this.value);
        }
        toInteger() {
          if (!this.tag.isInteger()) {
            throw new error_1.ASN1TypeError("not an integer");
          }
          return (0, parse_1.parseInteger)(this.value);
        }
        toOID() {
          if (!this.tag.isOID()) {
            throw new error_1.ASN1TypeError("not an OID");
          }
          return (0, parse_1.parseOID)(this.value);
        }
        toDate() {
          switch (true) {
            case this.tag.isUTCTime():
              return (0, parse_1.parseTime)(this.value, true);
            case this.tag.isGeneralizedTime():
              return (0, parse_1.parseTime)(this.value, false);
            default:
              throw new error_1.ASN1TypeError("not a date");
          }
        }
        toBitString() {
          if (!this.tag.isBitString()) {
            throw new error_1.ASN1TypeError("not a bit string");
          }
          return (0, parse_1.parseBitString)(this.value);
        }
      }
      exports.ASN1Obj = ASN1Obj;
      function parseStream(stream) {
        const tag = new tag_1.ASN1Tag(stream.getUint8());
        const len = (0, length_1.decodeLength)(stream);
        const value = stream.slice(stream.position, len);
        const start = stream.position;
        let subs = [];
        if (tag.constructed) {
          subs = collectSubs(stream, len);
        } else if (tag.isOctetString()) {
          try {
            subs = collectSubs(stream, len);
          } catch (e) {}
        }
        if (subs.length === 0) {
          stream.seek(start + len);
        }
        return new ASN1Obj(tag, value, subs);
      }
      function collectSubs(stream, len) {
        const end = stream.position + len;
        if (end > stream.length) {
          throw new error_1.ASN1ParseError("invalid length");
        }
        const subs = [];
        while (stream.position < end) {
          subs.push(parseStream(stream));
        }
        if (stream.position !== end) {
          throw new error_1.ASN1ParseError("invalid length");
        }
        return subs;
      }
    },
    3947: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseBitString =
        exports.parseBoolean =
        exports.parseOID =
        exports.parseTime =
        exports.parseStringASCII =
        exports.parseInteger =
          void 0;
      const RE_TIME_SHORT_YEAR =
        /^(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d{3})?Z$/;
      const RE_TIME_LONG_YEAR =
        /^(\d{4})(\d{2})(\d{2})(\d{2})(\d{2})(\d{2})(\.\d{3})?Z$/;
      function parseInteger(buf) {
        let pos = 0;
        const end = buf.length;
        let val = buf[pos];
        const neg = val > 127;
        const pad = neg ? 255 : 0;
        while (val == pad && ++pos < end) {
          val = buf[pos];
        }
        const len = end - pos;
        if (len === 0) return BigInt(neg ? -1 : 0);
        val = neg ? val - 256 : val;
        let n = BigInt(val);
        for (let i = pos + 1; i < end; ++i) {
          n = n * BigInt(256) + BigInt(buf[i]);
        }
        return n;
      }
      exports.parseInteger = parseInteger;
      function parseStringASCII(buf) {
        return buf.toString("ascii");
      }
      exports.parseStringASCII = parseStringASCII;
      function parseTime(buf, shortYear) {
        const timeStr = parseStringASCII(buf);
        const m = shortYear
          ? RE_TIME_SHORT_YEAR.exec(timeStr)
          : RE_TIME_LONG_YEAR.exec(timeStr);
        if (!m) {
          throw new Error("invalid time");
        }
        if (shortYear) {
          let year = Number(m[1]);
          year += year >= 50 ? 1900 : 2e3;
          m[1] = year.toString();
        }
        return new Date(`${m[1]}-${m[2]}-${m[3]}T${m[4]}:${m[5]}:${m[6]}Z`);
      }
      exports.parseTime = parseTime;
      function parseOID(buf) {
        let pos = 0;
        const end = buf.length;
        let n = buf[pos++];
        const first = Math.floor(n / 40);
        const second = n % 40;
        let oid = `${first}.${second}`;
        let val = 0;
        for (; pos < end; ++pos) {
          n = buf[pos];
          val = (val << 7) + (n & 127);
          if ((n & 128) === 0) {
            oid += `.${val}`;
            val = 0;
          }
        }
        return oid;
      }
      exports.parseOID = parseOID;
      function parseBoolean(buf) {
        return buf[0] !== 0;
      }
      exports.parseBoolean = parseBoolean;
      function parseBitString(buf) {
        const unused = buf[0];
        const start = 1;
        const end = buf.length;
        const bits = [];
        for (let i = start; i < end; ++i) {
          const byte = buf[i];
          const skip = i === end - 1 ? unused : 0;
          for (let j = 7; j >= skip; --j) {
            bits.push((byte >> j) & 1);
          }
        }
        return bits;
      }
      exports.parseBitString = parseBitString;
    },
    3725: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ASN1Tag = void 0;
      const error_1 = __nccwpck_require__(6136);
      const UNIVERSAL_TAG = {
        BOOLEAN: 1,
        INTEGER: 2,
        BIT_STRING: 3,
        OCTET_STRING: 4,
        OBJECT_IDENTIFIER: 6,
        SEQUENCE: 16,
        SET: 17,
        PRINTABLE_STRING: 19,
        UTC_TIME: 23,
        GENERALIZED_TIME: 24,
      };
      const TAG_CLASS = {
        UNIVERSAL: 0,
        APPLICATION: 1,
        CONTEXT_SPECIFIC: 2,
        PRIVATE: 3,
      };
      class ASN1Tag {
        constructor(enc) {
          this.number = enc & 31;
          this.constructed = (enc & 32) === 32;
          this.class = enc >> 6;
          if (this.number === 31) {
            throw new error_1.ASN1ParseError("long form tags not supported");
          }
          if (this.class === TAG_CLASS.UNIVERSAL && this.number === 0) {
            throw new error_1.ASN1ParseError("unsupported tag 0x00");
          }
        }
        isUniversal() {
          return this.class === TAG_CLASS.UNIVERSAL;
        }
        isContextSpecific(num) {
          const res = this.class === TAG_CLASS.CONTEXT_SPECIFIC;
          return num !== undefined ? res && this.number === num : res;
        }
        isBoolean() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.BOOLEAN;
        }
        isInteger() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.INTEGER;
        }
        isBitString() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.BIT_STRING;
        }
        isOctetString() {
          return (
            this.isUniversal() && this.number === UNIVERSAL_TAG.OCTET_STRING
          );
        }
        isOID() {
          return (
            this.isUniversal() &&
            this.number === UNIVERSAL_TAG.OBJECT_IDENTIFIER
          );
        }
        isUTCTime() {
          return this.isUniversal() && this.number === UNIVERSAL_TAG.UTC_TIME;
        }
        isGeneralizedTime() {
          return (
            this.isUniversal() && this.number === UNIVERSAL_TAG.GENERALIZED_TIME
          );
        }
        toDER() {
          return this.number | (this.constructed ? 32 : 0) | (this.class << 6);
        }
      }
      exports.ASN1Tag = ASN1Tag;
    },
    3914: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.bufferEqual =
        exports.verify =
        exports.hash =
        exports.digest =
        exports.createPublicKey =
          void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const SHA256_ALGORITHM = "sha256";
      function createPublicKey(key, type = "spki") {
        if (typeof key === "string") {
          return crypto_1.default.createPublicKey(key);
        } else {
          return crypto_1.default.createPublicKey({ key, format: "der", type });
        }
      }
      exports.createPublicKey = createPublicKey;
      function digest(algorithm, ...data) {
        const hash = crypto_1.default.createHash(algorithm);
        for (const d of data) {
          hash.update(d);
        }
        return hash.digest();
      }
      exports.digest = digest;
      function hash(...data) {
        const hash = crypto_1.default.createHash(SHA256_ALGORITHM);
        for (const d of data) {
          hash.update(d);
        }
        return hash.digest();
      }
      exports.hash = hash;
      function verify(data, key, signature, algorithm) {
        try {
          return crypto_1.default.verify(algorithm, data, key, signature);
        } catch (e) {
          return false;
        }
      }
      exports.verify = verify;
      function bufferEqual(a, b) {
        try {
          return crypto_1.default.timingSafeEqual(a, b);
        } catch {
          return false;
        }
      }
      exports.bufferEqual = bufferEqual;
    },
    9892: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.preAuthEncoding = void 0;
      const PAE_PREFIX = "DSSEv1";
      function preAuthEncoding(payloadType, payload) {
        const prefix = [
          PAE_PREFIX,
          payloadType.length,
          payloadType,
          payload.length,
          "",
        ].join(" ");
        return Buffer.concat([Buffer.from(prefix, "ascii"), payload]);
      }
      exports.preAuthEncoding = preAuthEncoding;
    },
    7496: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.base64Decode = exports.base64Encode = void 0;
      const BASE64_ENCODING = "base64";
      const UTF8_ENCODING = "utf-8";
      function base64Encode(str) {
        return Buffer.from(str, UTF8_ENCODING).toString(BASE64_ENCODING);
      }
      exports.base64Encode = base64Encode;
      function base64Decode(str) {
        return Buffer.from(str, BASE64_ENCODING).toString(UTF8_ENCODING);
      }
      exports.base64Decode = base64Decode;
    },
    3352: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509SCTExtension =
        exports.X509Certificate =
        exports.EXTENSION_OID_SCT =
        exports.ByteStream =
        exports.RFC3161Timestamp =
        exports.pem =
        exports.json =
        exports.encoding =
        exports.dsse =
        exports.crypto =
        exports.ASN1Obj =
          void 0;
      var asn1_1 = __nccwpck_require__(4095);
      Object.defineProperty(exports, "ASN1Obj", {
        enumerable: true,
        get: function () {
          return asn1_1.ASN1Obj;
        },
      });
      exports.crypto = __importStar(__nccwpck_require__(3914));
      exports.dsse = __importStar(__nccwpck_require__(9892));
      exports.encoding = __importStar(__nccwpck_require__(7496));
      exports.json = __importStar(__nccwpck_require__(9022));
      exports.pem = __importStar(__nccwpck_require__(5225));
      var rfc3161_1 = __nccwpck_require__(7411);
      Object.defineProperty(exports, "RFC3161Timestamp", {
        enumerable: true,
        get: function () {
          return rfc3161_1.RFC3161Timestamp;
        },
      });
      var stream_1 = __nccwpck_require__(2283);
      Object.defineProperty(exports, "ByteStream", {
        enumerable: true,
        get: function () {
          return stream_1.ByteStream;
        },
      });
      var x509_1 = __nccwpck_require__(5500);
      Object.defineProperty(exports, "EXTENSION_OID_SCT", {
        enumerable: true,
        get: function () {
          return x509_1.EXTENSION_OID_SCT;
        },
      });
      Object.defineProperty(exports, "X509Certificate", {
        enumerable: true,
        get: function () {
          return x509_1.X509Certificate;
        },
      });
      Object.defineProperty(exports, "X509SCTExtension", {
        enumerable: true,
        get: function () {
          return x509_1.X509SCTExtension;
        },
      });
    },
    9022: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.canonicalize = void 0;
      function canonicalize(object) {
        let buffer = "";
        if (
          object === null ||
          typeof object !== "object" ||
          object.toJSON != null
        ) {
          buffer += JSON.stringify(object);
        } else if (Array.isArray(object)) {
          buffer += "[";
          let first = true;
          object.forEach((element) => {
            if (!first) {
              buffer += ",";
            }
            first = false;
            buffer += canonicalize(element);
          });
          buffer += "]";
        } else {
          buffer += "{";
          let first = true;
          Object.keys(object)
            .sort()
            .forEach((property) => {
              if (!first) {
                buffer += ",";
              }
              first = false;
              buffer += JSON.stringify(property);
              buffer += ":";
              buffer += canonicalize(object[property]);
            });
          buffer += "}";
        }
        return buffer;
      }
      exports.canonicalize = canonicalize;
    },
    5960: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SHA2_HASH_ALGOS = exports.ECDSA_SIGNATURE_ALGOS = void 0;
      exports.ECDSA_SIGNATURE_ALGOS = {
        "1.2.840.10045.4.3.1": "sha224",
        "1.2.840.10045.4.3.2": "sha256",
        "1.2.840.10045.4.3.3": "sha384",
        "1.2.840.10045.4.3.4": "sha512",
      };
      exports.SHA2_HASH_ALGOS = {
        "2.16.840.1.101.3.4.2.1": "sha256",
        "2.16.840.1.101.3.4.2.2": "sha384",
        "2.16.840.1.101.3.4.2.3": "sha512",
      };
    },
    5225: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fromDER = exports.toDER = void 0;
      const PEM_HEADER = /-----BEGIN (.*)-----/;
      const PEM_FOOTER = /-----END (.*)-----/;
      function toDER(certificate) {
        let der = "";
        certificate.split("\n").forEach((line) => {
          if (line.match(PEM_HEADER) || line.match(PEM_FOOTER)) {
            return;
          }
          der += line;
        });
        return Buffer.from(der, "base64");
      }
      exports.toDER = toDER;
      function fromDER(certificate, type = "CERTIFICATE") {
        const der = certificate.toString("base64");
        const lines = der.match(/.{1,64}/g) || "";
        return [`-----BEGIN ${type}-----`, ...lines, `-----END ${type}-----`]
          .join("\n")
          .concat("\n");
      }
      exports.fromDER = fromDER;
    },
    4526: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RFC3161TimestampVerificationError = void 0;
      class RFC3161TimestampVerificationError extends Error {}
      exports.RFC3161TimestampVerificationError =
        RFC3161TimestampVerificationError;
    },
    7411: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RFC3161Timestamp = void 0;
      var timestamp_1 = __nccwpck_require__(9180);
      Object.defineProperty(exports, "RFC3161Timestamp", {
        enumerable: true,
        get: function () {
          return timestamp_1.RFC3161Timestamp;
        },
      });
    },
    9180: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RFC3161Timestamp = void 0;
      const asn1_1 = __nccwpck_require__(4095);
      const crypto = __importStar(__nccwpck_require__(3914));
      const oid_1 = __nccwpck_require__(5960);
      const error_1 = __nccwpck_require__(4526);
      const tstinfo_1 = __nccwpck_require__(852);
      const OID_PKCS9_CONTENT_TYPE_SIGNED_DATA = "1.2.840.113549.1.7.2";
      const OID_PKCS9_CONTENT_TYPE_TSTINFO = "1.2.840.113549.1.9.16.1.4";
      const OID_PKCS9_MESSAGE_DIGEST_KEY = "1.2.840.113549.1.9.4";
      class RFC3161Timestamp {
        constructor(asn1) {
          this.root = asn1;
        }
        static parse(der) {
          const asn1 = asn1_1.ASN1Obj.parseBuffer(der);
          return new RFC3161Timestamp(asn1);
        }
        get status() {
          return this.pkiStatusInfoObj.subs[0].toInteger();
        }
        get contentType() {
          return this.contentTypeObj.toOID();
        }
        get eContentType() {
          return this.eContentTypeObj.toOID();
        }
        get signingTime() {
          return this.tstInfo.genTime;
        }
        get signerIssuer() {
          return this.signerSidObj.subs[0].value;
        }
        get signerSerialNumber() {
          return this.signerSidObj.subs[1].value;
        }
        get signerDigestAlgorithm() {
          const oid = this.signerDigestAlgorithmObj.subs[0].toOID();
          return oid_1.SHA2_HASH_ALGOS[oid];
        }
        get signatureAlgorithm() {
          const oid = this.signatureAlgorithmObj.subs[0].toOID();
          return oid_1.ECDSA_SIGNATURE_ALGOS[oid];
        }
        get signatureValue() {
          return this.signatureValueObj.value;
        }
        get tstInfo() {
          return new tstinfo_1.TSTInfo(this.eContentObj.subs[0].subs[0]);
        }
        verify(data, publicKey) {
          if (!this.timeStampTokenObj) {
            throw new error_1.RFC3161TimestampVerificationError(
              "timeStampToken is missing",
            );
          }
          if (this.contentType !== OID_PKCS9_CONTENT_TYPE_SIGNED_DATA) {
            throw new error_1.RFC3161TimestampVerificationError(
              `incorrect content type: ${this.contentType}`,
            );
          }
          if (this.eContentType !== OID_PKCS9_CONTENT_TYPE_TSTINFO) {
            throw new error_1.RFC3161TimestampVerificationError(
              `incorrect encapsulated content type: ${this.eContentType}`,
            );
          }
          this.tstInfo.verify(data);
          this.verifyMessageDigest();
          this.verifySignature(publicKey);
        }
        verifyMessageDigest() {
          const tstInfoDigest = crypto.digest(
            this.signerDigestAlgorithm,
            this.tstInfo.raw,
          );
          const expectedDigest =
            this.messageDigestAttributeObj.subs[1].subs[0].value;
          if (!crypto.bufferEqual(tstInfoDigest, expectedDigest)) {
            throw new error_1.RFC3161TimestampVerificationError(
              "signed data does not match tstInfo",
            );
          }
        }
        verifySignature(key) {
          const signedAttrs = this.signedAttrsObj.toDER();
          signedAttrs[0] = 49;
          const verified = crypto.verify(
            signedAttrs,
            key,
            this.signatureValue,
            this.signatureAlgorithm,
          );
          if (!verified) {
            throw new error_1.RFC3161TimestampVerificationError(
              "signature verification failed",
            );
          }
        }
        get pkiStatusInfoObj() {
          return this.root.subs[0];
        }
        get timeStampTokenObj() {
          return this.root.subs[1];
        }
        get contentTypeObj() {
          return this.timeStampTokenObj.subs[0];
        }
        get signedDataObj() {
          const obj = this.timeStampTokenObj.subs.find((sub) =>
            sub.tag.isContextSpecific(0),
          );
          return obj.subs[0];
        }
        get encapContentInfoObj() {
          return this.signedDataObj.subs[2];
        }
        get signerInfosObj() {
          const sd = this.signedDataObj;
          return sd.subs[sd.subs.length - 1];
        }
        get signerInfoObj() {
          return this.signerInfosObj.subs[0];
        }
        get eContentTypeObj() {
          return this.encapContentInfoObj.subs[0];
        }
        get eContentObj() {
          return this.encapContentInfoObj.subs[1];
        }
        get signedAttrsObj() {
          const signedAttrs = this.signerInfoObj.subs.find((sub) =>
            sub.tag.isContextSpecific(0),
          );
          return signedAttrs;
        }
        get messageDigestAttributeObj() {
          const messageDigest = this.signedAttrsObj.subs.find(
            (sub) =>
              sub.subs[0].tag.isOID() &&
              sub.subs[0].toOID() === OID_PKCS9_MESSAGE_DIGEST_KEY,
          );
          return messageDigest;
        }
        get signerSidObj() {
          return this.signerInfoObj.subs[1];
        }
        get signerDigestAlgorithmObj() {
          return this.signerInfoObj.subs[2];
        }
        get signatureAlgorithmObj() {
          return this.signerInfoObj.subs[4];
        }
        get signatureValueObj() {
          return this.signerInfoObj.subs[5];
        }
      }
      exports.RFC3161Timestamp = RFC3161Timestamp;
    },
    852: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSTInfo = void 0;
      const crypto = __importStar(__nccwpck_require__(3914));
      const oid_1 = __nccwpck_require__(5960);
      const error_1 = __nccwpck_require__(4526);
      class TSTInfo {
        constructor(asn1) {
          this.root = asn1;
        }
        get version() {
          return this.root.subs[0].toInteger();
        }
        get genTime() {
          return this.root.subs[4].toDate();
        }
        get messageImprintHashAlgorithm() {
          const oid = this.messageImprintObj.subs[0].subs[0].toOID();
          return oid_1.SHA2_HASH_ALGOS[oid];
        }
        get messageImprintHashedMessage() {
          return this.messageImprintObj.subs[1].value;
        }
        get raw() {
          return this.root.toDER();
        }
        verify(data) {
          const digest = crypto.digest(this.messageImprintHashAlgorithm, data);
          if (!crypto.bufferEqual(digest, this.messageImprintHashedMessage)) {
            throw new error_1.RFC3161TimestampVerificationError(
              "message imprint does not match artifact",
            );
          }
        }
        get messageImprintObj() {
          return this.root.subs[2];
        }
      }
      exports.TSTInfo = TSTInfo;
    },
    2283: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ByteStream = void 0;
      class StreamError extends Error {}
      class ByteStream {
        constructor(buffer) {
          this.start = 0;
          if (buffer) {
            this.buf = buffer;
            this.view = Buffer.from(buffer);
          } else {
            this.buf = new ArrayBuffer(0);
            this.view = Buffer.from(this.buf);
          }
        }
        get buffer() {
          return this.view.subarray(0, this.start);
        }
        get length() {
          return this.view.byteLength;
        }
        get position() {
          return this.start;
        }
        seek(position) {
          this.start = position;
        }
        slice(start, len) {
          const end = start + len;
          if (end > this.length) {
            throw new StreamError("request past end of buffer");
          }
          return this.view.subarray(start, end);
        }
        appendChar(char) {
          this.ensureCapacity(1);
          this.view[this.start] = char;
          this.start += 1;
        }
        appendUint16(num) {
          this.ensureCapacity(2);
          const value = new Uint16Array([num]);
          const view = new Uint8Array(value.buffer);
          this.view[this.start] = view[1];
          this.view[this.start + 1] = view[0];
          this.start += 2;
        }
        appendUint24(num) {
          this.ensureCapacity(3);
          const value = new Uint32Array([num]);
          const view = new Uint8Array(value.buffer);
          this.view[this.start] = view[2];
          this.view[this.start + 1] = view[1];
          this.view[this.start + 2] = view[0];
          this.start += 3;
        }
        appendView(view) {
          this.ensureCapacity(view.length);
          this.view.set(view, this.start);
          this.start += view.length;
        }
        getBlock(size) {
          if (size <= 0) {
            return Buffer.alloc(0);
          }
          if (this.start + size > this.view.length) {
            throw new Error("request past end of buffer");
          }
          const result = this.view.subarray(this.start, this.start + size);
          this.start += size;
          return result;
        }
        getUint8() {
          return this.getBlock(1)[0];
        }
        getUint16() {
          const block = this.getBlock(2);
          return (block[0] << 8) | block[1];
        }
        ensureCapacity(size) {
          if (this.start + size > this.view.byteLength) {
            const blockSize =
              ByteStream.BLOCK_SIZE + (size > ByteStream.BLOCK_SIZE ? size : 0);
            this.realloc(this.view.byteLength + blockSize);
          }
        }
        realloc(size) {
          const newArray = new ArrayBuffer(size);
          const newView = Buffer.from(newArray);
          newView.set(this.view);
          this.buf = newArray;
          this.view = newView;
        }
      }
      exports.ByteStream = ByteStream;
      ByteStream.BLOCK_SIZE = 1024;
    },
    6381: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509Certificate = exports.EXTENSION_OID_SCT = void 0;
      const asn1_1 = __nccwpck_require__(4095);
      const crypto = __importStar(__nccwpck_require__(3914));
      const oid_1 = __nccwpck_require__(5960);
      const pem = __importStar(__nccwpck_require__(5225));
      const ext_1 = __nccwpck_require__(1292);
      const EXTENSION_OID_SUBJECT_KEY_ID = "2.5.29.14";
      const EXTENSION_OID_KEY_USAGE = "2.5.29.15";
      const EXTENSION_OID_SUBJECT_ALT_NAME = "2.5.29.17";
      const EXTENSION_OID_BASIC_CONSTRAINTS = "2.5.29.19";
      const EXTENSION_OID_AUTHORITY_KEY_ID = "2.5.29.35";
      exports.EXTENSION_OID_SCT = "1.3.6.1.4.1.11129.2.4.2";
      class X509Certificate {
        constructor(asn1) {
          this.root = asn1;
        }
        static parse(cert) {
          const der = typeof cert === "string" ? pem.toDER(cert) : cert;
          const asn1 = asn1_1.ASN1Obj.parseBuffer(der);
          return new X509Certificate(asn1);
        }
        get tbsCertificate() {
          return this.tbsCertificateObj;
        }
        get version() {
          const ver = this.versionObj.subs[0].toInteger();
          return `v${(ver + BigInt(1)).toString()}`;
        }
        get serialNumber() {
          return this.serialNumberObj.value;
        }
        get notBefore() {
          return this.validityObj.subs[0].toDate();
        }
        get notAfter() {
          return this.validityObj.subs[1].toDate();
        }
        get issuer() {
          return this.issuerObj.value;
        }
        get subject() {
          return this.subjectObj.value;
        }
        get publicKey() {
          return this.subjectPublicKeyInfoObj.toDER();
        }
        get signatureAlgorithm() {
          const oid = this.signatureAlgorithmObj.subs[0].toOID();
          return oid_1.ECDSA_SIGNATURE_ALGOS[oid];
        }
        get signatureValue() {
          return this.signatureValueObj.value.subarray(1);
        }
        get subjectAltName() {
          const ext = this.extSubjectAltName;
          return ext?.uri || ext?.rfc822Name;
        }
        get extensions() {
          const extSeq = this.extensionsObj?.subs[0];
          return extSeq?.subs || [];
        }
        get extKeyUsage() {
          const ext = this.findExtension(EXTENSION_OID_KEY_USAGE);
          return ext ? new ext_1.X509KeyUsageExtension(ext) : undefined;
        }
        get extBasicConstraints() {
          const ext = this.findExtension(EXTENSION_OID_BASIC_CONSTRAINTS);
          return ext ? new ext_1.X509BasicConstraintsExtension(ext) : undefined;
        }
        get extSubjectAltName() {
          const ext = this.findExtension(EXTENSION_OID_SUBJECT_ALT_NAME);
          return ext
            ? new ext_1.X509SubjectAlternativeNameExtension(ext)
            : undefined;
        }
        get extAuthorityKeyID() {
          const ext = this.findExtension(EXTENSION_OID_AUTHORITY_KEY_ID);
          return ext ? new ext_1.X509AuthorityKeyIDExtension(ext) : undefined;
        }
        get extSubjectKeyID() {
          const ext = this.findExtension(EXTENSION_OID_SUBJECT_KEY_ID);
          return ext ? new ext_1.X509SubjectKeyIDExtension(ext) : undefined;
        }
        get extSCT() {
          const ext = this.findExtension(exports.EXTENSION_OID_SCT);
          return ext ? new ext_1.X509SCTExtension(ext) : undefined;
        }
        get isCA() {
          const ca = this.extBasicConstraints?.isCA || false;
          if (this.extKeyUsage) {
            ca && this.extKeyUsage.keyCertSign;
          }
          return ca;
        }
        extension(oid) {
          const ext = this.findExtension(oid);
          return ext ? new ext_1.X509Extension(ext) : undefined;
        }
        verify(issuerCertificate) {
          const publicKey = issuerCertificate?.publicKey || this.publicKey;
          const key = crypto.createPublicKey(publicKey);
          return crypto.verify(
            this.tbsCertificate.toDER(),
            key,
            this.signatureValue,
            this.signatureAlgorithm,
          );
        }
        validForDate(date) {
          return this.notBefore <= date && date <= this.notAfter;
        }
        equals(other) {
          return this.root.toDER().equals(other.root.toDER());
        }
        clone() {
          const der = this.root.toDER();
          const clone = Buffer.alloc(der.length);
          der.copy(clone);
          return X509Certificate.parse(clone);
        }
        findExtension(oid) {
          return this.extensions.find((ext) => ext.subs[0].toOID() === oid);
        }
        get tbsCertificateObj() {
          return this.root.subs[0];
        }
        get signatureAlgorithmObj() {
          return this.root.subs[1];
        }
        get signatureValueObj() {
          return this.root.subs[2];
        }
        get versionObj() {
          return this.tbsCertificateObj.subs[0];
        }
        get serialNumberObj() {
          return this.tbsCertificateObj.subs[1];
        }
        get issuerObj() {
          return this.tbsCertificateObj.subs[3];
        }
        get validityObj() {
          return this.tbsCertificateObj.subs[4];
        }
        get subjectObj() {
          return this.tbsCertificateObj.subs[5];
        }
        get subjectPublicKeyInfoObj() {
          return this.tbsCertificateObj.subs[6];
        }
        get extensionsObj() {
          return this.tbsCertificateObj.subs.find((sub) =>
            sub.tag.isContextSpecific(3),
          );
        }
      }
      exports.X509Certificate = X509Certificate;
    },
    1292: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509SCTExtension =
        exports.X509SubjectKeyIDExtension =
        exports.X509AuthorityKeyIDExtension =
        exports.X509SubjectAlternativeNameExtension =
        exports.X509KeyUsageExtension =
        exports.X509BasicConstraintsExtension =
        exports.X509Extension =
          void 0;
      const stream_1 = __nccwpck_require__(2283);
      const sct_1 = __nccwpck_require__(454);
      class X509Extension {
        constructor(asn1) {
          this.root = asn1;
        }
        get oid() {
          return this.root.subs[0].toOID();
        }
        get critical() {
          return this.root.subs.length === 3
            ? this.root.subs[1].toBoolean()
            : false;
        }
        get value() {
          return this.extnValueObj.value;
        }
        get valueObj() {
          return this.extnValueObj;
        }
        get extnValueObj() {
          return this.root.subs[this.root.subs.length - 1];
        }
      }
      exports.X509Extension = X509Extension;
      class X509BasicConstraintsExtension extends X509Extension {
        get isCA() {
          return this.sequence.subs[0]?.toBoolean() ?? false;
        }
        get pathLenConstraint() {
          return this.sequence.subs.length > 1
            ? this.sequence.subs[1].toInteger()
            : undefined;
        }
        get sequence() {
          return this.extnValueObj.subs[0];
        }
      }
      exports.X509BasicConstraintsExtension = X509BasicConstraintsExtension;
      class X509KeyUsageExtension extends X509Extension {
        get digitalSignature() {
          return this.bitString[0] === 1;
        }
        get keyCertSign() {
          return this.bitString[5] === 1;
        }
        get crlSign() {
          return this.bitString[6] === 1;
        }
        get bitString() {
          return this.extnValueObj.subs[0].toBitString();
        }
      }
      exports.X509KeyUsageExtension = X509KeyUsageExtension;
      class X509SubjectAlternativeNameExtension extends X509Extension {
        get rfc822Name() {
          return this.findGeneralName(1)?.value.toString("ascii");
        }
        get uri() {
          return this.findGeneralName(6)?.value.toString("ascii");
        }
        otherName(oid) {
          const otherName = this.findGeneralName(0);
          if (otherName === undefined) {
            return undefined;
          }
          const otherNameOID = otherName.subs[0].toOID();
          if (otherNameOID !== oid) {
            return undefined;
          }
          const otherNameValue = otherName.subs[1];
          return otherNameValue.subs[0].value.toString("ascii");
        }
        findGeneralName(tag) {
          return this.generalNames.find((gn) => gn.tag.isContextSpecific(tag));
        }
        get generalNames() {
          return this.extnValueObj.subs[0].subs;
        }
      }
      exports.X509SubjectAlternativeNameExtension =
        X509SubjectAlternativeNameExtension;
      class X509AuthorityKeyIDExtension extends X509Extension {
        get keyIdentifier() {
          return this.findSequenceMember(0)?.value;
        }
        findSequenceMember(tag) {
          return this.sequence.subs.find((el) => el.tag.isContextSpecific(tag));
        }
        get sequence() {
          return this.extnValueObj.subs[0];
        }
      }
      exports.X509AuthorityKeyIDExtension = X509AuthorityKeyIDExtension;
      class X509SubjectKeyIDExtension extends X509Extension {
        get keyIdentifier() {
          return this.extnValueObj.subs[0].value;
        }
      }
      exports.X509SubjectKeyIDExtension = X509SubjectKeyIDExtension;
      class X509SCTExtension extends X509Extension {
        constructor(asn1) {
          super(asn1);
        }
        get signedCertificateTimestamps() {
          const buf = this.extnValueObj.subs[0].value;
          const stream = new stream_1.ByteStream(buf);
          const end = stream.getUint16() + 2;
          const sctList = [];
          while (stream.position < end) {
            const sctLength = stream.getUint16();
            const sct = stream.getBlock(sctLength);
            sctList.push(sct_1.SignedCertificateTimestamp.parse(sct));
          }
          if (stream.position !== end) {
            throw new Error("SCT list length does not match actual length");
          }
          return sctList;
        }
      }
      exports.X509SCTExtension = X509SCTExtension;
    },
    5500: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.X509SCTExtension =
        exports.X509Certificate =
        exports.EXTENSION_OID_SCT =
          void 0;
      var cert_1 = __nccwpck_require__(6381);
      Object.defineProperty(exports, "EXTENSION_OID_SCT", {
        enumerable: true,
        get: function () {
          return cert_1.EXTENSION_OID_SCT;
        },
      });
      Object.defineProperty(exports, "X509Certificate", {
        enumerable: true,
        get: function () {
          return cert_1.X509Certificate;
        },
      });
      var ext_1 = __nccwpck_require__(1292);
      Object.defineProperty(exports, "X509SCTExtension", {
        enumerable: true,
        get: function () {
          return ext_1.X509SCTExtension;
        },
      });
    },
    454: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SignedCertificateTimestamp = void 0;
      const crypto = __importStar(__nccwpck_require__(3914));
      const stream_1 = __nccwpck_require__(2283);
      class SignedCertificateTimestamp {
        constructor(options) {
          this.version = options.version;
          this.logID = options.logID;
          this.timestamp = options.timestamp;
          this.extensions = options.extensions;
          this.hashAlgorithm = options.hashAlgorithm;
          this.signatureAlgorithm = options.signatureAlgorithm;
          this.signature = options.signature;
        }
        get datetime() {
          return new Date(Number(this.timestamp.readBigInt64BE()));
        }
        get algorithm() {
          switch (this.hashAlgorithm) {
            case 0:
              return "none";
            case 1:
              return "md5";
            case 2:
              return "sha1";
            case 3:
              return "sha224";
            case 4:
              return "sha256";
            case 5:
              return "sha384";
            case 6:
              return "sha512";
            default:
              return "unknown";
          }
        }
        verify(preCert, key) {
          const stream = new stream_1.ByteStream();
          stream.appendChar(this.version);
          stream.appendChar(0);
          stream.appendView(this.timestamp);
          stream.appendUint16(1);
          stream.appendView(preCert);
          stream.appendUint16(this.extensions.byteLength);
          if (this.extensions.byteLength > 0) {
            stream.appendView(this.extensions);
          }
          return crypto.verify(
            stream.buffer,
            key,
            this.signature,
            this.algorithm,
          );
        }
        static parse(buf) {
          const stream = new stream_1.ByteStream(buf);
          const version = stream.getUint8();
          const logID = stream.getBlock(32);
          const timestamp = stream.getBlock(8);
          const extenstionLength = stream.getUint16();
          const extensions = stream.getBlock(extenstionLength);
          const hashAlgorithm = stream.getUint8();
          const signatureAlgorithm = stream.getUint8();
          const sigLength = stream.getUint16();
          const signature = stream.getBlock(sigLength);
          if (stream.position !== buf.length) {
            throw new Error("SCT buffer length mismatch");
          }
          return new SignedCertificateTimestamp({
            version,
            logID,
            timestamp,
            extensions,
            hashAlgorithm,
            signatureAlgorithm,
            signature,
          });
        }
      }
      exports.SignedCertificateTimestamp = SignedCertificateTimestamp;
    },
    714: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signature = exports.Envelope = void 0;
      function createBaseEnvelope() {
        return { payload: Buffer.alloc(0), payloadType: "", signatures: [] };
      }
      exports.Envelope = {
        fromJSON(object) {
          return {
            payload: isSet(object.payload)
              ? Buffer.from(bytesFromBase64(object.payload))
              : Buffer.alloc(0),
            payloadType: isSet(object.payloadType)
              ? String(object.payloadType)
              : "",
            signatures: Array.isArray(object?.signatures)
              ? object.signatures.map((e) => exports.Signature.fromJSON(e))
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.payload !== undefined &&
            (obj.payload = base64FromBytes(
              message.payload !== undefined ? message.payload : Buffer.alloc(0),
            ));
          message.payloadType !== undefined &&
            (obj.payloadType = message.payloadType);
          if (message.signatures) {
            obj.signatures = message.signatures.map((e) =>
              e ? exports.Signature.toJSON(e) : undefined,
            );
          } else {
            obj.signatures = [];
          }
          return obj;
        },
      };
      function createBaseSignature() {
        return { sig: Buffer.alloc(0), keyid: "" };
      }
      exports.Signature = {
        fromJSON(object) {
          return {
            sig: isSet(object.sig)
              ? Buffer.from(bytesFromBase64(object.sig))
              : Buffer.alloc(0),
            keyid: isSet(object.keyid) ? String(object.keyid) : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.sig !== undefined &&
            (obj.sig = base64FromBytes(
              message.sig !== undefined ? message.sig : Buffer.alloc(0),
            ));
          message.keyid !== undefined && (obj.keyid = message.keyid);
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    3027: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Timestamp = void 0;
      function createBaseTimestamp() {
        return { seconds: "0", nanos: 0 };
      }
      exports.Timestamp = {
        fromJSON(object) {
          return {
            seconds: isSet(object.seconds) ? String(object.seconds) : "0",
            nanos: isSet(object.nanos) ? Number(object.nanos) : 0,
          };
        },
        toJSON(message) {
          const obj = {};
          message.seconds !== undefined && (obj.seconds = message.seconds);
          message.nanos !== undefined &&
            (obj.nanos = Math.round(message.nanos));
          return obj;
        },
      };
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    8293: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Bundle =
        exports.VerificationMaterial =
        exports.TimestampVerificationData =
          void 0;
      const envelope_1 = __nccwpck_require__(714);
      const sigstore_common_1 = __nccwpck_require__(2193);
      const sigstore_rekor_1 = __nccwpck_require__(4951);
      function createBaseTimestampVerificationData() {
        return { rfc3161Timestamps: [] };
      }
      exports.TimestampVerificationData = {
        fromJSON(object) {
          return {
            rfc3161Timestamps: Array.isArray(object?.rfc3161Timestamps)
              ? object.rfc3161Timestamps.map((e) =>
                  sigstore_common_1.RFC3161SignedTimestamp.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.rfc3161Timestamps) {
            obj.rfc3161Timestamps = message.rfc3161Timestamps.map((e) =>
              e
                ? sigstore_common_1.RFC3161SignedTimestamp.toJSON(e)
                : undefined,
            );
          } else {
            obj.rfc3161Timestamps = [];
          }
          return obj;
        },
      };
      function createBaseVerificationMaterial() {
        return {
          content: undefined,
          tlogEntries: [],
          timestampVerificationData: undefined,
        };
      }
      exports.VerificationMaterial = {
        fromJSON(object) {
          return {
            content: isSet(object.publicKey)
              ? {
                  $case: "publicKey",
                  publicKey: sigstore_common_1.PublicKeyIdentifier.fromJSON(
                    object.publicKey,
                  ),
                }
              : isSet(object.x509CertificateChain)
                ? {
                    $case: "x509CertificateChain",
                    x509CertificateChain:
                      sigstore_common_1.X509CertificateChain.fromJSON(
                        object.x509CertificateChain,
                      ),
                  }
                : isSet(object.certificate)
                  ? {
                      $case: "certificate",
                      certificate: sigstore_common_1.X509Certificate.fromJSON(
                        object.certificate,
                      ),
                    }
                  : undefined,
            tlogEntries: Array.isArray(object?.tlogEntries)
              ? object.tlogEntries.map((e) =>
                  sigstore_rekor_1.TransparencyLogEntry.fromJSON(e),
                )
              : [],
            timestampVerificationData: isSet(object.timestampVerificationData)
              ? exports.TimestampVerificationData.fromJSON(
                  object.timestampVerificationData,
                )
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.content?.$case === "publicKey" &&
            (obj.publicKey = message.content?.publicKey
              ? sigstore_common_1.PublicKeyIdentifier.toJSON(
                  message.content?.publicKey,
                )
              : undefined);
          message.content?.$case === "x509CertificateChain" &&
            (obj.x509CertificateChain = message.content?.x509CertificateChain
              ? sigstore_common_1.X509CertificateChain.toJSON(
                  message.content?.x509CertificateChain,
                )
              : undefined);
          message.content?.$case === "certificate" &&
            (obj.certificate = message.content?.certificate
              ? sigstore_common_1.X509Certificate.toJSON(
                  message.content?.certificate,
                )
              : undefined);
          if (message.tlogEntries) {
            obj.tlogEntries = message.tlogEntries.map((e) =>
              e ? sigstore_rekor_1.TransparencyLogEntry.toJSON(e) : undefined,
            );
          } else {
            obj.tlogEntries = [];
          }
          message.timestampVerificationData !== undefined &&
            (obj.timestampVerificationData = message.timestampVerificationData
              ? exports.TimestampVerificationData.toJSON(
                  message.timestampVerificationData,
                )
              : undefined);
          return obj;
        },
      };
      function createBaseBundle() {
        return {
          mediaType: "",
          verificationMaterial: undefined,
          content: undefined,
        };
      }
      exports.Bundle = {
        fromJSON(object) {
          return {
            mediaType: isSet(object.mediaType) ? String(object.mediaType) : "",
            verificationMaterial: isSet(object.verificationMaterial)
              ? exports.VerificationMaterial.fromJSON(
                  object.verificationMaterial,
                )
              : undefined,
            content: isSet(object.messageSignature)
              ? {
                  $case: "messageSignature",
                  messageSignature: sigstore_common_1.MessageSignature.fromJSON(
                    object.messageSignature,
                  ),
                }
              : isSet(object.dsseEnvelope)
                ? {
                    $case: "dsseEnvelope",
                    dsseEnvelope: envelope_1.Envelope.fromJSON(
                      object.dsseEnvelope,
                    ),
                  }
                : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.mediaType !== undefined &&
            (obj.mediaType = message.mediaType);
          message.verificationMaterial !== undefined &&
            (obj.verificationMaterial = message.verificationMaterial
              ? exports.VerificationMaterial.toJSON(
                  message.verificationMaterial,
                )
              : undefined);
          message.content?.$case === "messageSignature" &&
            (obj.messageSignature = message.content?.messageSignature
              ? sigstore_common_1.MessageSignature.toJSON(
                  message.content?.messageSignature,
                )
              : undefined);
          message.content?.$case === "dsseEnvelope" &&
            (obj.dsseEnvelope = message.content?.dsseEnvelope
              ? envelope_1.Envelope.toJSON(message.content?.dsseEnvelope)
              : undefined);
          return obj;
        },
      };
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    2193: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TimeRange =
        exports.X509CertificateChain =
        exports.SubjectAlternativeName =
        exports.X509Certificate =
        exports.DistinguishedName =
        exports.ObjectIdentifierValuePair =
        exports.ObjectIdentifier =
        exports.PublicKeyIdentifier =
        exports.PublicKey =
        exports.RFC3161SignedTimestamp =
        exports.LogId =
        exports.MessageSignature =
        exports.HashOutput =
        exports.subjectAlternativeNameTypeToJSON =
        exports.subjectAlternativeNameTypeFromJSON =
        exports.SubjectAlternativeNameType =
        exports.publicKeyDetailsToJSON =
        exports.publicKeyDetailsFromJSON =
        exports.PublicKeyDetails =
        exports.hashAlgorithmToJSON =
        exports.hashAlgorithmFromJSON =
        exports.HashAlgorithm =
          void 0;
      const timestamp_1 = __nccwpck_require__(3027);
      var HashAlgorithm;
      (function (HashAlgorithm) {
        HashAlgorithm[(HashAlgorithm["HASH_ALGORITHM_UNSPECIFIED"] = 0)] =
          "HASH_ALGORITHM_UNSPECIFIED";
        HashAlgorithm[(HashAlgorithm["SHA2_256"] = 1)] = "SHA2_256";
        HashAlgorithm[(HashAlgorithm["SHA2_384"] = 2)] = "SHA2_384";
        HashAlgorithm[(HashAlgorithm["SHA2_512"] = 3)] = "SHA2_512";
        HashAlgorithm[(HashAlgorithm["SHA3_256"] = 4)] = "SHA3_256";
        HashAlgorithm[(HashAlgorithm["SHA3_384"] = 5)] = "SHA3_384";
      })(
        (HashAlgorithm = exports.HashAlgorithm || (exports.HashAlgorithm = {})),
      );
      function hashAlgorithmFromJSON(object) {
        switch (object) {
          case 0:
          case "HASH_ALGORITHM_UNSPECIFIED":
            return HashAlgorithm.HASH_ALGORITHM_UNSPECIFIED;
          case 1:
          case "SHA2_256":
            return HashAlgorithm.SHA2_256;
          case 2:
          case "SHA2_384":
            return HashAlgorithm.SHA2_384;
          case 3:
          case "SHA2_512":
            return HashAlgorithm.SHA2_512;
          case 4:
          case "SHA3_256":
            return HashAlgorithm.SHA3_256;
          case 5:
          case "SHA3_384":
            return HashAlgorithm.SHA3_384;
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " + object + " for enum HashAlgorithm",
            );
        }
      }
      exports.hashAlgorithmFromJSON = hashAlgorithmFromJSON;
      function hashAlgorithmToJSON(object) {
        switch (object) {
          case HashAlgorithm.HASH_ALGORITHM_UNSPECIFIED:
            return "HASH_ALGORITHM_UNSPECIFIED";
          case HashAlgorithm.SHA2_256:
            return "SHA2_256";
          case HashAlgorithm.SHA2_384:
            return "SHA2_384";
          case HashAlgorithm.SHA2_512:
            return "SHA2_512";
          case HashAlgorithm.SHA3_256:
            return "SHA3_256";
          case HashAlgorithm.SHA3_384:
            return "SHA3_384";
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " + object + " for enum HashAlgorithm",
            );
        }
      }
      exports.hashAlgorithmToJSON = hashAlgorithmToJSON;
      var PublicKeyDetails;
      (function (PublicKeyDetails) {
        PublicKeyDetails[
          (PublicKeyDetails["PUBLIC_KEY_DETAILS_UNSPECIFIED"] = 0)
        ] = "PUBLIC_KEY_DETAILS_UNSPECIFIED";
        PublicKeyDetails[(PublicKeyDetails["PKCS1_RSA_PKCS1V5"] = 1)] =
          "PKCS1_RSA_PKCS1V5";
        PublicKeyDetails[(PublicKeyDetails["PKCS1_RSA_PSS"] = 2)] =
          "PKCS1_RSA_PSS";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PKCS1V5"] = 3)] =
          "PKIX_RSA_PKCS1V5";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS"] = 4)] =
          "PKIX_RSA_PSS";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_RSA_PKCS1V15_2048_SHA256"] = 9)
        ] = "PKIX_RSA_PKCS1V15_2048_SHA256";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_RSA_PKCS1V15_3072_SHA256"] = 10)
        ] = "PKIX_RSA_PKCS1V15_3072_SHA256";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_RSA_PKCS1V15_4096_SHA256"] = 11)
        ] = "PKIX_RSA_PKCS1V15_4096_SHA256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS_2048_SHA256"] = 16)] =
          "PKIX_RSA_PSS_2048_SHA256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS_3072_SHA256"] = 17)] =
          "PKIX_RSA_PSS_3072_SHA256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_RSA_PSS_4096_SHA256"] = 18)] =
          "PKIX_RSA_PSS_4096_SHA256";
        PublicKeyDetails[
          (PublicKeyDetails["PKIX_ECDSA_P256_HMAC_SHA_256"] = 6)
        ] = "PKIX_ECDSA_P256_HMAC_SHA_256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ECDSA_P256_SHA_256"] = 5)] =
          "PKIX_ECDSA_P256_SHA_256";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ECDSA_P384_SHA_384"] = 12)] =
          "PKIX_ECDSA_P384_SHA_384";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ECDSA_P521_SHA_512"] = 13)] =
          "PKIX_ECDSA_P521_SHA_512";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ED25519"] = 7)] =
          "PKIX_ED25519";
        PublicKeyDetails[(PublicKeyDetails["PKIX_ED25519_PH"] = 8)] =
          "PKIX_ED25519_PH";
        PublicKeyDetails[(PublicKeyDetails["LMS_SHA256"] = 14)] = "LMS_SHA256";
        PublicKeyDetails[(PublicKeyDetails["LMOTS_SHA256"] = 15)] =
          "LMOTS_SHA256";
      })(
        (PublicKeyDetails =
          exports.PublicKeyDetails || (exports.PublicKeyDetails = {})),
      );
      function publicKeyDetailsFromJSON(object) {
        switch (object) {
          case 0:
          case "PUBLIC_KEY_DETAILS_UNSPECIFIED":
            return PublicKeyDetails.PUBLIC_KEY_DETAILS_UNSPECIFIED;
          case 1:
          case "PKCS1_RSA_PKCS1V5":
            return PublicKeyDetails.PKCS1_RSA_PKCS1V5;
          case 2:
          case "PKCS1_RSA_PSS":
            return PublicKeyDetails.PKCS1_RSA_PSS;
          case 3:
          case "PKIX_RSA_PKCS1V5":
            return PublicKeyDetails.PKIX_RSA_PKCS1V5;
          case 4:
          case "PKIX_RSA_PSS":
            return PublicKeyDetails.PKIX_RSA_PSS;
          case 9:
          case "PKIX_RSA_PKCS1V15_2048_SHA256":
            return PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256;
          case 10:
          case "PKIX_RSA_PKCS1V15_3072_SHA256":
            return PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256;
          case 11:
          case "PKIX_RSA_PKCS1V15_4096_SHA256":
            return PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256;
          case 16:
          case "PKIX_RSA_PSS_2048_SHA256":
            return PublicKeyDetails.PKIX_RSA_PSS_2048_SHA256;
          case 17:
          case "PKIX_RSA_PSS_3072_SHA256":
            return PublicKeyDetails.PKIX_RSA_PSS_3072_SHA256;
          case 18:
          case "PKIX_RSA_PSS_4096_SHA256":
            return PublicKeyDetails.PKIX_RSA_PSS_4096_SHA256;
          case 6:
          case "PKIX_ECDSA_P256_HMAC_SHA_256":
            return PublicKeyDetails.PKIX_ECDSA_P256_HMAC_SHA_256;
          case 5:
          case "PKIX_ECDSA_P256_SHA_256":
            return PublicKeyDetails.PKIX_ECDSA_P256_SHA_256;
          case 12:
          case "PKIX_ECDSA_P384_SHA_384":
            return PublicKeyDetails.PKIX_ECDSA_P384_SHA_384;
          case 13:
          case "PKIX_ECDSA_P521_SHA_512":
            return PublicKeyDetails.PKIX_ECDSA_P521_SHA_512;
          case 7:
          case "PKIX_ED25519":
            return PublicKeyDetails.PKIX_ED25519;
          case 8:
          case "PKIX_ED25519_PH":
            return PublicKeyDetails.PKIX_ED25519_PH;
          case 14:
          case "LMS_SHA256":
            return PublicKeyDetails.LMS_SHA256;
          case 15:
          case "LMOTS_SHA256":
            return PublicKeyDetails.LMOTS_SHA256;
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum PublicKeyDetails",
            );
        }
      }
      exports.publicKeyDetailsFromJSON = publicKeyDetailsFromJSON;
      function publicKeyDetailsToJSON(object) {
        switch (object) {
          case PublicKeyDetails.PUBLIC_KEY_DETAILS_UNSPECIFIED:
            return "PUBLIC_KEY_DETAILS_UNSPECIFIED";
          case PublicKeyDetails.PKCS1_RSA_PKCS1V5:
            return "PKCS1_RSA_PKCS1V5";
          case PublicKeyDetails.PKCS1_RSA_PSS:
            return "PKCS1_RSA_PSS";
          case PublicKeyDetails.PKIX_RSA_PKCS1V5:
            return "PKIX_RSA_PKCS1V5";
          case PublicKeyDetails.PKIX_RSA_PSS:
            return "PKIX_RSA_PSS";
          case PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256:
            return "PKIX_RSA_PKCS1V15_2048_SHA256";
          case PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256:
            return "PKIX_RSA_PKCS1V15_3072_SHA256";
          case PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256:
            return "PKIX_RSA_PKCS1V15_4096_SHA256";
          case PublicKeyDetails.PKIX_RSA_PSS_2048_SHA256:
            return "PKIX_RSA_PSS_2048_SHA256";
          case PublicKeyDetails.PKIX_RSA_PSS_3072_SHA256:
            return "PKIX_RSA_PSS_3072_SHA256";
          case PublicKeyDetails.PKIX_RSA_PSS_4096_SHA256:
            return "PKIX_RSA_PSS_4096_SHA256";
          case PublicKeyDetails.PKIX_ECDSA_P256_HMAC_SHA_256:
            return "PKIX_ECDSA_P256_HMAC_SHA_256";
          case PublicKeyDetails.PKIX_ECDSA_P256_SHA_256:
            return "PKIX_ECDSA_P256_SHA_256";
          case PublicKeyDetails.PKIX_ECDSA_P384_SHA_384:
            return "PKIX_ECDSA_P384_SHA_384";
          case PublicKeyDetails.PKIX_ECDSA_P521_SHA_512:
            return "PKIX_ECDSA_P521_SHA_512";
          case PublicKeyDetails.PKIX_ED25519:
            return "PKIX_ED25519";
          case PublicKeyDetails.PKIX_ED25519_PH:
            return "PKIX_ED25519_PH";
          case PublicKeyDetails.LMS_SHA256:
            return "LMS_SHA256";
          case PublicKeyDetails.LMOTS_SHA256:
            return "LMOTS_SHA256";
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum PublicKeyDetails",
            );
        }
      }
      exports.publicKeyDetailsToJSON = publicKeyDetailsToJSON;
      var SubjectAlternativeNameType;
      (function (SubjectAlternativeNameType) {
        SubjectAlternativeNameType[
          (SubjectAlternativeNameType[
            "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED"
          ] = 0)
        ] = "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED";
        SubjectAlternativeNameType[(SubjectAlternativeNameType["EMAIL"] = 1)] =
          "EMAIL";
        SubjectAlternativeNameType[(SubjectAlternativeNameType["URI"] = 2)] =
          "URI";
        SubjectAlternativeNameType[
          (SubjectAlternativeNameType["OTHER_NAME"] = 3)
        ] = "OTHER_NAME";
      })(
        (SubjectAlternativeNameType =
          exports.SubjectAlternativeNameType ||
          (exports.SubjectAlternativeNameType = {})),
      );
      function subjectAlternativeNameTypeFromJSON(object) {
        switch (object) {
          case 0:
          case "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED":
            return SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED;
          case 1:
          case "EMAIL":
            return SubjectAlternativeNameType.EMAIL;
          case 2:
          case "URI":
            return SubjectAlternativeNameType.URI;
          case 3:
          case "OTHER_NAME":
            return SubjectAlternativeNameType.OTHER_NAME;
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum SubjectAlternativeNameType",
            );
        }
      }
      exports.subjectAlternativeNameTypeFromJSON =
        subjectAlternativeNameTypeFromJSON;
      function subjectAlternativeNameTypeToJSON(object) {
        switch (object) {
          case SubjectAlternativeNameType.SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED:
            return "SUBJECT_ALTERNATIVE_NAME_TYPE_UNSPECIFIED";
          case SubjectAlternativeNameType.EMAIL:
            return "EMAIL";
          case SubjectAlternativeNameType.URI:
            return "URI";
          case SubjectAlternativeNameType.OTHER_NAME:
            return "OTHER_NAME";
          default:
            throw new tsProtoGlobalThis.Error(
              "Unrecognized enum value " +
                object +
                " for enum SubjectAlternativeNameType",
            );
        }
      }
      exports.subjectAlternativeNameTypeToJSON =
        subjectAlternativeNameTypeToJSON;
      function createBaseHashOutput() {
        return { algorithm: 0, digest: Buffer.alloc(0) };
      }
      exports.HashOutput = {
        fromJSON(object) {
          return {
            algorithm: isSet(object.algorithm)
              ? hashAlgorithmFromJSON(object.algorithm)
              : 0,
            digest: isSet(object.digest)
              ? Buffer.from(bytesFromBase64(object.digest))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.algorithm !== undefined &&
            (obj.algorithm = hashAlgorithmToJSON(message.algorithm));
          message.digest !== undefined &&
            (obj.digest = base64FromBytes(
              message.digest !== undefined ? message.digest : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseMessageSignature() {
        return { messageDigest: undefined, signature: Buffer.alloc(0) };
      }
      exports.MessageSignature = {
        fromJSON(object) {
          return {
            messageDigest: isSet(object.messageDigest)
              ? exports.HashOutput.fromJSON(object.messageDigest)
              : undefined,
            signature: isSet(object.signature)
              ? Buffer.from(bytesFromBase64(object.signature))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.messageDigest !== undefined &&
            (obj.messageDigest = message.messageDigest
              ? exports.HashOutput.toJSON(message.messageDigest)
              : undefined);
          message.signature !== undefined &&
            (obj.signature = base64FromBytes(
              message.signature !== undefined
                ? message.signature
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseLogId() {
        return { keyId: Buffer.alloc(0) };
      }
      exports.LogId = {
        fromJSON(object) {
          return {
            keyId: isSet(object.keyId)
              ? Buffer.from(bytesFromBase64(object.keyId))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.keyId !== undefined &&
            (obj.keyId = base64FromBytes(
              message.keyId !== undefined ? message.keyId : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseRFC3161SignedTimestamp() {
        return { signedTimestamp: Buffer.alloc(0) };
      }
      exports.RFC3161SignedTimestamp = {
        fromJSON(object) {
          return {
            signedTimestamp: isSet(object.signedTimestamp)
              ? Buffer.from(bytesFromBase64(object.signedTimestamp))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.signedTimestamp !== undefined &&
            (obj.signedTimestamp = base64FromBytes(
              message.signedTimestamp !== undefined
                ? message.signedTimestamp
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBasePublicKey() {
        return { rawBytes: undefined, keyDetails: 0, validFor: undefined };
      }
      exports.PublicKey = {
        fromJSON(object) {
          return {
            rawBytes: isSet(object.rawBytes)
              ? Buffer.from(bytesFromBase64(object.rawBytes))
              : undefined,
            keyDetails: isSet(object.keyDetails)
              ? publicKeyDetailsFromJSON(object.keyDetails)
              : 0,
            validFor: isSet(object.validFor)
              ? exports.TimeRange.fromJSON(object.validFor)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.rawBytes !== undefined &&
            (obj.rawBytes =
              message.rawBytes !== undefined
                ? base64FromBytes(message.rawBytes)
                : undefined);
          message.keyDetails !== undefined &&
            (obj.keyDetails = publicKeyDetailsToJSON(message.keyDetails));
          message.validFor !== undefined &&
            (obj.validFor = message.validFor
              ? exports.TimeRange.toJSON(message.validFor)
              : undefined);
          return obj;
        },
      };
      function createBasePublicKeyIdentifier() {
        return { hint: "" };
      }
      exports.PublicKeyIdentifier = {
        fromJSON(object) {
          return { hint: isSet(object.hint) ? String(object.hint) : "" };
        },
        toJSON(message) {
          const obj = {};
          message.hint !== undefined && (obj.hint = message.hint);
          return obj;
        },
      };
      function createBaseObjectIdentifier() {
        return { id: [] };
      }
      exports.ObjectIdentifier = {
        fromJSON(object) {
          return {
            id: Array.isArray(object?.id)
              ? object.id.map((e) => Number(e))
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.id) {
            obj.id = message.id.map((e) => Math.round(e));
          } else {
            obj.id = [];
          }
          return obj;
        },
      };
      function createBaseObjectIdentifierValuePair() {
        return { oid: undefined, value: Buffer.alloc(0) };
      }
      exports.ObjectIdentifierValuePair = {
        fromJSON(object) {
          return {
            oid: isSet(object.oid)
              ? exports.ObjectIdentifier.fromJSON(object.oid)
              : undefined,
            value: isSet(object.value)
              ? Buffer.from(bytesFromBase64(object.value))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.oid !== undefined &&
            (obj.oid = message.oid
              ? exports.ObjectIdentifier.toJSON(message.oid)
              : undefined);
          message.value !== undefined &&
            (obj.value = base64FromBytes(
              message.value !== undefined ? message.value : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseDistinguishedName() {
        return { organization: "", commonName: "" };
      }
      exports.DistinguishedName = {
        fromJSON(object) {
          return {
            organization: isSet(object.organization)
              ? String(object.organization)
              : "",
            commonName: isSet(object.commonName)
              ? String(object.commonName)
              : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.organization !== undefined &&
            (obj.organization = message.organization);
          message.commonName !== undefined &&
            (obj.commonName = message.commonName);
          return obj;
        },
      };
      function createBaseX509Certificate() {
        return { rawBytes: Buffer.alloc(0) };
      }
      exports.X509Certificate = {
        fromJSON(object) {
          return {
            rawBytes: isSet(object.rawBytes)
              ? Buffer.from(bytesFromBase64(object.rawBytes))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.rawBytes !== undefined &&
            (obj.rawBytes = base64FromBytes(
              message.rawBytes !== undefined
                ? message.rawBytes
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseSubjectAlternativeName() {
        return { type: 0, identity: undefined };
      }
      exports.SubjectAlternativeName = {
        fromJSON(object) {
          return {
            type: isSet(object.type)
              ? subjectAlternativeNameTypeFromJSON(object.type)
              : 0,
            identity: isSet(object.regexp)
              ? { $case: "regexp", regexp: String(object.regexp) }
              : isSet(object.value)
                ? { $case: "value", value: String(object.value) }
                : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.type !== undefined &&
            (obj.type = subjectAlternativeNameTypeToJSON(message.type));
          message.identity?.$case === "regexp" &&
            (obj.regexp = message.identity?.regexp);
          message.identity?.$case === "value" &&
            (obj.value = message.identity?.value);
          return obj;
        },
      };
      function createBaseX509CertificateChain() {
        return { certificates: [] };
      }
      exports.X509CertificateChain = {
        fromJSON(object) {
          return {
            certificates: Array.isArray(object?.certificates)
              ? object.certificates.map((e) =>
                  exports.X509Certificate.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.certificates) {
            obj.certificates = message.certificates.map((e) =>
              e ? exports.X509Certificate.toJSON(e) : undefined,
            );
          } else {
            obj.certificates = [];
          }
          return obj;
        },
      };
      function createBaseTimeRange() {
        return { start: undefined, end: undefined };
      }
      exports.TimeRange = {
        fromJSON(object) {
          return {
            start: isSet(object.start)
              ? fromJsonTimestamp(object.start)
              : undefined,
            end: isSet(object.end) ? fromJsonTimestamp(object.end) : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.start !== undefined &&
            (obj.start = message.start.toISOString());
          message.end !== undefined && (obj.end = message.end.toISOString());
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function fromTimestamp(t) {
        let millis = Number(t.seconds) * 1e3;
        millis += t.nanos / 1e6;
        return new Date(millis);
      }
      function fromJsonTimestamp(o) {
        if (o instanceof Date) {
          return o;
        } else if (typeof o === "string") {
          return new Date(o);
        } else {
          return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    4951: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TransparencyLogEntry =
        exports.InclusionPromise =
        exports.InclusionProof =
        exports.Checkpoint =
        exports.KindVersion =
          void 0;
      const sigstore_common_1 = __nccwpck_require__(2193);
      function createBaseKindVersion() {
        return { kind: "", version: "" };
      }
      exports.KindVersion = {
        fromJSON(object) {
          return {
            kind: isSet(object.kind) ? String(object.kind) : "",
            version: isSet(object.version) ? String(object.version) : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.kind !== undefined && (obj.kind = message.kind);
          message.version !== undefined && (obj.version = message.version);
          return obj;
        },
      };
      function createBaseCheckpoint() {
        return { envelope: "" };
      }
      exports.Checkpoint = {
        fromJSON(object) {
          return {
            envelope: isSet(object.envelope) ? String(object.envelope) : "",
          };
        },
        toJSON(message) {
          const obj = {};
          message.envelope !== undefined && (obj.envelope = message.envelope);
          return obj;
        },
      };
      function createBaseInclusionProof() {
        return {
          logIndex: "0",
          rootHash: Buffer.alloc(0),
          treeSize: "0",
          hashes: [],
          checkpoint: undefined,
        };
      }
      exports.InclusionProof = {
        fromJSON(object) {
          return {
            logIndex: isSet(object.logIndex) ? String(object.logIndex) : "0",
            rootHash: isSet(object.rootHash)
              ? Buffer.from(bytesFromBase64(object.rootHash))
              : Buffer.alloc(0),
            treeSize: isSet(object.treeSize) ? String(object.treeSize) : "0",
            hashes: Array.isArray(object?.hashes)
              ? object.hashes.map((e) => Buffer.from(bytesFromBase64(e)))
              : [],
            checkpoint: isSet(object.checkpoint)
              ? exports.Checkpoint.fromJSON(object.checkpoint)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.logIndex !== undefined && (obj.logIndex = message.logIndex);
          message.rootHash !== undefined &&
            (obj.rootHash = base64FromBytes(
              message.rootHash !== undefined
                ? message.rootHash
                : Buffer.alloc(0),
            ));
          message.treeSize !== undefined && (obj.treeSize = message.treeSize);
          if (message.hashes) {
            obj.hashes = message.hashes.map((e) =>
              base64FromBytes(e !== undefined ? e : Buffer.alloc(0)),
            );
          } else {
            obj.hashes = [];
          }
          message.checkpoint !== undefined &&
            (obj.checkpoint = message.checkpoint
              ? exports.Checkpoint.toJSON(message.checkpoint)
              : undefined);
          return obj;
        },
      };
      function createBaseInclusionPromise() {
        return { signedEntryTimestamp: Buffer.alloc(0) };
      }
      exports.InclusionPromise = {
        fromJSON(object) {
          return {
            signedEntryTimestamp: isSet(object.signedEntryTimestamp)
              ? Buffer.from(bytesFromBase64(object.signedEntryTimestamp))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.signedEntryTimestamp !== undefined &&
            (obj.signedEntryTimestamp = base64FromBytes(
              message.signedEntryTimestamp !== undefined
                ? message.signedEntryTimestamp
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      function createBaseTransparencyLogEntry() {
        return {
          logIndex: "0",
          logId: undefined,
          kindVersion: undefined,
          integratedTime: "0",
          inclusionPromise: undefined,
          inclusionProof: undefined,
          canonicalizedBody: Buffer.alloc(0),
        };
      }
      exports.TransparencyLogEntry = {
        fromJSON(object) {
          return {
            logIndex: isSet(object.logIndex) ? String(object.logIndex) : "0",
            logId: isSet(object.logId)
              ? sigstore_common_1.LogId.fromJSON(object.logId)
              : undefined,
            kindVersion: isSet(object.kindVersion)
              ? exports.KindVersion.fromJSON(object.kindVersion)
              : undefined,
            integratedTime: isSet(object.integratedTime)
              ? String(object.integratedTime)
              : "0",
            inclusionPromise: isSet(object.inclusionPromise)
              ? exports.InclusionPromise.fromJSON(object.inclusionPromise)
              : undefined,
            inclusionProof: isSet(object.inclusionProof)
              ? exports.InclusionProof.fromJSON(object.inclusionProof)
              : undefined,
            canonicalizedBody: isSet(object.canonicalizedBody)
              ? Buffer.from(bytesFromBase64(object.canonicalizedBody))
              : Buffer.alloc(0),
          };
        },
        toJSON(message) {
          const obj = {};
          message.logIndex !== undefined && (obj.logIndex = message.logIndex);
          message.logId !== undefined &&
            (obj.logId = message.logId
              ? sigstore_common_1.LogId.toJSON(message.logId)
              : undefined);
          message.kindVersion !== undefined &&
            (obj.kindVersion = message.kindVersion
              ? exports.KindVersion.toJSON(message.kindVersion)
              : undefined);
          message.integratedTime !== undefined &&
            (obj.integratedTime = message.integratedTime);
          message.inclusionPromise !== undefined &&
            (obj.inclusionPromise = message.inclusionPromise
              ? exports.InclusionPromise.toJSON(message.inclusionPromise)
              : undefined);
          message.inclusionProof !== undefined &&
            (obj.inclusionProof = message.inclusionProof
              ? exports.InclusionProof.toJSON(message.inclusionProof)
              : undefined);
          message.canonicalizedBody !== undefined &&
            (obj.canonicalizedBody = base64FromBytes(
              message.canonicalizedBody !== undefined
                ? message.canonicalizedBody
                : Buffer.alloc(0),
            ));
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    4012: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ClientTrustConfig =
        exports.SigningConfig =
        exports.TrustedRoot =
        exports.CertificateAuthority =
        exports.TransparencyLogInstance =
          void 0;
      const sigstore_common_1 = __nccwpck_require__(2193);
      function createBaseTransparencyLogInstance() {
        return {
          baseUrl: "",
          hashAlgorithm: 0,
          publicKey: undefined,
          logId: undefined,
          checkpointKeyId: undefined,
        };
      }
      exports.TransparencyLogInstance = {
        fromJSON(object) {
          return {
            baseUrl: isSet(object.baseUrl) ? String(object.baseUrl) : "",
            hashAlgorithm: isSet(object.hashAlgorithm)
              ? (0, sigstore_common_1.hashAlgorithmFromJSON)(
                  object.hashAlgorithm,
                )
              : 0,
            publicKey: isSet(object.publicKey)
              ? sigstore_common_1.PublicKey.fromJSON(object.publicKey)
              : undefined,
            logId: isSet(object.logId)
              ? sigstore_common_1.LogId.fromJSON(object.logId)
              : undefined,
            checkpointKeyId: isSet(object.checkpointKeyId)
              ? sigstore_common_1.LogId.fromJSON(object.checkpointKeyId)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.baseUrl !== undefined && (obj.baseUrl = message.baseUrl);
          message.hashAlgorithm !== undefined &&
            (obj.hashAlgorithm = (0, sigstore_common_1.hashAlgorithmToJSON)(
              message.hashAlgorithm,
            ));
          message.publicKey !== undefined &&
            (obj.publicKey = message.publicKey
              ? sigstore_common_1.PublicKey.toJSON(message.publicKey)
              : undefined);
          message.logId !== undefined &&
            (obj.logId = message.logId
              ? sigstore_common_1.LogId.toJSON(message.logId)
              : undefined);
          message.checkpointKeyId !== undefined &&
            (obj.checkpointKeyId = message.checkpointKeyId
              ? sigstore_common_1.LogId.toJSON(message.checkpointKeyId)
              : undefined);
          return obj;
        },
      };
      function createBaseCertificateAuthority() {
        return {
          subject: undefined,
          uri: "",
          certChain: undefined,
          validFor: undefined,
        };
      }
      exports.CertificateAuthority = {
        fromJSON(object) {
          return {
            subject: isSet(object.subject)
              ? sigstore_common_1.DistinguishedName.fromJSON(object.subject)
              : undefined,
            uri: isSet(object.uri) ? String(object.uri) : "",
            certChain: isSet(object.certChain)
              ? sigstore_common_1.X509CertificateChain.fromJSON(
                  object.certChain,
                )
              : undefined,
            validFor: isSet(object.validFor)
              ? sigstore_common_1.TimeRange.fromJSON(object.validFor)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.subject !== undefined &&
            (obj.subject = message.subject
              ? sigstore_common_1.DistinguishedName.toJSON(message.subject)
              : undefined);
          message.uri !== undefined && (obj.uri = message.uri);
          message.certChain !== undefined &&
            (obj.certChain = message.certChain
              ? sigstore_common_1.X509CertificateChain.toJSON(message.certChain)
              : undefined);
          message.validFor !== undefined &&
            (obj.validFor = message.validFor
              ? sigstore_common_1.TimeRange.toJSON(message.validFor)
              : undefined);
          return obj;
        },
      };
      function createBaseTrustedRoot() {
        return {
          mediaType: "",
          tlogs: [],
          certificateAuthorities: [],
          ctlogs: [],
          timestampAuthorities: [],
        };
      }
      exports.TrustedRoot = {
        fromJSON(object) {
          return {
            mediaType: isSet(object.mediaType) ? String(object.mediaType) : "",
            tlogs: Array.isArray(object?.tlogs)
              ? object.tlogs.map((e) =>
                  exports.TransparencyLogInstance.fromJSON(e),
                )
              : [],
            certificateAuthorities: Array.isArray(
              object?.certificateAuthorities,
            )
              ? object.certificateAuthorities.map((e) =>
                  exports.CertificateAuthority.fromJSON(e),
                )
              : [],
            ctlogs: Array.isArray(object?.ctlogs)
              ? object.ctlogs.map((e) =>
                  exports.TransparencyLogInstance.fromJSON(e),
                )
              : [],
            timestampAuthorities: Array.isArray(object?.timestampAuthorities)
              ? object.timestampAuthorities.map((e) =>
                  exports.CertificateAuthority.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.mediaType !== undefined &&
            (obj.mediaType = message.mediaType);
          if (message.tlogs) {
            obj.tlogs = message.tlogs.map((e) =>
              e ? exports.TransparencyLogInstance.toJSON(e) : undefined,
            );
          } else {
            obj.tlogs = [];
          }
          if (message.certificateAuthorities) {
            obj.certificateAuthorities = message.certificateAuthorities.map(
              (e) => (e ? exports.CertificateAuthority.toJSON(e) : undefined),
            );
          } else {
            obj.certificateAuthorities = [];
          }
          if (message.ctlogs) {
            obj.ctlogs = message.ctlogs.map((e) =>
              e ? exports.TransparencyLogInstance.toJSON(e) : undefined,
            );
          } else {
            obj.ctlogs = [];
          }
          if (message.timestampAuthorities) {
            obj.timestampAuthorities = message.timestampAuthorities.map((e) =>
              e ? exports.CertificateAuthority.toJSON(e) : undefined,
            );
          } else {
            obj.timestampAuthorities = [];
          }
          return obj;
        },
      };
      function createBaseSigningConfig() {
        return { caUrl: "", oidcUrl: "", tlogUrls: [], tsaUrls: [] };
      }
      exports.SigningConfig = {
        fromJSON(object) {
          return {
            caUrl: isSet(object.caUrl) ? String(object.caUrl) : "",
            oidcUrl: isSet(object.oidcUrl) ? String(object.oidcUrl) : "",
            tlogUrls: Array.isArray(object?.tlogUrls)
              ? object.tlogUrls.map((e) => String(e))
              : [],
            tsaUrls: Array.isArray(object?.tsaUrls)
              ? object.tsaUrls.map((e) => String(e))
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.caUrl !== undefined && (obj.caUrl = message.caUrl);
          message.oidcUrl !== undefined && (obj.oidcUrl = message.oidcUrl);
          if (message.tlogUrls) {
            obj.tlogUrls = message.tlogUrls.map((e) => e);
          } else {
            obj.tlogUrls = [];
          }
          if (message.tsaUrls) {
            obj.tsaUrls = message.tsaUrls.map((e) => e);
          } else {
            obj.tsaUrls = [];
          }
          return obj;
        },
      };
      function createBaseClientTrustConfig() {
        return {
          mediaType: "",
          trustedRoot: undefined,
          signingConfig: undefined,
        };
      }
      exports.ClientTrustConfig = {
        fromJSON(object) {
          return {
            mediaType: isSet(object.mediaType) ? String(object.mediaType) : "",
            trustedRoot: isSet(object.trustedRoot)
              ? exports.TrustedRoot.fromJSON(object.trustedRoot)
              : undefined,
            signingConfig: isSet(object.signingConfig)
              ? exports.SigningConfig.fromJSON(object.signingConfig)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.mediaType !== undefined &&
            (obj.mediaType = message.mediaType);
          message.trustedRoot !== undefined &&
            (obj.trustedRoot = message.trustedRoot
              ? exports.TrustedRoot.toJSON(message.trustedRoot)
              : undefined);
          message.signingConfig !== undefined &&
            (obj.signingConfig = message.signingConfig
              ? exports.SigningConfig.toJSON(message.signingConfig)
              : undefined);
          return obj;
        },
      };
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    9980: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Input =
        exports.Artifact =
        exports.ArtifactVerificationOptions_ObserverTimestampOptions =
        exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions =
        exports.ArtifactVerificationOptions_TimestampAuthorityOptions =
        exports.ArtifactVerificationOptions_CtlogOptions =
        exports.ArtifactVerificationOptions_TlogOptions =
        exports.ArtifactVerificationOptions =
        exports.PublicKeyIdentities =
        exports.CertificateIdentities =
        exports.CertificateIdentity =
          void 0;
      const sigstore_bundle_1 = __nccwpck_require__(8293);
      const sigstore_common_1 = __nccwpck_require__(2193);
      const sigstore_trustroot_1 = __nccwpck_require__(4012);
      function createBaseCertificateIdentity() {
        return { issuer: "", san: undefined, oids: [] };
      }
      exports.CertificateIdentity = {
        fromJSON(object) {
          return {
            issuer: isSet(object.issuer) ? String(object.issuer) : "",
            san: isSet(object.san)
              ? sigstore_common_1.SubjectAlternativeName.fromJSON(object.san)
              : undefined,
            oids: Array.isArray(object?.oids)
              ? object.oids.map((e) =>
                  sigstore_common_1.ObjectIdentifierValuePair.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          message.issuer !== undefined && (obj.issuer = message.issuer);
          message.san !== undefined &&
            (obj.san = message.san
              ? sigstore_common_1.SubjectAlternativeName.toJSON(message.san)
              : undefined);
          if (message.oids) {
            obj.oids = message.oids.map((e) =>
              e
                ? sigstore_common_1.ObjectIdentifierValuePair.toJSON(e)
                : undefined,
            );
          } else {
            obj.oids = [];
          }
          return obj;
        },
      };
      function createBaseCertificateIdentities() {
        return { identities: [] };
      }
      exports.CertificateIdentities = {
        fromJSON(object) {
          return {
            identities: Array.isArray(object?.identities)
              ? object.identities.map((e) =>
                  exports.CertificateIdentity.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.identities) {
            obj.identities = message.identities.map((e) =>
              e ? exports.CertificateIdentity.toJSON(e) : undefined,
            );
          } else {
            obj.identities = [];
          }
          return obj;
        },
      };
      function createBasePublicKeyIdentities() {
        return { publicKeys: [] };
      }
      exports.PublicKeyIdentities = {
        fromJSON(object) {
          return {
            publicKeys: Array.isArray(object?.publicKeys)
              ? object.publicKeys.map((e) =>
                  sigstore_common_1.PublicKey.fromJSON(e),
                )
              : [],
          };
        },
        toJSON(message) {
          const obj = {};
          if (message.publicKeys) {
            obj.publicKeys = message.publicKeys.map((e) =>
              e ? sigstore_common_1.PublicKey.toJSON(e) : undefined,
            );
          } else {
            obj.publicKeys = [];
          }
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions() {
        return {
          signers: undefined,
          tlogOptions: undefined,
          ctlogOptions: undefined,
          tsaOptions: undefined,
          integratedTsOptions: undefined,
          observerOptions: undefined,
        };
      }
      exports.ArtifactVerificationOptions = {
        fromJSON(object) {
          return {
            signers: isSet(object.certificateIdentities)
              ? {
                  $case: "certificateIdentities",
                  certificateIdentities: exports.CertificateIdentities.fromJSON(
                    object.certificateIdentities,
                  ),
                }
              : isSet(object.publicKeys)
                ? {
                    $case: "publicKeys",
                    publicKeys: exports.PublicKeyIdentities.fromJSON(
                      object.publicKeys,
                    ),
                  }
                : undefined,
            tlogOptions: isSet(object.tlogOptions)
              ? exports.ArtifactVerificationOptions_TlogOptions.fromJSON(
                  object.tlogOptions,
                )
              : undefined,
            ctlogOptions: isSet(object.ctlogOptions)
              ? exports.ArtifactVerificationOptions_CtlogOptions.fromJSON(
                  object.ctlogOptions,
                )
              : undefined,
            tsaOptions: isSet(object.tsaOptions)
              ? exports.ArtifactVerificationOptions_TimestampAuthorityOptions.fromJSON(
                  object.tsaOptions,
                )
              : undefined,
            integratedTsOptions: isSet(object.integratedTsOptions)
              ? exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions.fromJSON(
                  object.integratedTsOptions,
                )
              : undefined,
            observerOptions: isSet(object.observerOptions)
              ? exports.ArtifactVerificationOptions_ObserverTimestampOptions.fromJSON(
                  object.observerOptions,
                )
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.signers?.$case === "certificateIdentities" &&
            (obj.certificateIdentities = message.signers?.certificateIdentities
              ? exports.CertificateIdentities.toJSON(
                  message.signers?.certificateIdentities,
                )
              : undefined);
          message.signers?.$case === "publicKeys" &&
            (obj.publicKeys = message.signers?.publicKeys
              ? exports.PublicKeyIdentities.toJSON(message.signers?.publicKeys)
              : undefined);
          message.tlogOptions !== undefined &&
            (obj.tlogOptions = message.tlogOptions
              ? exports.ArtifactVerificationOptions_TlogOptions.toJSON(
                  message.tlogOptions,
                )
              : undefined);
          message.ctlogOptions !== undefined &&
            (obj.ctlogOptions = message.ctlogOptions
              ? exports.ArtifactVerificationOptions_CtlogOptions.toJSON(
                  message.ctlogOptions,
                )
              : undefined);
          message.tsaOptions !== undefined &&
            (obj.tsaOptions = message.tsaOptions
              ? exports.ArtifactVerificationOptions_TimestampAuthorityOptions.toJSON(
                  message.tsaOptions,
                )
              : undefined);
          message.integratedTsOptions !== undefined &&
            (obj.integratedTsOptions = message.integratedTsOptions
              ? exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions.toJSON(
                  message.integratedTsOptions,
                )
              : undefined);
          message.observerOptions !== undefined &&
            (obj.observerOptions = message.observerOptions
              ? exports.ArtifactVerificationOptions_ObserverTimestampOptions.toJSON(
                  message.observerOptions,
                )
              : undefined);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_TlogOptions() {
        return {
          threshold: 0,
          performOnlineVerification: false,
          disable: false,
        };
      }
      exports.ArtifactVerificationOptions_TlogOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            performOnlineVerification: isSet(object.performOnlineVerification)
              ? Boolean(object.performOnlineVerification)
              : false,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.performOnlineVerification !== undefined &&
            (obj.performOnlineVerification = message.performOnlineVerification);
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_CtlogOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_CtlogOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_TimestampAuthorityOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_TimestampAuthorityOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_TlogIntegratedTimestampOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_TlogIntegratedTimestampOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifactVerificationOptions_ObserverTimestampOptions() {
        return { threshold: 0, disable: false };
      }
      exports.ArtifactVerificationOptions_ObserverTimestampOptions = {
        fromJSON(object) {
          return {
            threshold: isSet(object.threshold) ? Number(object.threshold) : 0,
            disable: isSet(object.disable) ? Boolean(object.disable) : false,
          };
        },
        toJSON(message) {
          const obj = {};
          message.threshold !== undefined &&
            (obj.threshold = Math.round(message.threshold));
          message.disable !== undefined && (obj.disable = message.disable);
          return obj;
        },
      };
      function createBaseArtifact() {
        return { data: undefined };
      }
      exports.Artifact = {
        fromJSON(object) {
          return {
            data: isSet(object.artifactUri)
              ? {
                  $case: "artifactUri",
                  artifactUri: String(object.artifactUri),
                }
              : isSet(object.artifact)
                ? {
                    $case: "artifact",
                    artifact: Buffer.from(bytesFromBase64(object.artifact)),
                  }
                : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.data?.$case === "artifactUri" &&
            (obj.artifactUri = message.data?.artifactUri);
          message.data?.$case === "artifact" &&
            (obj.artifact =
              message.data?.artifact !== undefined
                ? base64FromBytes(message.data?.artifact)
                : undefined);
          return obj;
        },
      };
      function createBaseInput() {
        return {
          artifactTrustRoot: undefined,
          artifactVerificationOptions: undefined,
          bundle: undefined,
          artifact: undefined,
        };
      }
      exports.Input = {
        fromJSON(object) {
          return {
            artifactTrustRoot: isSet(object.artifactTrustRoot)
              ? sigstore_trustroot_1.TrustedRoot.fromJSON(
                  object.artifactTrustRoot,
                )
              : undefined,
            artifactVerificationOptions: isSet(
              object.artifactVerificationOptions,
            )
              ? exports.ArtifactVerificationOptions.fromJSON(
                  object.artifactVerificationOptions,
                )
              : undefined,
            bundle: isSet(object.bundle)
              ? sigstore_bundle_1.Bundle.fromJSON(object.bundle)
              : undefined,
            artifact: isSet(object.artifact)
              ? exports.Artifact.fromJSON(object.artifact)
              : undefined,
          };
        },
        toJSON(message) {
          const obj = {};
          message.artifactTrustRoot !== undefined &&
            (obj.artifactTrustRoot = message.artifactTrustRoot
              ? sigstore_trustroot_1.TrustedRoot.toJSON(
                  message.artifactTrustRoot,
                )
              : undefined);
          message.artifactVerificationOptions !== undefined &&
            (obj.artifactVerificationOptions =
              message.artifactVerificationOptions
                ? exports.ArtifactVerificationOptions.toJSON(
                    message.artifactVerificationOptions,
                  )
                : undefined);
          message.bundle !== undefined &&
            (obj.bundle = message.bundle
              ? sigstore_bundle_1.Bundle.toJSON(message.bundle)
              : undefined);
          message.artifact !== undefined &&
            (obj.artifact = message.artifact
              ? exports.Artifact.toJSON(message.artifact)
              : undefined);
          return obj;
        },
      };
      var tsProtoGlobalThis = (() => {
        if (typeof globalThis !== "undefined") {
          return globalThis;
        }
        if (typeof self !== "undefined") {
          return self;
        }
        if (typeof window !== "undefined") {
          return window;
        }
        if (typeof global !== "undefined") {
          return global;
        }
        throw "Unable to locate global object";
      })();
      function bytesFromBase64(b64) {
        if (tsProtoGlobalThis.Buffer) {
          return Uint8Array.from(tsProtoGlobalThis.Buffer.from(b64, "base64"));
        } else {
          const bin = tsProtoGlobalThis.atob(b64);
          const arr = new Uint8Array(bin.length);
          for (let i = 0; i < bin.length; ++i) {
            arr[i] = bin.charCodeAt(i);
          }
          return arr;
        }
      }
      function base64FromBytes(arr) {
        if (tsProtoGlobalThis.Buffer) {
          return tsProtoGlobalThis.Buffer.from(arr).toString("base64");
        } else {
          const bin = [];
          arr.forEach((byte) => {
            bin.push(String.fromCharCode(byte));
          });
          return tsProtoGlobalThis.btoa(bin.join(""));
        }
      }
      function isSet(value) {
        return value !== null && value !== undefined;
      }
    },
    530: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(__nccwpck_require__(714), exports);
      __exportStar(__nccwpck_require__(8293), exports);
      __exportStar(__nccwpck_require__(2193), exports);
      __exportStar(__nccwpck_require__(4951), exports);
      __exportStar(__nccwpck_require__(4012), exports);
      __exportStar(__nccwpck_require__(9980), exports);
    },
    5: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.BaseBundleBuilder = void 0;
      class BaseBundleBuilder {
        constructor(options) {
          this.signer = options.signer;
          this.witnesses = options.witnesses;
        }
        async create(artifact) {
          const signature = await this.prepare(artifact).then((blob) =>
            this.signer.sign(blob),
          );
          const bundle = await this.package(artifact, signature);
          const verificationMaterials = await Promise.all(
            this.witnesses.map((witness) =>
              witness.testify(bundle.content, publicKey(signature.key)),
            ),
          );
          const tlogEntryList = [];
          const timestampList = [];
          verificationMaterials.forEach(
            ({ tlogEntries, rfc3161Timestamps }) => {
              tlogEntryList.push(...(tlogEntries ?? []));
              timestampList.push(...(rfc3161Timestamps ?? []));
            },
          );
          bundle.verificationMaterial.tlogEntries = tlogEntryList;
          bundle.verificationMaterial.timestampVerificationData = {
            rfc3161Timestamps: timestampList,
          };
          return bundle;
        }
        async prepare(artifact) {
          return artifact.data;
        }
      }
      exports.BaseBundleBuilder = BaseBundleBuilder;
      function publicKey(key) {
        switch (key.$case) {
          case "publicKey":
            return key.publicKey;
          case "x509Certificate":
            return key.certificate;
        }
      }
    },
    6947: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toDSSEBundle = exports.toMessageSignatureBundle = void 0;
      const sigstore = __importStar(__nccwpck_require__(9715));
      const util_1 = __nccwpck_require__(724);
      function toMessageSignatureBundle(artifact, signature) {
        const digest = util_1.crypto.hash(artifact.data);
        return sigstore.toMessageSignatureBundle({
          digest,
          signature: signature.signature,
          certificate:
            signature.key.$case === "x509Certificate"
              ? util_1.pem.toDER(signature.key.certificate)
              : undefined,
          keyHint:
            signature.key.$case === "publicKey"
              ? signature.key.hint
              : undefined,
        });
      }
      exports.toMessageSignatureBundle = toMessageSignatureBundle;
      function toDSSEBundle(artifact, signature, singleCertificate) {
        return sigstore.toDSSEBundle({
          artifact: artifact.data,
          artifactType: artifact.type,
          signature: signature.signature,
          certificate:
            signature.key.$case === "x509Certificate"
              ? util_1.pem.toDER(signature.key.certificate)
              : undefined,
          keyHint:
            signature.key.$case === "publicKey"
              ? signature.key.hint
              : undefined,
          singleCertificate,
        });
      }
      exports.toDSSEBundle = toDSSEBundle;
    },
    8791: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DSSEBundleBuilder = void 0;
      const util_1 = __nccwpck_require__(724);
      const base_1 = __nccwpck_require__(5);
      const bundle_1 = __nccwpck_require__(6947);
      class DSSEBundleBuilder extends base_1.BaseBundleBuilder {
        constructor(options) {
          super(options);
          this.singleCertificate = options.singleCertificate ?? false;
        }
        async prepare(artifact) {
          const a = artifactDefaults(artifact);
          return util_1.dsse.preAuthEncoding(a.type, a.data);
        }
        async package(artifact, signature) {
          return (0, bundle_1.toDSSEBundle)(
            artifactDefaults(artifact),
            signature,
            this.singleCertificate,
          );
        }
      }
      exports.DSSEBundleBuilder = DSSEBundleBuilder;
      function artifactDefaults(artifact) {
        return { ...artifact, type: artifact.type ?? "" };
      }
    },
    4929: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageSignatureBundleBuilder = exports.DSSEBundleBuilder =
        void 0;
      var dsse_1 = __nccwpck_require__(8791);
      Object.defineProperty(exports, "DSSEBundleBuilder", {
        enumerable: true,
        get: function () {
          return dsse_1.DSSEBundleBuilder;
        },
      });
      var message_1 = __nccwpck_require__(5243);
      Object.defineProperty(exports, "MessageSignatureBundleBuilder", {
        enumerable: true,
        get: function () {
          return message_1.MessageSignatureBundleBuilder;
        },
      });
    },
    5243: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageSignatureBundleBuilder = void 0;
      const base_1 = __nccwpck_require__(5);
      const bundle_1 = __nccwpck_require__(6947);
      class MessageSignatureBundleBuilder extends base_1.BaseBundleBuilder {
        constructor(options) {
          super(options);
        }
        async package(artifact, signature) {
          return (0, bundle_1.toMessageSignatureBundle)(artifact, signature);
        }
      }
      exports.MessageSignatureBundleBuilder = MessageSignatureBundleBuilder;
    },
    532: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.internalError = exports.InternalError = void 0;
      const error_1 = __nccwpck_require__(1294);
      class InternalError extends Error {
        constructor({ code, message, cause }) {
          super(message);
          this.name = this.constructor.name;
          this.cause = cause;
          this.code = code;
        }
      }
      exports.InternalError = InternalError;
      function internalError(err, code, message) {
        if (err instanceof error_1.HTTPError) {
          message += ` - ${err.message}`;
        }
        throw new InternalError({ code, message, cause: err });
      }
      exports.internalError = internalError;
    },
    1294: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HTTPError = void 0;
      class HTTPError extends Error {
        constructor({ status, message, location }) {
          super(`(${status}) ${message}`);
          this.statusCode = status;
          this.location = location;
        }
      }
      exports.HTTPError = HTTPError;
    },
    8509: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.fetchWithRetry = void 0;
      const http2_1 = __nccwpck_require__(5158);
      const make_fetch_happen_1 = __importDefault(__nccwpck_require__(9525));
      const proc_log_1 = __nccwpck_require__(6528);
      const promise_retry_1 = __importDefault(__nccwpck_require__(4742));
      const util_1 = __nccwpck_require__(724);
      const error_1 = __nccwpck_require__(1294);
      const {
        HTTP2_HEADER_LOCATION,
        HTTP2_HEADER_CONTENT_TYPE,
        HTTP2_HEADER_USER_AGENT,
        HTTP_STATUS_INTERNAL_SERVER_ERROR,
        HTTP_STATUS_TOO_MANY_REQUESTS,
        HTTP_STATUS_REQUEST_TIMEOUT,
      } = http2_1.constants;
      async function fetchWithRetry(url, options) {
        return (0, promise_retry_1.default)(async (retry, attemptNum) => {
          const method = options.method || "POST";
          const headers = {
            [HTTP2_HEADER_USER_AGENT]: util_1.ua.getUserAgent(),
            ...options.headers,
          };
          const response = await (0, make_fetch_happen_1.default)(url, {
            method,
            headers,
            body: options.body,
            timeout: options.timeout,
            retry: false,
          }).catch((reason) => {
            proc_log_1.log.http(
              "fetch",
              `${method} ${url} attempt ${attemptNum} failed with ${reason}`,
            );
            return retry(reason);
          });
          if (response.ok) {
            return response;
          } else {
            const error = await errorFromResponse(response);
            proc_log_1.log.http(
              "fetch",
              `${method} ${url} attempt ${attemptNum} failed with ${response.status}`,
            );
            if (retryable(response.status)) {
              return retry(error);
            } else {
              throw error;
            }
          }
        }, retryOpts(options.retry));
      }
      exports.fetchWithRetry = fetchWithRetry;
      const errorFromResponse = async (response) => {
        let message = response.statusText;
        const location =
          response.headers?.get(HTTP2_HEADER_LOCATION) || undefined;
        const contentType = response.headers?.get(HTTP2_HEADER_CONTENT_TYPE);
        if (contentType?.includes("application/json")) {
          try {
            const body = await response.json();
            message = body.message || message;
          } catch (e) {}
        }
        return new error_1.HTTPError({
          status: response.status,
          message,
          location,
        });
      };
      const retryable = (status) =>
        [HTTP_STATUS_REQUEST_TIMEOUT, HTTP_STATUS_TOO_MANY_REQUESTS].includes(
          status,
        ) || status >= HTTP_STATUS_INTERNAL_SERVER_ERROR;
      const retryOpts = (retry) => {
        if (typeof retry === "boolean") {
          return { retries: retry ? 1 : 0 };
        } else if (typeof retry === "number") {
          return { retries: retry };
        } else {
          return { retries: 0, ...retry };
        }
      };
    },
    2960: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Fulcio = void 0;
      const fetch_1 = __nccwpck_require__(8509);
      class Fulcio {
        constructor(options) {
          this.options = options;
        }
        async createSigningCertificate(request) {
          const { baseURL, retry, timeout } = this.options;
          const url = `${baseURL}/api/v2/signingCert`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(request),
            timeout,
            retry,
          });
          return response.json();
        }
      }
      exports.Fulcio = Fulcio;
    },
    6205: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Rekor = void 0;
      const fetch_1 = __nccwpck_require__(8509);
      class Rekor {
        constructor(options) {
          this.options = options;
        }
        async createEntry(propsedEntry) {
          const { baseURL, timeout, retry } = this.options;
          const url = `${baseURL}/api/v1/log/entries`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(propsedEntry),
            timeout,
            retry,
          });
          const data = await response.json();
          return entryFromResponse(data);
        }
        async getEntry(uuid) {
          const { baseURL, timeout, retry } = this.options;
          const url = `${baseURL}/api/v1/log/entries/${uuid}`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            method: "GET",
            headers: { Accept: "application/json" },
            timeout,
            retry,
          });
          const data = await response.json();
          return entryFromResponse(data);
        }
      }
      exports.Rekor = Rekor;
      function entryFromResponse(data) {
        const entries = Object.entries(data);
        if (entries.length != 1) {
          throw new Error("Received multiple entries in Rekor response");
        }
        const [uuid, entry] = entries[0];
        return { ...entry, uuid };
      }
    },
    2759: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TimestampAuthority = void 0;
      const fetch_1 = __nccwpck_require__(8509);
      class TimestampAuthority {
        constructor(options) {
          this.options = options;
        }
        async createTimestamp(request) {
          const { baseURL, timeout, retry } = this.options;
          const url = `${baseURL}/api/v1/timestamp`;
          const response = await (0, fetch_1.fetchWithRetry)(url, {
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(request),
            timeout,
            retry,
          });
          return response.buffer();
        }
      }
      exports.TimestampAuthority = TimestampAuthority;
    },
    3110: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CIContextProvider = void 0;
      const make_fetch_happen_1 = __importDefault(__nccwpck_require__(9525));
      const providers = [getGHAToken, getEnv];
      class CIContextProvider {
        constructor(audience = "sigstore") {
          this.audience = audience;
        }
        async getToken() {
          return Promise.any(
            providers.map((getToken) => getToken(this.audience)),
          ).catch(() => Promise.reject("CI: no tokens available"));
        }
      }
      exports.CIContextProvider = CIContextProvider;
      async function getGHAToken(audience) {
        if (
          !process.env.ACTIONS_ID_TOKEN_REQUEST_URL ||
          !process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN
        ) {
          return Promise.reject("no token available");
        }
        const url = new URL(process.env.ACTIONS_ID_TOKEN_REQUEST_URL);
        url.searchParams.append("audience", audience);
        const response = await (0, make_fetch_happen_1.default)(url.href, {
          retry: 2,
          headers: {
            Accept: "application/json",
            Authorization: `Bearer ${process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN}`,
          },
        });
        return response.json().then((data) => data.value);
      }
      async function getEnv() {
        if (!process.env.SIGSTORE_ID_TOKEN) {
          return Promise.reject("no token available");
        }
        return process.env.SIGSTORE_ID_TOKEN;
      }
    },
    4463: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CIContextProvider = void 0;
      var ci_1 = __nccwpck_require__(3110);
      Object.defineProperty(exports, "CIContextProvider", {
        enumerable: true,
        get: function () {
          return ci_1.CIContextProvider;
        },
      });
    },
    2071: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAWitness =
        exports.RekorWitness =
        exports.DEFAULT_REKOR_URL =
        exports.FulcioSigner =
        exports.DEFAULT_FULCIO_URL =
        exports.CIContextProvider =
        exports.InternalError =
        exports.MessageSignatureBundleBuilder =
        exports.DSSEBundleBuilder =
          void 0;
      var bundler_1 = __nccwpck_require__(4929);
      Object.defineProperty(exports, "DSSEBundleBuilder", {
        enumerable: true,
        get: function () {
          return bundler_1.DSSEBundleBuilder;
        },
      });
      Object.defineProperty(exports, "MessageSignatureBundleBuilder", {
        enumerable: true,
        get: function () {
          return bundler_1.MessageSignatureBundleBuilder;
        },
      });
      var error_1 = __nccwpck_require__(532);
      Object.defineProperty(exports, "InternalError", {
        enumerable: true,
        get: function () {
          return error_1.InternalError;
        },
      });
      var identity_1 = __nccwpck_require__(4463);
      Object.defineProperty(exports, "CIContextProvider", {
        enumerable: true,
        get: function () {
          return identity_1.CIContextProvider;
        },
      });
      var signer_1 = __nccwpck_require__(7551);
      Object.defineProperty(exports, "DEFAULT_FULCIO_URL", {
        enumerable: true,
        get: function () {
          return signer_1.DEFAULT_FULCIO_URL;
        },
      });
      Object.defineProperty(exports, "FulcioSigner", {
        enumerable: true,
        get: function () {
          return signer_1.FulcioSigner;
        },
      });
      var witness_1 = __nccwpck_require__(2170);
      Object.defineProperty(exports, "DEFAULT_REKOR_URL", {
        enumerable: true,
        get: function () {
          return witness_1.DEFAULT_REKOR_URL;
        },
      });
      Object.defineProperty(exports, "RekorWitness", {
        enumerable: true,
        get: function () {
          return witness_1.RekorWitness;
        },
      });
      Object.defineProperty(exports, "TSAWitness", {
        enumerable: true,
        get: function () {
          return witness_1.TSAWitness;
        },
      });
    },
    334: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CAClient = void 0;
      const error_1 = __nccwpck_require__(532);
      const fulcio_1 = __nccwpck_require__(2960);
      class CAClient {
        constructor(options) {
          this.fulcio = new fulcio_1.Fulcio({
            baseURL: options.fulcioBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async createSigningCertificate(identityToken, publicKey, challenge) {
          const request = toCertificateRequest(
            identityToken,
            publicKey,
            challenge,
          );
          try {
            const resp = await this.fulcio.createSigningCertificate(request);
            const cert = resp.signedCertificateEmbeddedSct
              ? resp.signedCertificateEmbeddedSct
              : resp.signedCertificateDetachedSct;
            return cert.chain.certificates;
          } catch (err) {
            (0, error_1.internalError)(
              err,
              "CA_CREATE_SIGNING_CERTIFICATE_ERROR",
              "error creating signing certificate",
            );
          }
        }
      }
      exports.CAClient = CAClient;
      function toCertificateRequest(identityToken, publicKey, challenge) {
        return {
          credentials: { oidcIdentityToken: identityToken },
          publicKeyRequest: {
            publicKey: { algorithm: "ECDSA", content: publicKey },
            proofOfPossession: challenge.toString("base64"),
          },
        };
      }
    },
    8489: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.EphemeralSigner = void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const EC_KEYPAIR_TYPE = "ec";
      const P256_CURVE = "P-256";
      class EphemeralSigner {
        constructor() {
          this.keypair = crypto_1.default.generateKeyPairSync(EC_KEYPAIR_TYPE, {
            namedCurve: P256_CURVE,
          });
        }
        async sign(data) {
          const signature = crypto_1.default.sign(
            null,
            data,
            this.keypair.privateKey,
          );
          const publicKey = this.keypair.publicKey
            .export({ format: "pem", type: "spki" })
            .toString("ascii");
          return { signature, key: { $case: "publicKey", publicKey } };
        }
      }
      exports.EphemeralSigner = EphemeralSigner;
    },
    7328: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FulcioSigner = exports.DEFAULT_FULCIO_URL = void 0;
      const error_1 = __nccwpck_require__(532);
      const util_1 = __nccwpck_require__(724);
      const ca_1 = __nccwpck_require__(334);
      const ephemeral_1 = __nccwpck_require__(8489);
      exports.DEFAULT_FULCIO_URL = "https://fulcio.sigstore.dev";
      class FulcioSigner {
        constructor(options) {
          this.ca = new ca_1.CAClient({
            ...options,
            fulcioBaseURL: options.fulcioBaseURL || exports.DEFAULT_FULCIO_URL,
          });
          this.identityProvider = options.identityProvider;
          this.keyHolder =
            options.keyHolder || new ephemeral_1.EphemeralSigner();
        }
        async sign(data) {
          const identityToken = await this.getIdentityToken();
          let subject;
          try {
            subject = util_1.oidc.extractJWTSubject(identityToken);
          } catch (err) {
            throw new error_1.InternalError({
              code: "IDENTITY_TOKEN_PARSE_ERROR",
              message: `invalid identity token: ${identityToken}`,
              cause: err,
            });
          }
          const challenge = await this.keyHolder.sign(Buffer.from(subject));
          if (challenge.key.$case !== "publicKey") {
            throw new error_1.InternalError({
              code: "CA_CREATE_SIGNING_CERTIFICATE_ERROR",
              message: "unexpected format for signing key",
            });
          }
          const certificates = await this.ca.createSigningCertificate(
            identityToken,
            challenge.key.publicKey,
            challenge.signature,
          );
          const signature = await this.keyHolder.sign(data);
          return {
            signature: signature.signature,
            key: { $case: "x509Certificate", certificate: certificates[0] },
          };
        }
        async getIdentityToken() {
          try {
            return await this.identityProvider.getToken();
          } catch (err) {
            throw new error_1.InternalError({
              code: "IDENTITY_TOKEN_READ_ERROR",
              message: "error retrieving identity token",
              cause: err,
            });
          }
        }
      }
      exports.FulcioSigner = FulcioSigner;
    },
    7551: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.FulcioSigner = exports.DEFAULT_FULCIO_URL = void 0;
      var fulcio_1 = __nccwpck_require__(7328);
      Object.defineProperty(exports, "DEFAULT_FULCIO_URL", {
        enumerable: true,
        get: function () {
          return fulcio_1.DEFAULT_FULCIO_URL;
        },
      });
      Object.defineProperty(exports, "FulcioSigner", {
        enumerable: true,
        get: function () {
          return fulcio_1.FulcioSigner;
        },
      });
    },
    724: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ua =
        exports.oidc =
        exports.pem =
        exports.json =
        exports.encoding =
        exports.dsse =
        exports.crypto =
          void 0;
      var core_1 = __nccwpck_require__(3352);
      Object.defineProperty(exports, "crypto", {
        enumerable: true,
        get: function () {
          return core_1.crypto;
        },
      });
      Object.defineProperty(exports, "dsse", {
        enumerable: true,
        get: function () {
          return core_1.dsse;
        },
      });
      Object.defineProperty(exports, "encoding", {
        enumerable: true,
        get: function () {
          return core_1.encoding;
        },
      });
      Object.defineProperty(exports, "json", {
        enumerable: true,
        get: function () {
          return core_1.json;
        },
      });
      Object.defineProperty(exports, "pem", {
        enumerable: true,
        get: function () {
          return core_1.pem;
        },
      });
      exports.oidc = __importStar(__nccwpck_require__(3397));
      exports.ua = __importStar(__nccwpck_require__(6253));
    },
    3397: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.extractJWTSubject = void 0;
      const core_1 = __nccwpck_require__(3352);
      function extractJWTSubject(jwt) {
        const parts = jwt.split(".", 3);
        const payload = JSON.parse(core_1.encoding.base64Decode(parts[1]));
        switch (payload.iss) {
          case "https://accounts.google.com":
          case "https://oauth2.sigstore.dev/auth":
            return payload.email;
          default:
            return payload.sub;
        }
      }
      exports.extractJWTSubject = extractJWTSubject;
    },
    6253: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getUserAgent = void 0;
      const os_1 = __importDefault(__nccwpck_require__(2037));
      const getUserAgent = () => {
        const packageVersion = __nccwpck_require__(3684).version;
        const nodeVersion = process.version;
        const platformName = os_1.default.platform();
        const archName = os_1.default.arch();
        return `sigstore-js/${packageVersion} (Node ${nodeVersion}) (${platformName}/${archName})`;
      };
      exports.getUserAgent = getUserAgent;
    },
    2170: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAWitness =
        exports.RekorWitness =
        exports.DEFAULT_REKOR_URL =
          void 0;
      var tlog_1 = __nccwpck_require__(7843);
      Object.defineProperty(exports, "DEFAULT_REKOR_URL", {
        enumerable: true,
        get: function () {
          return tlog_1.DEFAULT_REKOR_URL;
        },
      });
      Object.defineProperty(exports, "RekorWitness", {
        enumerable: true,
        get: function () {
          return tlog_1.RekorWitness;
        },
      });
      var tsa_1 = __nccwpck_require__(49);
      Object.defineProperty(exports, "TSAWitness", {
        enumerable: true,
        get: function () {
          return tsa_1.TSAWitness;
        },
      });
    },
    6737: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TLogClient = void 0;
      const error_1 = __nccwpck_require__(532);
      const error_2 = __nccwpck_require__(1294);
      const rekor_1 = __nccwpck_require__(6205);
      class TLogClient {
        constructor(options) {
          this.fetchOnConflict = options.fetchOnConflict ?? false;
          this.rekor = new rekor_1.Rekor({
            baseURL: options.rekorBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async createEntry(proposedEntry) {
          let entry;
          try {
            entry = await this.rekor.createEntry(proposedEntry);
          } catch (err) {
            if (entryExistsError(err) && this.fetchOnConflict) {
              const uuid = err.location.split("/").pop() || "";
              try {
                entry = await this.rekor.getEntry(uuid);
              } catch (err) {
                (0, error_1.internalError)(
                  err,
                  "TLOG_FETCH_ENTRY_ERROR",
                  "error fetching tlog entry",
                );
              }
            } else {
              (0, error_1.internalError)(
                err,
                "TLOG_CREATE_ENTRY_ERROR",
                "error creating tlog entry",
              );
            }
          }
          return entry;
        }
      }
      exports.TLogClient = TLogClient;
      function entryExistsError(value) {
        return (
          value instanceof error_2.HTTPError &&
          value.statusCode === 409 &&
          value.location !== undefined
        );
      }
    },
    3776: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toProposedEntry = void 0;
      const bundle_1 = __nccwpck_require__(9715);
      const util_1 = __nccwpck_require__(724);
      function toProposedEntry(content, publicKey, entryType = "intoto") {
        switch (content.$case) {
          case "dsseEnvelope":
            if (entryType === "dsse") {
              return toProposedDSSEEntry(content.dsseEnvelope, publicKey);
            }
            return toProposedIntotoEntry(content.dsseEnvelope, publicKey);
          case "messageSignature":
            return toProposedHashedRekordEntry(
              content.messageSignature,
              publicKey,
            );
        }
      }
      exports.toProposedEntry = toProposedEntry;
      function toProposedHashedRekordEntry(messageSignature, publicKey) {
        const hexDigest = messageSignature.messageDigest.digest.toString("hex");
        const b64Signature = messageSignature.signature.toString("base64");
        const b64Key = util_1.encoding.base64Encode(publicKey);
        return {
          apiVersion: "0.0.1",
          kind: "hashedrekord",
          spec: {
            data: { hash: { algorithm: "sha256", value: hexDigest } },
            signature: {
              content: b64Signature,
              publicKey: { content: b64Key },
            },
          },
        };
      }
      function toProposedDSSEEntry(envelope, publicKey) {
        const envelopeJSON = JSON.stringify(
          (0, bundle_1.envelopeToJSON)(envelope),
        );
        const encodedKey = util_1.encoding.base64Encode(publicKey);
        return {
          apiVersion: "0.0.1",
          kind: "dsse",
          spec: {
            proposedContent: {
              envelope: envelopeJSON,
              verifiers: [encodedKey],
            },
          },
        };
      }
      function toProposedIntotoEntry(envelope, publicKey) {
        const payloadHash = util_1.crypto
          .hash(envelope.payload)
          .toString("hex");
        const envelopeHash = calculateDSSEHash(envelope, publicKey);
        const payload = util_1.encoding.base64Encode(
          envelope.payload.toString("base64"),
        );
        const sig = util_1.encoding.base64Encode(
          envelope.signatures[0].sig.toString("base64"),
        );
        const keyid = envelope.signatures[0].keyid;
        const encodedKey = util_1.encoding.base64Encode(publicKey);
        const dsse = {
          payloadType: envelope.payloadType,
          payload,
          signatures: [{ sig, publicKey: encodedKey }],
        };
        if (keyid.length > 0) {
          dsse.signatures[0].keyid = keyid;
        }
        return {
          apiVersion: "0.0.2",
          kind: "intoto",
          spec: {
            content: {
              envelope: dsse,
              hash: { algorithm: "sha256", value: envelopeHash },
              payloadHash: { algorithm: "sha256", value: payloadHash },
            },
          },
        };
      }
      function calculateDSSEHash(envelope, publicKey) {
        const dsse = {
          payloadType: envelope.payloadType,
          payload: envelope.payload.toString("base64"),
          signatures: [
            { sig: envelope.signatures[0].sig.toString("base64"), publicKey },
          ],
        };
        if (envelope.signatures[0].keyid.length > 0) {
          dsse.signatures[0].keyid = envelope.signatures[0].keyid;
        }
        return util_1.crypto
          .hash(util_1.json.canonicalize(dsse))
          .toString("hex");
      }
    },
    7843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RekorWitness = exports.DEFAULT_REKOR_URL = void 0;
      const util_1 = __nccwpck_require__(724);
      const client_1 = __nccwpck_require__(6737);
      const entry_1 = __nccwpck_require__(3776);
      exports.DEFAULT_REKOR_URL = "https://rekor.sigstore.dev";
      class RekorWitness {
        constructor(options) {
          this.entryType = options.entryType;
          this.tlog = new client_1.TLogClient({
            ...options,
            rekorBaseURL: options.rekorBaseURL || exports.DEFAULT_REKOR_URL,
          });
        }
        async testify(content, publicKey) {
          const proposedEntry = (0, entry_1.toProposedEntry)(
            content,
            publicKey,
            this.entryType,
          );
          const entry = await this.tlog.createEntry(proposedEntry);
          return toTransparencyLogEntry(entry);
        }
      }
      exports.RekorWitness = RekorWitness;
      function toTransparencyLogEntry(entry) {
        const logID = Buffer.from(entry.logID, "hex");
        const bodyJSON = util_1.encoding.base64Decode(entry.body);
        const entryBody = JSON.parse(bodyJSON);
        const promise = entry?.verification?.signedEntryTimestamp
          ? inclusionPromise(entry.verification.signedEntryTimestamp)
          : undefined;
        const proof = entry?.verification?.inclusionProof
          ? inclusionProof(entry.verification.inclusionProof)
          : undefined;
        const tlogEntry = {
          logIndex: entry.logIndex.toString(),
          logId: { keyId: logID },
          integratedTime: entry.integratedTime.toString(),
          kindVersion: { kind: entryBody.kind, version: entryBody.apiVersion },
          inclusionPromise: promise,
          inclusionProof: proof,
          canonicalizedBody: Buffer.from(entry.body, "base64"),
        };
        return { tlogEntries: [tlogEntry] };
      }
      function inclusionPromise(promise) {
        return { signedEntryTimestamp: Buffer.from(promise, "base64") };
      }
      function inclusionProof(proof) {
        return {
          logIndex: proof.logIndex.toString(),
          treeSize: proof.treeSize.toString(),
          rootHash: Buffer.from(proof.rootHash, "hex"),
          hashes: proof.hashes.map((h) => Buffer.from(h, "hex")),
          checkpoint: { envelope: proof.checkpoint },
        };
      }
    },
    2239: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAClient = void 0;
      const error_1 = __nccwpck_require__(532);
      const tsa_1 = __nccwpck_require__(2759);
      const util_1 = __nccwpck_require__(724);
      class TSAClient {
        constructor(options) {
          this.tsa = new tsa_1.TimestampAuthority({
            baseURL: options.tsaBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async createTimestamp(signature) {
          const request = {
            artifactHash: util_1.crypto.hash(signature).toString("base64"),
            hashAlgorithm: "sha256",
          };
          try {
            return await this.tsa.createTimestamp(request);
          } catch (err) {
            (0, error_1.internalError)(
              err,
              "TSA_CREATE_TIMESTAMP_ERROR",
              "error creating timestamp",
            );
          }
        }
      }
      exports.TSAClient = TSAClient;
    },
    49: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TSAWitness = void 0;
      const client_1 = __nccwpck_require__(2239);
      class TSAWitness {
        constructor(options) {
          this.tsa = new client_1.TSAClient({
            tsaBaseURL: options.tsaBaseURL,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async testify(content) {
          const signature = extractSignature(content);
          const timestamp = await this.tsa.createTimestamp(signature);
          return { rfc3161Timestamps: [{ signedTimestamp: timestamp }] };
        }
      }
      exports.TSAWitness = TSAWitness;
      function extractSignature(content) {
        switch (content.$case) {
          case "dsseEnvelope":
            return content.dsseEnvelope.signatures[0].sig;
          case "messageSignature":
            return content.messageSignature.signature;
        }
      }
    },
    8134: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.appDataPath = void 0;
      const os_1 = __importDefault(__nccwpck_require__(2037));
      const path_1 = __importDefault(__nccwpck_require__(1017));
      function appDataPath(name) {
        const homedir = os_1.default.homedir();
        switch (process.platform) {
          case "darwin": {
            const appSupport = path_1.default.join(
              homedir,
              "Library",
              "Application Support",
            );
            return path_1.default.join(appSupport, name);
          }
          case "win32": {
            const localAppData =
              process.env.LOCALAPPDATA ||
              path_1.default.join(homedir, "AppData", "Local");
            return path_1.default.join(localAppData, name, "Data");
          }
          default: {
            const localData =
              process.env.XDG_DATA_HOME ||
              path_1.default.join(homedir, ".local", "share");
            return path_1.default.join(localData, name);
          }
        }
      }
      exports.appDataPath = appDataPath;
    },
    8447: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TUFClient = void 0;
      const fs_1 = __importDefault(__nccwpck_require__(7147));
      const path_1 = __importDefault(__nccwpck_require__(1017));
      const tuf_js_1 = __nccwpck_require__(9475);
      const _1 = __nccwpck_require__(8567);
      const target_1 = __nccwpck_require__(1412);
      const TARGETS_DIR_NAME = "targets";
      class TUFClient {
        constructor(options) {
          const url = new URL(options.mirrorURL);
          const repoName = encodeURIComponent(
            url.host + url.pathname.replace(/\/$/, ""),
          );
          const cachePath = path_1.default.join(options.cachePath, repoName);
          initTufCache(cachePath);
          seedCache({
            cachePath,
            mirrorURL: options.mirrorURL,
            tufRootPath: options.rootPath,
            forceInit: options.forceInit,
          });
          this.updater = initClient({
            mirrorURL: options.mirrorURL,
            cachePath,
            forceCache: options.forceCache,
            retry: options.retry,
            timeout: options.timeout,
          });
        }
        async refresh() {
          return this.updater.refresh();
        }
        getTarget(targetName) {
          return (0, target_1.readTarget)(this.updater, targetName);
        }
      }
      exports.TUFClient = TUFClient;
      function initTufCache(cachePath) {
        const targetsPath = path_1.default.join(cachePath, TARGETS_DIR_NAME);
        if (!fs_1.default.existsSync(cachePath)) {
          fs_1.default.mkdirSync(cachePath, { recursive: true });
        }
        if (!fs_1.default.existsSync(targetsPath)) {
          fs_1.default.mkdirSync(targetsPath);
        }
      }
      function seedCache({ cachePath, mirrorURL, tufRootPath, forceInit }) {
        const cachedRootPath = path_1.default.join(cachePath, "root.json");
        if (!fs_1.default.existsSync(cachedRootPath) || forceInit) {
          if (tufRootPath) {
            fs_1.default.copyFileSync(tufRootPath, cachedRootPath);
          } else {
            const seeds = __nccwpck_require__(4998);
            const repoSeed = seeds[mirrorURL];
            if (!repoSeed) {
              throw new _1.TUFError({
                code: "TUF_INIT_CACHE_ERROR",
                message: `No root.json found for mirror: ${mirrorURL}`,
              });
            }
            fs_1.default.writeFileSync(
              cachedRootPath,
              Buffer.from(repoSeed["root.json"], "base64"),
            );
            Object.entries(repoSeed.targets).forEach(([targetName, target]) => {
              fs_1.default.writeFileSync(
                path_1.default.join(cachePath, TARGETS_DIR_NAME, targetName),
                Buffer.from(target, "base64"),
              );
            });
          }
        }
      }
      function initClient(options) {
        const config = {
          fetchTimeout: options.timeout,
          fetchRetry: options.retry,
        };
        return new tuf_js_1.Updater({
          metadataBaseUrl: options.mirrorURL,
          targetBaseUrl: `${options.mirrorURL}/targets`,
          metadataDir: options.cachePath,
          targetDir: path_1.default.join(options.cachePath, TARGETS_DIR_NAME),
          forceCache: options.forceCache,
          config,
        });
      }
    },
    8624: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TUFError = void 0;
      class TUFError extends Error {
        constructor({ code, message, cause }) {
          super(message);
          this.code = code;
          this.cause = cause;
          this.name = this.constructor.name;
        }
      }
      exports.TUFError = TUFError;
    },
    8567: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TUFError =
        exports.initTUF =
        exports.getTrustedRoot =
        exports.DEFAULT_MIRROR_URL =
          void 0;
      const protobuf_specs_1 = __nccwpck_require__(530);
      const appdata_1 = __nccwpck_require__(8134);
      const client_1 = __nccwpck_require__(8447);
      exports.DEFAULT_MIRROR_URL = "https://tuf-repo-cdn.sigstore.dev";
      const DEFAULT_CACHE_DIR = "sigstore-js";
      const DEFAULT_RETRY = { retries: 2 };
      const DEFAULT_TIMEOUT = 5e3;
      const TRUSTED_ROOT_TARGET = "trusted_root.json";
      async function getTrustedRoot(options = {}) {
        const client = createClient(options);
        const trustedRoot = await client.getTarget(TRUSTED_ROOT_TARGET);
        return protobuf_specs_1.TrustedRoot.fromJSON(JSON.parse(trustedRoot));
      }
      exports.getTrustedRoot = getTrustedRoot;
      async function initTUF(options = {}) {
        const client = createClient(options);
        return client.refresh().then(() => client);
      }
      exports.initTUF = initTUF;
      function createClient(options) {
        return new client_1.TUFClient({
          cachePath:
            options.cachePath || (0, appdata_1.appDataPath)(DEFAULT_CACHE_DIR),
          rootPath: options.rootPath,
          mirrorURL: options.mirrorURL || exports.DEFAULT_MIRROR_URL,
          retry: options.retry ?? DEFAULT_RETRY,
          timeout: options.timeout ?? DEFAULT_TIMEOUT,
          forceCache: options.forceCache ?? false,
          forceInit: options.forceInit ?? options.force ?? false,
        });
      }
      var error_1 = __nccwpck_require__(8624);
      Object.defineProperty(exports, "TUFError", {
        enumerable: true,
        get: function () {
          return error_1.TUFError;
        },
      });
    },
    1412: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.readTarget = void 0;
      const fs_1 = __importDefault(__nccwpck_require__(7147));
      const error_1 = __nccwpck_require__(8624);
      async function readTarget(tuf, targetPath) {
        const path = await getTargetPath(tuf, targetPath);
        return new Promise((resolve, reject) => {
          fs_1.default.readFile(path, "utf-8", (err, data) => {
            if (err) {
              reject(
                new error_1.TUFError({
                  code: "TUF_READ_TARGET_ERROR",
                  message: `error reading target ${path}`,
                  cause: err,
                }),
              );
            } else {
              resolve(data);
            }
          });
        });
      }
      exports.readTarget = readTarget;
      async function getTargetPath(tuf, target) {
        let targetInfo;
        try {
          targetInfo = await tuf.getTargetInfo(target);
        } catch (err) {
          throw new error_1.TUFError({
            code: "TUF_REFRESH_METADATA_ERROR",
            message: "error refreshing TUF metadata",
            cause: err,
          });
        }
        if (!targetInfo) {
          throw new error_1.TUFError({
            code: "TUF_FIND_TARGET_ERROR",
            message: `target ${target} not found`,
          });
        }
        let path = await tuf.findCachedTarget(targetInfo);
        if (!path) {
          try {
            path = await tuf.downloadTarget(targetInfo);
          } catch (err) {
            throw new error_1.TUFError({
              code: "TUF_DOWNLOAD_TARGET_ERROR",
              message: `error downloading target ${path}`,
              cause: err,
            });
          }
        }
        return path;
      }
    },
    4542: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DSSESignatureContent = void 0;
      const core_1 = __nccwpck_require__(3352);
      class DSSESignatureContent {
        constructor(env) {
          this.env = env;
        }
        compareDigest(digest) {
          return core_1.crypto.bufferEqual(
            digest,
            core_1.crypto.hash(this.env.payload),
          );
        }
        compareSignature(signature) {
          return core_1.crypto.bufferEqual(signature, this.signature);
        }
        verifySignature(key) {
          return core_1.crypto.verify(
            this.preAuthEncoding,
            key,
            this.signature,
          );
        }
        get signature() {
          return this.env.signatures.length > 0
            ? this.env.signatures[0].sig
            : Buffer.from("");
        }
        get preAuthEncoding() {
          return core_1.dsse.preAuthEncoding(
            this.env.payloadType,
            this.env.payload,
          );
        }
      }
      exports.DSSESignatureContent = DSSESignatureContent;
    },
    9045: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.signatureContent = exports.toSignedEntity = void 0;
      const core_1 = __nccwpck_require__(3352);
      const dsse_1 = __nccwpck_require__(4542);
      const message_1 = __nccwpck_require__(6843);
      function toSignedEntity(bundle, artifact) {
        const { tlogEntries, timestampVerificationData } =
          bundle.verificationMaterial;
        const timestamps = [];
        for (const entry of tlogEntries) {
          timestamps.push({ $case: "transparency-log", tlogEntry: entry });
        }
        for (const ts of timestampVerificationData?.rfc3161Timestamps ?? []) {
          timestamps.push({
            $case: "timestamp-authority",
            timestamp: core_1.RFC3161Timestamp.parse(ts.signedTimestamp),
          });
        }
        return {
          signature: signatureContent(bundle, artifact),
          key: key(bundle),
          tlogEntries,
          timestamps,
        };
      }
      exports.toSignedEntity = toSignedEntity;
      function signatureContent(bundle, artifact) {
        switch (bundle.content.$case) {
          case "dsseEnvelope":
            return new dsse_1.DSSESignatureContent(bundle.content.dsseEnvelope);
          case "messageSignature":
            return new message_1.MessageSignatureContent(
              bundle.content.messageSignature,
              artifact,
            );
        }
      }
      exports.signatureContent = signatureContent;
      function key(bundle) {
        switch (bundle.verificationMaterial.content.$case) {
          case "publicKey":
            return {
              $case: "public-key",
              hint: bundle.verificationMaterial.content.publicKey.hint,
            };
          case "x509CertificateChain":
            return {
              $case: "certificate",
              certificate: core_1.X509Certificate.parse(
                bundle.verificationMaterial.content.x509CertificateChain
                  .certificates[0].rawBytes,
              ),
            };
          case "certificate":
            return {
              $case: "certificate",
              certificate: core_1.X509Certificate.parse(
                bundle.verificationMaterial.content.certificate.rawBytes,
              ),
            };
        }
      }
    },
    6843: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.MessageSignatureContent = void 0;
      const core_1 = __nccwpck_require__(3352);
      class MessageSignatureContent {
        constructor(messageSignature, artifact) {
          this.signature = messageSignature.signature;
          this.messageDigest = messageSignature.messageDigest.digest;
          this.artifact = artifact;
        }
        compareSignature(signature) {
          return core_1.crypto.bufferEqual(signature, this.signature);
        }
        compareDigest(digest) {
          return core_1.crypto.bufferEqual(digest, this.messageDigest);
        }
        verifySignature(key) {
          return core_1.crypto.verify(this.artifact, key, this.signature);
        }
      }
      exports.MessageSignatureContent = MessageSignatureContent;
    },
    8948: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.PolicyError = exports.VerificationError = void 0;
      class BaseError extends Error {
        constructor({ code, message, cause }) {
          super(message);
          this.code = code;
          this.cause = cause;
          this.name = this.constructor.name;
        }
      }
      class VerificationError extends BaseError {}
      exports.VerificationError = VerificationError;
      class PolicyError extends BaseError {}
      exports.PolicyError = PolicyError;
    },
    666: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Verifier =
        exports.toTrustMaterial =
        exports.VerificationError =
        exports.PolicyError =
        exports.toSignedEntity =
          void 0;
      var bundle_1 = __nccwpck_require__(9045);
      Object.defineProperty(exports, "toSignedEntity", {
        enumerable: true,
        get: function () {
          return bundle_1.toSignedEntity;
        },
      });
      var error_1 = __nccwpck_require__(8948);
      Object.defineProperty(exports, "PolicyError", {
        enumerable: true,
        get: function () {
          return error_1.PolicyError;
        },
      });
      Object.defineProperty(exports, "VerificationError", {
        enumerable: true,
        get: function () {
          return error_1.VerificationError;
        },
      });
      var trust_1 = __nccwpck_require__(4503);
      Object.defineProperty(exports, "toTrustMaterial", {
        enumerable: true,
        get: function () {
          return trust_1.toTrustMaterial;
        },
      });
      var verifier_1 = __nccwpck_require__(5456);
      Object.defineProperty(exports, "Verifier", {
        enumerable: true,
        get: function () {
          return verifier_1.Verifier;
        },
      });
    },
    8766: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.CertificateChainVerifier = exports.verifyCertificateChain =
        void 0;
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      function verifyCertificateChain(leaf, certificateAuthorities) {
        const cas = (0, trust_1.filterCertAuthorities)(certificateAuthorities, {
          start: leaf.notBefore,
          end: leaf.notAfter,
        });
        let error;
        for (const ca of cas) {
          try {
            const verifier = new CertificateChainVerifier({
              trustedCerts: ca.certChain,
              untrustedCert: leaf,
            });
            return verifier.verify();
          } catch (err) {
            error = err;
          }
        }
        throw new error_1.VerificationError({
          code: "CERTIFICATE_ERROR",
          message: "Failed to verify certificate chain",
          cause: error,
        });
      }
      exports.verifyCertificateChain = verifyCertificateChain;
      class CertificateChainVerifier {
        constructor(opts) {
          this.untrustedCert = opts.untrustedCert;
          this.trustedCerts = opts.trustedCerts;
          this.localCerts = dedupeCertificates([
            ...opts.trustedCerts,
            opts.untrustedCert,
          ]);
        }
        verify() {
          const certificatePath = this.sort();
          this.checkPath(certificatePath);
          return certificatePath;
        }
        sort() {
          const leafCert = this.untrustedCert;
          let paths = this.buildPaths(leafCert);
          paths = paths.filter((path) =>
            path.some((cert) => this.trustedCerts.includes(cert)),
          );
          if (paths.length === 0) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "no trusted certificate path found",
            });
          }
          const path = paths.reduce((prev, curr) =>
            prev.length < curr.length ? prev : curr,
          );
          return [leafCert, ...path].slice(0, -1);
        }
        buildPaths(certificate) {
          const paths = [];
          const issuers = this.findIssuer(certificate);
          if (issuers.length === 0) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "no valid certificate path found",
            });
          }
          for (let i = 0; i < issuers.length; i++) {
            const issuer = issuers[i];
            if (issuer.equals(certificate)) {
              paths.push([certificate]);
              continue;
            }
            const subPaths = this.buildPaths(issuer);
            for (let j = 0; j < subPaths.length; j++) {
              paths.push([issuer, ...subPaths[j]]);
            }
          }
          return paths;
        }
        findIssuer(certificate) {
          let issuers = [];
          let keyIdentifier;
          if (certificate.subject.equals(certificate.issuer)) {
            if (certificate.verify()) {
              return [certificate];
            }
          }
          if (certificate.extAuthorityKeyID) {
            keyIdentifier = certificate.extAuthorityKeyID.keyIdentifier;
          }
          this.localCerts.forEach((possibleIssuer) => {
            if (keyIdentifier) {
              if (possibleIssuer.extSubjectKeyID) {
                if (
                  possibleIssuer.extSubjectKeyID.keyIdentifier.equals(
                    keyIdentifier,
                  )
                ) {
                  issuers.push(possibleIssuer);
                }
                return;
              }
            }
            if (possibleIssuer.subject.equals(certificate.issuer)) {
              issuers.push(possibleIssuer);
            }
          });
          issuers = issuers.filter((issuer) => {
            try {
              return certificate.verify(issuer);
            } catch (ex) {
              return false;
            }
          });
          return issuers;
        }
        checkPath(path) {
          if (path.length < 1) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message:
                "certificate chain must contain at least one certificate",
            });
          }
          const validCAs = path.slice(1).every((cert) => cert.isCA);
          if (!validCAs) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "intermediate certificate is not a CA",
            });
          }
          for (let i = path.length - 2; i >= 0; i--) {
            if (!path[i].issuer.equals(path[i + 1].subject)) {
              throw new error_1.VerificationError({
                code: "CERTIFICATE_ERROR",
                message: "incorrect certificate name chaining",
              });
            }
          }
          for (let i = 0; i < path.length; i++) {
            const cert = path[i];
            if (cert.extBasicConstraints?.isCA) {
              const pathLength = cert.extBasicConstraints.pathLenConstraint;
              if (pathLength !== undefined && pathLength < i - 1) {
                throw new error_1.VerificationError({
                  code: "CERTIFICATE_ERROR",
                  message: "path length constraint exceeded",
                });
              }
            }
          }
        }
      }
      exports.CertificateChainVerifier = CertificateChainVerifier;
      function dedupeCertificates(certs) {
        for (let i = 0; i < certs.length; i++) {
          for (let j = i + 1; j < certs.length; j++) {
            if (certs[i].equals(certs[j])) {
              certs.splice(j, 1);
              j--;
            }
          }
        }
        return certs;
      }
    },
    6829: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyCertificate = exports.verifyPublicKey = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const certificate_1 = __nccwpck_require__(8766);
      const sct_1 = __nccwpck_require__(8669);
      const OID_FULCIO_ISSUER_V1 = "1.3.6.1.4.1.57264.1.1";
      const OID_FULCIO_ISSUER_V2 = "1.3.6.1.4.1.57264.1.8";
      function verifyPublicKey(hint, timestamps, trustMaterial) {
        const key = trustMaterial.publicKey(hint);
        timestamps.forEach((timestamp) => {
          if (!key.validFor(timestamp)) {
            throw new error_1.VerificationError({
              code: "PUBLIC_KEY_ERROR",
              message: `Public key is not valid for timestamp: ${timestamp.toISOString()}`,
            });
          }
        });
        return { key: key.publicKey };
      }
      exports.verifyPublicKey = verifyPublicKey;
      function verifyCertificate(leaf, timestamps, trustMaterial) {
        const path = (0, certificate_1.verifyCertificateChain)(
          leaf,
          trustMaterial.certificateAuthorities,
        );
        const validForDate = timestamps.every((timestamp) =>
          path.every((cert) => cert.validForDate(timestamp)),
        );
        if (!validForDate) {
          throw new error_1.VerificationError({
            code: "CERTIFICATE_ERROR",
            message:
              "certificate is not valid or expired at the specified date",
          });
        }
        return {
          scts: (0, sct_1.verifySCTs)(path[0], path[1], trustMaterial.ctlogs),
          signer: getSigner(path[0]),
        };
      }
      exports.verifyCertificate = verifyCertificate;
      function getSigner(cert) {
        let issuer;
        const issuerExtension = cert.extension(OID_FULCIO_ISSUER_V2);
        if (issuerExtension) {
          issuer = issuerExtension.valueObj.subs?.[0]?.value.toString("ascii");
        } else {
          issuer = cert
            .extension(OID_FULCIO_ISSUER_V1)
            ?.value.toString("ascii");
        }
        const identity = {
          extensions: { issuer },
          subjectAlternativeName: cert.subjectAltName,
        };
        return { key: core_1.crypto.createPublicKey(cert.publicKey), identity };
      }
    },
    8669: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifySCTs = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      function verifySCTs(cert, issuer, ctlogs) {
        let extSCT;
        const clone = cert.clone();
        for (let i = 0; i < clone.extensions.length; i++) {
          const ext = clone.extensions[i];
          if (ext.subs[0].toOID() === core_1.EXTENSION_OID_SCT) {
            extSCT = new core_1.X509SCTExtension(ext);
            clone.extensions.splice(i, 1);
            break;
          }
        }
        if (!extSCT) {
          return [];
        }
        if (extSCT.signedCertificateTimestamps.length === 0) {
          return [];
        }
        const preCert = new core_1.ByteStream();
        const issuerId = core_1.crypto.hash(issuer.publicKey);
        preCert.appendView(issuerId);
        const tbs = clone.tbsCertificate.toDER();
        preCert.appendUint24(tbs.length);
        preCert.appendView(tbs);
        return extSCT.signedCertificateTimestamps.map((sct) => {
          const validCTLogs = (0, trust_1.filterTLogAuthorities)(ctlogs, {
            logID: sct.logID,
            targetDate: sct.datetime,
          });
          const verified = validCTLogs.some((log) =>
            sct.verify(preCert.buffer, log.publicKey),
          );
          if (!verified) {
            throw new error_1.VerificationError({
              code: "CERTIFICATE_ERROR",
              message: "SCT verification failed",
            });
          }
          return sct.logID;
        });
      }
      exports.verifySCTs = verifySCTs;
    },
    3978: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyExtensions = exports.verifySubjectAlternativeName = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifySubjectAlternativeName(policyIdentity, signerIdentity) {
        if (
          signerIdentity === undefined ||
          !signerIdentity.match(policyIdentity)
        ) {
          throw new error_1.PolicyError({
            code: "UNTRUSTED_SIGNER_ERROR",
            message: `certificate identity error - expected ${policyIdentity}, got ${signerIdentity}`,
          });
        }
      }
      exports.verifySubjectAlternativeName = verifySubjectAlternativeName;
      function verifyExtensions(policyExtensions, signerExtensions = {}) {
        let key;
        for (key in policyExtensions) {
          if (signerExtensions[key] !== policyExtensions[key]) {
            throw new error_1.PolicyError({
              code: "UNTRUSTED_SIGNER_ERROR",
              message: `invalid certificate extension - expected ${key}=${policyExtensions[key]}, got ${key}=${signerExtensions[key]}`,
            });
          }
        }
      }
      exports.verifyExtensions = verifyExtensions;
    },
    7339: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyCheckpoint = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      const CHECKPOINT_SEPARATOR = "\n\n";
      const SIGNATURE_REGEX = /\u2014 (\S+) (\S+)\n/g;
      function verifyCheckpoint(entry, tlogs) {
        const validTLogs = (0, trust_1.filterTLogAuthorities)(tlogs, {
          targetDate: new Date(Number(entry.integratedTime) * 1e3),
        });
        const inclusionProof = entry.inclusionProof;
        const signedNote = SignedNote.fromString(
          inclusionProof.checkpoint.envelope,
        );
        const checkpoint = LogCheckpoint.fromString(signedNote.note);
        if (!verifySignedNote(signedNote, validTLogs)) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "invalid checkpoint signature",
          });
        }
        if (
          !core_1.crypto.bufferEqual(
            checkpoint.logHash,
            inclusionProof.rootHash,
          )
        ) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "root hash mismatch",
          });
        }
      }
      exports.verifyCheckpoint = verifyCheckpoint;
      function verifySignedNote(signedNote, tlogs) {
        const data = Buffer.from(signedNote.note, "utf-8");
        return signedNote.signatures.every((signature) => {
          const tlog = tlogs.find((tlog) =>
            core_1.crypto.bufferEqual(
              tlog.logID.subarray(0, 4),
              signature.keyHint,
            ),
          );
          if (!tlog) {
            return false;
          }
          return core_1.crypto.verify(
            data,
            tlog.publicKey,
            signature.signature,
          );
        });
      }
      class SignedNote {
        constructor(note, signatures) {
          this.note = note;
          this.signatures = signatures;
        }
        static fromString(envelope) {
          if (!envelope.includes(CHECKPOINT_SEPARATOR)) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "missing checkpoint separator",
            });
          }
          const split = envelope.indexOf(CHECKPOINT_SEPARATOR);
          const header = envelope.slice(0, split + 1);
          const data = envelope.slice(split + CHECKPOINT_SEPARATOR.length);
          const matches = data.matchAll(SIGNATURE_REGEX);
          const signatures = Array.from(matches, (match) => {
            const [, name, signature] = match;
            const sigBytes = Buffer.from(signature, "base64");
            if (sigBytes.length < 5) {
              throw new error_1.VerificationError({
                code: "TLOG_INCLUSION_PROOF_ERROR",
                message: "malformed checkpoint signature",
              });
            }
            return {
              name,
              keyHint: sigBytes.subarray(0, 4),
              signature: sigBytes.subarray(4),
            };
          });
          if (signatures.length === 0) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "no signatures found in checkpoint",
            });
          }
          return new SignedNote(header, signatures);
        }
      }
      class LogCheckpoint {
        constructor(origin, logSize, logHash, rest) {
          this.origin = origin;
          this.logSize = logSize;
          this.logHash = logHash;
          this.rest = rest;
        }
        static fromString(note) {
          const lines = note.trimEnd().split("\n");
          if (lines.length < 3) {
            throw new error_1.VerificationError({
              code: "TLOG_INCLUSION_PROOF_ERROR",
              message: "too few lines in checkpoint header",
            });
          }
          const origin = lines[0];
          const logSize = BigInt(lines[1]);
          const rootHash = Buffer.from(lines[2], "base64");
          const rest = lines.slice(3);
          return new LogCheckpoint(origin, logSize, rootHash, rest);
        }
      }
    },
    9511: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyTLogTimestamp = exports.verifyTSATimestamp = void 0;
      const error_1 = __nccwpck_require__(8948);
      const checkpoint_1 = __nccwpck_require__(7339);
      const merkle_1 = __nccwpck_require__(1407);
      const set_1 = __nccwpck_require__(7527);
      const tsa_1 = __nccwpck_require__(2574);
      function verifyTSATimestamp(timestamp, data, timestampAuthorities) {
        (0, tsa_1.verifyRFC3161Timestamp)(
          timestamp,
          data,
          timestampAuthorities,
        );
        return {
          type: "timestamp-authority",
          logID: timestamp.signerSerialNumber,
          timestamp: timestamp.signingTime,
        };
      }
      exports.verifyTSATimestamp = verifyTSATimestamp;
      function verifyTLogTimestamp(entry, tlogAuthorities) {
        let inclusionVerified = false;
        if (isTLogEntryWithInclusionPromise(entry)) {
          (0, set_1.verifyTLogSET)(entry, tlogAuthorities);
          inclusionVerified = true;
        }
        if (isTLogEntryWithInclusionProof(entry)) {
          (0, merkle_1.verifyMerkleInclusion)(entry);
          (0, checkpoint_1.verifyCheckpoint)(entry, tlogAuthorities);
          inclusionVerified = true;
        }
        if (!inclusionVerified) {
          throw new error_1.VerificationError({
            code: "TLOG_MISSING_INCLUSION_ERROR",
            message: "inclusion could not be verified",
          });
        }
        return {
          type: "transparency-log",
          logID: entry.logId.keyId,
          timestamp: new Date(Number(entry.integratedTime) * 1e3),
        };
      }
      exports.verifyTLogTimestamp = verifyTLogTimestamp;
      function isTLogEntryWithInclusionPromise(entry) {
        return entry.inclusionPromise !== undefined;
      }
      function isTLogEntryWithInclusionProof(entry) {
        return entry.inclusionProof !== undefined;
      }
    },
    1407: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyMerkleInclusion = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const RFC6962_LEAF_HASH_PREFIX = Buffer.from([0]);
      const RFC6962_NODE_HASH_PREFIX = Buffer.from([1]);
      function verifyMerkleInclusion(entry) {
        const inclusionProof = entry.inclusionProof;
        const logIndex = BigInt(inclusionProof.logIndex);
        const treeSize = BigInt(inclusionProof.treeSize);
        if (logIndex < 0n || logIndex >= treeSize) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: `invalid index: ${logIndex}`,
          });
        }
        const { inner, border } = decompInclProof(logIndex, treeSize);
        if (inclusionProof.hashes.length !== inner + border) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "invalid hash count",
          });
        }
        const innerHashes = inclusionProof.hashes.slice(0, inner);
        const borderHashes = inclusionProof.hashes.slice(inner);
        const leafHash = hashLeaf(entry.canonicalizedBody);
        const calculatedHash = chainBorderRight(
          chainInner(leafHash, innerHashes, logIndex),
          borderHashes,
        );
        if (
          !core_1.crypto.bufferEqual(calculatedHash, inclusionProof.rootHash)
        ) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROOF_ERROR",
            message: "calculated root hash does not match inclusion proof",
          });
        }
      }
      exports.verifyMerkleInclusion = verifyMerkleInclusion;
      function decompInclProof(index, size) {
        const inner = innerProofSize(index, size);
        const border = onesCount(index >> BigInt(inner));
        return { inner, border };
      }
      function chainInner(seed, hashes, index) {
        return hashes.reduce((acc, h, i) => {
          if ((index >> BigInt(i)) & BigInt(1)) {
            return hashChildren(h, acc);
          } else {
            return hashChildren(acc, h);
          }
        }, seed);
      }
      function chainBorderRight(seed, hashes) {
        return hashes.reduce((acc, h) => hashChildren(h, acc), seed);
      }
      function innerProofSize(index, size) {
        return bitLength(index ^ (size - BigInt(1)));
      }
      function onesCount(num) {
        return num.toString(2).split("1").length - 1;
      }
      function bitLength(n) {
        if (n === 0n) {
          return 0;
        }
        return n.toString(2).length;
      }
      function hashChildren(left, right) {
        return core_1.crypto.hash(RFC6962_NODE_HASH_PREFIX, left, right);
      }
      function hashLeaf(leaf) {
        return core_1.crypto.hash(RFC6962_LEAF_HASH_PREFIX, leaf);
      }
    },
    7527: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyTLogSET = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const trust_1 = __nccwpck_require__(4503);
      function verifyTLogSET(entry, tlogs) {
        const validTLogs = (0, trust_1.filterTLogAuthorities)(tlogs, {
          logID: entry.logId.keyId,
          targetDate: new Date(Number(entry.integratedTime) * 1e3),
        });
        const verified = validTLogs.some((tlog) => {
          const payload = toVerificationPayload(entry);
          const data = Buffer.from(core_1.json.canonicalize(payload), "utf8");
          const signature = entry.inclusionPromise.signedEntryTimestamp;
          return core_1.crypto.verify(data, tlog.publicKey, signature);
        });
        if (!verified) {
          throw new error_1.VerificationError({
            code: "TLOG_INCLUSION_PROMISE_ERROR",
            message: "inclusion promise could not be verified",
          });
        }
      }
      exports.verifyTLogSET = verifyTLogSET;
      function toVerificationPayload(entry) {
        const { integratedTime, logIndex, logId, canonicalizedBody } = entry;
        return {
          body: canonicalizedBody.toString("base64"),
          integratedTime: Number(integratedTime),
          logIndex: Number(logIndex),
          logID: logId.keyId.toString("hex"),
        };
      }
    },
    2574: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyRFC3161Timestamp = void 0;
      const core_1 = __nccwpck_require__(3352);
      const error_1 = __nccwpck_require__(8948);
      const certificate_1 = __nccwpck_require__(8766);
      const trust_1 = __nccwpck_require__(4503);
      function verifyRFC3161Timestamp(timestamp, data, timestampAuthorities) {
        const signingTime = timestamp.signingTime;
        timestampAuthorities = (0, trust_1.filterCertAuthorities)(
          timestampAuthorities,
          { start: signingTime, end: signingTime },
        );
        timestampAuthorities = filterCAsBySerialAndIssuer(
          timestampAuthorities,
          {
            serialNumber: timestamp.signerSerialNumber,
            issuer: timestamp.signerIssuer,
          },
        );
        const verified = timestampAuthorities.some((ca) => {
          try {
            verifyTimestampForCA(timestamp, data, ca);
            return true;
          } catch (e) {
            return false;
          }
        });
        if (!verified) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "timestamp could not be verified",
          });
        }
      }
      exports.verifyRFC3161Timestamp = verifyRFC3161Timestamp;
      function verifyTimestampForCA(timestamp, data, ca) {
        const [leaf, ...cas] = ca.certChain;
        const signingKey = core_1.crypto.createPublicKey(leaf.publicKey);
        const signingTime = timestamp.signingTime;
        try {
          new certificate_1.CertificateChainVerifier({
            untrustedCert: leaf,
            trustedCerts: cas,
          }).verify();
        } catch (e) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "invalid certificate chain",
          });
        }
        const validAtSigningTime = ca.certChain.every((cert) =>
          cert.validForDate(signingTime),
        );
        if (!validAtSigningTime) {
          throw new error_1.VerificationError({
            code: "TIMESTAMP_ERROR",
            message: "timestamp was signed with an expired certificate",
          });
        }
        timestamp.verify(data, signingKey);
      }
      function filterCAsBySerialAndIssuer(timestampAuthorities, criteria) {
        return timestampAuthorities.filter(
          (ca) =>
            ca.certChain.length > 0 &&
            core_1.crypto.bufferEqual(
              ca.certChain[0].serialNumber,
              criteria.serialNumber,
            ) &&
            core_1.crypto.bufferEqual(ca.certChain[0].issuer, criteria.issuer),
        );
      }
    },
    4625: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyDSSETLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifyDSSETLogBody(tlogEntry, content) {
        switch (tlogEntry.apiVersion) {
          case "0.0.1":
            return verifyDSSE001TLogBody(tlogEntry, content);
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported dsse version: ${tlogEntry.apiVersion}`,
            });
        }
      }
      exports.verifyDSSETLogBody = verifyDSSETLogBody;
      function verifyDSSE001TLogBody(tlogEntry, content) {
        if (tlogEntry.spec.signatures?.length !== 1) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "signature count mismatch",
          });
        }
        const tlogSig = tlogEntry.spec.signatures[0].signature;
        if (!content.compareSignature(Buffer.from(tlogSig, "base64")))
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "tlog entry signature mismatch",
          });
        const tlogHash = tlogEntry.spec.payloadHash?.value || "";
        if (!content.compareDigest(Buffer.from(tlogHash, "hex"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "DSSE payload hash mismatch",
          });
        }
      }
    },
    935: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyHashedRekordTLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifyHashedRekordTLogBody(tlogEntry, content) {
        switch (tlogEntry.apiVersion) {
          case "0.0.1":
            return verifyHashedrekord001TLogBody(tlogEntry, content);
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported hashedrekord version: ${tlogEntry.apiVersion}`,
            });
        }
      }
      exports.verifyHashedRekordTLogBody = verifyHashedRekordTLogBody;
      function verifyHashedrekord001TLogBody(tlogEntry, content) {
        const tlogSig = tlogEntry.spec.signature.content || "";
        if (!content.compareSignature(Buffer.from(tlogSig, "base64"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "signature mismatch",
          });
        }
        const tlogDigest = tlogEntry.spec.data.hash?.value || "";
        if (!content.compareDigest(Buffer.from(tlogDigest, "hex"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "digest mismatch",
          });
        }
      }
    },
    4566: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyTLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      const dsse_1 = __nccwpck_require__(4625);
      const hashedrekord_1 = __nccwpck_require__(935);
      const intoto_1 = __nccwpck_require__(3109);
      function verifyTLogBody(entry, sigContent) {
        const { kind, version } = entry.kindVersion;
        const body = JSON.parse(entry.canonicalizedBody.toString("utf8"));
        if (kind !== body.kind || version !== body.apiVersion) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: `kind/version mismatch - expected: ${kind}/${version}, received: ${body.kind}/${body.apiVersion}`,
          });
        }
        switch (body.kind) {
          case "dsse":
            return (0, dsse_1.verifyDSSETLogBody)(body, sigContent);
          case "intoto":
            return (0, intoto_1.verifyIntotoTLogBody)(body, sigContent);
          case "hashedrekord":
            return (0, hashedrekord_1.verifyHashedRekordTLogBody)(
              body,
              sigContent,
            );
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported kind: ${kind}`,
            });
        }
      }
      exports.verifyTLogBody = verifyTLogBody;
    },
    3109: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifyIntotoTLogBody = void 0;
      const error_1 = __nccwpck_require__(8948);
      function verifyIntotoTLogBody(tlogEntry, content) {
        switch (tlogEntry.apiVersion) {
          case "0.0.2":
            return verifyIntoto002TLogBody(tlogEntry, content);
          default:
            throw new error_1.VerificationError({
              code: "TLOG_BODY_ERROR",
              message: `unsupported intoto version: ${tlogEntry.apiVersion}`,
            });
        }
      }
      exports.verifyIntotoTLogBody = verifyIntotoTLogBody;
      function verifyIntoto002TLogBody(tlogEntry, content) {
        if (tlogEntry.spec.content.envelope.signatures?.length !== 1) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "signature count mismatch",
          });
        }
        const tlogSig = base64Decode(
          tlogEntry.spec.content.envelope.signatures[0].sig,
        );
        if (!content.compareSignature(Buffer.from(tlogSig, "base64"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "tlog entry signature mismatch",
          });
        }
        const tlogHash = tlogEntry.spec.content.payloadHash?.value || "";
        if (!content.compareDigest(Buffer.from(tlogHash, "hex"))) {
          throw new error_1.VerificationError({
            code: "TLOG_BODY_ERROR",
            message: "DSSE payload hash mismatch",
          });
        }
      }
      function base64Decode(str) {
        return Buffer.from(str, "base64").toString("utf-8");
      }
    },
    6906: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.filterTLogAuthorities = exports.filterCertAuthorities = void 0;
      function filterCertAuthorities(certAuthorities, criteria) {
        return certAuthorities.filter(
          (ca) =>
            ca.validFor.start <= criteria.start &&
            ca.validFor.end >= criteria.end,
        );
      }
      exports.filterCertAuthorities = filterCertAuthorities;
      function filterTLogAuthorities(tlogAuthorities, criteria) {
        return tlogAuthorities.filter((tlog) => {
          if (criteria.logID && !tlog.logID.equals(criteria.logID)) {
            return false;
          }
          return (
            tlog.validFor.start <= criteria.targetDate &&
            criteria.targetDate <= tlog.validFor.end
          );
        });
      }
      exports.filterTLogAuthorities = filterTLogAuthorities;
    },
    4503: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.toTrustMaterial =
        exports.filterTLogAuthorities =
        exports.filterCertAuthorities =
          void 0;
      const core_1 = __nccwpck_require__(3352);
      const protobuf_specs_1 = __nccwpck_require__(530);
      const error_1 = __nccwpck_require__(8948);
      const BEGINNING_OF_TIME = new Date(0);
      const END_OF_TIME = new Date(864e13);
      var filter_1 = __nccwpck_require__(6906);
      Object.defineProperty(exports, "filterCertAuthorities", {
        enumerable: true,
        get: function () {
          return filter_1.filterCertAuthorities;
        },
      });
      Object.defineProperty(exports, "filterTLogAuthorities", {
        enumerable: true,
        get: function () {
          return filter_1.filterTLogAuthorities;
        },
      });
      function toTrustMaterial(root, keys) {
        const keyFinder = typeof keys === "function" ? keys : keyLocator(keys);
        return {
          certificateAuthorities:
            root.certificateAuthorities.map(createCertAuthority),
          timestampAuthorities:
            root.timestampAuthorities.map(createCertAuthority),
          tlogs: root.tlogs.map(createTLogAuthority),
          ctlogs: root.ctlogs.map(createTLogAuthority),
          publicKey: keyFinder,
        };
      }
      exports.toTrustMaterial = toTrustMaterial;
      function createTLogAuthority(tlogInstance) {
        const keyDetails = tlogInstance.publicKey.keyDetails;
        const keyType =
          keyDetails === protobuf_specs_1.PublicKeyDetails.PKCS1_RSA_PKCS1V5 ||
          keyDetails === protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V5 ||
          keyDetails ===
            protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_2048_SHA256 ||
          keyDetails ===
            protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_3072_SHA256 ||
          keyDetails ===
            protobuf_specs_1.PublicKeyDetails.PKIX_RSA_PKCS1V15_4096_SHA256
            ? "pkcs1"
            : "spki";
        return {
          logID: tlogInstance.logId.keyId,
          publicKey: core_1.crypto.createPublicKey(
            tlogInstance.publicKey.rawBytes,
            keyType,
          ),
          validFor: {
            start: tlogInstance.publicKey.validFor?.start || BEGINNING_OF_TIME,
            end: tlogInstance.publicKey.validFor?.end || END_OF_TIME,
          },
        };
      }
      function createCertAuthority(ca) {
        return {
          certChain: ca.certChain.certificates.map((cert) =>
            core_1.X509Certificate.parse(cert.rawBytes),
          ),
          validFor: {
            start: ca.validFor?.start || BEGINNING_OF_TIME,
            end: ca.validFor?.end || END_OF_TIME,
          },
        };
      }
      function keyLocator(keys) {
        return (hint) => {
          const key = (keys || {})[hint];
          if (!key) {
            throw new error_1.VerificationError({
              code: "PUBLIC_KEY_ERROR",
              message: `key not found: ${hint}`,
            });
          }
          return {
            publicKey: core_1.crypto.createPublicKey(key.rawBytes),
            validFor: (date) =>
              (key.validFor?.start || BEGINNING_OF_TIME) <= date &&
              (key.validFor?.end || END_OF_TIME) >= date,
          };
        };
      }
    },
    5456: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Verifier = void 0;
      const util_1 = __nccwpck_require__(3837);
      const error_1 = __nccwpck_require__(8948);
      const key_1 = __nccwpck_require__(6829);
      const policy_1 = __nccwpck_require__(3978);
      const timestamp_1 = __nccwpck_require__(9511);
      const tlog_1 = __nccwpck_require__(4566);
      class Verifier {
        constructor(trustMaterial, options = {}) {
          this.trustMaterial = trustMaterial;
          this.options = {
            ctlogThreshold: options.ctlogThreshold ?? 1,
            tlogThreshold: options.tlogThreshold ?? 1,
            tsaThreshold: options.tsaThreshold ?? 0,
          };
        }
        verify(entity, policy) {
          const timestamps = this.verifyTimestamps(entity);
          const signer = this.verifySigningKey(entity, timestamps);
          this.verifyTLogs(entity);
          this.verifySignature(entity, signer);
          if (policy) {
            this.verifyPolicy(policy, signer.identity || {});
          }
          return signer;
        }
        verifyTimestamps(entity) {
          let tlogCount = 0;
          let tsaCount = 0;
          const timestamps = entity.timestamps.map((timestamp) => {
            switch (timestamp.$case) {
              case "timestamp-authority":
                tsaCount++;
                return (0, timestamp_1.verifyTSATimestamp)(
                  timestamp.timestamp,
                  entity.signature.signature,
                  this.trustMaterial.timestampAuthorities,
                );
              case "transparency-log":
                tlogCount++;
                return (0, timestamp_1.verifyTLogTimestamp)(
                  timestamp.tlogEntry,
                  this.trustMaterial.tlogs,
                );
            }
          });
          if (containsDupes(timestamps)) {
            throw new error_1.VerificationError({
              code: "TIMESTAMP_ERROR",
              message: "duplicate timestamp",
            });
          }
          if (tlogCount < this.options.tlogThreshold) {
            throw new error_1.VerificationError({
              code: "TIMESTAMP_ERROR",
              message: `expected ${this.options.tlogThreshold} tlog timestamps, got ${tlogCount}`,
            });
          }
          if (tsaCount < this.options.tsaThreshold) {
            throw new error_1.VerificationError({
              code: "TIMESTAMP_ERROR",
              message: `expected ${this.options.tsaThreshold} tsa timestamps, got ${tsaCount}`,
            });
          }
          return timestamps.map((t) => t.timestamp);
        }
        verifySigningKey({ key }, timestamps) {
          switch (key.$case) {
            case "public-key": {
              return (0, key_1.verifyPublicKey)(
                key.hint,
                timestamps,
                this.trustMaterial,
              );
            }
            case "certificate": {
              const result = (0, key_1.verifyCertificate)(
                key.certificate,
                timestamps,
                this.trustMaterial,
              );
              if (containsDupes(result.scts)) {
                throw new error_1.VerificationError({
                  code: "CERTIFICATE_ERROR",
                  message: "duplicate SCT",
                });
              }
              if (result.scts.length < this.options.ctlogThreshold) {
                throw new error_1.VerificationError({
                  code: "CERTIFICATE_ERROR",
                  message: `expected ${this.options.ctlogThreshold} SCTs, got ${result.scts.length}`,
                });
              }
              return result.signer;
            }
          }
        }
        verifyTLogs({ signature: content, tlogEntries }) {
          tlogEntries.forEach((entry) =>
            (0, tlog_1.verifyTLogBody)(entry, content),
          );
        }
        verifySignature(entity, signer) {
          if (!entity.signature.verifySignature(signer.key)) {
            throw new error_1.VerificationError({
              code: "SIGNATURE_ERROR",
              message: "signature verification failed",
            });
          }
        }
        verifyPolicy(policy, identity) {
          if (policy.subjectAlternativeName) {
            (0, policy_1.verifySubjectAlternativeName)(
              policy.subjectAlternativeName,
              identity.subjectAlternativeName,
            );
          }
          if (policy.extensions) {
            (0, policy_1.verifyExtensions)(
              policy.extensions,
              identity.extensions,
            );
          }
        }
      }
      exports.Verifier = Verifier;
      function containsDupes(arr) {
        for (let i = 0; i < arr.length; i++) {
          for (let j = i + 1; j < arr.length; j++) {
            if ((0, util_1.isDeepStrictEqual)(arr[i], arr[j])) {
              return true;
            }
          }
        }
        return false;
      }
    },
    9652: (module) => {
      const COMMA = ",";
      const COLON = ":";
      const LEFT_SQUARE_BRACKET = "[";
      const RIGHT_SQUARE_BRACKET = "]";
      const LEFT_CURLY_BRACKET = "{";
      const RIGHT_CURLY_BRACKET = "}";
      function canonicalize(object) {
        const buffer = [];
        if (typeof object === "string") {
          buffer.push(canonicalizeString(object));
        } else if (typeof object === "boolean") {
          buffer.push(JSON.stringify(object));
        } else if (Number.isInteger(object)) {
          buffer.push(JSON.stringify(object));
        } else if (object === null) {
          buffer.push(JSON.stringify(object));
        } else if (Array.isArray(object)) {
          buffer.push(LEFT_SQUARE_BRACKET);
          let first = true;
          object.forEach((element) => {
            if (!first) {
              buffer.push(COMMA);
            }
            first = false;
            buffer.push(canonicalize(element));
          });
          buffer.push(RIGHT_SQUARE_BRACKET);
        } else if (typeof object === "object") {
          buffer.push(LEFT_CURLY_BRACKET);
          let first = true;
          Object.keys(object)
            .sort()
            .forEach((property) => {
              if (!first) {
                buffer.push(COMMA);
              }
              first = false;
              buffer.push(canonicalizeString(property));
              buffer.push(COLON);
              buffer.push(canonicalize(object[property]));
            });
          buffer.push(RIGHT_CURLY_BRACKET);
        } else {
          throw new TypeError("cannot encode " + object.toString());
        }
        return buffer.join("");
      }
      function canonicalizeString(string) {
        const escapedString = string
          .replace(/\\/g, "\\\\")
          .replace(/"/g, '\\"');
        return '"' + escapedString + '"';
      }
      module.exports = { canonicalize };
    },
    159: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signed = exports.isMetadataKind = exports.MetadataKind = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      const SPECIFICATION_VERSION = ["1", "0", "31"];
      var MetadataKind;
      (function (MetadataKind) {
        MetadataKind["Root"] = "root";
        MetadataKind["Timestamp"] = "timestamp";
        MetadataKind["Snapshot"] = "snapshot";
        MetadataKind["Targets"] = "targets";
      })(MetadataKind || (exports.MetadataKind = MetadataKind = {}));
      function isMetadataKind(value) {
        return (
          typeof value === "string" &&
          Object.values(MetadataKind).includes(value)
        );
      }
      exports.isMetadataKind = isMetadataKind;
      class Signed {
        constructor(options) {
          this.specVersion =
            options.specVersion || SPECIFICATION_VERSION.join(".");
          const specList = this.specVersion.split(".");
          if (
            !(specList.length === 2 || specList.length === 3) ||
            !specList.every((item) => isNumeric(item))
          ) {
            throw new error_1.ValueError("Failed to parse specVersion");
          }
          if (specList[0] != SPECIFICATION_VERSION[0]) {
            throw new error_1.ValueError("Unsupported specVersion");
          }
          this.expires = options.expires || new Date().toISOString();
          this.version = options.version || 1;
          this.unrecognizedFields = options.unrecognizedFields || {};
        }
        equals(other) {
          if (!(other instanceof Signed)) {
            return false;
          }
          return (
            this.specVersion === other.specVersion &&
            this.expires === other.expires &&
            this.version === other.version &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        isExpired(referenceTime) {
          if (!referenceTime) {
            referenceTime = new Date();
          }
          return referenceTime >= new Date(this.expires);
        }
        static commonFieldsFromJSON(data) {
          const { spec_version, expires, version, ...rest } = data;
          if (
            utils_1.guard.isDefined(spec_version) &&
            !(typeof spec_version === "string")
          ) {
            throw new TypeError("spec_version must be a string");
          }
          if (
            utils_1.guard.isDefined(expires) &&
            !(typeof expires === "string")
          ) {
            throw new TypeError("expires must be a string");
          }
          if (
            utils_1.guard.isDefined(version) &&
            !(typeof version === "number")
          ) {
            throw new TypeError("version must be a number");
          }
          return {
            specVersion: spec_version,
            expires,
            version,
            unrecognizedFields: rest,
          };
        }
      }
      exports.Signed = Signed;
      function isNumeric(str) {
        return !isNaN(Number(str));
      }
    },
    1662: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Delegations = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const key_1 = __nccwpck_require__(6697);
      const role_1 = __nccwpck_require__(9393);
      const utils_1 = __nccwpck_require__(5688);
      class Delegations {
        constructor(options) {
          this.keys = options.keys;
          this.unrecognizedFields = options.unrecognizedFields || {};
          if (options.roles) {
            if (
              Object.keys(options.roles).some((roleName) =>
                role_1.TOP_LEVEL_ROLE_NAMES.includes(roleName),
              )
            ) {
              throw new error_1.ValueError(
                "Delegated role name conflicts with top-level role name",
              );
            }
          }
          this.succinctRoles = options.succinctRoles;
          this.roles = options.roles;
        }
        equals(other) {
          if (!(other instanceof Delegations)) {
            return false;
          }
          return (
            util_1.default.isDeepStrictEqual(this.keys, other.keys) &&
            util_1.default.isDeepStrictEqual(this.roles, other.roles) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            ) &&
            util_1.default.isDeepStrictEqual(
              this.succinctRoles,
              other.succinctRoles,
            )
          );
        }
        *rolesForTarget(targetPath) {
          if (this.roles) {
            for (const role of Object.values(this.roles)) {
              if (role.isDelegatedPath(targetPath)) {
                yield { role: role.name, terminating: role.terminating };
              }
            }
          } else if (this.succinctRoles) {
            yield {
              role: this.succinctRoles.getRoleForTarget(targetPath),
              terminating: true,
            };
          }
        }
        toJSON() {
          const json = {
            keys: keysToJSON(this.keys),
            ...this.unrecognizedFields,
          };
          if (this.roles) {
            json.roles = rolesToJSON(this.roles);
          } else if (this.succinctRoles) {
            json.succinct_roles = this.succinctRoles.toJSON();
          }
          return json;
        }
        static fromJSON(data) {
          const { keys, roles, succinct_roles, ...unrecognizedFields } = data;
          let succinctRoles;
          if (utils_1.guard.isObject(succinct_roles)) {
            succinctRoles = role_1.SuccinctRoles.fromJSON(succinct_roles);
          }
          return new Delegations({
            keys: keysFromJSON(keys),
            roles: rolesFromJSON(roles),
            unrecognizedFields,
            succinctRoles,
          });
        }
      }
      exports.Delegations = Delegations;
      function keysToJSON(keys) {
        return Object.entries(keys).reduce(
          (acc, [keyId, key]) => ({ ...acc, [keyId]: key.toJSON() }),
          {},
        );
      }
      function rolesToJSON(roles) {
        return Object.values(roles).map((role) => role.toJSON());
      }
      function keysFromJSON(data) {
        if (!utils_1.guard.isObjectRecord(data)) {
          throw new TypeError("keys is malformed");
        }
        return Object.entries(data).reduce(
          (acc, [keyID, keyData]) => ({
            ...acc,
            [keyID]: key_1.Key.fromJSON(keyID, keyData),
          }),
          {},
        );
      }
      function rolesFromJSON(data) {
        let roleMap;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectArray(data)) {
            throw new TypeError("roles is malformed");
          }
          roleMap = data.reduce((acc, role) => {
            const delegatedRole = role_1.DelegatedRole.fromJSON(role);
            return { ...acc, [delegatedRole.name]: delegatedRole };
          }, {});
        }
        return roleMap;
      }
    },
    8448: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.UnsupportedAlgorithmError =
        exports.CryptoError =
        exports.LengthOrHashMismatchError =
        exports.UnsignedMetadataError =
        exports.RepositoryError =
        exports.ValueError =
          void 0;
      class ValueError extends Error {}
      exports.ValueError = ValueError;
      class RepositoryError extends Error {}
      exports.RepositoryError = RepositoryError;
      class UnsignedMetadataError extends RepositoryError {}
      exports.UnsignedMetadataError = UnsignedMetadataError;
      class LengthOrHashMismatchError extends RepositoryError {}
      exports.LengthOrHashMismatchError = LengthOrHashMismatchError;
      class CryptoError extends Error {}
      exports.CryptoError = CryptoError;
      class UnsupportedAlgorithmError extends CryptoError {}
      exports.UnsupportedAlgorithmError = UnsupportedAlgorithmError;
    },
    1923: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TargetFile = exports.MetaFile = void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      class MetaFile {
        constructor(opts) {
          if (opts.version <= 0) {
            throw new error_1.ValueError("Metafile version must be at least 1");
          }
          if (opts.length !== undefined) {
            validateLength(opts.length);
          }
          this.version = opts.version;
          this.length = opts.length;
          this.hashes = opts.hashes;
          this.unrecognizedFields = opts.unrecognizedFields || {};
        }
        equals(other) {
          if (!(other instanceof MetaFile)) {
            return false;
          }
          return (
            this.version === other.version &&
            this.length === other.length &&
            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        verify(data) {
          if (this.length !== undefined) {
            if (data.length !== this.length) {
              throw new error_1.LengthOrHashMismatchError(
                `Expected length ${this.length} but got ${data.length}`,
              );
            }
          }
          if (this.hashes) {
            Object.entries(this.hashes).forEach(([key, value]) => {
              let hash;
              try {
                hash = crypto_1.default.createHash(key);
              } catch (e) {
                throw new error_1.LengthOrHashMismatchError(
                  `Hash algorithm ${key} not supported`,
                );
              }
              const observedHash = hash.update(data).digest("hex");
              if (observedHash !== value) {
                throw new error_1.LengthOrHashMismatchError(
                  `Expected hash ${value} but got ${observedHash}`,
                );
              }
            });
          }
        }
        toJSON() {
          const json = { version: this.version, ...this.unrecognizedFields };
          if (this.length !== undefined) {
            json.length = this.length;
          }
          if (this.hashes) {
            json.hashes = this.hashes;
          }
          return json;
        }
        static fromJSON(data) {
          const { version, length, hashes, ...rest } = data;
          if (typeof version !== "number") {
            throw new TypeError("version must be a number");
          }
          if (utils_1.guard.isDefined(length) && typeof length !== "number") {
            throw new TypeError("length must be a number");
          }
          if (
            utils_1.guard.isDefined(hashes) &&
            !utils_1.guard.isStringRecord(hashes)
          ) {
            throw new TypeError("hashes must be string keys and values");
          }
          return new MetaFile({
            version,
            length,
            hashes,
            unrecognizedFields: rest,
          });
        }
      }
      exports.MetaFile = MetaFile;
      class TargetFile {
        constructor(opts) {
          validateLength(opts.length);
          this.length = opts.length;
          this.path = opts.path;
          this.hashes = opts.hashes;
          this.unrecognizedFields = opts.unrecognizedFields || {};
        }
        get custom() {
          const custom = this.unrecognizedFields["custom"];
          if (
            !custom ||
            Array.isArray(custom) ||
            !(typeof custom === "object")
          ) {
            return {};
          }
          return custom;
        }
        equals(other) {
          if (!(other instanceof TargetFile)) {
            return false;
          }
          return (
            this.length === other.length &&
            this.path === other.path &&
            util_1.default.isDeepStrictEqual(this.hashes, other.hashes) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        async verify(stream) {
          let observedLength = 0;
          const digests = Object.keys(this.hashes).reduce((acc, key) => {
            try {
              acc[key] = crypto_1.default.createHash(key);
            } catch (e) {
              throw new error_1.LengthOrHashMismatchError(
                `Hash algorithm ${key} not supported`,
              );
            }
            return acc;
          }, {});
          for await (const chunk of stream) {
            observedLength += chunk.length;
            Object.values(digests).forEach((digest) => {
              digest.update(chunk);
            });
          }
          if (observedLength !== this.length) {
            throw new error_1.LengthOrHashMismatchError(
              `Expected length ${this.length} but got ${observedLength}`,
            );
          }
          Object.entries(digests).forEach(([key, value]) => {
            const expected = this.hashes[key];
            const actual = value.digest("hex");
            if (actual !== expected) {
              throw new error_1.LengthOrHashMismatchError(
                `Expected hash ${expected} but got ${actual}`,
              );
            }
          });
        }
        toJSON() {
          return {
            length: this.length,
            hashes: this.hashes,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(path, data) {
          const { length, hashes, ...rest } = data;
          if (typeof length !== "number") {
            throw new TypeError("length must be a number");
          }
          if (!utils_1.guard.isStringRecord(hashes)) {
            throw new TypeError("hashes must have string keys and values");
          }
          return new TargetFile({
            length,
            path,
            hashes,
            unrecognizedFields: rest,
          });
        }
      }
      exports.TargetFile = TargetFile;
      function validateLength(length) {
        if (length < 0) {
          throw new error_1.ValueError("Length must be at least 0");
        }
      }
    },
    5833: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Timestamp =
        exports.Targets =
        exports.Snapshot =
        exports.Signature =
        exports.Root =
        exports.Metadata =
        exports.Key =
        exports.TargetFile =
        exports.MetaFile =
        exports.ValueError =
        exports.MetadataKind =
          void 0;
      var base_1 = __nccwpck_require__(159);
      Object.defineProperty(exports, "MetadataKind", {
        enumerable: true,
        get: function () {
          return base_1.MetadataKind;
        },
      });
      var error_1 = __nccwpck_require__(8448);
      Object.defineProperty(exports, "ValueError", {
        enumerable: true,
        get: function () {
          return error_1.ValueError;
        },
      });
      var file_1 = __nccwpck_require__(1923);
      Object.defineProperty(exports, "MetaFile", {
        enumerable: true,
        get: function () {
          return file_1.MetaFile;
        },
      });
      Object.defineProperty(exports, "TargetFile", {
        enumerable: true,
        get: function () {
          return file_1.TargetFile;
        },
      });
      var key_1 = __nccwpck_require__(6697);
      Object.defineProperty(exports, "Key", {
        enumerable: true,
        get: function () {
          return key_1.Key;
        },
      });
      var metadata_1 = __nccwpck_require__(1593);
      Object.defineProperty(exports, "Metadata", {
        enumerable: true,
        get: function () {
          return metadata_1.Metadata;
        },
      });
      var root_1 = __nccwpck_require__(9392);
      Object.defineProperty(exports, "Root", {
        enumerable: true,
        get: function () {
          return root_1.Root;
        },
      });
      var signature_1 = __nccwpck_require__(4222);
      Object.defineProperty(exports, "Signature", {
        enumerable: true,
        get: function () {
          return signature_1.Signature;
        },
      });
      var snapshot_1 = __nccwpck_require__(2326);
      Object.defineProperty(exports, "Snapshot", {
        enumerable: true,
        get: function () {
          return snapshot_1.Snapshot;
        },
      });
      var targets_1 = __nccwpck_require__(5799);
      Object.defineProperty(exports, "Targets", {
        enumerable: true,
        get: function () {
          return targets_1.Targets;
        },
      });
      var timestamp_1 = __nccwpck_require__(4042);
      Object.defineProperty(exports, "Timestamp", {
        enumerable: true,
        get: function () {
          return timestamp_1.Timestamp;
        },
      });
    },
    6697: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Key = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      const key_1 = __nccwpck_require__(8725);
      class Key {
        constructor(options) {
          const { keyID, keyType, scheme, keyVal, unrecognizedFields } =
            options;
          this.keyID = keyID;
          this.keyType = keyType;
          this.scheme = scheme;
          this.keyVal = keyVal;
          this.unrecognizedFields = unrecognizedFields || {};
        }
        verifySignature(metadata) {
          const signature = metadata.signatures[this.keyID];
          if (!signature)
            throw new error_1.UnsignedMetadataError(
              "no signature for key found in metadata",
            );
          if (!this.keyVal.public)
            throw new error_1.UnsignedMetadataError("no public key found");
          const publicKey = (0, key_1.getPublicKey)({
            keyType: this.keyType,
            scheme: this.scheme,
            keyVal: this.keyVal.public,
          });
          const signedData = metadata.signed.toJSON();
          try {
            if (
              !utils_1.crypto.verifySignature(
                signedData,
                publicKey,
                signature.sig,
              )
            ) {
              throw new error_1.UnsignedMetadataError(
                `failed to verify ${this.keyID} signature`,
              );
            }
          } catch (error) {
            if (error instanceof error_1.UnsignedMetadataError) {
              throw error;
            }
            throw new error_1.UnsignedMetadataError(
              `failed to verify ${this.keyID} signature`,
            );
          }
        }
        equals(other) {
          if (!(other instanceof Key)) {
            return false;
          }
          return (
            this.keyID === other.keyID &&
            this.keyType === other.keyType &&
            this.scheme === other.scheme &&
            util_1.default.isDeepStrictEqual(this.keyVal, other.keyVal) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        toJSON() {
          return {
            keytype: this.keyType,
            scheme: this.scheme,
            keyval: this.keyVal,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(keyID, data) {
          const { keytype, scheme, keyval, ...rest } = data;
          if (typeof keytype !== "string") {
            throw new TypeError("keytype must be a string");
          }
          if (typeof scheme !== "string") {
            throw new TypeError("scheme must be a string");
          }
          if (!utils_1.guard.isStringRecord(keyval)) {
            throw new TypeError("keyval must be a string record");
          }
          return new Key({
            keyID,
            keyType: keytype,
            scheme,
            keyVal: keyval,
            unrecognizedFields: rest,
          });
        }
      }
      exports.Key = Key;
    },
    1593: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Metadata = void 0;
      const canonical_json_1 = __nccwpck_require__(9652);
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const error_1 = __nccwpck_require__(8448);
      const root_1 = __nccwpck_require__(9392);
      const signature_1 = __nccwpck_require__(4222);
      const snapshot_1 = __nccwpck_require__(2326);
      const targets_1 = __nccwpck_require__(5799);
      const timestamp_1 = __nccwpck_require__(4042);
      const utils_1 = __nccwpck_require__(5688);
      class Metadata {
        constructor(signed, signatures, unrecognizedFields) {
          this.signed = signed;
          this.signatures = signatures || {};
          this.unrecognizedFields = unrecognizedFields || {};
        }
        sign(signer, append = true) {
          const bytes = Buffer.from(
            (0, canonical_json_1.canonicalize)(this.signed.toJSON()),
          );
          const signature = signer(bytes);
          if (!append) {
            this.signatures = {};
          }
          this.signatures[signature.keyID] = signature;
        }
        verifyDelegate(delegatedRole, delegatedMetadata) {
          let role;
          let keys = {};
          switch (this.signed.type) {
            case base_1.MetadataKind.Root:
              keys = this.signed.keys;
              role = this.signed.roles[delegatedRole];
              break;
            case base_1.MetadataKind.Targets:
              if (!this.signed.delegations) {
                throw new error_1.ValueError(
                  `No delegations found for ${delegatedRole}`,
                );
              }
              keys = this.signed.delegations.keys;
              if (this.signed.delegations.roles) {
                role = this.signed.delegations.roles[delegatedRole];
              } else if (this.signed.delegations.succinctRoles) {
                if (
                  this.signed.delegations.succinctRoles.isDelegatedRole(
                    delegatedRole,
                  )
                ) {
                  role = this.signed.delegations.succinctRoles;
                }
              }
              break;
            default:
              throw new TypeError("invalid metadata type");
          }
          if (!role) {
            throw new error_1.ValueError(
              `no delegation found for ${delegatedRole}`,
            );
          }
          const signingKeys = new Set();
          role.keyIDs.forEach((keyID) => {
            const key = keys[keyID];
            if (!key) {
              return;
            }
            try {
              key.verifySignature(delegatedMetadata);
              signingKeys.add(key.keyID);
            } catch (error) {}
          });
          if (signingKeys.size < role.threshold) {
            throw new error_1.UnsignedMetadataError(
              `${delegatedRole} was signed by ${signingKeys.size}/${role.threshold} keys`,
            );
          }
        }
        equals(other) {
          if (!(other instanceof Metadata)) {
            return false;
          }
          return (
            this.signed.equals(other.signed) &&
            util_1.default.isDeepStrictEqual(
              this.signatures,
              other.signatures,
            ) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        toJSON() {
          const signatures = Object.values(this.signatures).map((signature) =>
            signature.toJSON(),
          );
          return {
            signatures,
            signed: this.signed.toJSON(),
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(type, data) {
          const { signed, signatures, ...rest } = data;
          if (
            !utils_1.guard.isDefined(signed) ||
            !utils_1.guard.isObject(signed)
          ) {
            throw new TypeError("signed is not defined");
          }
          if (type !== signed._type) {
            throw new error_1.ValueError(
              `expected '${type}', got ${signed["_type"]}`,
            );
          }
          let signedObj;
          switch (type) {
            case base_1.MetadataKind.Root:
              signedObj = root_1.Root.fromJSON(signed);
              break;
            case base_1.MetadataKind.Timestamp:
              signedObj = timestamp_1.Timestamp.fromJSON(signed);
              break;
            case base_1.MetadataKind.Snapshot:
              signedObj = snapshot_1.Snapshot.fromJSON(signed);
              break;
            case base_1.MetadataKind.Targets:
              signedObj = targets_1.Targets.fromJSON(signed);
              break;
            default:
              throw new TypeError("invalid metadata type");
          }
          const sigMap = signaturesFromJSON(signatures);
          return new Metadata(signedObj, sigMap, rest);
        }
      }
      exports.Metadata = Metadata;
      function signaturesFromJSON(data) {
        if (!utils_1.guard.isObjectArray(data)) {
          throw new TypeError("signatures is not an array");
        }
        return data.reduce((acc, sigData) => {
          const signature = signature_1.Signature.fromJSON(sigData);
          return { ...acc, [signature.keyID]: signature };
        }, {});
      }
    },
    9393: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SuccinctRoles =
        exports.DelegatedRole =
        exports.Role =
        exports.TOP_LEVEL_ROLE_NAMES =
          void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const minimatch_1 = __nccwpck_require__(4501);
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(8448);
      const utils_1 = __nccwpck_require__(5688);
      exports.TOP_LEVEL_ROLE_NAMES = [
        "root",
        "targets",
        "snapshot",
        "timestamp",
      ];
      class Role {
        constructor(options) {
          const { keyIDs, threshold, unrecognizedFields } = options;
          if (hasDuplicates(keyIDs)) {
            throw new error_1.ValueError("duplicate key IDs found");
          }
          if (threshold < 1) {
            throw new error_1.ValueError("threshold must be at least 1");
          }
          this.keyIDs = keyIDs;
          this.threshold = threshold;
          this.unrecognizedFields = unrecognizedFields || {};
        }
        equals(other) {
          if (!(other instanceof Role)) {
            return false;
          }
          return (
            this.threshold === other.threshold &&
            util_1.default.isDeepStrictEqual(this.keyIDs, other.keyIDs) &&
            util_1.default.isDeepStrictEqual(
              this.unrecognizedFields,
              other.unrecognizedFields,
            )
          );
        }
        toJSON() {
          return {
            keyids: this.keyIDs,
            threshold: this.threshold,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { keyids, threshold, ...rest } = data;
          if (!utils_1.guard.isStringArray(keyids)) {
            throw new TypeError("keyids must be an array");
          }
          if (typeof threshold !== "number") {
            throw new TypeError("threshold must be a number");
          }
          return new Role({
            keyIDs: keyids,
            threshold,
            unrecognizedFields: rest,
          });
        }
      }
      exports.Role = Role;
      function hasDuplicates(array) {
        return new Set(array).size !== array.length;
      }
      class DelegatedRole extends Role {
        constructor(opts) {
          super(opts);
          const { name, terminating, paths, pathHashPrefixes } = opts;
          this.name = name;
          this.terminating = terminating;
          if (opts.paths && opts.pathHashPrefixes) {
            throw new error_1.ValueError(
              "paths and pathHashPrefixes are mutually exclusive",
            );
          }
          this.paths = paths;
          this.pathHashPrefixes = pathHashPrefixes;
        }
        equals(other) {
          if (!(other instanceof DelegatedRole)) {
            return false;
          }
          return (
            super.equals(other) &&
            this.name === other.name &&
            this.terminating === other.terminating &&
            util_1.default.isDeepStrictEqual(this.paths, other.paths) &&
            util_1.default.isDeepStrictEqual(
              this.pathHashPrefixes,
              other.pathHashPrefixes,
            )
          );
        }
        isDelegatedPath(targetFilepath) {
          if (this.paths) {
            return this.paths.some((pathPattern) =>
              isTargetInPathPattern(targetFilepath, pathPattern),
            );
          }
          if (this.pathHashPrefixes) {
            const hasher = crypto_1.default.createHash("sha256");
            const pathHash = hasher.update(targetFilepath).digest("hex");
            return this.pathHashPrefixes.some((pathHashPrefix) =>
              pathHash.startsWith(pathHashPrefix),
            );
          }
          return false;
        }
        toJSON() {
          const json = {
            ...super.toJSON(),
            name: this.name,
            terminating: this.terminating,
          };
          if (this.paths) {
            json.paths = this.paths;
          }
          if (this.pathHashPrefixes) {
            json.path_hash_prefixes = this.pathHashPrefixes;
          }
          return json;
        }
        static fromJSON(data) {
          const {
            keyids,
            threshold,
            name,
            terminating,
            paths,
            path_hash_prefixes,
            ...rest
          } = data;
          if (!utils_1.guard.isStringArray(keyids)) {
            throw new TypeError("keyids must be an array of strings");
          }
          if (typeof threshold !== "number") {
            throw new TypeError("threshold must be a number");
          }
          if (typeof name !== "string") {
            throw new TypeError("name must be a string");
          }
          if (typeof terminating !== "boolean") {
            throw new TypeError("terminating must be a boolean");
          }
          if (
            utils_1.guard.isDefined(paths) &&
            !utils_1.guard.isStringArray(paths)
          ) {
            throw new TypeError("paths must be an array of strings");
          }
          if (
            utils_1.guard.isDefined(path_hash_prefixes) &&
            !utils_1.guard.isStringArray(path_hash_prefixes)
          ) {
            throw new TypeError(
              "path_hash_prefixes must be an array of strings",
            );
          }
          return new DelegatedRole({
            keyIDs: keyids,
            threshold,
            name,
            terminating,
            paths,
            pathHashPrefixes: path_hash_prefixes,
            unrecognizedFields: rest,
          });
        }
      }
      exports.DelegatedRole = DelegatedRole;
      const zip = (a, b) => a.map((k, i) => [k, b[i]]);
      function isTargetInPathPattern(target, pattern) {
        const targetParts = target.split("/");
        const patternParts = pattern.split("/");
        if (patternParts.length != targetParts.length) {
          return false;
        }
        return zip(targetParts, patternParts).every(
          ([targetPart, patternPart]) =>
            (0, minimatch_1.minimatch)(targetPart, patternPart),
        );
      }
      class SuccinctRoles extends Role {
        constructor(opts) {
          super(opts);
          const { bitLength, namePrefix } = opts;
          if (bitLength <= 0 || bitLength > 32) {
            throw new error_1.ValueError("bitLength must be between 1 and 32");
          }
          this.bitLength = bitLength;
          this.namePrefix = namePrefix;
          this.numberOfBins = Math.pow(2, bitLength);
          this.suffixLen = (this.numberOfBins - 1).toString(16).length;
        }
        equals(other) {
          if (!(other instanceof SuccinctRoles)) {
            return false;
          }
          return (
            super.equals(other) &&
            this.bitLength === other.bitLength &&
            this.namePrefix === other.namePrefix
          );
        }
        getRoleForTarget(targetFilepath) {
          const hasher = crypto_1.default.createHash("sha256");
          const hasherBuffer = hasher.update(targetFilepath).digest();
          const hashBytes = hasherBuffer.subarray(0, 4);
          const shiftValue = 32 - this.bitLength;
          const binNumber = hashBytes.readUInt32BE() >>> shiftValue;
          const suffix = binNumber.toString(16).padStart(this.suffixLen, "0");
          return `${this.namePrefix}-${suffix}`;
        }
        *getRoles() {
          for (let i = 0; i < this.numberOfBins; i++) {
            const suffix = i.toString(16).padStart(this.suffixLen, "0");
            yield `${this.namePrefix}-${suffix}`;
          }
        }
        isDelegatedRole(roleName) {
          const desiredPrefix = this.namePrefix + "-";
          if (!roleName.startsWith(desiredPrefix)) {
            return false;
          }
          const suffix = roleName.slice(desiredPrefix.length, roleName.length);
          if (suffix.length != this.suffixLen) {
            return false;
          }
          if (!suffix.match(/^[0-9a-fA-F]+$/)) {
            return false;
          }
          const num = parseInt(suffix, 16);
          return 0 <= num && num < this.numberOfBins;
        }
        toJSON() {
          const json = {
            ...super.toJSON(),
            bit_length: this.bitLength,
            name_prefix: this.namePrefix,
          };
          return json;
        }
        static fromJSON(data) {
          const { keyids, threshold, bit_length, name_prefix, ...rest } = data;
          if (!utils_1.guard.isStringArray(keyids)) {
            throw new TypeError("keyids must be an array of strings");
          }
          if (typeof threshold !== "number") {
            throw new TypeError("threshold must be a number");
          }
          if (typeof bit_length !== "number") {
            throw new TypeError("bit_length must be a number");
          }
          if (typeof name_prefix !== "string") {
            throw new TypeError("name_prefix must be a string");
          }
          return new SuccinctRoles({
            keyIDs: keyids,
            threshold,
            bitLength: bit_length,
            namePrefix: name_prefix,
            unrecognizedFields: rest,
          });
        }
      }
      exports.SuccinctRoles = SuccinctRoles;
    },
    9392: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Root = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const error_1 = __nccwpck_require__(8448);
      const key_1 = __nccwpck_require__(6697);
      const role_1 = __nccwpck_require__(9393);
      const utils_1 = __nccwpck_require__(5688);
      class Root extends base_1.Signed {
        constructor(options) {
          super(options);
          this.type = base_1.MetadataKind.Root;
          this.keys = options.keys || {};
          this.consistentSnapshot = options.consistentSnapshot ?? true;
          if (!options.roles) {
            this.roles = role_1.TOP_LEVEL_ROLE_NAMES.reduce(
              (acc, role) => ({
                ...acc,
                [role]: new role_1.Role({ keyIDs: [], threshold: 1 }),
              }),
              {},
            );
          } else {
            const roleNames = new Set(Object.keys(options.roles));
            if (
              !role_1.TOP_LEVEL_ROLE_NAMES.every((role) => roleNames.has(role))
            ) {
              throw new error_1.ValueError("missing top-level role");
            }
            this.roles = options.roles;
          }
        }
        addKey(key, role) {
          if (!this.roles[role]) {
            throw new error_1.ValueError(`role ${role} does not exist`);
          }
          if (!this.roles[role].keyIDs.includes(key.keyID)) {
            this.roles[role].keyIDs.push(key.keyID);
          }
          this.keys[key.keyID] = key;
        }
        equals(other) {
          if (!(other instanceof Root)) {
            return false;
          }
          return (
            super.equals(other) &&
            this.consistentSnapshot === other.consistentSnapshot &&
            util_1.default.isDeepStrictEqual(this.keys, other.keys) &&
            util_1.default.isDeepStrictEqual(this.roles, other.roles)
          );
        }
        toJSON() {
          return {
            _type: this.type,
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            keys: keysToJSON(this.keys),
            roles: rolesToJSON(this.roles),
            consistent_snapshot: this.consistentSnapshot,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { keys, roles, consistent_snapshot, ...rest } =
            unrecognizedFields;
          if (typeof consistent_snapshot !== "boolean") {
            throw new TypeError("consistent_snapshot must be a boolean");
          }
          return new Root({
            ...commonFields,
            keys: keysFromJSON(keys),
            roles: rolesFromJSON(roles),
            consistentSnapshot: consistent_snapshot,
            unrecognizedFields: rest,
          });
        }
      }
      exports.Root = Root;
      function keysToJSON(keys) {
        return Object.entries(keys).reduce(
          (acc, [keyID, key]) => ({ ...acc, [keyID]: key.toJSON() }),
          {},
        );
      }
      function rolesToJSON(roles) {
        return Object.entries(roles).reduce(
          (acc, [roleName, role]) => ({ ...acc, [roleName]: role.toJSON() }),
          {},
        );
      }
      function keysFromJSON(data) {
        let keys;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("keys must be an object");
          }
          keys = Object.entries(data).reduce(
            (acc, [keyID, keyData]) => ({
              ...acc,
              [keyID]: key_1.Key.fromJSON(keyID, keyData),
            }),
            {},
          );
        }
        return keys;
      }
      function rolesFromJSON(data) {
        let roles;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("roles must be an object");
          }
          roles = Object.entries(data).reduce(
            (acc, [roleName, roleData]) => ({
              ...acc,
              [roleName]: role_1.Role.fromJSON(roleData),
            }),
            {},
          );
        }
        return roles;
      }
    },
    4222: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Signature = void 0;
      class Signature {
        constructor(options) {
          const { keyID, sig } = options;
          this.keyID = keyID;
          this.sig = sig;
        }
        toJSON() {
          return { keyid: this.keyID, sig: this.sig };
        }
        static fromJSON(data) {
          const { keyid, sig } = data;
          if (typeof keyid !== "string") {
            throw new TypeError("keyid must be a string");
          }
          if (typeof sig !== "string") {
            throw new TypeError("sig must be a string");
          }
          return new Signature({ keyID: keyid, sig });
        }
      }
      exports.Signature = Signature;
    },
    2326: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Snapshot = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const file_1 = __nccwpck_require__(1923);
      const utils_1 = __nccwpck_require__(5688);
      class Snapshot extends base_1.Signed {
        constructor(opts) {
          super(opts);
          this.type = base_1.MetadataKind.Snapshot;
          this.meta = opts.meta || {
            "targets.json": new file_1.MetaFile({ version: 1 }),
          };
        }
        equals(other) {
          if (!(other instanceof Snapshot)) {
            return false;
          }
          return (
            super.equals(other) &&
            util_1.default.isDeepStrictEqual(this.meta, other.meta)
          );
        }
        toJSON() {
          return {
            _type: this.type,
            meta: metaToJSON(this.meta),
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { meta, ...rest } = unrecognizedFields;
          return new Snapshot({
            ...commonFields,
            meta: metaFromJSON(meta),
            unrecognizedFields: rest,
          });
        }
      }
      exports.Snapshot = Snapshot;
      function metaToJSON(meta) {
        return Object.entries(meta).reduce(
          (acc, [path, metadata]) => ({ ...acc, [path]: metadata.toJSON() }),
          {},
        );
      }
      function metaFromJSON(data) {
        let meta;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("meta field is malformed");
          } else {
            meta = Object.entries(data).reduce(
              (acc, [path, metadata]) => ({
                ...acc,
                [path]: file_1.MetaFile.fromJSON(metadata),
              }),
              {},
            );
          }
        }
        return meta;
      }
    },
    5799: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Targets = void 0;
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const base_1 = __nccwpck_require__(159);
      const delegations_1 = __nccwpck_require__(1662);
      const file_1 = __nccwpck_require__(1923);
      const utils_1 = __nccwpck_require__(5688);
      class Targets extends base_1.Signed {
        constructor(options) {
          super(options);
          this.type = base_1.MetadataKind.Targets;
          this.targets = options.targets || {};
          this.delegations = options.delegations;
        }
        addTarget(target) {
          this.targets[target.path] = target;
        }
        equals(other) {
          if (!(other instanceof Targets)) {
            return false;
          }
          return (
            super.equals(other) &&
            util_1.default.isDeepStrictEqual(this.targets, other.targets) &&
            util_1.default.isDeepStrictEqual(
              this.delegations,
              other.delegations,
            )
          );
        }
        toJSON() {
          const json = {
            _type: this.type,
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            targets: targetsToJSON(this.targets),
            ...this.unrecognizedFields,
          };
          if (this.delegations) {
            json.delegations = this.delegations.toJSON();
          }
          return json;
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { targets, delegations, ...rest } = unrecognizedFields;
          return new Targets({
            ...commonFields,
            targets: targetsFromJSON(targets),
            delegations: delegationsFromJSON(delegations),
            unrecognizedFields: rest,
          });
        }
      }
      exports.Targets = Targets;
      function targetsToJSON(targets) {
        return Object.entries(targets).reduce(
          (acc, [path, target]) => ({ ...acc, [path]: target.toJSON() }),
          {},
        );
      }
      function targetsFromJSON(data) {
        let targets;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObjectRecord(data)) {
            throw new TypeError("targets must be an object");
          } else {
            targets = Object.entries(data).reduce(
              (acc, [path, target]) => ({
                ...acc,
                [path]: file_1.TargetFile.fromJSON(path, target),
              }),
              {},
            );
          }
        }
        return targets;
      }
      function delegationsFromJSON(data) {
        let delegations;
        if (utils_1.guard.isDefined(data)) {
          if (!utils_1.guard.isObject(data)) {
            throw new TypeError("delegations must be an object");
          } else {
            delegations = delegations_1.Delegations.fromJSON(data);
          }
        }
        return delegations;
      }
    },
    4042: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Timestamp = void 0;
      const base_1 = __nccwpck_require__(159);
      const file_1 = __nccwpck_require__(1923);
      const utils_1 = __nccwpck_require__(5688);
      class Timestamp extends base_1.Signed {
        constructor(options) {
          super(options);
          this.type = base_1.MetadataKind.Timestamp;
          this.snapshotMeta =
            options.snapshotMeta || new file_1.MetaFile({ version: 1 });
        }
        equals(other) {
          if (!(other instanceof Timestamp)) {
            return false;
          }
          return (
            super.equals(other) && this.snapshotMeta.equals(other.snapshotMeta)
          );
        }
        toJSON() {
          return {
            _type: this.type,
            spec_version: this.specVersion,
            version: this.version,
            expires: this.expires,
            meta: { "snapshot.json": this.snapshotMeta.toJSON() },
            ...this.unrecognizedFields,
          };
        }
        static fromJSON(data) {
          const { unrecognizedFields, ...commonFields } =
            base_1.Signed.commonFieldsFromJSON(data);
          const { meta, ...rest } = unrecognizedFields;
          return new Timestamp({
            ...commonFields,
            snapshotMeta: snapshotMetaFromJSON(meta),
            unrecognizedFields: rest,
          });
        }
      }
      exports.Timestamp = Timestamp;
      function snapshotMetaFromJSON(data) {
        let snapshotMeta;
        if (utils_1.guard.isDefined(data)) {
          const snapshotData = data["snapshot.json"];
          if (
            !utils_1.guard.isDefined(snapshotData) ||
            !utils_1.guard.isObject(snapshotData)
          ) {
            throw new TypeError("missing snapshot.json in meta");
          } else {
            snapshotMeta = file_1.MetaFile.fromJSON(snapshotData);
          }
        }
        return snapshotMeta;
      }
    },
    7106: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isObjectRecord =
        exports.isStringRecord =
        exports.isObjectArray =
        exports.isStringArray =
        exports.isObject =
        exports.isDefined =
          void 0;
      function isDefined(val) {
        return val !== undefined;
      }
      exports.isDefined = isDefined;
      function isObject(value) {
        return typeof value === "object" && value !== null;
      }
      exports.isObject = isObject;
      function isStringArray(value) {
        return (
          Array.isArray(value) && value.every((v) => typeof v === "string")
        );
      }
      exports.isStringArray = isStringArray;
      function isObjectArray(value) {
        return Array.isArray(value) && value.every(isObject);
      }
      exports.isObjectArray = isObjectArray;
      function isStringRecord(value) {
        return (
          typeof value === "object" &&
          value !== null &&
          Object.keys(value).every((k) => typeof k === "string") &&
          Object.values(value).every((v) => typeof v === "string")
        );
      }
      exports.isStringRecord = isStringRecord;
      function isObjectRecord(value) {
        return (
          typeof value === "object" &&
          value !== null &&
          Object.keys(value).every((k) => typeof k === "string") &&
          Object.values(value).every((v) => typeof v === "object" && v !== null)
        );
      }
      exports.isObjectRecord = isObjectRecord;
    },
    5688: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.crypto = exports.guard = void 0;
      exports.guard = __importStar(__nccwpck_require__(7106));
      exports.crypto = __importStar(__nccwpck_require__(8430));
    },
    8725: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.getPublicKey = void 0;
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const error_1 = __nccwpck_require__(8448);
      const oid_1 = __nccwpck_require__(8680);
      const ASN1_TAG_SEQUENCE = 48;
      const ANS1_TAG_BIT_STRING = 3;
      const NULL_BYTE = 0;
      const OID_EDDSA = "1.3.101.112";
      const OID_EC_PUBLIC_KEY = "1.2.840.10045.2.1";
      const OID_EC_CURVE_P256V1 = "1.2.840.10045.3.1.7";
      const PEM_HEADER = "-----BEGIN PUBLIC KEY-----";
      function getPublicKey(keyInfo) {
        switch (keyInfo.keyType) {
          case "rsa":
            return getRSAPublicKey(keyInfo);
          case "ed25519":
            return getED25519PublicKey(keyInfo);
          case "ecdsa":
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
            return getECDCSAPublicKey(keyInfo);
          default:
            throw new error_1.UnsupportedAlgorithmError(
              `Unsupported key type: ${keyInfo.keyType}`,
            );
        }
      }
      exports.getPublicKey = getPublicKey;
      function getRSAPublicKey(keyInfo) {
        if (!keyInfo.keyVal.startsWith(PEM_HEADER)) {
          throw new error_1.CryptoError("Invalid key format");
        }
        const key = crypto_1.default.createPublicKey(keyInfo.keyVal);
        switch (keyInfo.scheme) {
          case "rsassa-pss-sha256":
            return {
              key,
              padding: crypto_1.default.constants.RSA_PKCS1_PSS_PADDING,
            };
          default:
            throw new error_1.UnsupportedAlgorithmError(
              `Unsupported RSA scheme: ${keyInfo.scheme}`,
            );
        }
      }
      function getED25519PublicKey(keyInfo) {
        let key;
        if (keyInfo.keyVal.startsWith(PEM_HEADER)) {
          key = crypto_1.default.createPublicKey(keyInfo.keyVal);
        } else {
          if (!isHex(keyInfo.keyVal)) {
            throw new error_1.CryptoError("Invalid key format");
          }
          key = crypto_1.default.createPublicKey({
            key: ed25519.hexToDER(keyInfo.keyVal),
            format: "der",
            type: "spki",
          });
        }
        return { key };
      }
      function getECDCSAPublicKey(keyInfo) {
        let key;
        if (keyInfo.keyVal.startsWith(PEM_HEADER)) {
          key = crypto_1.default.createPublicKey(keyInfo.keyVal);
        } else {
          if (!isHex(keyInfo.keyVal)) {
            throw new error_1.CryptoError("Invalid key format");
          }
          key = crypto_1.default.createPublicKey({
            key: ecdsa.hexToDER(keyInfo.keyVal),
            format: "der",
            type: "spki",
          });
        }
        return { key };
      }
      const ed25519 = {
        hexToDER: (hex) => {
          const key = Buffer.from(hex, "hex");
          const oid = (0, oid_1.encodeOIDString)(OID_EDDSA);
          const elements = Buffer.concat([
            Buffer.concat([
              Buffer.from([ASN1_TAG_SEQUENCE]),
              Buffer.from([oid.length]),
              oid,
            ]),
            Buffer.concat([
              Buffer.from([ANS1_TAG_BIT_STRING]),
              Buffer.from([key.length + 1]),
              Buffer.from([NULL_BYTE]),
              key,
            ]),
          ]);
          const der = Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([elements.length]),
            elements,
          ]);
          return der;
        },
      };
      const ecdsa = {
        hexToDER: (hex) => {
          const key = Buffer.from(hex, "hex");
          const bitString = Buffer.concat([
            Buffer.from([ANS1_TAG_BIT_STRING]),
            Buffer.from([key.length + 1]),
            Buffer.from([NULL_BYTE]),
            key,
          ]);
          const oids = Buffer.concat([
            (0, oid_1.encodeOIDString)(OID_EC_PUBLIC_KEY),
            (0, oid_1.encodeOIDString)(OID_EC_CURVE_P256V1),
          ]);
          const oidSequence = Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([oids.length]),
            oids,
          ]);
          const der = Buffer.concat([
            Buffer.from([ASN1_TAG_SEQUENCE]),
            Buffer.from([oidSequence.length + bitString.length]),
            oidSequence,
            bitString,
          ]);
          return der;
        },
      };
      const isHex = (key) => /^[0-9a-fA-F]+$/.test(key);
    },
    8680: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.encodeOIDString = void 0;
      const ANS1_TAG_OID = 6;
      function encodeOIDString(oid) {
        const parts = oid.split(".");
        const first = parseInt(parts[0], 10) * 40 + parseInt(parts[1], 10);
        const rest = [];
        parts.slice(2).forEach((part) => {
          const bytes = encodeVariableLengthInteger(parseInt(part, 10));
          rest.push(...bytes);
        });
        const der = Buffer.from([first, ...rest]);
        return Buffer.from([ANS1_TAG_OID, der.length, ...der]);
      }
      exports.encodeOIDString = encodeOIDString;
      function encodeVariableLengthInteger(value) {
        const bytes = [];
        let mask = 0;
        while (value > 0) {
          bytes.unshift((value & 127) | mask);
          value >>= 7;
          mask = 128;
        }
        return bytes;
      }
    },
    8430: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verifySignature = void 0;
      const canonical_json_1 = __nccwpck_require__(9652);
      const crypto_1 = __importDefault(__nccwpck_require__(6113));
      const verifySignature = (metaDataSignedData, key, signature) => {
        const canonicalData = Buffer.from(
          (0, canonical_json_1.canonicalize)(metaDataSignedData),
        );
        return crypto_1.default.verify(
          undefined,
          canonicalData,
          key,
          Buffer.from(signature, "hex"),
        );
      };
      exports.verifySignature = verifySignature;
    },
    8348: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.req = exports.json = exports.toBuffer = void 0;
      const http = __importStar(__nccwpck_require__(3685));
      const https = __importStar(__nccwpck_require__(5687));
      async function toBuffer(stream) {
        let length = 0;
        const chunks = [];
        for await (const chunk of stream) {
          length += chunk.length;
          chunks.push(chunk);
        }
        return Buffer.concat(chunks, length);
      }
      exports.toBuffer = toBuffer;
      async function json(stream) {
        const buf = await toBuffer(stream);
        const str = buf.toString("utf8");
        try {
          return JSON.parse(str);
        } catch (_err) {
          const err = _err;
          err.message += ` (input: ${str})`;
          throw err;
        }
      }
      exports.json = json;
      function req(url, opts = {}) {
        const href = typeof url === "string" ? url : url.href;
        const req = (href.startsWith("https:") ? https : http).request(
          url,
          opts,
        );
        const promise = new Promise((resolve, reject) => {
          req.once("response", resolve).once("error", reject).end();
        });
        req.then = promise.then.bind(promise);
        return req;
      }
      exports.req = req;
    },
    694: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Agent = void 0;
      const net = __importStar(__nccwpck_require__(1808));
      const http = __importStar(__nccwpck_require__(3685));
      const https_1 = __nccwpck_require__(5687);
      __exportStar(__nccwpck_require__(8348), exports);
      const INTERNAL = Symbol("AgentBaseInternalState");
      class Agent extends http.Agent {
        constructor(opts) {
          super(opts);
          this[INTERNAL] = {};
        }
        isSecureEndpoint(options) {
          if (options) {
            if (typeof options.secureEndpoint === "boolean") {
              return options.secureEndpoint;
            }
            if (typeof options.protocol === "string") {
              return options.protocol === "https:";
            }
          }
          const { stack } = new Error();
          if (typeof stack !== "string") return false;
          return stack
            .split("\n")
            .some(
              (l) =>
                l.indexOf("(https.js:") !== -1 ||
                l.indexOf("node:https:") !== -1,
            );
        }
        incrementSockets(name) {
          if (
            this.maxSockets === Infinity &&
            this.maxTotalSockets === Infinity
          ) {
            return null;
          }
          if (!this.sockets[name]) {
            this.sockets[name] = [];
          }
          const fakeSocket = new net.Socket({ writable: false });
          this.sockets[name].push(fakeSocket);
          this.totalSocketCount++;
          return fakeSocket;
        }
        decrementSockets(name, socket) {
          if (!this.sockets[name] || socket === null) {
            return;
          }
          const sockets = this.sockets[name];
          const index = sockets.indexOf(socket);
          if (index !== -1) {
            sockets.splice(index, 1);
            this.totalSocketCount--;
            if (sockets.length === 0) {
              delete this.sockets[name];
            }
          }
        }
        getName(options) {
          const secureEndpoint =
            typeof options.secureEndpoint === "boolean"
              ? options.secureEndpoint
              : this.isSecureEndpoint(options);
          if (secureEndpoint) {
            return https_1.Agent.prototype.getName.call(this, options);
          }
          return super.getName(options);
        }
        createSocket(req, options, cb) {
          const connectOpts = {
            ...options,
            secureEndpoint: this.isSecureEndpoint(options),
          };
          const name = this.getName(connectOpts);
          const fakeSocket = this.incrementSockets(name);
          Promise.resolve()
            .then(() => this.connect(req, connectOpts))
            .then(
              (socket) => {
                this.decrementSockets(name, fakeSocket);
                if (socket instanceof http.Agent) {
                  return socket.addRequest(req, connectOpts);
                }
                this[INTERNAL].currentSocket = socket;
                super.createSocket(req, options, cb);
              },
              (err) => {
                this.decrementSockets(name, fakeSocket);
                cb(err);
              },
            );
        }
        createConnection() {
          const socket = this[INTERNAL].currentSocket;
          this[INTERNAL].currentSocket = undefined;
          if (!socket) {
            throw new Error(
              "No socket was returned in the `connect()` function",
            );
          }
          return socket;
        }
        get defaultPort() {
          return (
            this[INTERNAL].defaultPort ??
            (this.protocol === "https:" ? 443 : 80)
          );
        }
        set defaultPort(v) {
          if (this[INTERNAL]) {
            this[INTERNAL].defaultPort = v;
          }
        }
        get protocol() {
          return (
            this[INTERNAL].protocol ??
            (this.isSecureEndpoint() ? "https:" : "http:")
          );
        }
        set protocol(v) {
          if (this[INTERNAL]) {
            this[INTERNAL].protocol = v;
          }
        }
      }
      exports.Agent = Agent;
    },
    9417: (module) => {
      "use strict";
      module.exports = balanced;
      function balanced(a, b, str) {
        if (a instanceof RegExp) a = maybeMatch(a, str);
        if (b instanceof RegExp) b = maybeMatch(b, str);
        var r = range(a, b, str);
        return (
          r && {
            start: r[0],
            end: r[1],
            pre: str.slice(0, r[0]),
            body: str.slice(r[0] + a.length, r[1]),
            post: str.slice(r[1] + b.length),
          }
        );
      }
      function maybeMatch(reg, str) {
        var m = str.match(reg);
        return m ? m[0] : null;
      }
      balanced.range = range;
      function range(a, b, str) {
        var begs, beg, left, right, result;
        var ai = str.indexOf(a);
        var bi = str.indexOf(b, ai + 1);
        var i = ai;
        if (ai >= 0 && bi > 0) {
          if (a === b) {
            return [ai, bi];
          }
          begs = [];
          left = str.length;
          while (i >= 0 && !result) {
            if (i == ai) {
              begs.push(i);
              ai = str.indexOf(a, i + 1);
            } else if (begs.length == 1) {
              result = [begs.pop(), bi];
            } else {
              beg = begs.pop();
              if (beg < left) {
                left = beg;
                right = bi;
              }
              bi = str.indexOf(b, i + 1);
            }
            i = ai < bi && ai >= 0 ? ai : bi;
          }
          if (begs.length) {
            result = [left, right];
          }
        }
        return result;
      }
    },
    6339: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const vendors = __nccwpck_require__(3236);
      const env = process.env;
      Object.defineProperty(exports, "_vendors", {
        value: vendors.map(function (v) {
          return v.constant;
        }),
      });
      exports.name = null;
      exports.isPR = null;
      vendors.forEach(function (vendor) {
        const envs = Array.isArray(vendor.env) ? vendor.env : [vendor.env];
        const isCI = envs.every(function (obj) {
          return checkEnv(obj);
        });
        exports[vendor.constant] = isCI;
        if (!isCI) {
          return;
        }
        exports.name = vendor.name;
        switch (typeof vendor.pr) {
          case "string":
            exports.isPR = !!env[vendor.pr];
            break;
          case "object":
            if ("env" in vendor.pr) {
              exports.isPR =
                vendor.pr.env in env && env[vendor.pr.env] !== vendor.pr.ne;
            } else if ("any" in vendor.pr) {
              exports.isPR = vendor.pr.any.some(function (key) {
                return !!env[key];
              });
            } else {
              exports.isPR = checkEnv(vendor.pr);
            }
            break;
          default:
            exports.isPR = null;
        }
      });
      exports.isCI = !!(
        env.CI !== "false" &&
        (env.BUILD_ID ||
          env.BUILD_NUMBER ||
          env.CI ||
          env.CI_APP_ID ||
          env.CI_BUILD_ID ||
          env.CI_BUILD_NUMBER ||
          env.CI_NAME ||
          env.CONTINUOUS_INTEGRATION ||
          env.RUN_ID ||
          exports.name ||
          false)
      );
      function checkEnv(obj) {
        if (typeof obj === "string") return !!env[obj];
        if ("env" in obj) {
          return env[obj.env] && env[obj.env].includes(obj.includes);
        }
        if ("any" in obj) {
          return obj.any.some(function (k) {
            return !!env[k];
          });
        }
        return Object.keys(obj).every(function (k) {
          return env[k] === obj[k];
        });
      }
    },
    8222: (module, exports, __nccwpck_require__) => {
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.storage = localstorage();
      exports.destroy = (() => {
        let warned = false;
        return () => {
          if (!warned) {
            warned = true;
            console.warn(
              "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
            );
          }
        };
      })();
      exports.colors = [
        "#0000CC",
        "#0000FF",
        "#0033CC",
        "#0033FF",
        "#0066CC",
        "#0066FF",
        "#0099CC",
        "#0099FF",
        "#00CC00",
        "#00CC33",
        "#00CC66",
        "#00CC99",
        "#00CCCC",
        "#00CCFF",
        "#3300CC",
        "#3300FF",
        "#3333CC",
        "#3333FF",
        "#3366CC",
        "#3366FF",
        "#3399CC",
        "#3399FF",
        "#33CC00",
        "#33CC33",
        "#33CC66",
        "#33CC99",
        "#33CCCC",
        "#33CCFF",
        "#6600CC",
        "#6600FF",
        "#6633CC",
        "#6633FF",
        "#66CC00",
        "#66CC33",
        "#9900CC",
        "#9900FF",
        "#9933CC",
        "#9933FF",
        "#99CC00",
        "#99CC33",
        "#CC0000",
        "#CC0033",
        "#CC0066",
        "#CC0099",
        "#CC00CC",
        "#CC00FF",
        "#CC3300",
        "#CC3333",
        "#CC3366",
        "#CC3399",
        "#CC33CC",
        "#CC33FF",
        "#CC6600",
        "#CC6633",
        "#CC9900",
        "#CC9933",
        "#CCCC00",
        "#CCCC33",
        "#FF0000",
        "#FF0033",
        "#FF0066",
        "#FF0099",
        "#FF00CC",
        "#FF00FF",
        "#FF3300",
        "#FF3333",
        "#FF3366",
        "#FF3399",
        "#FF33CC",
        "#FF33FF",
        "#FF6600",
        "#FF6633",
        "#FF9900",
        "#FF9933",
        "#FFCC00",
        "#FFCC33",
      ];
      function useColors() {
        if (
          typeof window !== "undefined" &&
          window.process &&
          (window.process.type === "renderer" || window.process.__nwjs)
        ) {
          return true;
        }
        if (
          typeof navigator !== "undefined" &&
          navigator.userAgent &&
          navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
        ) {
          return false;
        }
        let m;
        return (
          (typeof document !== "undefined" &&
            document.documentElement &&
            document.documentElement.style &&
            document.documentElement.style.WebkitAppearance) ||
          (typeof window !== "undefined" &&
            window.console &&
            (window.console.firebug ||
              (window.console.exception && window.console.table))) ||
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
            parseInt(m[1], 10) >= 31) ||
          (typeof navigator !== "undefined" &&
            navigator.userAgent &&
            navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
        );
      }
      function formatArgs(args) {
        args[0] =
          (this.useColors ? "%c" : "") +
          this.namespace +
          (this.useColors ? " %c" : " ") +
          args[0] +
          (this.useColors ? "%c " : " ") +
          "+" +
          module.exports.humanize(this.diff);
        if (!this.useColors) {
          return;
        }
        const c = "color: " + this.color;
        args.splice(1, 0, c, "color: inherit");
        let index = 0;
        let lastC = 0;
        args[0].replace(/%[a-zA-Z%]/g, (match) => {
          if (match === "%%") {
            return;
          }
          index++;
          if (match === "%c") {
            lastC = index;
          }
        });
        args.splice(lastC, 0, c);
      }
      exports.log = console.debug || console.log || (() => {});
      function save(namespaces) {
        try {
          if (namespaces) {
            exports.storage.setItem("debug", namespaces);
          } else {
            exports.storage.removeItem("debug");
          }
        } catch (error) {}
      }
      function load() {
        let r;
        try {
          r = exports.storage.getItem("debug");
        } catch (error) {}
        if (!r && typeof process !== "undefined" && "env" in process) {
          r = process.env.DEBUG;
        }
        return r;
      }
      function localstorage() {
        try {
          return localStorage;
        } catch (error) {}
      }
      module.exports = __nccwpck_require__(6243)(exports);
      const { formatters } = module.exports;
      formatters.j = function (v) {
        try {
          return JSON.stringify(v);
        } catch (error) {
          return "[UnexpectedJSONParseError]: " + error.message;
        }
      };
    },
    6243: (module, __unused_webpack_exports, __nccwpck_require__) => {
      function setup(env) {
        createDebug.debug = createDebug;
        createDebug.default = createDebug;
        createDebug.coerce = coerce;
        createDebug.disable = disable;
        createDebug.enable = enable;
        createDebug.enabled = enabled;
        createDebug.humanize = __nccwpck_require__(900);
        createDebug.destroy = destroy;
        Object.keys(env).forEach((key) => {
          createDebug[key] = env[key];
        });
        createDebug.names = [];
        createDebug.skips = [];
        createDebug.formatters = {};
        function selectColor(namespace) {
          let hash = 0;
          for (let i = 0; i < namespace.length; i++) {
            hash = (hash << 5) - hash + namespace.charCodeAt(i);
            hash |= 0;
          }
          return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
        }
        createDebug.selectColor = selectColor;
        function createDebug(namespace) {
          let prevTime;
          let enableOverride = null;
          let namespacesCache;
          let enabledCache;
          function debug(...args) {
            if (!debug.enabled) {
              return;
            }
            const self = debug;
            const curr = Number(new Date());
            const ms = curr - (prevTime || curr);
            self.diff = ms;
            self.prev = prevTime;
            self.curr = curr;
            prevTime = curr;
            args[0] = createDebug.coerce(args[0]);
            if (typeof args[0] !== "string") {
              args.unshift("%O");
            }
            let index = 0;
            args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
              if (match === "%%") {
                return "%";
              }
              index++;
              const formatter = createDebug.formatters[format];
              if (typeof formatter === "function") {
                const val = args[index];
                match = formatter.call(self, val);
                args.splice(index, 1);
                index--;
              }
              return match;
            });
            createDebug.formatArgs.call(self, args);
            const logFn = self.log || createDebug.log;
            logFn.apply(self, args);
          }
          debug.namespace = namespace;
          debug.useColors = createDebug.useColors();
          debug.color = createDebug.selectColor(namespace);
          debug.extend = extend;
          debug.destroy = createDebug.destroy;
          Object.defineProperty(debug, "enabled", {
            enumerable: true,
            configurable: false,
            get: () => {
              if (enableOverride !== null) {
                return enableOverride;
              }
              if (namespacesCache !== createDebug.namespaces) {
                namespacesCache = createDebug.namespaces;
                enabledCache = createDebug.enabled(namespace);
              }
              return enabledCache;
            },
            set: (v) => {
              enableOverride = v;
            },
          });
          if (typeof createDebug.init === "function") {
            createDebug.init(debug);
          }
          return debug;
        }
        function extend(namespace, delimiter) {
          const newDebug = createDebug(
            this.namespace +
              (typeof delimiter === "undefined" ? ":" : delimiter) +
              namespace,
          );
          newDebug.log = this.log;
          return newDebug;
        }
        function enable(namespaces) {
          createDebug.save(namespaces);
          createDebug.namespaces = namespaces;
          createDebug.names = [];
          createDebug.skips = [];
          let i;
          const split = (
            typeof namespaces === "string" ? namespaces : ""
          ).split(/[\s,]+/);
          const len = split.length;
          for (i = 0; i < len; i++) {
            if (!split[i]) {
              continue;
            }
            namespaces = split[i].replace(/\*/g, ".*?");
            if (namespaces[0] === "-") {
              createDebug.skips.push(
                new RegExp("^" + namespaces.slice(1) + "$"),
              );
            } else {
              createDebug.names.push(new RegExp("^" + namespaces + "$"));
            }
          }
        }
        function disable() {
          const namespaces = [
            ...createDebug.names.map(toNamespace),
            ...createDebug.skips
              .map(toNamespace)
              .map((namespace) => "-" + namespace),
          ].join(",");
          createDebug.enable("");
          return namespaces;
        }
        function enabled(name) {
          if (name[name.length - 1] === "*") {
            return true;
          }
          let i;
          let len;
          for (i = 0, len = createDebug.skips.length; i < len; i++) {
            if (createDebug.skips[i].test(name)) {
              return false;
            }
          }
          for (i = 0, len = createDebug.names.length; i < len; i++) {
            if (createDebug.names[i].test(name)) {
              return true;
            }
          }
          return false;
        }
        function toNamespace(regexp) {
          return regexp
            .toString()
            .substring(2, regexp.toString().length - 2)
            .replace(/\.\*\?$/, "*");
        }
        function coerce(val) {
          if (val instanceof Error) {
            return val.stack || val.message;
          }
          return val;
        }
        function destroy() {
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          );
        }
        createDebug.enable(createDebug.load());
        return createDebug;
      }
      module.exports = setup;
    },
    8237: (module, __unused_webpack_exports, __nccwpck_require__) => {
      if (
        typeof process === "undefined" ||
        process.type === "renderer" ||
        process.browser === true ||
        process.__nwjs
      ) {
        module.exports = __nccwpck_require__(8222);
      } else {
        module.exports = __nccwpck_require__(5332);
      }
    },
    5332: (module, exports, __nccwpck_require__) => {
      const tty = __nccwpck_require__(6224);
      const util = __nccwpck_require__(3837);
      exports.init = init;
      exports.log = log;
      exports.formatArgs = formatArgs;
      exports.save = save;
      exports.load = load;
      exports.useColors = useColors;
      exports.destroy = util.deprecate(
        () => {},
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
      exports.colors = [6, 2, 3, 4, 5, 1];
      try {
        const supportsColor = __nccwpck_require__(132);
        if (
          supportsColor &&
          (supportsColor.stderr || supportsColor).level >= 2
        ) {
          exports.colors = [
            20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62,
            63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112,
            113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165,
            166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185, 196,
            197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209,
            214, 215, 220, 221,
          ];
        }
      } catch (error) {}
      exports.inspectOpts = Object.keys(process.env)
        .filter((key) => /^debug_/i.test(key))
        .reduce((obj, key) => {
          const prop = key
            .substring(6)
            .toLowerCase()
            .replace(/_([a-z])/g, (_, k) => k.toUpperCase());
          let val = process.env[key];
          if (/^(yes|on|true|enabled)$/i.test(val)) {
            val = true;
          } else if (/^(no|off|false|disabled)$/i.test(val)) {
            val = false;
          } else if (val === "null") {
            val = null;
          } else {
            val = Number(val);
          }
          obj[prop] = val;
          return obj;
        }, {});
      function useColors() {
        return "colors" in exports.inspectOpts
          ? Boolean(exports.inspectOpts.colors)
          : tty.isatty(process.stderr.fd);
      }
      function formatArgs(args) {
        const { namespace: name, useColors } = this;
        if (useColors) {
          const c = this.color;
          const colorCode = "[3" + (c < 8 ? c : "8;5;" + c);
          const prefix = `  ${colorCode};1m${name} [0m`;
          args[0] = prefix + args[0].split("\n").join("\n" + prefix);
          args.push(
            colorCode + "m+" + module.exports.humanize(this.diff) + "[0m",
          );
        } else {
          args[0] = getDate() + name + " " + args[0];
        }
      }
      function getDate() {
        if (exports.inspectOpts.hideDate) {
          return "";
        }
        return new Date().toISOString() + " ";
      }
      function log(...args) {
        return process.stderr.write(
          util.formatWithOptions(exports.inspectOpts, ...args) + "\n",
        );
      }
      function save(namespaces) {
        if (namespaces) {
          process.env.DEBUG = namespaces;
        } else {
          delete process.env.DEBUG;
        }
      }
      function load() {
        return process.env.DEBUG;
      }
      function init(debug) {
        debug.inspectOpts = {};
        const keys = Object.keys(exports.inspectOpts);
        for (let i = 0; i < keys.length; i++) {
          debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
        }
      }
      module.exports = __nccwpck_require__(6243)(exports);
      const { formatters } = module.exports;
      formatters.o = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util
          .inspect(v, this.inspectOpts)
          .split("\n")
          .map((str) => str.trim())
          .join(" ");
      };
      formatters.O = function (v) {
        this.inspectOpts.colors = this.useColors;
        return util.inspect(v, this.inspectOpts);
      };
    },
    8685: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var iconvLite = __nccwpck_require__(9032);
      module.exports.O = convert;
      function convert(str, to, from) {
        from = checkEncoding(from || "UTF-8");
        to = checkEncoding(to || "UTF-8");
        str = str || "";
        var result;
        if (from !== "UTF-8" && typeof str === "string") {
          str = Buffer.from(str, "binary");
        }
        if (from === to) {
          if (typeof str === "string") {
            result = Buffer.from(str);
          } else {
            result = str;
          }
        } else {
          try {
            result = convertIconvLite(str, to, from);
          } catch (E) {
            console.error(E);
            result = str;
          }
        }
        if (typeof result === "string") {
          result = Buffer.from(result, "utf-8");
        }
        return result;
      }
      function convertIconvLite(str, to, from) {
        if (to === "UTF-8") {
          return iconvLite.decode(str, from);
        } else if (from === "UTF-8") {
          return iconvLite.encode(str, to);
        } else {
          return iconvLite.encode(iconvLite.decode(str, from), to);
        }
      }
      function checkEncoding(name) {
        return (name || "")
          .toString()
          .trim()
          .replace(/^latin[\-_]?(\d+)$/i, "ISO-8859-$1")
          .replace(/^win(?:dows)?[\-_]?(\d+)$/i, "WINDOWS-$1")
          .replace(/^utf[\-_]?(\d+)$/i, "UTF-$1")
          .replace(/^ks_c_5601\-1987$/i, "CP949")
          .replace(/^us[\-_]?ascii$/i, "ASCII")
          .toUpperCase();
      }
    },
    2997: (module) => {
      "use strict";
      function assign(obj, props) {
        for (const key in props) {
          Object.defineProperty(obj, key, {
            value: props[key],
            enumerable: true,
            configurable: true,
          });
        }
        return obj;
      }
      function createError(err, code, props) {
        if (!err || typeof err === "string") {
          throw new TypeError("Please pass an Error to err-code");
        }
        if (!props) {
          props = {};
        }
        if (typeof code === "object") {
          props = code;
          code = undefined;
        }
        if (code != null) {
          props.code = code;
        }
        try {
          return assign(err, props);
        } catch (_) {
          props.message = err.message;
          props.stack = err.stack;
          const ErrClass = function () {};
          ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
          return assign(new ErrClass(), props);
        }
      }
      module.exports = createError;
    },
    1756: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const parseUrl = __nccwpck_require__(4250);
      const isGitHubShorthand = (arg) => {
        const firstHash = arg.indexOf("#");
        const firstSlash = arg.indexOf("/");
        const secondSlash = arg.indexOf("/", firstSlash + 1);
        const firstColon = arg.indexOf(":");
        const firstSpace = /\s/.exec(arg);
        const firstAt = arg.indexOf("@");
        const spaceOnlyAfterHash =
          !firstSpace || (firstHash > -1 && firstSpace.index > firstHash);
        const atOnlyAfterHash =
          firstAt === -1 || (firstHash > -1 && firstAt > firstHash);
        const colonOnlyAfterHash =
          firstColon === -1 || (firstHash > -1 && firstColon > firstHash);
        const secondSlashOnlyAfterHash =
          secondSlash === -1 || (firstHash > -1 && secondSlash > firstHash);
        const hasSlash = firstSlash > 0;
        const doesNotEndWithSlash =
          firstHash > -1 ? arg[firstHash - 1] !== "/" : !arg.endsWith("/");
        const doesNotStartWithDot = !arg.startsWith(".");
        return (
          spaceOnlyAfterHash &&
          hasSlash &&
          doesNotEndWithSlash &&
          doesNotStartWithDot &&
          atOnlyAfterHash &&
          colonOnlyAfterHash &&
          secondSlashOnlyAfterHash
        );
      };
      module.exports = (giturl, opts, { gitHosts, protocols }) => {
        if (!giturl) {
          return;
        }
        const correctedUrl = isGitHubShorthand(giturl)
          ? `github:${giturl}`
          : giturl;
        const parsed = parseUrl(correctedUrl, protocols);
        if (!parsed) {
          return;
        }
        const gitHostShortcut = gitHosts.byShortcut[parsed.protocol];
        const gitHostDomain =
          gitHosts.byDomain[
            parsed.hostname.startsWith("www.")
              ? parsed.hostname.slice(4)
              : parsed.hostname
          ];
        const gitHostName = gitHostShortcut || gitHostDomain;
        if (!gitHostName) {
          return;
        }
        const gitHostInfo = gitHosts[gitHostShortcut || gitHostDomain];
        let auth = null;
        if (
          protocols[parsed.protocol]?.auth &&
          (parsed.username || parsed.password)
        ) {
          auth = `${parsed.username}${parsed.password ? ":" + parsed.password : ""}`;
        }
        let committish = null;
        let user = null;
        let project = null;
        let defaultRepresentation = null;
        try {
          if (gitHostShortcut) {
            let pathname = parsed.pathname.startsWith("/")
              ? parsed.pathname.slice(1)
              : parsed.pathname;
            const firstAt = pathname.indexOf("@");
            if (firstAt > -1) {
              pathname = pathname.slice(firstAt + 1);
            }
            const lastSlash = pathname.lastIndexOf("/");
            if (lastSlash > -1) {
              user = decodeURIComponent(pathname.slice(0, lastSlash));
              if (!user) {
                user = null;
              }
              project = decodeURIComponent(pathname.slice(lastSlash + 1));
            } else {
              project = decodeURIComponent(pathname);
            }
            if (project.endsWith(".git")) {
              project = project.slice(0, -4);
            }
            if (parsed.hash) {
              committish = decodeURIComponent(parsed.hash.slice(1));
            }
            defaultRepresentation = "shortcut";
          } else {
            if (!gitHostInfo.protocols.includes(parsed.protocol)) {
              return;
            }
            const segments = gitHostInfo.extract(parsed);
            if (!segments) {
              return;
            }
            user = segments.user && decodeURIComponent(segments.user);
            project = decodeURIComponent(segments.project);
            committish = decodeURIComponent(segments.committish);
            defaultRepresentation =
              protocols[parsed.protocol]?.name || parsed.protocol.slice(0, -1);
          }
        } catch (err) {
          if (err instanceof URIError) {
            return;
          } else {
            throw err;
          }
        }
        return [
          gitHostName,
          user,
          auth,
          project,
          committish,
          defaultRepresentation,
          opts,
        ];
      };
    },
    5572: (module) => {
      "use strict";
      const maybeJoin = (...args) =>
        args.every((arg) => arg) ? args.join("") : "";
      const maybeEncode = (arg) => (arg ? encodeURIComponent(arg) : "");
      const formatHashFragment = (f) =>
        f
          .toLowerCase()
          .replace(/^\W+|\/|\W+$/g, "")
          .replace(/\W+/g, "-");
      const defaults = {
        sshtemplate: ({ domain, user, project, committish }) =>
          `git@${domain}:${user}/${project}.git${maybeJoin("#", committish)}`,
        sshurltemplate: ({ domain, user, project, committish }) =>
          `git+ssh://git@${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        edittemplate: ({ domain, user, project, committish, editpath, path }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", editpath, "/", maybeEncode(committish || "HEAD"), "/", path)}`,
        browsetemplate: ({ domain, user, project, committish, treepath }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}`,
        browsetreetemplate: ({
          domain,
          user,
          project,
          committish,
          treepath,
          path,
          fragment,
          hashformat,
        }) =>
          `https://${domain}/${user}/${project}/${treepath}/${maybeEncode(committish || "HEAD")}/${path}${maybeJoin("#", hashformat(fragment || ""))}`,
        browseblobtemplate: ({
          domain,
          user,
          project,
          committish,
          blobpath,
          path,
          fragment,
          hashformat,
        }) =>
          `https://${domain}/${user}/${project}/${blobpath}/${maybeEncode(committish || "HEAD")}/${path}${maybeJoin("#", hashformat(fragment || ""))}`,
        docstemplate: ({ domain, user, project, treepath, committish }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish))}#readme`,
        httpstemplate: ({ auth, domain, user, project, committish }) =>
          `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        filetemplate: ({ domain, user, project, committish, path }) =>
          `https://${domain}/${user}/${project}/raw/${maybeEncode(committish || "HEAD")}/${path}`,
        shortcuttemplate: ({ type, user, project, committish }) =>
          `${type}:${user}/${project}${maybeJoin("#", committish)}`,
        pathtemplate: ({ user, project, committish }) =>
          `${user}/${project}${maybeJoin("#", committish)}`,
        bugstemplate: ({ domain, user, project }) =>
          `https://${domain}/${user}/${project}/issues`,
        hashformat: formatHashFragment,
      };
      const hosts = {};
      hosts.github = {
        protocols: [
          "git:",
          "http:",
          "git+ssh:",
          "git+https:",
          "ssh:",
          "https:",
        ],
        domain: "github.com",
        treepath: "tree",
        blobpath: "blob",
        editpath: "edit",
        filetemplate: ({ auth, user, project, committish, path }) =>
          `https://${maybeJoin(auth, "@")}raw.githubusercontent.com/${user}/${project}/${maybeEncode(committish || "HEAD")}/${path}`,
        gittemplate: ({ auth, domain, user, project, committish }) =>
          `git://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://codeload.${domain}/${user}/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
        extract: (url) => {
          let [, user, project, type, committish] = url.pathname.split("/", 5);
          if (type && type !== "tree") {
            return;
          }
          if (!type) {
            committish = url.hash.slice(1);
          }
          if (project && project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (!user || !project) {
            return;
          }
          return { user, project, committish };
        },
      };
      hosts.bitbucket = {
        protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
        domain: "bitbucket.org",
        treepath: "src",
        blobpath: "src",
        editpath: "?mode=edit",
        edittemplate: ({
          domain,
          user,
          project,
          committish,
          treepath,
          path,
          editpath,
        }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", treepath, "/", maybeEncode(committish || "HEAD"), "/", path, editpath)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}/get/${maybeEncode(committish || "HEAD")}.tar.gz`,
        extract: (url) => {
          let [, user, project, aux] = url.pathname.split("/", 4);
          if (["get"].includes(aux)) {
            return;
          }
          if (project && project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (!user || !project) {
            return;
          }
          return { user, project, committish: url.hash.slice(1) };
        },
      };
      hosts.gitlab = {
        protocols: ["git+ssh:", "git+https:", "ssh:", "https:"],
        domain: "gitlab.com",
        treepath: "tree",
        blobpath: "tree",
        editpath: "-/edit",
        httpstemplate: ({ auth, domain, user, project, committish }) =>
          `git+https://${maybeJoin(auth, "@")}${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}/repository/archive.tar.gz?ref=${maybeEncode(committish || "HEAD")}`,
        extract: (url) => {
          const path = url.pathname.slice(1);
          if (path.includes("/-/") || path.includes("/archive.tar.gz")) {
            return;
          }
          const segments = path.split("/");
          let project = segments.pop();
          if (project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          const user = segments.join("/");
          if (!user || !project) {
            return;
          }
          return { user, project, committish: url.hash.slice(1) };
        },
      };
      hosts.gist = {
        protocols: ["git:", "git+ssh:", "git+https:", "ssh:", "https:"],
        domain: "gist.github.com",
        editpath: "edit",
        sshtemplate: ({ domain, project, committish }) =>
          `git@${domain}:${project}.git${maybeJoin("#", committish)}`,
        sshurltemplate: ({ domain, project, committish }) =>
          `git+ssh://git@${domain}/${project}.git${maybeJoin("#", committish)}`,
        edittemplate: ({ domain, user, project, committish, editpath }) =>
          `https://${domain}/${user}/${project}${maybeJoin("/", maybeEncode(committish))}/${editpath}`,
        browsetemplate: ({ domain, project, committish }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
        browsetreetemplate: ({
          domain,
          project,
          committish,
          path,
          hashformat,
        }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path))}`,
        browseblobtemplate: ({
          domain,
          project,
          committish,
          path,
          hashformat,
        }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}${maybeJoin("#", hashformat(path))}`,
        docstemplate: ({ domain, project, committish }) =>
          `https://${domain}/${project}${maybeJoin("/", maybeEncode(committish))}`,
        httpstemplate: ({ domain, project, committish }) =>
          `git+https://${domain}/${project}.git${maybeJoin("#", committish)}`,
        filetemplate: ({ user, project, committish, path }) =>
          `https://gist.githubusercontent.com/${user}/${project}/raw${maybeJoin("/", maybeEncode(committish))}/${path}`,
        shortcuttemplate: ({ type, project, committish }) =>
          `${type}:${project}${maybeJoin("#", committish)}`,
        pathtemplate: ({ project, committish }) =>
          `${project}${maybeJoin("#", committish)}`,
        bugstemplate: ({ domain, project }) => `https://${domain}/${project}`,
        gittemplate: ({ domain, project, committish }) =>
          `git://${domain}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ project, committish }) =>
          `https://codeload.github.com/gist/${project}/tar.gz/${maybeEncode(committish || "HEAD")}`,
        extract: (url) => {
          let [, user, project, aux] = url.pathname.split("/", 4);
          if (aux === "raw") {
            return;
          }
          if (!project) {
            if (!user) {
              return;
            }
            project = user;
            user = null;
          }
          if (project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          return { user, project, committish: url.hash.slice(1) };
        },
        hashformat: function (fragment) {
          return fragment && "file-" + formatHashFragment(fragment);
        },
      };
      hosts.sourcehut = {
        protocols: ["git+ssh:", "https:"],
        domain: "git.sr.ht",
        treepath: "tree",
        blobpath: "tree",
        filetemplate: ({ domain, user, project, committish, path }) =>
          `https://${domain}/${user}/${project}/blob/${maybeEncode(committish) || "HEAD"}/${path}`,
        httpstemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}.git${maybeJoin("#", committish)}`,
        tarballtemplate: ({ domain, user, project, committish }) =>
          `https://${domain}/${user}/${project}/archive/${maybeEncode(committish) || "HEAD"}.tar.gz`,
        bugstemplate: () => null,
        extract: (url) => {
          let [, user, project, aux] = url.pathname.split("/", 4);
          if (["archive"].includes(aux)) {
            return;
          }
          if (project && project.endsWith(".git")) {
            project = project.slice(0, -4);
          }
          if (!user || !project) {
            return;
          }
          return { user, project, committish: url.hash.slice(1) };
        },
      };
      for (const [name, host] of Object.entries(hosts)) {
        hosts[name] = Object.assign({}, defaults, host);
      }
      module.exports = hosts;
    },
    167: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { LRUCache } = __nccwpck_require__(3866);
      const hosts = __nccwpck_require__(5572);
      const fromUrl = __nccwpck_require__(1756);
      const parseUrl = __nccwpck_require__(4250);
      const cache = new LRUCache({ max: 1e3 });
      class GitHost {
        constructor(
          type,
          user,
          auth,
          project,
          committish,
          defaultRepresentation,
          opts = {},
        ) {
          Object.assign(this, GitHost.#gitHosts[type], {
            type,
            user,
            auth,
            project,
            committish,
            default: defaultRepresentation,
            opts,
          });
        }
        static #gitHosts = { byShortcut: {}, byDomain: {} };
        static #protocols = {
          "git+ssh:": { name: "sshurl" },
          "ssh:": { name: "sshurl" },
          "git+https:": { name: "https", auth: true },
          "git:": { auth: true },
          "http:": { auth: true },
          "https:": { auth: true },
          "git+http:": { auth: true },
        };
        static addHost(name, host) {
          GitHost.#gitHosts[name] = host;
          GitHost.#gitHosts.byDomain[host.domain] = name;
          GitHost.#gitHosts.byShortcut[`${name}:`] = name;
          GitHost.#protocols[`${name}:`] = { name };
        }
        static fromUrl(giturl, opts) {
          if (typeof giturl !== "string") {
            return;
          }
          const key = giturl + JSON.stringify(opts || {});
          if (!cache.has(key)) {
            const hostArgs = fromUrl(giturl, opts, {
              gitHosts: GitHost.#gitHosts,
              protocols: GitHost.#protocols,
            });
            cache.set(key, hostArgs ? new GitHost(...hostArgs) : undefined);
          }
          return cache.get(key);
        }
        static parseUrl(url) {
          return parseUrl(url);
        }
        #fill(template, opts) {
          if (typeof template !== "function") {
            return null;
          }
          const options = { ...this, ...this.opts, ...opts };
          if (!options.path) {
            options.path = "";
          }
          if (options.path.startsWith("/")) {
            options.path = options.path.slice(1);
          }
          if (options.noCommittish) {
            options.committish = null;
          }
          const result = template(options);
          return options.noGitPlus && result.startsWith("git+")
            ? result.slice(4)
            : result;
        }
        hash() {
          return this.committish ? `#${this.committish}` : "";
        }
        ssh(opts) {
          return this.#fill(this.sshtemplate, opts);
        }
        sshurl(opts) {
          return this.#fill(this.sshurltemplate, opts);
        }
        browse(path, ...args) {
          if (typeof path !== "string") {
            return this.#fill(this.browsetemplate, path);
          }
          if (typeof args[0] !== "string") {
            return this.#fill(this.browsetreetemplate, { ...args[0], path });
          }
          return this.#fill(this.browsetreetemplate, {
            ...args[1],
            fragment: args[0],
            path,
          });
        }
        browseFile(path, ...args) {
          if (typeof args[0] !== "string") {
            return this.#fill(this.browseblobtemplate, { ...args[0], path });
          }
          return this.#fill(this.browseblobtemplate, {
            ...args[1],
            fragment: args[0],
            path,
          });
        }
        docs(opts) {
          return this.#fill(this.docstemplate, opts);
        }
        bugs(opts) {
          return this.#fill(this.bugstemplate, opts);
        }
        https(opts) {
          return this.#fill(this.httpstemplate, opts);
        }
        git(opts) {
          return this.#fill(this.gittemplate, opts);
        }
        shortcut(opts) {
          return this.#fill(this.shortcuttemplate, opts);
        }
        path(opts) {
          return this.#fill(this.pathtemplate, opts);
        }
        tarball(opts) {
          return this.#fill(this.tarballtemplate, {
            ...opts,
            noCommittish: false,
          });
        }
        file(path, opts) {
          return this.#fill(this.filetemplate, { ...opts, path });
        }
        edit(path, opts) {
          return this.#fill(this.edittemplate, { ...opts, path });
        }
        getDefaultRepresentation() {
          return this.default;
        }
        toString(opts) {
          if (this.default && typeof this[this.default] === "function") {
            return this[this.default](opts);
          }
          return this.sshurl(opts);
        }
      }
      for (const [name, host] of Object.entries(hosts)) {
        GitHost.addHost(name, host);
      }
      module.exports = GitHost;
    },
    4250: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const url = __nccwpck_require__(7310);
      const lastIndexOfBefore = (str, char, beforeChar) => {
        const startPosition = str.indexOf(beforeChar);
        return str.lastIndexOf(
          char,
          startPosition > -1 ? startPosition : Infinity,
        );
      };
      const safeUrl = (u) => {
        try {
          return new url.URL(u);
        } catch {}
      };
      const correctProtocol = (arg, protocols) => {
        const firstColon = arg.indexOf(":");
        const proto = arg.slice(0, firstColon + 1);
        if (Object.prototype.hasOwnProperty.call(protocols, proto)) {
          return arg;
        }
        const firstAt = arg.indexOf("@");
        if (firstAt > -1) {
          if (firstAt > firstColon) {
            return `git+ssh://${arg}`;
          } else {
            return arg;
          }
        }
        const doubleSlash = arg.indexOf("//");
        if (doubleSlash === firstColon + 1) {
          return arg;
        }
        return `${arg.slice(0, firstColon + 1)}//${arg.slice(firstColon + 1)}`;
      };
      const correctUrl = (giturl) => {
        const firstAt = lastIndexOfBefore(giturl, "@", "#");
        const lastColonBeforeHash = lastIndexOfBefore(giturl, ":", "#");
        if (lastColonBeforeHash > firstAt) {
          giturl =
            giturl.slice(0, lastColonBeforeHash) +
            "/" +
            giturl.slice(lastColonBeforeHash + 1);
        }
        if (
          lastIndexOfBefore(giturl, ":", "#") === -1 &&
          giturl.indexOf("//") === -1
        ) {
          giturl = `git+ssh://${giturl}`;
        }
        return giturl;
      };
      module.exports = (giturl, protocols) => {
        const withProtocol = protocols
          ? correctProtocol(giturl, protocols)
          : giturl;
        return safeUrl(withProtocol) || safeUrl(correctUrl(withProtocol));
      };
    },
    1002: (module) => {
      "use strict";
      const statusCodeCacheableByDefault = new Set([
        200, 203, 204, 206, 300, 301, 308, 404, 405, 410, 414, 501,
      ]);
      const understoodStatuses = new Set([
        200, 203, 204, 300, 301, 302, 303, 307, 308, 404, 405, 410, 414, 501,
      ]);
      const errorStatusCodes = new Set([500, 502, 503, 504]);
      const hopByHopHeaders = {
        date: true,
        connection: true,
        "keep-alive": true,
        "proxy-authenticate": true,
        "proxy-authorization": true,
        te: true,
        trailer: true,
        "transfer-encoding": true,
        upgrade: true,
      };
      const excludedFromRevalidationUpdate = {
        "content-length": true,
        "content-encoding": true,
        "transfer-encoding": true,
        "content-range": true,
      };
      function toNumberOrZero(s) {
        const n = parseInt(s, 10);
        return isFinite(n) ? n : 0;
      }
      function isErrorResponse(response) {
        if (!response) {
          return true;
        }
        return errorStatusCodes.has(response.status);
      }
      function parseCacheControl(header) {
        const cc = {};
        if (!header) return cc;
        const parts = header.trim().split(/,/);
        for (const part of parts) {
          const [k, v] = part.split(/=/, 2);
          cc[k.trim()] =
            v === undefined ? true : v.trim().replace(/^"|"$/g, "");
        }
        return cc;
      }
      function formatCacheControl(cc) {
        let parts = [];
        for (const k in cc) {
          const v = cc[k];
          parts.push(v === true ? k : k + "=" + v);
        }
        if (!parts.length) {
          return undefined;
        }
        return parts.join(", ");
      }
      module.exports = class CachePolicy {
        constructor(
          req,
          res,
          {
            shared,
            cacheHeuristic,
            immutableMinTimeToLive,
            ignoreCargoCult,
            _fromObject,
          } = {},
        ) {
          if (_fromObject) {
            this._fromObject(_fromObject);
            return;
          }
          if (!res || !res.headers) {
            throw Error("Response headers missing");
          }
          this._assertRequestHasHeaders(req);
          this._responseTime = this.now();
          this._isShared = shared !== false;
          this._cacheHeuristic =
            undefined !== cacheHeuristic ? cacheHeuristic : 0.1;
          this._immutableMinTtl =
            undefined !== immutableMinTimeToLive
              ? immutableMinTimeToLive
              : 24 * 3600 * 1e3;
          this._status = "status" in res ? res.status : 200;
          this._resHeaders = res.headers;
          this._rescc = parseCacheControl(res.headers["cache-control"]);
          this._method = "method" in req ? req.method : "GET";
          this._url = req.url;
          this._host = req.headers.host;
          this._noAuthorization = !req.headers.authorization;
          this._reqHeaders = res.headers.vary ? req.headers : null;
          this._reqcc = parseCacheControl(req.headers["cache-control"]);
          if (
            ignoreCargoCult &&
            "pre-check" in this._rescc &&
            "post-check" in this._rescc
          ) {
            delete this._rescc["pre-check"];
            delete this._rescc["post-check"];
            delete this._rescc["no-cache"];
            delete this._rescc["no-store"];
            delete this._rescc["must-revalidate"];
            this._resHeaders = Object.assign({}, this._resHeaders, {
              "cache-control": formatCacheControl(this._rescc),
            });
            delete this._resHeaders.expires;
            delete this._resHeaders.pragma;
          }
          if (
            res.headers["cache-control"] == null &&
            /no-cache/.test(res.headers.pragma)
          ) {
            this._rescc["no-cache"] = true;
          }
        }
        now() {
          return Date.now();
        }
        storable() {
          return !!(
            !this._reqcc["no-store"] &&
            ("GET" === this._method ||
              "HEAD" === this._method ||
              ("POST" === this._method && this._hasExplicitExpiration())) &&
            understoodStatuses.has(this._status) &&
            !this._rescc["no-store"] &&
            (!this._isShared || !this._rescc.private) &&
            (!this._isShared ||
              this._noAuthorization ||
              this._allowsStoringAuthenticated()) &&
            (this._resHeaders.expires ||
              this._rescc["max-age"] ||
              (this._isShared && this._rescc["s-maxage"]) ||
              this._rescc.public ||
              statusCodeCacheableByDefault.has(this._status))
          );
        }
        _hasExplicitExpiration() {
          return (
            (this._isShared && this._rescc["s-maxage"]) ||
            this._rescc["max-age"] ||
            this._resHeaders.expires
          );
        }
        _assertRequestHasHeaders(req) {
          if (!req || !req.headers) {
            throw Error("Request headers missing");
          }
        }
        satisfiesWithoutRevalidation(req) {
          this._assertRequestHasHeaders(req);
          const requestCC = parseCacheControl(req.headers["cache-control"]);
          if (requestCC["no-cache"] || /no-cache/.test(req.headers.pragma)) {
            return false;
          }
          if (requestCC["max-age"] && this.age() > requestCC["max-age"]) {
            return false;
          }
          if (
            requestCC["min-fresh"] &&
            this.timeToLive() < 1e3 * requestCC["min-fresh"]
          ) {
            return false;
          }
          if (this.stale()) {
            const allowsStale =
              requestCC["max-stale"] &&
              !this._rescc["must-revalidate"] &&
              (true === requestCC["max-stale"] ||
                requestCC["max-stale"] > this.age() - this.maxAge());
            if (!allowsStale) {
              return false;
            }
          }
          return this._requestMatches(req, false);
        }
        _requestMatches(req, allowHeadMethod) {
          return (
            (!this._url || this._url === req.url) &&
            this._host === req.headers.host &&
            (!req.method ||
              this._method === req.method ||
              (allowHeadMethod && "HEAD" === req.method)) &&
            this._varyMatches(req)
          );
        }
        _allowsStoringAuthenticated() {
          return (
            this._rescc["must-revalidate"] ||
            this._rescc.public ||
            this._rescc["s-maxage"]
          );
        }
        _varyMatches(req) {
          if (!this._resHeaders.vary) {
            return true;
          }
          if (this._resHeaders.vary === "*") {
            return false;
          }
          const fields = this._resHeaders.vary
            .trim()
            .toLowerCase()
            .split(/\s*,\s*/);
          for (const name of fields) {
            if (req.headers[name] !== this._reqHeaders[name]) return false;
          }
          return true;
        }
        _copyWithoutHopByHopHeaders(inHeaders) {
          const headers = {};
          for (const name in inHeaders) {
            if (hopByHopHeaders[name]) continue;
            headers[name] = inHeaders[name];
          }
          if (inHeaders.connection) {
            const tokens = inHeaders.connection.trim().split(/\s*,\s*/);
            for (const name of tokens) {
              delete headers[name];
            }
          }
          if (headers.warning) {
            const warnings = headers.warning
              .split(/,/)
              .filter((warning) => !/^\s*1[0-9][0-9]/.test(warning));
            if (!warnings.length) {
              delete headers.warning;
            } else {
              headers.warning = warnings.join(",").trim();
            }
          }
          return headers;
        }
        responseHeaders() {
          const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);
          const age = this.age();
          if (
            age > 3600 * 24 &&
            !this._hasExplicitExpiration() &&
            this.maxAge() > 3600 * 24
          ) {
            headers.warning =
              (headers.warning ? `${headers.warning}, ` : "") +
              '113 - "rfc7234 5.5.4"';
          }
          headers.age = `${Math.round(age)}`;
          headers.date = new Date(this.now()).toUTCString();
          return headers;
        }
        date() {
          const serverDate = Date.parse(this._resHeaders.date);
          if (isFinite(serverDate)) {
            return serverDate;
          }
          return this._responseTime;
        }
        age() {
          let age = this._ageValue();
          const residentTime = (this.now() - this._responseTime) / 1e3;
          return age + residentTime;
        }
        _ageValue() {
          return toNumberOrZero(this._resHeaders.age);
        }
        maxAge() {
          if (!this.storable() || this._rescc["no-cache"]) {
            return 0;
          }
          if (
            this._isShared &&
            this._resHeaders["set-cookie"] &&
            !this._rescc.public &&
            !this._rescc.immutable
          ) {
            return 0;
          }
          if (this._resHeaders.vary === "*") {
            return 0;
          }
          if (this._isShared) {
            if (this._rescc["proxy-revalidate"]) {
              return 0;
            }
            if (this._rescc["s-maxage"]) {
              return toNumberOrZero(this._rescc["s-maxage"]);
            }
          }
          if (this._rescc["max-age"]) {
            return toNumberOrZero(this._rescc["max-age"]);
          }
          const defaultMinTtl = this._rescc.immutable
            ? this._immutableMinTtl
            : 0;
          const serverDate = this.date();
          if (this._resHeaders.expires) {
            const expires = Date.parse(this._resHeaders.expires);
            if (Number.isNaN(expires) || expires < serverDate) {
              return 0;
            }
            return Math.max(defaultMinTtl, (expires - serverDate) / 1e3);
          }
          if (this._resHeaders["last-modified"]) {
            const lastModified = Date.parse(this._resHeaders["last-modified"]);
            if (isFinite(lastModified) && serverDate > lastModified) {
              return Math.max(
                defaultMinTtl,
                ((serverDate - lastModified) / 1e3) * this._cacheHeuristic,
              );
            }
          }
          return defaultMinTtl;
        }
        timeToLive() {
          const age = this.maxAge() - this.age();
          const staleIfErrorAge =
            age + toNumberOrZero(this._rescc["stale-if-error"]);
          const staleWhileRevalidateAge =
            age + toNumberOrZero(this._rescc["stale-while-revalidate"]);
          return (
            Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1e3
          );
        }
        stale() {
          return this.maxAge() <= this.age();
        }
        _useStaleIfError() {
          return (
            this.maxAge() + toNumberOrZero(this._rescc["stale-if-error"]) >
            this.age()
          );
        }
        useStaleWhileRevalidate() {
          return (
            this.maxAge() +
              toNumberOrZero(this._rescc["stale-while-revalidate"]) >
            this.age()
          );
        }
        static fromObject(obj) {
          return new this(undefined, undefined, { _fromObject: obj });
        }
        _fromObject(obj) {
          if (this._responseTime) throw Error("Reinitialized");
          if (!obj || obj.v !== 1) throw Error("Invalid serialization");
          this._responseTime = obj.t;
          this._isShared = obj.sh;
          this._cacheHeuristic = obj.ch;
          this._immutableMinTtl =
            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1e3;
          this._status = obj.st;
          this._resHeaders = obj.resh;
          this._rescc = obj.rescc;
          this._method = obj.m;
          this._url = obj.u;
          this._host = obj.h;
          this._noAuthorization = obj.a;
          this._reqHeaders = obj.reqh;
          this._reqcc = obj.reqcc;
        }
        toObject() {
          return {
            v: 1,
            t: this._responseTime,
            sh: this._isShared,
            ch: this._cacheHeuristic,
            imm: this._immutableMinTtl,
            st: this._status,
            resh: this._resHeaders,
            rescc: this._rescc,
            m: this._method,
            u: this._url,
            h: this._host,
            a: this._noAuthorization,
            reqh: this._reqHeaders,
            reqcc: this._reqcc,
          };
        }
        revalidationHeaders(incomingReq) {
          this._assertRequestHasHeaders(incomingReq);
          const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);
          delete headers["if-range"];
          if (!this._requestMatches(incomingReq, true) || !this.storable()) {
            delete headers["if-none-match"];
            delete headers["if-modified-since"];
            return headers;
          }
          if (this._resHeaders.etag) {
            headers["if-none-match"] = headers["if-none-match"]
              ? `${headers["if-none-match"]}, ${this._resHeaders.etag}`
              : this._resHeaders.etag;
          }
          const forbidsWeakValidators =
            headers["accept-ranges"] ||
            headers["if-match"] ||
            headers["if-unmodified-since"] ||
            (this._method && this._method != "GET");
          if (forbidsWeakValidators) {
            delete headers["if-modified-since"];
            if (headers["if-none-match"]) {
              const etags = headers["if-none-match"]
                .split(/,/)
                .filter((etag) => !/^\s*W\//.test(etag));
              if (!etags.length) {
                delete headers["if-none-match"];
              } else {
                headers["if-none-match"] = etags.join(",").trim();
              }
            }
          } else if (
            this._resHeaders["last-modified"] &&
            !headers["if-modified-since"]
          ) {
            headers["if-modified-since"] = this._resHeaders["last-modified"];
          }
          return headers;
        }
        revalidatedPolicy(request, response) {
          this._assertRequestHasHeaders(request);
          if (this._useStaleIfError() && isErrorResponse(response)) {
            return { modified: false, matches: false, policy: this };
          }
          if (!response || !response.headers) {
            throw Error("Response headers missing");
          }
          let matches = false;
          if (response.status !== undefined && response.status != 304) {
            matches = false;
          } else if (
            response.headers.etag &&
            !/^\s*W\//.test(response.headers.etag)
          ) {
            matches =
              this._resHeaders.etag &&
              this._resHeaders.etag.replace(/^\s*W\//, "") ===
                response.headers.etag;
          } else if (this._resHeaders.etag && response.headers.etag) {
            matches =
              this._resHeaders.etag.replace(/^\s*W\//, "") ===
              response.headers.etag.replace(/^\s*W\//, "");
          } else if (this._resHeaders["last-modified"]) {
            matches =
              this._resHeaders["last-modified"] ===
              response.headers["last-modified"];
          } else {
            if (
              !this._resHeaders.etag &&
              !this._resHeaders["last-modified"] &&
              !response.headers.etag &&
              !response.headers["last-modified"]
            ) {
              matches = true;
            }
          }
          if (!matches) {
            return {
              policy: new this.constructor(request, response),
              modified: response.status != 304,
              matches: false,
            };
          }
          const headers = {};
          for (const k in this._resHeaders) {
            headers[k] =
              k in response.headers && !excludedFromRevalidationUpdate[k]
                ? response.headers[k]
                : this._resHeaders[k];
          }
          const newResponse = Object.assign({}, response, {
            status: this._status,
            method: this._method,
            headers,
          });
          return {
            policy: new this.constructor(request, newResponse, {
              shared: this._isShared,
              cacheHeuristic: this._cacheHeuristic,
              immutableMinTimeToLive: this._immutableMinTtl,
            }),
            modified: false,
            matches: true,
          };
        }
      };
    },
    3764: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpProxyAgent = void 0;
      const net = __importStar(__nccwpck_require__(1808));
      const tls = __importStar(__nccwpck_require__(4404));
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const events_1 = __nccwpck_require__(2361);
      const agent_base_1 = __nccwpck_require__(694);
      const url_1 = __nccwpck_require__(7310);
      const debug = (0, debug_1.default)("http-proxy-agent");
      class HttpProxyAgent extends agent_base_1.Agent {
        constructor(proxy, opts) {
          super(opts);
          this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
          this.proxyHeaders = opts?.headers ?? {};
          debug("Creating new HttpProxyAgent instance: %o", this.proxy.href);
          const host = (this.proxy.hostname || this.proxy.host).replace(
            /^\[|\]$/g,
            "",
          );
          const port = this.proxy.port
            ? parseInt(this.proxy.port, 10)
            : this.proxy.protocol === "https:"
              ? 443
              : 80;
          this.connectOpts = {
            ...(opts ? omit(opts, "headers") : null),
            host,
            port,
          };
        }
        addRequest(req, opts) {
          req._header = null;
          this.setRequestProps(req, opts);
          super.addRequest(req, opts);
        }
        setRequestProps(req, opts) {
          const { proxy } = this;
          const protocol = opts.secureEndpoint ? "https:" : "http:";
          const hostname = req.getHeader("host") || "localhost";
          const base = `${protocol}//${hostname}`;
          const url = new url_1.URL(req.path, base);
          if (opts.port !== 80) {
            url.port = String(opts.port);
          }
          req.path = String(url);
          const headers =
            typeof this.proxyHeaders === "function"
              ? this.proxyHeaders()
              : { ...this.proxyHeaders };
          if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers["Proxy-Authorization"] =
              `Basic ${Buffer.from(auth).toString("base64")}`;
          }
          if (!headers["Proxy-Connection"]) {
            headers["Proxy-Connection"] = this.keepAlive
              ? "Keep-Alive"
              : "close";
          }
          for (const name of Object.keys(headers)) {
            const value = headers[name];
            if (value) {
              req.setHeader(name, value);
            }
          }
        }
        async connect(req, opts) {
          req._header = null;
          if (!req.path.includes("://")) {
            this.setRequestProps(req, opts);
          }
          let first;
          let endOfHeaders;
          debug("Regenerating stored HTTP header string for request");
          req._implicitHeader();
          if (req.outputData && req.outputData.length > 0) {
            debug(
              "Patching connection write() output buffer with updated header",
            );
            first = req.outputData[0].data;
            endOfHeaders = first.indexOf("\r\n\r\n") + 4;
            req.outputData[0].data =
              req._header + first.substring(endOfHeaders);
            debug("Output buffer: %o", req.outputData[0].data);
          }
          let socket;
          if (this.proxy.protocol === "https:") {
            debug("Creating `tls.Socket`: %o", this.connectOpts);
            socket = tls.connect(this.connectOpts);
          } else {
            debug("Creating `net.Socket`: %o", this.connectOpts);
            socket = net.connect(this.connectOpts);
          }
          await (0, events_1.once)(socket, "connect");
          return socket;
        }
      }
      HttpProxyAgent.protocols = ["http", "https"];
      exports.HttpProxyAgent = HttpProxyAgent;
      function omit(obj, ...keys) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
    },
    7219: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.HttpsProxyAgent = void 0;
      const net = __importStar(__nccwpck_require__(1808));
      const tls = __importStar(__nccwpck_require__(4404));
      const assert_1 = __importDefault(__nccwpck_require__(9491));
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const agent_base_1 = __nccwpck_require__(694);
      const url_1 = __nccwpck_require__(7310);
      const parse_proxy_response_1 = __nccwpck_require__(595);
      const debug = (0, debug_1.default)("https-proxy-agent");
      class HttpsProxyAgent extends agent_base_1.Agent {
        constructor(proxy, opts) {
          super(opts);
          this.options = { path: undefined };
          this.proxy = typeof proxy === "string" ? new url_1.URL(proxy) : proxy;
          this.proxyHeaders = opts?.headers ?? {};
          debug("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
          const host = (this.proxy.hostname || this.proxy.host).replace(
            /^\[|\]$/g,
            "",
          );
          const port = this.proxy.port
            ? parseInt(this.proxy.port, 10)
            : this.proxy.protocol === "https:"
              ? 443
              : 80;
          this.connectOpts = {
            ALPNProtocols: ["http/1.1"],
            ...(opts ? omit(opts, "headers") : null),
            host,
            port,
          };
        }
        async connect(req, opts) {
          const { proxy } = this;
          if (!opts.host) {
            throw new TypeError('No "host" provided');
          }
          let socket;
          if (proxy.protocol === "https:") {
            debug("Creating `tls.Socket`: %o", this.connectOpts);
            const servername =
              this.connectOpts.servername || this.connectOpts.host;
            socket = tls.connect({ ...this.connectOpts, servername });
          } else {
            debug("Creating `net.Socket`: %o", this.connectOpts);
            socket = net.connect(this.connectOpts);
          }
          const headers =
            typeof this.proxyHeaders === "function"
              ? this.proxyHeaders()
              : { ...this.proxyHeaders };
          const host = net.isIPv6(opts.host) ? `[${opts.host}]` : opts.host;
          let payload = `CONNECT ${host}:${opts.port} HTTP/1.1\r\n`;
          if (proxy.username || proxy.password) {
            const auth = `${decodeURIComponent(proxy.username)}:${decodeURIComponent(proxy.password)}`;
            headers["Proxy-Authorization"] =
              `Basic ${Buffer.from(auth).toString("base64")}`;
          }
          headers.Host = `${host}:${opts.port}`;
          if (!headers["Proxy-Connection"]) {
            headers["Proxy-Connection"] = this.keepAlive
              ? "Keep-Alive"
              : "close";
          }
          for (const name of Object.keys(headers)) {
            payload += `${name}: ${headers[name]}\r\n`;
          }
          const proxyResponsePromise = (0,
          parse_proxy_response_1.parseProxyResponse)(socket);
          socket.write(`${payload}\r\n`);
          const { connect, buffered } = await proxyResponsePromise;
          req.emit("proxyConnect", connect);
          this.emit("proxyConnect", connect, req);
          if (connect.statusCode === 200) {
            req.once("socket", resume);
            if (opts.secureEndpoint) {
              debug("Upgrading socket connection to TLS");
              const servername = opts.servername || opts.host;
              return tls.connect({
                ...omit(opts, "host", "path", "port"),
                socket,
                servername,
              });
            }
            return socket;
          }
          socket.destroy();
          const fakeSocket = new net.Socket({ writable: false });
          fakeSocket.readable = true;
          req.once("socket", (s) => {
            debug("Replaying proxy buffer for failed request");
            (0, assert_1.default)(s.listenerCount("data") > 0);
            s.push(buffered);
            s.push(null);
          });
          return fakeSocket;
        }
      }
      HttpsProxyAgent.protocols = ["http", "https"];
      exports.HttpsProxyAgent = HttpsProxyAgent;
      function resume(socket) {
        socket.resume();
      }
      function omit(obj, ...keys) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
    },
    595: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseProxyResponse = void 0;
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const debug = (0, debug_1.default)(
        "https-proxy-agent:parse-proxy-response",
      );
      function parseProxyResponse(socket) {
        return new Promise((resolve, reject) => {
          let buffersLength = 0;
          const buffers = [];
          function read() {
            const b = socket.read();
            if (b) ondata(b);
            else socket.once("readable", read);
          }
          function cleanup() {
            socket.removeListener("end", onend);
            socket.removeListener("error", onerror);
            socket.removeListener("readable", read);
          }
          function onend() {
            cleanup();
            debug("onend");
            reject(
              new Error(
                "Proxy connection ended before receiving CONNECT response",
              ),
            );
          }
          function onerror(err) {
            cleanup();
            debug("onerror %o", err);
            reject(err);
          }
          function ondata(b) {
            buffers.push(b);
            buffersLength += b.length;
            const buffered = Buffer.concat(buffers, buffersLength);
            const endOfHeaders = buffered.indexOf("\r\n\r\n");
            if (endOfHeaders === -1) {
              debug("have not received end of HTTP headers yet...");
              read();
              return;
            }
            const headerParts = buffered
              .slice(0, endOfHeaders)
              .toString("ascii")
              .split("\r\n");
            const firstLine = headerParts.shift();
            if (!firstLine) {
              socket.destroy();
              return reject(
                new Error("No header received from proxy CONNECT response"),
              );
            }
            const firstLineParts = firstLine.split(" ");
            const statusCode = +firstLineParts[1];
            const statusText = firstLineParts.slice(2).join(" ");
            const headers = {};
            for (const header of headerParts) {
              if (!header) continue;
              const firstColon = header.indexOf(":");
              if (firstColon === -1) {
                socket.destroy();
                return reject(
                  new Error(
                    `Invalid header from proxy CONNECT response: "${header}"`,
                  ),
                );
              }
              const key = header.slice(0, firstColon).toLowerCase();
              const value = header.slice(firstColon + 1).trimStart();
              const current = headers[key];
              if (typeof current === "string") {
                headers[key] = [current, value];
              } else if (Array.isArray(current)) {
                current.push(value);
              } else {
                headers[key] = value;
              }
            }
            debug("got proxy server response: %o %o", firstLine, headers);
            cleanup();
            resolve({ connect: { statusCode, statusText, headers }, buffered });
          }
          socket.on("error", onerror);
          socket.on("end", onend);
          read();
        });
      }
      exports.parseProxyResponse = parseProxyResponse;
    },
    9695: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports._dbcs = DBCSCodec;
      var UNASSIGNED = -1,
        GB18030_CODE = -2,
        SEQ_START = -10,
        NODE_START = -1e3,
        UNASSIGNED_NODE = new Array(256),
        DEF_CHAR = -1;
      for (var i = 0; i < 256; i++) UNASSIGNED_NODE[i] = UNASSIGNED;
      function DBCSCodec(codecOptions, iconv) {
        this.encodingName = codecOptions.encodingName;
        if (!codecOptions)
          throw new Error("DBCS codec is called without the data.");
        if (!codecOptions.table)
          throw new Error("Encoding '" + this.encodingName + "' has no data.");
        var mappingTable = codecOptions.table();
        this.decodeTables = [];
        this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
        this.decodeTableSeq = [];
        for (var i = 0; i < mappingTable.length; i++)
          this._addDecodeChunk(mappingTable[i]);
        if (typeof codecOptions.gb18030 === "function") {
          this.gb18030 = codecOptions.gb18030();
          var commonThirdByteNodeIdx = this.decodeTables.length;
          this.decodeTables.push(UNASSIGNED_NODE.slice(0));
          var commonFourthByteNodeIdx = this.decodeTables.length;
          this.decodeTables.push(UNASSIGNED_NODE.slice(0));
          var firstByteNode = this.decodeTables[0];
          for (var i = 129; i <= 254; i++) {
            var secondByteNode =
              this.decodeTables[NODE_START - firstByteNode[i]];
            for (var j = 48; j <= 57; j++) {
              if (secondByteNode[j] === UNASSIGNED) {
                secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
              } else if (secondByteNode[j] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 2");
              }
              var thirdByteNode =
                this.decodeTables[NODE_START - secondByteNode[j]];
              for (var k = 129; k <= 254; k++) {
                if (thirdByteNode[k] === UNASSIGNED) {
                  thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
                } else if (
                  thirdByteNode[k] ===
                  NODE_START - commonFourthByteNodeIdx
                ) {
                  continue;
                } else if (thirdByteNode[k] > NODE_START) {
                  throw new Error("gb18030 decode tables conflict at byte 3");
                }
                var fourthByteNode =
                  this.decodeTables[NODE_START - thirdByteNode[k]];
                for (var l = 48; l <= 57; l++) {
                  if (fourthByteNode[l] === UNASSIGNED)
                    fourthByteNode[l] = GB18030_CODE;
                }
              }
            }
          }
        }
        this.defaultCharUnicode = iconv.defaultCharUnicode;
        this.encodeTable = [];
        this.encodeTableSeq = [];
        var skipEncodeChars = {};
        if (codecOptions.encodeSkipVals)
          for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {
            var val = codecOptions.encodeSkipVals[i];
            if (typeof val === "number") skipEncodeChars[val] = true;
            else
              for (var j = val.from; j <= val.to; j++)
                skipEncodeChars[j] = true;
          }
        this._fillEncodeTable(0, 0, skipEncodeChars);
        if (codecOptions.encodeAdd) {
          for (var uChar in codecOptions.encodeAdd)
            if (
              Object.prototype.hasOwnProperty.call(
                codecOptions.encodeAdd,
                uChar,
              )
            )
              this._setEncodeChar(
                uChar.charCodeAt(0),
                codecOptions.encodeAdd[uChar],
              );
        }
        this.defCharSB =
          this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
        if (this.defCharSB === UNASSIGNED)
          this.defCharSB = this.encodeTable[0]["?"];
        if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
      }
      DBCSCodec.prototype.encoder = DBCSEncoder;
      DBCSCodec.prototype.decoder = DBCSDecoder;
      DBCSCodec.prototype._getDecodeTrieNode = function (addr) {
        var bytes = [];
        for (; addr > 0; addr >>>= 8) bytes.push(addr & 255);
        if (bytes.length == 0) bytes.push(0);
        var node = this.decodeTables[0];
        for (var i = bytes.length - 1; i > 0; i--) {
          var val = node[bytes[i]];
          if (val == UNASSIGNED) {
            node[bytes[i]] = NODE_START - this.decodeTables.length;
            this.decodeTables.push((node = UNASSIGNED_NODE.slice(0)));
          } else if (val <= NODE_START) {
            node = this.decodeTables[NODE_START - val];
          } else
            throw new Error(
              "Overwrite byte in " +
                this.encodingName +
                ", addr: " +
                addr.toString(16),
            );
        }
        return node;
      };
      DBCSCodec.prototype._addDecodeChunk = function (chunk) {
        var curAddr = parseInt(chunk[0], 16);
        var writeTable = this._getDecodeTrieNode(curAddr);
        curAddr = curAddr & 255;
        for (var k = 1; k < chunk.length; k++) {
          var part = chunk[k];
          if (typeof part === "string") {
            for (var l = 0; l < part.length; ) {
              var code = part.charCodeAt(l++);
              if (55296 <= code && code < 56320) {
                var codeTrail = part.charCodeAt(l++);
                if (56320 <= codeTrail && codeTrail < 57344)
                  writeTable[curAddr++] =
                    65536 + (code - 55296) * 1024 + (codeTrail - 56320);
                else
                  throw new Error(
                    "Incorrect surrogate pair in " +
                      this.encodingName +
                      " at chunk " +
                      chunk[0],
                  );
              } else if (4080 < code && code <= 4095) {
                var len = 4095 - code + 2;
                var seq = [];
                for (var m = 0; m < len; m++) seq.push(part.charCodeAt(l++));
                writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
                this.decodeTableSeq.push(seq);
              } else writeTable[curAddr++] = code;
            }
          } else if (typeof part === "number") {
            var charCode = writeTable[curAddr - 1] + 1;
            for (var l = 0; l < part; l++) writeTable[curAddr++] = charCode++;
          } else
            throw new Error(
              "Incorrect type '" +
                typeof part +
                "' given in " +
                this.encodingName +
                " at chunk " +
                chunk[0],
            );
        }
        if (curAddr > 255)
          throw new Error(
            "Incorrect chunk in " +
              this.encodingName +
              " at addr " +
              chunk[0] +
              ": too long" +
              curAddr,
          );
      };
      DBCSCodec.prototype._getEncodeBucket = function (uCode) {
        var high = uCode >> 8;
        if (this.encodeTable[high] === undefined)
          this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
        return this.encodeTable[high];
      };
      DBCSCodec.prototype._setEncodeChar = function (uCode, dbcsCode) {
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 255;
        if (bucket[low] <= SEQ_START)
          this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
        else if (bucket[low] == UNASSIGNED) bucket[low] = dbcsCode;
      };
      DBCSCodec.prototype._setEncodeSequence = function (seq, dbcsCode) {
        var uCode = seq[0];
        var bucket = this._getEncodeBucket(uCode);
        var low = uCode & 255;
        var node;
        if (bucket[low] <= SEQ_START) {
          node = this.encodeTableSeq[SEQ_START - bucket[low]];
        } else {
          node = {};
          if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
          bucket[low] = SEQ_START - this.encodeTableSeq.length;
          this.encodeTableSeq.push(node);
        }
        for (var j = 1; j < seq.length - 1; j++) {
          var oldVal = node[uCode];
          if (typeof oldVal === "object") node = oldVal;
          else {
            node = node[uCode] = {};
            if (oldVal !== undefined) node[DEF_CHAR] = oldVal;
          }
        }
        uCode = seq[seq.length - 1];
        node[uCode] = dbcsCode;
      };
      DBCSCodec.prototype._fillEncodeTable = function (
        nodeIdx,
        prefix,
        skipEncodeChars,
      ) {
        var node = this.decodeTables[nodeIdx];
        var hasValues = false;
        var subNodeEmpty = {};
        for (var i = 0; i < 256; i++) {
          var uCode = node[i];
          var mbCode = prefix + i;
          if (skipEncodeChars[mbCode]) continue;
          if (uCode >= 0) {
            this._setEncodeChar(uCode, mbCode);
            hasValues = true;
          } else if (uCode <= NODE_START) {
            var subNodeIdx = NODE_START - uCode;
            if (!subNodeEmpty[subNodeIdx]) {
              var newPrefix = (mbCode << 8) >>> 0;
              if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
                hasValues = true;
              else subNodeEmpty[subNodeIdx] = true;
            }
          } else if (uCode <= SEQ_START) {
            this._setEncodeSequence(
              this.decodeTableSeq[SEQ_START - uCode],
              mbCode,
            );
            hasValues = true;
          }
        }
        return hasValues;
      };
      function DBCSEncoder(options, codec) {
        this.leadSurrogate = -1;
        this.seqObj = undefined;
        this.encodeTable = codec.encodeTable;
        this.encodeTableSeq = codec.encodeTableSeq;
        this.defaultCharSingleByte = codec.defCharSB;
        this.gb18030 = codec.gb18030;
      }
      DBCSEncoder.prototype.write = function (str) {
        var newBuf = Buffer.alloc(str.length * (this.gb18030 ? 4 : 3)),
          leadSurrogate = this.leadSurrogate,
          seqObj = this.seqObj,
          nextChar = -1,
          i = 0,
          j = 0;
        while (true) {
          if (nextChar === -1) {
            if (i == str.length) break;
            var uCode = str.charCodeAt(i++);
          } else {
            var uCode = nextChar;
            nextChar = -1;
          }
          if (55296 <= uCode && uCode < 57344) {
            if (uCode < 56320) {
              if (leadSurrogate === -1) {
                leadSurrogate = uCode;
                continue;
              } else {
                leadSurrogate = uCode;
                uCode = UNASSIGNED;
              }
            } else {
              if (leadSurrogate !== -1) {
                uCode =
                  65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
                leadSurrogate = -1;
              } else {
                uCode = UNASSIGNED;
              }
            }
          } else if (leadSurrogate !== -1) {
            nextChar = uCode;
            uCode = UNASSIGNED;
            leadSurrogate = -1;
          }
          var dbcsCode = UNASSIGNED;
          if (seqObj !== undefined && uCode != UNASSIGNED) {
            var resCode = seqObj[uCode];
            if (typeof resCode === "object") {
              seqObj = resCode;
              continue;
            } else if (typeof resCode == "number") {
              dbcsCode = resCode;
            } else if (resCode == undefined) {
              resCode = seqObj[DEF_CHAR];
              if (resCode !== undefined) {
                dbcsCode = resCode;
                nextChar = uCode;
              } else {
              }
            }
            seqObj = undefined;
          } else if (uCode >= 0) {
            var subtable = this.encodeTable[uCode >> 8];
            if (subtable !== undefined) dbcsCode = subtable[uCode & 255];
            if (dbcsCode <= SEQ_START) {
              seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
              continue;
            }
            if (dbcsCode == UNASSIGNED && this.gb18030) {
              var idx = findIdx(this.gb18030.uChars, uCode);
              if (idx != -1) {
                var dbcsCode =
                  this.gb18030.gbChars[idx] +
                  (uCode - this.gb18030.uChars[idx]);
                newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
                dbcsCode = dbcsCode % 12600;
                newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
                dbcsCode = dbcsCode % 1260;
                newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
                dbcsCode = dbcsCode % 10;
                newBuf[j++] = 48 + dbcsCode;
                continue;
              }
            }
          }
          if (dbcsCode === UNASSIGNED) dbcsCode = this.defaultCharSingleByte;
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else if (dbcsCode < 65536) {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          } else if (dbcsCode < 16777216) {
            newBuf[j++] = dbcsCode >> 16;
            newBuf[j++] = (dbcsCode >> 8) & 255;
            newBuf[j++] = dbcsCode & 255;
          } else {
            newBuf[j++] = dbcsCode >>> 24;
            newBuf[j++] = (dbcsCode >>> 16) & 255;
            newBuf[j++] = (dbcsCode >>> 8) & 255;
            newBuf[j++] = dbcsCode & 255;
          }
        }
        this.seqObj = seqObj;
        this.leadSurrogate = leadSurrogate;
        return newBuf.slice(0, j);
      };
      DBCSEncoder.prototype.end = function () {
        if (this.leadSurrogate === -1 && this.seqObj === undefined) return;
        var newBuf = Buffer.alloc(10),
          j = 0;
        if (this.seqObj) {
          var dbcsCode = this.seqObj[DEF_CHAR];
          if (dbcsCode !== undefined) {
            if (dbcsCode < 256) {
              newBuf[j++] = dbcsCode;
            } else {
              newBuf[j++] = dbcsCode >> 8;
              newBuf[j++] = dbcsCode & 255;
            }
          } else {
          }
          this.seqObj = undefined;
        }
        if (this.leadSurrogate !== -1) {
          newBuf[j++] = this.defaultCharSingleByte;
          this.leadSurrogate = -1;
        }
        return newBuf.slice(0, j);
      };
      DBCSEncoder.prototype.findIdx = findIdx;
      function DBCSDecoder(options, codec) {
        this.nodeIdx = 0;
        this.prevBytes = [];
        this.decodeTables = codec.decodeTables;
        this.decodeTableSeq = codec.decodeTableSeq;
        this.defaultCharUnicode = codec.defaultCharUnicode;
        this.gb18030 = codec.gb18030;
      }
      DBCSDecoder.prototype.write = function (buf) {
        var newBuf = Buffer.alloc(buf.length * 2),
          nodeIdx = this.nodeIdx,
          prevBytes = this.prevBytes,
          prevOffset = this.prevBytes.length,
          seqStart = -this.prevBytes.length,
          uCode;
        for (var i = 0, j = 0; i < buf.length; i++) {
          var curByte = i >= 0 ? buf[i] : prevBytes[i + prevOffset];
          var uCode = this.decodeTables[nodeIdx][curByte];
          if (uCode >= 0) {
          } else if (uCode === UNASSIGNED) {
            uCode = this.defaultCharUnicode.charCodeAt(0);
            i = seqStart;
          } else if (uCode === GB18030_CODE) {
            if (i >= 3) {
              var ptr =
                (buf[i - 3] - 129) * 12600 +
                (buf[i - 2] - 48) * 1260 +
                (buf[i - 1] - 129) * 10 +
                (curByte - 48);
            } else {
              var ptr =
                (prevBytes[i - 3 + prevOffset] - 129) * 12600 +
                ((i - 2 >= 0 ? buf[i - 2] : prevBytes[i - 2 + prevOffset]) -
                  48) *
                  1260 +
                ((i - 1 >= 0 ? buf[i - 1] : prevBytes[i - 1 + prevOffset]) -
                  129) *
                  10 +
                (curByte - 48);
            }
            var idx = findIdx(this.gb18030.gbChars, ptr);
            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
          } else if (uCode <= NODE_START) {
            nodeIdx = NODE_START - uCode;
            continue;
          } else if (uCode <= SEQ_START) {
            var seq = this.decodeTableSeq[SEQ_START - uCode];
            for (var k = 0; k < seq.length - 1; k++) {
              uCode = seq[k];
              newBuf[j++] = uCode & 255;
              newBuf[j++] = uCode >> 8;
            }
            uCode = seq[seq.length - 1];
          } else
            throw new Error(
              "iconv-lite internal error: invalid decoding table value " +
                uCode +
                " at " +
                nodeIdx +
                "/" +
                curByte,
            );
          if (uCode >= 65536) {
            uCode -= 65536;
            var uCodeLead = 55296 | (uCode >> 10);
            newBuf[j++] = uCodeLead & 255;
            newBuf[j++] = uCodeLead >> 8;
            uCode = 56320 | (uCode & 1023);
          }
          newBuf[j++] = uCode & 255;
          newBuf[j++] = uCode >> 8;
          nodeIdx = 0;
          seqStart = i + 1;
        }
        this.nodeIdx = nodeIdx;
        this.prevBytes =
          seqStart >= 0
            ? Array.prototype.slice.call(buf, seqStart)
            : prevBytes
                .slice(seqStart + prevOffset)
                .concat(Array.prototype.slice.call(buf));
        return newBuf.slice(0, j).toString("ucs2");
      };
      DBCSDecoder.prototype.end = function () {
        var ret = "";
        while (this.prevBytes.length > 0) {
          ret += this.defaultCharUnicode;
          var bytesArr = this.prevBytes.slice(1);
          this.prevBytes = [];
          this.nodeIdx = 0;
          if (bytesArr.length > 0) ret += this.write(bytesArr);
        }
        this.prevBytes = [];
        this.nodeIdx = 0;
        return ret;
      };
      function findIdx(table, val) {
        if (table[0] > val) return -1;
        var l = 0,
          r = table.length;
        while (l < r - 1) {
          var mid = l + ((r - l + 1) >> 1);
          if (table[mid] <= val) l = mid;
          else r = mid;
        }
        return l;
      }
    },
    1386: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      module.exports = {
        shiftjis: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(7014);
          },
          encodeAdd: { "¥": 92, "‾": 126 },
          encodeSkipVals: [{ from: 60736, to: 63808 }],
        },
        csshiftjis: "shiftjis",
        mskanji: "shiftjis",
        sjis: "shiftjis",
        windows31j: "shiftjis",
        ms31j: "shiftjis",
        xsjis: "shiftjis",
        windows932: "shiftjis",
        ms932: "shiftjis",
        932: "shiftjis",
        cp932: "shiftjis",
        eucjp: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(1532);
          },
          encodeAdd: { "¥": 92, "‾": 126 },
        },
        gb2312: "cp936",
        gb231280: "cp936",
        gb23121980: "cp936",
        csgb2312: "cp936",
        csiso58gb231280: "cp936",
        euccn: "cp936",
        windows936: "cp936",
        ms936: "cp936",
        936: "cp936",
        cp936: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336);
          },
        },
        gbk: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336).concat(__nccwpck_require__(4346));
          },
        },
        xgbk: "gbk",
        isoir58: "gbk",
        gb18030: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(3336).concat(__nccwpck_require__(4346));
          },
          gb18030: function () {
            return __nccwpck_require__(6258);
          },
          encodeSkipVals: [128],
          encodeAdd: { "€": 41699 },
        },
        chinese: "gb18030",
        windows949: "cp949",
        ms949: "cp949",
        949: "cp949",
        cp949: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(7348);
          },
        },
        cseuckr: "cp949",
        csksc56011987: "cp949",
        euckr: "cp949",
        isoir149: "cp949",
        korean: "cp949",
        ksc56011987: "cp949",
        ksc56011989: "cp949",
        ksc5601: "cp949",
        windows950: "cp950",
        ms950: "cp950",
        950: "cp950",
        cp950: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(4284);
          },
        },
        big5: "big5hkscs",
        big5hkscs: {
          type: "_dbcs",
          table: function () {
            return __nccwpck_require__(4284).concat(__nccwpck_require__(3480));
          },
          encodeSkipVals: [
            36457, 36463, 36478, 36523, 36532, 36557, 36560, 36695, 36713,
            36718, 36811, 36862, 36973, 36986, 37060, 37084, 37105, 37311,
            37551, 37552, 37553, 37554, 37585, 37959, 38090, 38361, 38652,
            39285, 39798, 39800, 39803, 39878, 39902, 39916, 39926, 40002,
            40019, 40034, 40040, 40043, 40055, 40124, 40125, 40144, 40279,
            40282, 40388, 40431, 40443, 40617, 40687, 40701, 40800, 40907,
            41079, 41180, 41183, 36812, 37576, 38468, 38637, 41636, 41637,
            41639, 41638, 41676, 41678,
          ],
        },
        cnbig5: "big5hkscs",
        csbig5: "big5hkscs",
        xxbig5: "big5hkscs",
      };
    },
    2733: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var modules = [
        __nccwpck_require__(2376),
        __nccwpck_require__(9557),
        __nccwpck_require__(1155),
        __nccwpck_require__(1644),
        __nccwpck_require__(6657),
        __nccwpck_require__(1080),
        __nccwpck_require__(1012),
        __nccwpck_require__(9695),
        __nccwpck_require__(1386),
      ];
      for (var i = 0; i < modules.length; i++) {
        var module = modules[i];
        for (var enc in module)
          if (Object.prototype.hasOwnProperty.call(module, enc))
            exports[enc] = module[enc];
      }
    },
    2376: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      module.exports = {
        utf8: { type: "_internal", bomAware: true },
        cesu8: { type: "_internal", bomAware: true },
        unicode11utf8: "utf8",
        ucs2: { type: "_internal", bomAware: true },
        utf16le: "ucs2",
        binary: { type: "_internal" },
        base64: { type: "_internal" },
        hex: { type: "_internal" },
        _internal: InternalCodec,
      };
      function InternalCodec(codecOptions, iconv) {
        this.enc = codecOptions.encodingName;
        this.bomAware = codecOptions.bomAware;
        if (this.enc === "base64") this.encoder = InternalEncoderBase64;
        else if (this.enc === "cesu8") {
          this.enc = "utf8";
          this.encoder = InternalEncoderCesu8;
          if (Buffer.from("eda0bdedb2a9", "hex").toString() !== "💩") {
            this.decoder = InternalDecoderCesu8;
            this.defaultCharUnicode = iconv.defaultCharUnicode;
          }
        }
      }
      InternalCodec.prototype.encoder = InternalEncoder;
      InternalCodec.prototype.decoder = InternalDecoder;
      var StringDecoder = __nccwpck_require__(1576).StringDecoder;
      if (!StringDecoder.prototype.end)
        StringDecoder.prototype.end = function () {};
      function InternalDecoder(options, codec) {
        this.decoder = new StringDecoder(codec.enc);
      }
      InternalDecoder.prototype.write = function (buf) {
        if (!Buffer.isBuffer(buf)) {
          buf = Buffer.from(buf);
        }
        return this.decoder.write(buf);
      };
      InternalDecoder.prototype.end = function () {
        return this.decoder.end();
      };
      function InternalEncoder(options, codec) {
        this.enc = codec.enc;
      }
      InternalEncoder.prototype.write = function (str) {
        return Buffer.from(str, this.enc);
      };
      InternalEncoder.prototype.end = function () {};
      function InternalEncoderBase64(options, codec) {
        this.prevStr = "";
      }
      InternalEncoderBase64.prototype.write = function (str) {
        str = this.prevStr + str;
        var completeQuads = str.length - (str.length % 4);
        this.prevStr = str.slice(completeQuads);
        str = str.slice(0, completeQuads);
        return Buffer.from(str, "base64");
      };
      InternalEncoderBase64.prototype.end = function () {
        return Buffer.from(this.prevStr, "base64");
      };
      function InternalEncoderCesu8(options, codec) {}
      InternalEncoderCesu8.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length * 3),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var charCode = str.charCodeAt(i);
          if (charCode < 128) buf[bufIdx++] = charCode;
          else if (charCode < 2048) {
            buf[bufIdx++] = 192 + (charCode >>> 6);
            buf[bufIdx++] = 128 + (charCode & 63);
          } else {
            buf[bufIdx++] = 224 + (charCode >>> 12);
            buf[bufIdx++] = 128 + ((charCode >>> 6) & 63);
            buf[bufIdx++] = 128 + (charCode & 63);
          }
        }
        return buf.slice(0, bufIdx);
      };
      InternalEncoderCesu8.prototype.end = function () {};
      function InternalDecoderCesu8(options, codec) {
        this.acc = 0;
        this.contBytes = 0;
        this.accBytes = 0;
        this.defaultCharUnicode = codec.defaultCharUnicode;
      }
      InternalDecoderCesu8.prototype.write = function (buf) {
        var acc = this.acc,
          contBytes = this.contBytes,
          accBytes = this.accBytes,
          res = "";
        for (var i = 0; i < buf.length; i++) {
          var curByte = buf[i];
          if ((curByte & 192) !== 128) {
            if (contBytes > 0) {
              res += this.defaultCharUnicode;
              contBytes = 0;
            }
            if (curByte < 128) {
              res += String.fromCharCode(curByte);
            } else if (curByte < 224) {
              acc = curByte & 31;
              contBytes = 1;
              accBytes = 1;
            } else if (curByte < 240) {
              acc = curByte & 15;
              contBytes = 2;
              accBytes = 1;
            } else {
              res += this.defaultCharUnicode;
            }
          } else {
            if (contBytes > 0) {
              acc = (acc << 6) | (curByte & 63);
              contBytes--;
              accBytes++;
              if (contBytes === 0) {
                if (accBytes === 2 && acc < 128 && acc > 0)
                  res += this.defaultCharUnicode;
                else if (accBytes === 3 && acc < 2048)
                  res += this.defaultCharUnicode;
                else res += String.fromCharCode(acc);
              }
            } else {
              res += this.defaultCharUnicode;
            }
          }
        }
        this.acc = acc;
        this.contBytes = contBytes;
        this.accBytes = accBytes;
        return res;
      };
      InternalDecoderCesu8.prototype.end = function () {
        var res = 0;
        if (this.contBytes > 0) res += this.defaultCharUnicode;
        return res;
      };
    },
    6657: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports._sbcs = SBCSCodec;
      function SBCSCodec(codecOptions, iconv) {
        if (!codecOptions)
          throw new Error("SBCS codec is called without the data.");
        if (
          !codecOptions.chars ||
          (codecOptions.chars.length !== 128 &&
            codecOptions.chars.length !== 256)
        )
          throw new Error(
            "Encoding '" +
              codecOptions.type +
              "' has incorrect 'chars' (must be of len 128 or 256)",
          );
        if (codecOptions.chars.length === 128) {
          var asciiString = "";
          for (var i = 0; i < 128; i++) asciiString += String.fromCharCode(i);
          codecOptions.chars = asciiString + codecOptions.chars;
        }
        this.decodeBuf = Buffer.from(codecOptions.chars, "ucs2");
        var encodeBuf = Buffer.alloc(
          65536,
          iconv.defaultCharSingleByte.charCodeAt(0),
        );
        for (var i = 0; i < codecOptions.chars.length; i++)
          encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
        this.encodeBuf = encodeBuf;
      }
      SBCSCodec.prototype.encoder = SBCSEncoder;
      SBCSCodec.prototype.decoder = SBCSDecoder;
      function SBCSEncoder(options, codec) {
        this.encodeBuf = codec.encodeBuf;
      }
      SBCSEncoder.prototype.write = function (str) {
        var buf = Buffer.alloc(str.length);
        for (var i = 0; i < str.length; i++)
          buf[i] = this.encodeBuf[str.charCodeAt(i)];
        return buf;
      };
      SBCSEncoder.prototype.end = function () {};
      function SBCSDecoder(options, codec) {
        this.decodeBuf = codec.decodeBuf;
      }
      SBCSDecoder.prototype.write = function (buf) {
        var decodeBuf = this.decodeBuf;
        var newBuf = Buffer.alloc(buf.length * 2);
        var idx1 = 0,
          idx2 = 0;
        for (var i = 0; i < buf.length; i++) {
          idx1 = buf[i] * 2;
          idx2 = i * 2;
          newBuf[idx2] = decodeBuf[idx1];
          newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
        }
        return newBuf.toString("ucs2");
      };
      SBCSDecoder.prototype.end = function () {};
    },
    1012: (module) => {
      "use strict";
      module.exports = {
        437: "cp437",
        737: "cp737",
        775: "cp775",
        850: "cp850",
        852: "cp852",
        855: "cp855",
        856: "cp856",
        857: "cp857",
        858: "cp858",
        860: "cp860",
        861: "cp861",
        862: "cp862",
        863: "cp863",
        864: "cp864",
        865: "cp865",
        866: "cp866",
        869: "cp869",
        874: "windows874",
        922: "cp922",
        1046: "cp1046",
        1124: "cp1124",
        1125: "cp1125",
        1129: "cp1129",
        1133: "cp1133",
        1161: "cp1161",
        1162: "cp1162",
        1163: "cp1163",
        1250: "windows1250",
        1251: "windows1251",
        1252: "windows1252",
        1253: "windows1253",
        1254: "windows1254",
        1255: "windows1255",
        1256: "windows1256",
        1257: "windows1257",
        1258: "windows1258",
        28591: "iso88591",
        28592: "iso88592",
        28593: "iso88593",
        28594: "iso88594",
        28595: "iso88595",
        28596: "iso88596",
        28597: "iso88597",
        28598: "iso88598",
        28599: "iso88599",
        28600: "iso885910",
        28601: "iso885911",
        28603: "iso885913",
        28604: "iso885914",
        28605: "iso885915",
        28606: "iso885916",
        windows874: {
          type: "_sbcs",
          chars:
            "€����…�����������‘’“”•–—�������� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
        win874: "windows874",
        cp874: "windows874",
        windows1250: {
          type: "_sbcs",
          chars:
            "€�‚�„…†‡�‰Š‹ŚŤŽŹ�‘’“”•–—�™š›śťžź ˇ˘Ł¤Ą¦§¨©Ş«¬­®Ż°±˛ł´µ¶·¸ąş»Ľ˝ľżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙",
        },
        win1250: "windows1250",
        cp1250: "windows1250",
        windows1251: {
          type: "_sbcs",
          chars:
            "ЂЃ‚ѓ„…†‡€‰Љ‹ЊЌЋЏђ‘’“”•–—�™љ›њќћџ ЎўЈ¤Ґ¦§Ё©Є«¬­®Ї°±Ііґµ¶·ё№є»јЅѕїАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
        },
        win1251: "windows1251",
        cp1251: "windows1251",
        windows1252: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰Š‹Œ�Ž��‘’“”•–—˜™š›œ�žŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        win1252: "windows1252",
        cp1252: "windows1252",
        windows1253: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡�‰�‹�����‘’“”•–—�™�›���� ΅Ά£¤¥¦§¨©�«¬­®―°±²³΄µ¶·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�",
        },
        win1253: "windows1253",
        cp1253: "windows1253",
        windows1254: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰Š‹Œ����‘’“”•–—˜™š›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ",
        },
        win1254: "windows1254",
        cp1254: "windows1254",
        windows1255: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰�‹�����‘’“”•–—˜™�›���� ¡¢£₪¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾¿ְֱֲֳִֵֶַָֹֺֻּֽ־ֿ׀ׁׂ׃װױײ׳״�������אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�",
        },
        win1255: "windows1255",
        cp1255: "windows1255",
        windows1256: {
          type: "_sbcs",
          chars:
            "€پ‚ƒ„…†‡ˆ‰ٹ‹Œچژڈگ‘’“”•–—ک™ڑ›œ‌‍ں ،¢£¤¥¦§¨©ھ«¬­®¯°±²³´µ¶·¸¹؛»¼½¾؟ہءآأؤإئابةتثجحخدذرزسشصض×طظعغـفقكàلâمنهوçèéêëىيîïًٌٍَôُِ÷ّùْûü‎‏ے",
        },
        win1256: "windows1256",
        cp1256: "windows1256",
        windows1257: {
          type: "_sbcs",
          chars:
            "€�‚�„…†‡�‰�‹�¨ˇ¸�‘’“”•–—�™�›�¯˛� �¢£¤�¦§Ø©Ŗ«¬­®Æ°±²³´µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž˙",
        },
        win1257: "windows1257",
        cp1257: "windows1257",
        windows1258: {
          type: "_sbcs",
          chars:
            "€�‚ƒ„…†‡ˆ‰�‹Œ����‘’“”•–—˜™�›œ��Ÿ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ",
        },
        win1258: "windows1258",
        cp1258: "windows1258",
        iso88591: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        cp28591: "iso88591",
        iso88592: {
          type: "_sbcs",
          chars:
            " Ą˘Ł¤ĽŚ§¨ŠŞŤŹ­ŽŻ°ą˛ł´ľśˇ¸šşťź˝žżŔÁÂĂÄĹĆÇČÉĘËĚÍÎĎĐŃŇÓÔŐÖ×ŘŮÚŰÜÝŢßŕáâăäĺćçčéęëěíîďđńňóôőö÷řůúűüýţ˙",
        },
        cp28592: "iso88592",
        iso88593: {
          type: "_sbcs",
          chars:
            " Ħ˘£¤�Ĥ§¨İŞĞĴ­�Ż°ħ²³´µĥ·¸ışğĵ½�żÀÁÂ�ÄĊĈÇÈÉÊËÌÍÎÏ�ÑÒÓÔĠÖ×ĜÙÚÛÜŬŜßàáâ�äċĉçèéêëìíîï�ñòóôġö÷ĝùúûüŭŝ˙",
        },
        cp28593: "iso88593",
        iso88594: {
          type: "_sbcs",
          chars:
            " ĄĸŖ¤ĨĻ§¨ŠĒĢŦ­Ž¯°ą˛ŗ´ĩļˇ¸šēģŧŊžŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎĪĐŅŌĶÔÕÖ×ØŲÚÛÜŨŪßāáâãäåæįčéęëėíîīđņōķôõö÷øųúûüũū˙",
        },
        cp28594: "iso88594",
        iso88595: {
          type: "_sbcs",
          chars:
            " ЁЂЃЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђѓєѕіїјљњћќ§ўџ",
        },
        cp28595: "iso88595",
        iso88596: {
          type: "_sbcs",
          chars:
            " ���¤�������،­�������������؛���؟�ءآأؤإئابةتثجحخدذرزسشصضطظعغ�����ـفقكلمنهوىيًٌٍَُِّْ�������������",
        },
        cp28596: "iso88596",
        iso88597: {
          type: "_sbcs",
          chars:
            " ‘’£€₯¦§¨©ͺ«¬­�―°±²³΄΅Ά·ΈΉΊ»Ό½ΎΏΐΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡ�ΣΤΥΦΧΨΩΪΫάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ�",
        },
        cp28597: "iso88597",
        iso88598: {
          type: "_sbcs",
          chars:
            " �¢£¤¥¦§¨©×«¬­®¯°±²³´µ¶·¸¹÷»¼½¾��������������������������������‗אבגדהוזחטיךכלםמןנסעףפץצקרשת��‎‏�",
        },
        cp28598: "iso88598",
        iso88599: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏĞÑÒÓÔÕÖ×ØÙÚÛÜİŞßàáâãäåæçèéêëìíîïğñòóôõö÷øùúûüışÿ",
        },
        cp28599: "iso88599",
        iso885910: {
          type: "_sbcs",
          chars:
            " ĄĒĢĪĨĶ§ĻĐŠŦŽ­ŪŊ°ąēģīĩķ·ļđšŧž―ūŋĀÁÂÃÄÅÆĮČÉĘËĖÍÎÏÐŅŌÓÔÕÖŨØŲÚÛÜÝÞßāáâãäåæįčéęëėíîïðņōóôõöũøųúûüýþĸ",
        },
        cp28600: "iso885910",
        iso885911: {
          type: "_sbcs",
          chars:
            " กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
        cp28601: "iso885911",
        iso885913: {
          type: "_sbcs",
          chars:
            " ”¢£¤„¦§Ø©Ŗ«¬­®Æ°±²³“µ¶·ø¹ŗ»¼½¾æĄĮĀĆÄÅĘĒČÉŹĖĢĶĪĻŠŃŅÓŌÕÖ×ŲŁŚŪÜŻŽßąįāćäåęēčéźėģķīļšńņóōõö÷ųłśūüżž’",
        },
        cp28603: "iso885913",
        iso885914: {
          type: "_sbcs",
          chars:
            " Ḃḃ£ĊċḊ§Ẁ©ẂḋỲ­®ŸḞḟĠġṀṁ¶ṖẁṗẃṠỳẄẅṡÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŴÑÒÓÔÕÖṪØÙÚÛÜÝŶßàáâãäåæçèéêëìíîïŵñòóôõöṫøùúûüýŷÿ",
        },
        cp28604: "iso885914",
        iso885915: {
          type: "_sbcs",
          chars:
            " ¡¢£€¥Š§š©ª«¬­®¯°±²³Žµ¶·ž¹º»ŒœŸ¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏÐÑÒÓÔÕÖ×ØÙÚÛÜÝÞßàáâãäåæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        cp28605: "iso885915",
        iso885916: {
          type: "_sbcs",
          chars:
            " ĄąŁ€„Š§š©Ș«Ź­źŻ°±ČłŽ”¶·žčș»ŒœŸżÀÁÂĂÄĆÆÇÈÉÊËÌÍÎÏĐŃÒÓÔŐÖŚŰÙÚÛÜĘȚßàáâăäćæçèéêëìíîïđńòóôőöśűùúûüęțÿ",
        },
        cp28606: "iso885916",
        cp437: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜ¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm437: "cp437",
        csibm437: "cp437",
        cp737: {
          type: "_sbcs",
          chars:
            "ΑΒΓΔΕΖΗΘΙΚΛΜΝΞΟΠΡΣΤΥΦΧΨΩαβγδεζηθικλμνξοπρσςτυφχψ░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ωάέήϊίόύϋώΆΈΉΊΌΎΏ±≥≤ΪΫ÷≈°∙·√ⁿ²■ ",
        },
        ibm737: "cp737",
        csibm737: "cp737",
        cp775: {
          type: "_sbcs",
          chars:
            "ĆüéāäģåćłēŖŗīŹÄÅÉæÆōöĢ¢ŚśÖÜø£Ø×¤ĀĪóŻżź”¦©®¬½¼Ł«»░▒▓│┤ĄČĘĖ╣║╗╝ĮŠ┐└┴┬├─┼ŲŪ╚╔╩╦╠═╬Žąčęėįšųūž┘┌█▄▌▐▀ÓßŌŃõÕµńĶķĻļņĒŅ’­±“¾¶§÷„°∙·¹³²■ ",
        },
        ibm775: "cp775",
        csibm775: "cp775",
        cp850: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈıÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ ",
        },
        ibm850: "cp850",
        csibm850: "cp850",
        cp852: {
          type: "_sbcs",
          chars:
            "ÇüéâäůćçłëŐőîŹÄĆÉĹĺôöĽľŚśÖÜŤťŁ×čáíóúĄąŽžĘę¬źČş«»░▒▓│┤ÁÂĚŞ╣║╗╝Żż┐└┴┬├─┼Ăă╚╔╩╦╠═╬¤đĐĎËďŇÍÎě┘┌█▄ŢŮ▀ÓßÔŃńňŠšŔÚŕŰýÝţ´­˝˛ˇ˘§÷¸°¨˙űŘř■ ",
        },
        ibm852: "cp852",
        csibm852: "cp852",
        cp855: {
          type: "_sbcs",
          chars:
            "ђЂѓЃёЁєЄѕЅіІїЇјЈљЉњЊћЋќЌўЎџЏюЮъЪаАбБцЦдДеЕфФгГ«»░▒▓│┤хХиИ╣║╗╝йЙ┐└┴┬├─┼кК╚╔╩╦╠═╬¤лЛмМнНоОп┘┌█▄Пя▀ЯрРсСтТуУжЖвВьЬ№­ыЫзЗшШэЭщЩчЧ§■ ",
        },
        ibm855: "cp855",
        csibm855: "cp855",
        cp856: {
          type: "_sbcs",
          chars:
            "אבגדהוזחטיךכלםמןנסעףפץצקרשת�£�×����������®¬½¼�«»░▒▓│┤���©╣║╗╝¢¥┐└┴┬├─┼��╚╔╩╦╠═╬¤���������┘┌█▄¦�▀������µ�������¯´­±‗¾¶§÷¸°¨·¹³²■ ",
        },
        ibm856: "cp856",
        csibm856: "cp856",
        cp857: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîıÄÅÉæÆôöòûùİÖÜø£ØŞşáíóúñÑĞğ¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ºªÊËÈ�ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµ�×ÚÛÙìÿ¯´­±�¾¶§÷¸°¨·¹³²■ ",
        },
        ibm857: "cp857",
        csibm857: "cp857",
        cp858: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø×ƒáíóúñÑªº¿®¬½¼¡«»░▒▓│┤ÁÂÀ©╣║╗╝¢¥┐└┴┬├─┼ãÃ╚╔╩╦╠═╬¤ðÐÊËÈ€ÍÎÏ┘┌█▄¦Ì▀ÓßÔÒõÕµþÞÚÛÙýÝ¯´­±‗¾¶§÷¸°¨·¹³²■ ",
        },
        ibm858: "cp858",
        csibm858: "cp858",
        cp860: {
          type: "_sbcs",
          chars:
            "ÇüéâãàÁçêÊèÍÔìÃÂÉÀÈôõòÚùÌÕÜ¢£Ù₧ÓáíóúñÑªº¿Ò¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm860: "cp860",
        csibm860: "cp860",
        cp861: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèÐðÞÄÅÉæÆôöþûÝýÖÜø£Ø₧ƒáíóúÁÍÓÚ¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm861: "cp861",
        csibm861: "cp861",
        cp862: {
          type: "_sbcs",
          chars:
            "אבגדהוזחטיךכלםמןנסעףפץצקרשת¢£¥₧ƒáíóúñÑªº¿⌐¬½¼¡«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm862: "cp862",
        csibm862: "cp862",
        cp863: {
          type: "_sbcs",
          chars:
            "ÇüéâÂà¶çêëèïî‗À§ÉÈÊôËÏûù¤ÔÜ¢£ÙÛƒ¦´óú¨¸³¯Î⌐¬½¼¾«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm863: "cp863",
        csibm863: "cp863",
        cp864: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#$٪&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~°·∙√▒─│┼┤┬├┴┐┌└┘β∞φ±½¼≈«»ﻷﻸ��ﻻﻼ� ­ﺂ£¤ﺄ��ﺎﺏﺕﺙ،ﺝﺡﺥ٠١٢٣٤٥٦٧٨٩ﻑ؛ﺱﺵﺹ؟¢ﺀﺁﺃﺅﻊﺋﺍﺑﺓﺗﺛﺟﺣﺧﺩﺫﺭﺯﺳﺷﺻﺿﻁﻅﻋﻏ¦¬÷×ﻉـﻓﻗﻛﻟﻣﻧﻫﻭﻯﻳﺽﻌﻎﻍﻡﹽّﻥﻩﻬﻰﻲﻐﻕﻵﻶﻝﻙﻱ■�",
        },
        ibm864: "cp864",
        csibm864: "cp864",
        cp865: {
          type: "_sbcs",
          chars:
            "ÇüéâäàåçêëèïîìÄÅÉæÆôöòûùÿÖÜø£Ø₧ƒáíóúñÑªº¿⌐¬½¼¡«¤░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        ibm865: "cp865",
        csibm865: "cp865",
        cp866: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№¤■ ",
        },
        ibm866: "cp866",
        csibm866: "cp866",
        cp869: {
          type: "_sbcs",
          chars:
            "������Ά�·¬¦‘’Έ―ΉΊΪΌ��ΎΫ©Ώ²³ά£έήίϊΐόύΑΒΓΔΕΖΗ½ΘΙ«»░▒▓│┤ΚΛΜΝ╣║╗╝ΞΟ┐└┴┬├─┼ΠΡ╚╔╩╦╠═╬ΣΤΥΦΧΨΩαβγ┘┌█▄δε▀ζηθικλμνξοπρσςτ΄­±υφχ§ψ΅°¨ωϋΰώ■ ",
        },
        ibm869: "cp869",
        csibm869: "cp869",
        cp922: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§¨©ª«¬­®‾°±²³´µ¶·¸¹º»¼½¾¿ÀÁÂÃÄÅÆÇÈÉÊËÌÍÎÏŠÑÒÓÔÕÖ×ØÙÚÛÜÝŽßàáâãäåæçèéêëìíîïšñòóôõö÷øùúûüýžÿ",
        },
        ibm922: "cp922",
        csibm922: "cp922",
        cp1046: {
          type: "_sbcs",
          chars:
            "ﺈ×÷ﹱ■│─┐┌└┘ﹹﹻﹽﹿﹷﺊﻰﻳﻲﻎﻏﻐﻶﻸﻺﻼ ¤ﺋﺑﺗﺛﺟﺣ،­ﺧﺳ٠١٢٣٤٥٦٧٨٩ﺷ؛ﺻﺿﻊ؟ﻋءآأؤإئابةتثجحخدذرزسشصضطﻇعغﻌﺂﺄﺎﻓـفقكلمنهوىيًٌٍَُِّْﻗﻛﻟﻵﻷﻹﻻﻣﻧﻬﻩ�",
        },
        ibm1046: "cp1046",
        csibm1046: "cp1046",
        cp1124: {
          type: "_sbcs",
          chars:
            " ЁЂҐЄЅІЇЈЉЊЋЌ­ЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя№ёђґєѕіїјљњћќ§ўџ",
        },
        ibm1124: "cp1124",
        csibm1124: "cp1124",
        cp1125: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёҐґЄєІіЇї·√№¤■ ",
        },
        ibm1125: "cp1125",
        csibm1125: "cp1125",
        cp1129: {
          type: "_sbcs",
          chars:
            " ¡¢£¤¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ",
        },
        ibm1129: "cp1129",
        csibm1129: "cp1129",
        cp1133: {
          type: "_sbcs",
          chars:
            " ກຂຄງຈສຊຍດຕຖທນບປຜຝພຟມຢຣລວຫອຮ���ຯະາຳິີຶືຸູຼັົຽ���ເແໂໃໄ່້໊໋໌ໍໆ�ໜໝ₭����������������໐໑໒໓໔໕໖໗໘໙��¢¬¦�",
        },
        ibm1133: "cp1133",
        csibm1133: "cp1133",
        cp1161: {
          type: "_sbcs",
          chars:
            "��������������������������������่กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู้๊๋€฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛¢¬¦ ",
        },
        ibm1161: "cp1161",
        csibm1161: "cp1161",
        cp1162: {
          type: "_sbcs",
          chars:
            "€…‘’“”•–— กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
        ibm1162: "cp1162",
        csibm1162: "cp1162",
        cp1163: {
          type: "_sbcs",
          chars:
            " ¡¢£€¥¦§œ©ª«¬­®¯°±²³Ÿµ¶·Œ¹º»¼½¾¿ÀÁÂĂÄÅÆÇÈÉÊË̀ÍÎÏĐÑ̉ÓÔƠÖ×ØÙÚÛÜỮßàáâăäåæçèéêë́íîïđṇ̃óôơö÷øùúûüư₫ÿ",
        },
        ibm1163: "cp1163",
        csibm1163: "cp1163",
        maccroatian: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®Š™´¨≠ŽØ∞±≤≥∆µ∂∑∏š∫ªºΩžø¿¡¬√ƒ≈Ć«Č… ÀÃÕŒœĐ—“”‘’÷◊�©⁄¤‹›Æ»–·‚„‰ÂćÁčÈÍÎÏÌÓÔđÒÚÛÙıˆ˜¯πË˚¸Êæˇ",
        },
        maccyrillic: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°¢£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµ∂ЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤",
        },
        macgreek: {
          type: "_sbcs",
          chars:
            "Ä¹²É³ÖÜ΅àâä΄¨çéèêë£™îï•½‰ôö¦­ùûü†ΓΔΘΛΞΠß®©ΣΪ§≠°·Α±≤≥¥ΒΕΖΗΙΚΜΦΫΨΩάΝ¬ΟΡ≈Τ«»… ΥΧΆΈœ–―“”‘’÷ΉΊΌΎέήίόΏύαβψδεφγηιξκλμνοπώρστθωςχυζϊϋΐΰ�",
        },
        maciceland: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûüÝ°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤ÐðÞþý·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macroman: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macromania: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ĂŞ∞±≤≥¥µ∂∑∏π∫ªºΩăş¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›Ţţ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macthai: {
          type: "_sbcs",
          chars:
            "«»…“”�•‘’� กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู\ufeff​–—฿เแโใไๅๆ็่้๊๋์ํ™๏๐๑๒๓๔๕๖๗๘๙®©����",
        },
        macturkish: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸĞğİıŞş‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙ�ˆ˜¯˘˙˚¸˝˛ˇ",
        },
        macukraine: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯ†°Ґ£§•¶І®©™Ђђ≠Ѓѓ∞±≤≥іµґЈЄєЇїЉљЊњјЅ¬√ƒ≈∆«»… ЋћЌќѕ–—“”‘’÷„ЎўЏџ№Ёёяабвгдежзийклмнопрстуфхцчшщъыьэю¤",
        },
        koi8r: {
          type: "_sbcs",
          chars:
            "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ё╓╔╕╖╗╘╙╚╛╜╝╞╟╠╡Ё╢╣╤╥╦╧╨╩╪╫╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        koi8u: {
          type: "_sbcs",
          chars:
            "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґ╝╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪Ґ╬©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        koi8ru: {
          type: "_sbcs",
          chars:
            "─│┌┐└┘├┤┬┴┼▀▄█▌▐░▒▓⌠■∙√≈≤≥ ⌡°²·÷═║╒ёє╔ії╗╘╙╚╛ґў╞╟╠╡ЁЄ╣ІЇ╦╧╨╩╪ҐЎ©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        koi8t: {
          type: "_sbcs",
          chars:
            "қғ‚Ғ„…†‡�‰ҳ‹ҲҷҶ�Қ‘’“”•–—�™�›�����ӯӮё¤ӣ¦§���«¬­®�°±²Ё�Ӣ¶·�№�»���©юабцдефгхийклмнопярстужвьызшэщчъЮАБЦДЕФГХИЙКЛМНОПЯРСТУЖВЬЫЗШЭЩЧЪ",
        },
        armscii8: {
          type: "_sbcs",
          chars:
            " �և։)(»«—.՝,-֊…՜՛՞ԱաԲբԳգԴդԵեԶզԷէԸըԹթԺժԻիԼլԽխԾծԿկՀհՁձՂղՃճՄմՅյՆնՇշՈոՉչՊպՋջՌռՍսՎվՏտՐրՑցՒւՓփՔքՕօՖֆ՚�",
        },
        rk1048: {
          type: "_sbcs",
          chars:
            "ЂЃ‚ѓ„…†‡€‰Љ‹ЊҚҺЏђ‘’“”•–—�™љ›њқһџ ҰұӘ¤Ө¦§Ё©Ғ«¬­®Ү°±Ііөµ¶·ё№ғ»әҢңүАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
        },
        tcvn: {
          type: "_sbcs",
          chars:
            "\0ÚỤỪỬỮ\b\t\n\v\f\rỨỰỲỶỸÝỴ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ÀẢÃÁẠẶẬÈẺẼÉẸỆÌỈĨÍỊÒỎÕÓỌỘỜỞỠỚỢÙỦŨ ĂÂÊÔƠƯĐăâêôơưđẶ̀̀̉̃́àảãáạẲằẳẵắẴẮẦẨẪẤỀặầẩẫấậèỂẻẽéẹềểễếệìỉỄẾỒĩíịòỔỏõóọồổỗốộờởỡớợùỖủũúụừửữứựỳỷỹýỵỐ",
        },
        georgianacademy: {
          type: "_sbcs",
          chars:
            "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზთიკლმნოპჟრსტუფქღყშჩცძწჭხჯჰჱჲჳჴჵჶçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        georgianps: {
          type: "_sbcs",
          chars:
            "‚ƒ„…†‡ˆ‰Š‹Œ‘’“”•–—˜™š›œŸ ¡¢£¤¥¦§¨©ª«¬­®¯°±²³´µ¶·¸¹º»¼½¾¿აბგდევზჱთიკლმნჲოპჟრსტჳუფქღყშჩცძწჭხჴჯჰჵæçèéêëìíîïðñòóôõö÷øùúûüýþÿ",
        },
        pt154: {
          type: "_sbcs",
          chars:
            "ҖҒӮғ„…ҶҮҲүҠӢҢҚҺҸҗ‘’“”•–—ҳҷҡӣңқһҹ ЎўЈӨҘҰ§Ё©Ә«¬ӯ®Ҝ°ұІіҙө¶·ё№ә»јҪҫҝАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
        },
        viscii: {
          type: "_sbcs",
          chars:
            "\0ẲẴẪ\b\t\n\v\f\rỶỸỴ !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~ẠẮẰẶẤẦẨẬẼẸẾỀỂỄỆỐỒỔỖỘỢỚỜỞỊỎỌỈỦŨỤỲÕắằặấầẩậẽẹếềểễệốồổỗỠƠộờởịỰỨỪỬơớƯÀÁÂÃẢĂẳẵÈÉÊẺÌÍĨỳĐứÒÓÔạỷừửÙÚỹỵÝỡưàáâãảăữẫèéêẻìíĩỉđựòóôõỏọụùúũủýợỮ",
        },
        iso646cn: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#¥%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������",
        },
        iso646jp: {
          type: "_sbcs",
          chars:
            "\0\b\t\n\v\f\r !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[¥]^_`abcdefghijklmnopqrstuvwxyz{|}‾��������������������������������������������������������������������������������������������������������������������������������",
        },
        hproman8: {
          type: "_sbcs",
          chars:
            " ÀÂÈÊËÎÏ´ˋˆ¨˜ÙÛ₤¯Ýý°ÇçÑñ¡¿¤£¥§ƒ¢âêôûáéóúàèòùäëöüÅîØÆåíøæÄìÖÜÉïßÔÁÃãÐðÍÌÓÒÕõŠšÚŸÿÞþ·µ¶¾—¼½ªº«■»±�",
        },
        macintosh: {
          type: "_sbcs",
          chars:
            "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄¤‹›ﬁﬂ‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ�ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ",
        },
        ascii: {
          type: "_sbcs",
          chars:
            "��������������������������������������������������������������������������������������������������������������������������������",
        },
        tis620: {
          type: "_sbcs",
          chars:
            "���������������������������������กขฃคฅฆงจฉชซฌญฎฏฐฑฒณดตถทธนบปผฝพฟภมยรฤลฦวศษสหฬอฮฯะัาำิีึืฺุู����฿เแโใไๅๆ็่้๊๋์ํ๎๏๐๑๒๓๔๕๖๗๘๙๚๛����",
        },
      };
    },
    1080: (module) => {
      "use strict";
      module.exports = {
        10029: "maccenteuro",
        maccenteuro: {
          type: "_sbcs",
          chars:
            "ÄĀāÉĄÖÜáąČäčĆćéŹźĎíďĒēĖóėôöõúĚěü†°Ę£§•¶ß®©™ę¨≠ģĮįĪ≤≥īĶ∂∑łĻļĽľĹĺŅņŃ¬√ńŇ∆«»… ňŐÕőŌ–—“”‘’÷◊ōŔŕŘ‹›řŖŗŠ‚„šŚśÁŤťÍŽžŪÓÔūŮÚůŰűŲųÝýķŻŁżĢˇ",
        },
        808: "cp808",
        ibm808: "cp808",
        cp808: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмноп░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀рстуфхцчшщъыьэюяЁёЄєЇїЎў°∙·√№€■ ",
        },
        mik: {
          type: "_sbcs",
          chars:
            "АБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя└┴┬├─┼╣║╚╔╩╦╠═╬┐░▒▓│┤№§╗╝┘┌█▄▌▐▀αßΓπΣσµτΦΘΩδ∞φε∩≡±≥≤⌠⌡÷≈°∙·√ⁿ²■ ",
        },
        cp720: {
          type: "_sbcs",
          chars:
            "éâàçêëèïîّْô¤ـûùءآأؤ£إئابةتثجحخدذرزسشص«»░▒▓│┤╡╢╖╕╣║╗╝╜╛┐└┴┬├─┼╞╟╚╔╩╦╠═╬╧╨╤╥╙╘╒╓╫╪┘┌█▄▌▐▀ضطظعغفµقكلمنهوىي≡ًٌٍَُِ≈°∙·√ⁿ²■ ",
        },
        ascii8bit: "ascii",
        usascii: "ascii",
        ansix34: "ascii",
        ansix341968: "ascii",
        ansix341986: "ascii",
        csascii: "ascii",
        cp367: "ascii",
        ibm367: "ascii",
        isoir6: "ascii",
        iso646us: "ascii",
        iso646irv: "ascii",
        us: "ascii",
        latin1: "iso88591",
        latin2: "iso88592",
        latin3: "iso88593",
        latin4: "iso88594",
        latin5: "iso88599",
        latin6: "iso885910",
        latin7: "iso885913",
        latin8: "iso885914",
        latin9: "iso885915",
        latin10: "iso885916",
        csisolatin1: "iso88591",
        csisolatin2: "iso88592",
        csisolatin3: "iso88593",
        csisolatin4: "iso88594",
        csisolatincyrillic: "iso88595",
        csisolatinarabic: "iso88596",
        csisolatingreek: "iso88597",
        csisolatinhebrew: "iso88598",
        csisolatin5: "iso88599",
        csisolatin6: "iso885910",
        l1: "iso88591",
        l2: "iso88592",
        l3: "iso88593",
        l4: "iso88594",
        l5: "iso88599",
        l6: "iso885910",
        l7: "iso885913",
        l8: "iso885914",
        l9: "iso885915",
        l10: "iso885916",
        isoir14: "iso646jp",
        isoir57: "iso646cn",
        isoir100: "iso88591",
        isoir101: "iso88592",
        isoir109: "iso88593",
        isoir110: "iso88594",
        isoir144: "iso88595",
        isoir127: "iso88596",
        isoir126: "iso88597",
        isoir138: "iso88598",
        isoir148: "iso88599",
        isoir157: "iso885910",
        isoir166: "tis620",
        isoir179: "iso885913",
        isoir199: "iso885914",
        isoir203: "iso885915",
        isoir226: "iso885916",
        cp819: "iso88591",
        ibm819: "iso88591",
        cyrillic: "iso88595",
        arabic: "iso88596",
        arabic8: "iso88596",
        ecma114: "iso88596",
        asmo708: "iso88596",
        greek: "iso88597",
        greek8: "iso88597",
        ecma118: "iso88597",
        elot928: "iso88597",
        hebrew: "iso88598",
        hebrew8: "iso88598",
        turkish: "iso88599",
        turkish8: "iso88599",
        thai: "iso885911",
        thai8: "iso885911",
        celtic: "iso885914",
        celtic8: "iso885914",
        isoceltic: "iso885914",
        tis6200: "tis620",
        tis62025291: "tis620",
        tis62025330: "tis620",
        1e4: "macroman",
        10006: "macgreek",
        10007: "maccyrillic",
        10079: "maciceland",
        10081: "macturkish",
        cspc8codepage437: "cp437",
        cspc775baltic: "cp775",
        cspc850multilingual: "cp850",
        cspcp852: "cp852",
        cspc862latinhebrew: "cp862",
        cpgr: "cp869",
        msee: "cp1250",
        mscyrl: "cp1251",
        msansi: "cp1252",
        msgreek: "cp1253",
        msturk: "cp1254",
        mshebr: "cp1255",
        msarab: "cp1256",
        winbaltrim: "cp1257",
        cp20866: "koi8r",
        20866: "koi8r",
        ibm878: "koi8r",
        cskoi8r: "koi8r",
        cp21866: "koi8u",
        21866: "koi8u",
        ibm1168: "koi8u",
        strk10482002: "rk1048",
        tcvn5712: "tcvn",
        tcvn57121: "tcvn",
        gb198880: "iso646cn",
        cn: "iso646cn",
        csiso14jisc6220ro: "iso646jp",
        jisc62201969ro: "iso646jp",
        jp: "iso646jp",
        cshproman8: "hproman8",
        r8: "hproman8",
        roman8: "hproman8",
        xroman8: "hproman8",
        ibm1051: "hproman8",
        mac: "macintosh",
        csmacintosh: "macintosh",
      };
    },
    1155: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports.utf16be = Utf16BECodec;
      function Utf16BECodec() {}
      Utf16BECodec.prototype.encoder = Utf16BEEncoder;
      Utf16BECodec.prototype.decoder = Utf16BEDecoder;
      Utf16BECodec.prototype.bomAware = true;
      function Utf16BEEncoder() {}
      Utf16BEEncoder.prototype.write = function (str) {
        var buf = Buffer.from(str, "ucs2");
        for (var i = 0; i < buf.length; i += 2) {
          var tmp = buf[i];
          buf[i] = buf[i + 1];
          buf[i + 1] = tmp;
        }
        return buf;
      };
      Utf16BEEncoder.prototype.end = function () {};
      function Utf16BEDecoder() {
        this.overflowByte = -1;
      }
      Utf16BEDecoder.prototype.write = function (buf) {
        if (buf.length == 0) return "";
        var buf2 = Buffer.alloc(buf.length + 1),
          i = 0,
          j = 0;
        if (this.overflowByte !== -1) {
          buf2[0] = buf[0];
          buf2[1] = this.overflowByte;
          i = 1;
          j = 2;
        }
        for (; i < buf.length - 1; i += 2, j += 2) {
          buf2[j] = buf[i + 1];
          buf2[j + 1] = buf[i];
        }
        this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
        return buf2.slice(0, j).toString("ucs2");
      };
      Utf16BEDecoder.prototype.end = function () {
        this.overflowByte = -1;
      };
      exports.utf16 = Utf16Codec;
      function Utf16Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf16Codec.prototype.encoder = Utf16Encoder;
      Utf16Codec.prototype.decoder = Utf16Decoder;
      function Utf16Encoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder("utf-16le", options);
      }
      Utf16Encoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf16Encoder.prototype.end = function () {
        return this.encoder.end();
      };
      function Utf16Decoder(options, codec) {
        this.decoder = null;
        this.initialBufs = [];
        this.initialBufsLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf16Decoder.prototype.write = function (buf) {
        if (!this.decoder) {
          this.initialBufs.push(buf);
          this.initialBufsLen += buf.length;
          if (this.initialBufsLen < 16) return "";
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.write(buf);
      };
      Utf16Decoder.prototype.end = function () {
        if (!this.decoder) {
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          var trail = this.decoder.end();
          if (trail) resStr += trail;
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.end();
      };
      function detectEncoding(bufs, defaultEncoding) {
        var b = [];
        var charsProcessed = 0;
        var asciiCharsLE = 0,
          asciiCharsBE = 0;
        outer_loop: for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254) return "utf-16le";
                if (b[0] === 254 && b[1] === 255) return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
        if (asciiCharsBE > asciiCharsLE) return "utf-16be";
        if (asciiCharsBE < asciiCharsLE) return "utf-16le";
        return defaultEncoding || "utf-16le";
      }
    },
    9557: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports._utf32 = Utf32Codec;
      function Utf32Codec(codecOptions, iconv) {
        this.iconv = iconv;
        this.bomAware = true;
        this.isLE = codecOptions.isLE;
      }
      exports.utf32le = { type: "_utf32", isLE: true };
      exports.utf32be = { type: "_utf32", isLE: false };
      exports.ucs4le = "utf32le";
      exports.ucs4be = "utf32be";
      Utf32Codec.prototype.encoder = Utf32Encoder;
      Utf32Codec.prototype.decoder = Utf32Decoder;
      function Utf32Encoder(options, codec) {
        this.isLE = codec.isLE;
        this.highSurrogate = 0;
      }
      Utf32Encoder.prototype.write = function (str) {
        var src = Buffer.from(str, "ucs2");
        var dst = Buffer.alloc(src.length * 2);
        var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
        var offset = 0;
        for (var i = 0; i < src.length; i += 2) {
          var code = src.readUInt16LE(i);
          var isHighSurrogate = 55296 <= code && code < 56320;
          var isLowSurrogate = 56320 <= code && code < 57344;
          if (this.highSurrogate) {
            if (isHighSurrogate || !isLowSurrogate) {
              write32.call(dst, this.highSurrogate, offset);
              offset += 4;
            } else {
              var codepoint =
                (((this.highSurrogate - 55296) << 10) | (code - 56320)) + 65536;
              write32.call(dst, codepoint, offset);
              offset += 4;
              this.highSurrogate = 0;
              continue;
            }
          }
          if (isHighSurrogate) this.highSurrogate = code;
          else {
            write32.call(dst, code, offset);
            offset += 4;
            this.highSurrogate = 0;
          }
        }
        if (offset < dst.length) dst = dst.slice(0, offset);
        return dst;
      };
      Utf32Encoder.prototype.end = function () {
        if (!this.highSurrogate) return;
        var buf = Buffer.alloc(4);
        if (this.isLE) buf.writeUInt32LE(this.highSurrogate, 0);
        else buf.writeUInt32BE(this.highSurrogate, 0);
        this.highSurrogate = 0;
        return buf;
      };
      function Utf32Decoder(options, codec) {
        this.isLE = codec.isLE;
        this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
        this.overflow = [];
      }
      Utf32Decoder.prototype.write = function (src) {
        if (src.length === 0) return "";
        var i = 0;
        var codepoint = 0;
        var dst = Buffer.alloc(src.length + 4);
        var offset = 0;
        var isLE = this.isLE;
        var overflow = this.overflow;
        var badChar = this.badChar;
        if (overflow.length > 0) {
          for (; i < src.length && overflow.length < 4; i++)
            overflow.push(src[i]);
          if (overflow.length === 4) {
            if (isLE) {
              codepoint =
                overflow[i] |
                (overflow[i + 1] << 8) |
                (overflow[i + 2] << 16) |
                (overflow[i + 3] << 24);
            } else {
              codepoint =
                overflow[i + 3] |
                (overflow[i + 2] << 8) |
                (overflow[i + 1] << 16) |
                (overflow[i] << 24);
            }
            overflow.length = 0;
            offset = _writeCodepoint(dst, offset, codepoint, badChar);
          }
        }
        for (; i < src.length - 3; i += 4) {
          if (isLE) {
            codepoint =
              src[i] |
              (src[i + 1] << 8) |
              (src[i + 2] << 16) |
              (src[i + 3] << 24);
          } else {
            codepoint =
              src[i + 3] |
              (src[i + 2] << 8) |
              (src[i + 1] << 16) |
              (src[i] << 24);
          }
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
        for (; i < src.length; i++) {
          overflow.push(src[i]);
        }
        return dst.slice(0, offset).toString("ucs2");
      };
      function _writeCodepoint(dst, offset, codepoint, badChar) {
        if (codepoint < 0 || codepoint > 1114111) {
          codepoint = badChar;
        }
        if (codepoint >= 65536) {
          codepoint -= 65536;
          var high = 55296 | (codepoint >> 10);
          dst[offset++] = high & 255;
          dst[offset++] = high >> 8;
          var codepoint = 56320 | (codepoint & 1023);
        }
        dst[offset++] = codepoint & 255;
        dst[offset++] = codepoint >> 8;
        return offset;
      }
      Utf32Decoder.prototype.end = function () {
        this.overflow.length = 0;
      };
      exports.utf32 = Utf32AutoCodec;
      exports.ucs4 = "utf32";
      function Utf32AutoCodec(options, iconv) {
        this.iconv = iconv;
      }
      Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
      Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
      function Utf32AutoEncoder(options, codec) {
        options = options || {};
        if (options.addBOM === undefined) options.addBOM = true;
        this.encoder = codec.iconv.getEncoder(
          options.defaultEncoding || "utf-32le",
          options,
        );
      }
      Utf32AutoEncoder.prototype.write = function (str) {
        return this.encoder.write(str);
      };
      Utf32AutoEncoder.prototype.end = function () {
        return this.encoder.end();
      };
      function Utf32AutoDecoder(options, codec) {
        this.decoder = null;
        this.initialBufs = [];
        this.initialBufsLen = 0;
        this.options = options || {};
        this.iconv = codec.iconv;
      }
      Utf32AutoDecoder.prototype.write = function (buf) {
        if (!this.decoder) {
          this.initialBufs.push(buf);
          this.initialBufsLen += buf.length;
          if (this.initialBufsLen < 32) return "";
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.write(buf);
      };
      Utf32AutoDecoder.prototype.end = function () {
        if (!this.decoder) {
          var encoding = detectEncoding(
            this.initialBufs,
            this.options.defaultEncoding,
          );
          this.decoder = this.iconv.getDecoder(encoding, this.options);
          var resStr = "";
          for (var i = 0; i < this.initialBufs.length; i++)
            resStr += this.decoder.write(this.initialBufs[i]);
          var trail = this.decoder.end();
          if (trail) resStr += trail;
          this.initialBufs.length = this.initialBufsLen = 0;
          return resStr;
        }
        return this.decoder.end();
      };
      function detectEncoding(bufs, defaultEncoding) {
        var b = [];
        var charsProcessed = 0;
        var invalidLE = 0,
          invalidBE = 0;
        var bmpCharsLE = 0,
          bmpCharsBE = 0;
        outer_loop: for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16) invalidBE++;
              if (b[3] !== 0 || b[2] > 16) invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0))
                bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0)
                bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
        if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
        if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
        return defaultEncoding || "utf-32le";
      }
    },
    1644: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      exports.utf7 = Utf7Codec;
      exports.unicode11utf7 = "utf7";
      function Utf7Codec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf7Codec.prototype.encoder = Utf7Encoder;
      Utf7Codec.prototype.decoder = Utf7Decoder;
      Utf7Codec.prototype.bomAware = true;
      var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
      function Utf7Encoder(options, codec) {
        this.iconv = codec.iconv;
      }
      Utf7Encoder.prototype.write = function (str) {
        return Buffer.from(
          str.replace(
            nonDirectChars,
            function (chunk) {
              return (
                "+" +
                (chunk === "+"
                  ? ""
                  : this.iconv
                      .encode(chunk, "utf16-be")
                      .toString("base64")
                      .replace(/=+$/, "")) +
                "-"
              );
            }.bind(this),
          ),
        );
      };
      Utf7Encoder.prototype.end = function () {};
      function Utf7Decoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = "";
      }
      var base64Regex = /[A-Za-z0-9\/+]/;
      var base64Chars = [];
      for (var i = 0; i < 256; i++)
        base64Chars[i] = base64Regex.test(String.fromCharCode(i));
      var plusChar = "+".charCodeAt(0),
        minusChar = "-".charCodeAt(0),
        andChar = "&".charCodeAt(0);
      Utf7Decoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;
        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            if (buf[i] == plusChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii");
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            if (!base64Chars[buf[i]]) {
              if (i == lastI && buf[i] == minusChar) {
                res += "+";
              } else {
                var b64str =
                  base64Accum + this.iconv.decode(buf.slice(lastI, i), "ascii");
                res += this.iconv.decode(
                  Buffer.from(b64str, "base64"),
                  "utf16-be",
                );
              }
              if (buf[i] != minusChar) i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = "";
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii");
        } else {
          var b64str =
            base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
          var canBeDecoded = b64str.length - (b64str.length % 8);
          base64Accum = b64str.slice(canBeDecoded);
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7Decoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
          res = this.iconv.decode(
            Buffer.from(this.base64Accum, "base64"),
            "utf16-be",
          );
        this.inBase64 = false;
        this.base64Accum = "";
        return res;
      };
      exports.utf7imap = Utf7IMAPCodec;
      function Utf7IMAPCodec(codecOptions, iconv) {
        this.iconv = iconv;
      }
      Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
      Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
      Utf7IMAPCodec.prototype.bomAware = true;
      function Utf7IMAPEncoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = Buffer.alloc(6);
        this.base64AccumIdx = 0;
      }
      Utf7IMAPEncoder.prototype.write = function (str) {
        var inBase64 = this.inBase64,
          base64Accum = this.base64Accum,
          base64AccumIdx = this.base64AccumIdx,
          buf = Buffer.alloc(str.length * 5 + 10),
          bufIdx = 0;
        for (var i = 0; i < str.length; i++) {
          var uChar = str.charCodeAt(i);
          if (32 <= uChar && uChar <= 126) {
            if (inBase64) {
              if (base64AccumIdx > 0) {
                bufIdx += buf.write(
                  base64Accum
                    .slice(0, base64AccumIdx)
                    .toString("base64")
                    .replace(/\//g, ",")
                    .replace(/=+$/, ""),
                  bufIdx,
                );
                base64AccumIdx = 0;
              }
              buf[bufIdx++] = minusChar;
              inBase64 = false;
            }
            if (!inBase64) {
              buf[bufIdx++] = uChar;
              if (uChar === andChar) buf[bufIdx++] = minusChar;
            }
          } else {
            if (!inBase64) {
              buf[bufIdx++] = andChar;
              inBase64 = true;
            }
            if (inBase64) {
              base64Accum[base64AccumIdx++] = uChar >> 8;
              base64Accum[base64AccumIdx++] = uChar & 255;
              if (base64AccumIdx == base64Accum.length) {
                bufIdx += buf.write(
                  base64Accum.toString("base64").replace(/\//g, ","),
                  bufIdx,
                );
                base64AccumIdx = 0;
              }
            }
          }
        }
        this.inBase64 = inBase64;
        this.base64AccumIdx = base64AccumIdx;
        return buf.slice(0, bufIdx);
      };
      Utf7IMAPEncoder.prototype.end = function () {
        var buf = Buffer.alloc(10),
          bufIdx = 0;
        if (this.inBase64) {
          if (this.base64AccumIdx > 0) {
            bufIdx += buf.write(
              this.base64Accum
                .slice(0, this.base64AccumIdx)
                .toString("base64")
                .replace(/\//g, ",")
                .replace(/=+$/, ""),
              bufIdx,
            );
            this.base64AccumIdx = 0;
          }
          buf[bufIdx++] = minusChar;
          this.inBase64 = false;
        }
        return buf.slice(0, bufIdx);
      };
      function Utf7IMAPDecoder(options, codec) {
        this.iconv = codec.iconv;
        this.inBase64 = false;
        this.base64Accum = "";
      }
      var base64IMAPChars = base64Chars.slice();
      base64IMAPChars[",".charCodeAt(0)] = true;
      Utf7IMAPDecoder.prototype.write = function (buf) {
        var res = "",
          lastI = 0,
          inBase64 = this.inBase64,
          base64Accum = this.base64Accum;
        for (var i = 0; i < buf.length; i++) {
          if (!inBase64) {
            if (buf[i] == andChar) {
              res += this.iconv.decode(buf.slice(lastI, i), "ascii");
              lastI = i + 1;
              inBase64 = true;
            }
          } else {
            if (!base64IMAPChars[buf[i]]) {
              if (i == lastI && buf[i] == minusChar) {
                res += "&";
              } else {
                var b64str =
                  base64Accum +
                  this.iconv
                    .decode(buf.slice(lastI, i), "ascii")
                    .replace(/,/g, "/");
                res += this.iconv.decode(
                  Buffer.from(b64str, "base64"),
                  "utf16-be",
                );
              }
              if (buf[i] != minusChar) i--;
              lastI = i + 1;
              inBase64 = false;
              base64Accum = "";
            }
          }
        }
        if (!inBase64) {
          res += this.iconv.decode(buf.slice(lastI), "ascii");
        } else {
          var b64str =
            base64Accum +
            this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
          var canBeDecoded = b64str.length - (b64str.length % 8);
          base64Accum = b64str.slice(canBeDecoded);
          b64str = b64str.slice(0, canBeDecoded);
          res += this.iconv.decode(Buffer.from(b64str, "base64"), "utf16-be");
        }
        this.inBase64 = inBase64;
        this.base64Accum = base64Accum;
        return res;
      };
      Utf7IMAPDecoder.prototype.end = function () {
        var res = "";
        if (this.inBase64 && this.base64Accum.length > 0)
          res = this.iconv.decode(
            Buffer.from(this.base64Accum, "base64"),
            "utf16-be",
          );
        this.inBase64 = false;
        this.base64Accum = "";
        return res;
      };
    },
    7961: (__unused_webpack_module, exports) => {
      "use strict";
      var BOMChar = "\ufeff";
      exports.PrependBOM = PrependBOMWrapper;
      function PrependBOMWrapper(encoder, options) {
        this.encoder = encoder;
        this.addBOM = true;
      }
      PrependBOMWrapper.prototype.write = function (str) {
        if (this.addBOM) {
          str = BOMChar + str;
          this.addBOM = false;
        }
        return this.encoder.write(str);
      };
      PrependBOMWrapper.prototype.end = function () {
        return this.encoder.end();
      };
      exports.StripBOM = StripBOMWrapper;
      function StripBOMWrapper(decoder, options) {
        this.decoder = decoder;
        this.pass = false;
        this.options = options || {};
      }
      StripBOMWrapper.prototype.write = function (buf) {
        var res = this.decoder.write(buf);
        if (this.pass || !res) return res;
        if (res[0] === BOMChar) {
          res = res.slice(1);
          if (typeof this.options.stripBOM === "function")
            this.options.stripBOM();
        }
        this.pass = true;
        return res;
      };
      StripBOMWrapper.prototype.end = function () {
        return this.decoder.end();
      };
    },
    9032: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      var bomHandling = __nccwpck_require__(7961),
        iconv = module.exports;
      iconv.encodings = null;
      iconv.defaultCharUnicode = "�";
      iconv.defaultCharSingleByte = "?";
      iconv.encode = function encode(str, encoding, options) {
        str = "" + (str || "");
        var encoder = iconv.getEncoder(encoding, options);
        var res = encoder.write(str);
        var trail = encoder.end();
        return trail && trail.length > 0 ? Buffer.concat([res, trail]) : res;
      };
      iconv.decode = function decode(buf, encoding, options) {
        if (typeof buf === "string") {
          if (!iconv.skipDecodeWarning) {
            console.error(
              "Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding",
            );
            iconv.skipDecodeWarning = true;
          }
          buf = Buffer.from("" + (buf || ""), "binary");
        }
        var decoder = iconv.getDecoder(encoding, options);
        var res = decoder.write(buf);
        var trail = decoder.end();
        return trail ? res + trail : res;
      };
      iconv.encodingExists = function encodingExists(enc) {
        try {
          iconv.getCodec(enc);
          return true;
        } catch (e) {
          return false;
        }
      };
      iconv.toEncoding = iconv.encode;
      iconv.fromEncoding = iconv.decode;
      iconv._codecDataCache = {};
      iconv.getCodec = function getCodec(encoding) {
        if (!iconv.encodings) iconv.encodings = __nccwpck_require__(2733);
        var enc = iconv._canonicalizeEncoding(encoding);
        var codecOptions = {};
        while (true) {
          var codec = iconv._codecDataCache[enc];
          if (codec) return codec;
          var codecDef = iconv.encodings[enc];
          switch (typeof codecDef) {
            case "string":
              enc = codecDef;
              break;
            case "object":
              for (var key in codecDef) codecOptions[key] = codecDef[key];
              if (!codecOptions.encodingName) codecOptions.encodingName = enc;
              enc = codecDef.type;
              break;
            case "function":
              if (!codecOptions.encodingName) codecOptions.encodingName = enc;
              codec = new codecDef(codecOptions, iconv);
              iconv._codecDataCache[codecOptions.encodingName] = codec;
              return codec;
            default:
              throw new Error(
                "Encoding not recognized: '" +
                  encoding +
                  "' (searched as: '" +
                  enc +
                  "')",
              );
          }
        }
      };
      iconv._canonicalizeEncoding = function (encoding) {
        return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
      };
      iconv.getEncoder = function getEncoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
          encoder = new codec.encoder(options, codec);
        if (codec.bomAware && options && options.addBOM)
          encoder = new bomHandling.PrependBOM(encoder, options);
        return encoder;
      };
      iconv.getDecoder = function getDecoder(encoding, options) {
        var codec = iconv.getCodec(encoding),
          decoder = new codec.decoder(options, codec);
        if (codec.bomAware && !(options && options.stripBOM === false))
          decoder = new bomHandling.StripBOM(decoder, options);
        return decoder;
      };
      iconv.enableStreamingAPI = function enableStreamingAPI(stream_module) {
        if (iconv.supportsStreams) return;
        var streams = __nccwpck_require__(6409)(stream_module);
        iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
        iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
        iconv.encodeStream = function encodeStream(encoding, options) {
          return new iconv.IconvLiteEncoderStream(
            iconv.getEncoder(encoding, options),
            options,
          );
        };
        iconv.decodeStream = function decodeStream(encoding, options) {
          return new iconv.IconvLiteDecoderStream(
            iconv.getDecoder(encoding, options),
            options,
          );
        };
        iconv.supportsStreams = true;
      };
      var stream_module;
      try {
        stream_module = __nccwpck_require__(2781);
      } catch (e) {}
      if (stream_module && stream_module.Transform) {
        iconv.enableStreamingAPI(stream_module);
      } else {
        iconv.encodeStream = iconv.decodeStream = function () {
          throw new Error(
            "iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.",
          );
        };
      }
      if (false) {
      }
    },
    6409: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var Buffer = __nccwpck_require__(5118).Buffer;
      module.exports = function (stream_module) {
        var Transform = stream_module.Transform;
        function IconvLiteEncoderStream(conv, options) {
          this.conv = conv;
          options = options || {};
          options.decodeStrings = false;
          Transform.call(this, options);
        }
        IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
          constructor: { value: IconvLiteEncoderStream },
        });
        IconvLiteEncoderStream.prototype._transform = function (
          chunk,
          encoding,
          done,
        ) {
          if (typeof chunk != "string")
            return done(
              new Error("Iconv encoding stream needs strings as its input."),
            );
          try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteEncoderStream.prototype._flush = function (done) {
          try {
            var res = this.conv.end();
            if (res && res.length) this.push(res);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteEncoderStream.prototype.collect = function (cb) {
          var chunks = [];
          this.on("error", cb);
          this.on("data", function (chunk) {
            chunks.push(chunk);
          });
          this.on("end", function () {
            cb(null, Buffer.concat(chunks));
          });
          return this;
        };
        function IconvLiteDecoderStream(conv, options) {
          this.conv = conv;
          options = options || {};
          options.encoding = this.encoding = "utf8";
          Transform.call(this, options);
        }
        IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
          constructor: { value: IconvLiteDecoderStream },
        });
        IconvLiteDecoderStream.prototype._transform = function (
          chunk,
          encoding,
          done,
        ) {
          if (!Buffer.isBuffer(chunk) && !(chunk instanceof Uint8Array))
            return done(
              new Error("Iconv decoding stream needs buffers as its input."),
            );
          try {
            var res = this.conv.write(chunk);
            if (res && res.length) this.push(res, this.encoding);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteDecoderStream.prototype._flush = function (done) {
          try {
            var res = this.conv.end();
            if (res && res.length) this.push(res, this.encoding);
            done();
          } catch (e) {
            done(e);
          }
        };
        IconvLiteDecoderStream.prototype.collect = function (cb) {
          var res = "";
          this.on("error", cb);
          this.on("data", function (chunk) {
            res += chunk;
          });
          this.on("end", function () {
            cb(null, res);
          });
          return this;
        };
        return { IconvLiteEncoderStream, IconvLiteDecoderStream };
      };
    },
    903: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AddressError = void 0;
      class AddressError extends Error {
        constructor(message, parseMessage) {
          super(message);
          this.name = "AddressError";
          if (parseMessage !== null) {
            this.parseMessage = parseMessage;
          }
        }
      }
      exports.AddressError = AddressError;
    },
    3233: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.isCorrect = exports.isInSubnet = void 0;
      function isInSubnet(address) {
        if (this.subnetMask < address.subnetMask) {
          return false;
        }
        if (this.mask(address.subnetMask) === address.mask()) {
          return true;
        }
        return false;
      }
      exports.isInSubnet = isInSubnet;
      function isCorrect(defaultBits) {
        return function () {
          if (this.addressMinusSuffix !== this.correctForm()) {
            return false;
          }
          if (this.subnetMask === defaultBits && !this.parsedSubnet) {
            return true;
          }
          return this.parsedSubnet === String(this.subnetMask);
        };
      }
      exports.isCorrect = isCorrect;
    },
    8953: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.v6 =
        exports.AddressError =
        exports.Address6 =
        exports.Address4 =
          void 0;
      const ipv4_1 = __nccwpck_require__(753);
      Object.defineProperty(exports, "Address4", {
        enumerable: true,
        get: function () {
          return ipv4_1.Address4;
        },
      });
      const ipv6_1 = __nccwpck_require__(8292);
      Object.defineProperty(exports, "Address6", {
        enumerable: true,
        get: function () {
          return ipv6_1.Address6;
        },
      });
      const address_error_1 = __nccwpck_require__(903);
      Object.defineProperty(exports, "AddressError", {
        enumerable: true,
        get: function () {
          return address_error_1.AddressError;
        },
      });
      const helpers = __importStar(__nccwpck_require__(945));
      exports.v6 = { helpers };
    },
    753: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Address4 = void 0;
      const common = __importStar(__nccwpck_require__(3233));
      const constants = __importStar(__nccwpck_require__(6417));
      const address_error_1 = __nccwpck_require__(903);
      const jsbn_1 = __nccwpck_require__(5587);
      const sprintf_js_1 = __nccwpck_require__(3988);
      class Address4 {
        constructor(address) {
          this.groups = constants.GROUPS;
          this.parsedAddress = [];
          this.parsedSubnet = "";
          this.subnet = "/32";
          this.subnetMask = 32;
          this.v4 = true;
          this.isCorrect = common.isCorrect(constants.BITS);
          this.isInSubnet = common.isInSubnet;
          this.address = address;
          const subnet = constants.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = `/${this.subnetMask}`;
            if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants.RE_SUBNET_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(address);
        }
        static isValid(address) {
          try {
            new Address4(address);
            return true;
          } catch (e) {
            return false;
          }
        }
        parse(address) {
          const groups = address.split(".");
          if (!address.match(constants.RE_ADDRESS)) {
            throw new address_error_1.AddressError("Invalid IPv4 address.");
          }
          return groups;
        }
        correctForm() {
          return this.parsedAddress.map((part) => parseInt(part, 10)).join(".");
        }
        static fromHex(hex) {
          const padded = hex.replace(/:/g, "").padStart(8, "0");
          const groups = [];
          let i;
          for (i = 0; i < 8; i += 2) {
            const h = padded.slice(i, i + 2);
            groups.push(parseInt(h, 16));
          }
          return new Address4(groups.join("."));
        }
        static fromInteger(integer) {
          return Address4.fromHex(integer.toString(16));
        }
        static fromArpa(arpaFormAddress) {
          const leader = arpaFormAddress.replace(/(\.in-addr\.arpa)?\.$/, "");
          const address = leader.split(".").reverse().join(".");
          return new Address4(address);
        }
        toHex() {
          return this.parsedAddress
            .map((part) =>
              (0, sprintf_js_1.sprintf)("%02x", parseInt(part, 10)),
            )
            .join(":");
        }
        toArray() {
          return this.parsedAddress.map((part) => parseInt(part, 10));
        }
        toGroup6() {
          const output = [];
          let i;
          for (i = 0; i < constants.GROUPS; i += 2) {
            const hex = (0, sprintf_js_1.sprintf)(
              "%02x%02x",
              parseInt(this.parsedAddress[i], 10),
              parseInt(this.parsedAddress[i + 1], 10),
            );
            output.push((0, sprintf_js_1.sprintf)("%x", parseInt(hex, 16)));
          }
          return output.join(":");
        }
        bigInteger() {
          return new jsbn_1.BigInteger(
            this.parsedAddress
              .map((n) => (0, sprintf_js_1.sprintf)("%02x", parseInt(n, 10)))
              .join(""),
            16,
          );
        }
        _startAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "0".repeat(constants.BITS - this.subnetMask),
            2,
          );
        }
        startAddress() {
          return Address4.fromBigInteger(this._startAddress());
        }
        startAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address4.fromBigInteger(this._startAddress().add(adjust));
        }
        _endAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "1".repeat(constants.BITS - this.subnetMask),
            2,
          );
        }
        endAddress() {
          return Address4.fromBigInteger(this._endAddress());
        }
        endAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address4.fromBigInteger(this._endAddress().subtract(adjust));
        }
        static fromBigInteger(bigInteger) {
          return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
        }
        mask(mask) {
          if (mask === undefined) {
            mask = this.subnetMask;
          }
          return this.getBitsBase2(0, mask);
        }
        getBitsBase2(start, end) {
          return this.binaryZeroPad().slice(start, end);
        }
        reverseForm(options) {
          if (!options) {
            options = {};
          }
          const reversed = this.correctForm().split(".").reverse().join(".");
          if (options.omitSuffix) {
            return reversed;
          }
          return (0, sprintf_js_1.sprintf)("%s.in-addr.arpa.", reversed);
        }
        isMulticast() {
          return this.isInSubnet(new Address4("224.0.0.0/4"));
        }
        binaryZeroPad() {
          return this.bigInteger().toString(2).padStart(constants.BITS, "0");
        }
        groupForV6() {
          const segments = this.parsedAddress;
          return this.address.replace(
            constants.RE_ADDRESS,
            (0, sprintf_js_1.sprintf)(
              '<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>',
              segments.slice(0, 2).join("."),
              segments.slice(2, 4).join("."),
            ),
          );
        }
      }
      exports.Address4 = Address4;
    },
    8292: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Address6 = void 0;
      const common = __importStar(__nccwpck_require__(3233));
      const constants4 = __importStar(__nccwpck_require__(6417));
      const constants6 = __importStar(__nccwpck_require__(7674));
      const helpers = __importStar(__nccwpck_require__(945));
      const ipv4_1 = __nccwpck_require__(753);
      const regular_expressions_1 = __nccwpck_require__(6738);
      const address_error_1 = __nccwpck_require__(903);
      const jsbn_1 = __nccwpck_require__(5587);
      const sprintf_js_1 = __nccwpck_require__(3988);
      function assert(condition) {
        if (!condition) {
          throw new Error("Assertion failed.");
        }
      }
      function addCommas(number) {
        const r = /(\d+)(\d{3})/;
        while (r.test(number)) {
          number = number.replace(r, "$1,$2");
        }
        return number;
      }
      function spanLeadingZeroes4(n) {
        n = n.replace(
          /^(0{1,})([1-9]+)$/,
          '<span class="parse-error">$1</span>$2',
        );
        n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
        return n;
      }
      function compact(address, slice) {
        const s1 = [];
        const s2 = [];
        let i;
        for (i = 0; i < address.length; i++) {
          if (i < slice[0]) {
            s1.push(address[i]);
          } else if (i > slice[1]) {
            s2.push(address[i]);
          }
        }
        return s1.concat(["compact"]).concat(s2);
      }
      function paddedHex(octet) {
        return (0, sprintf_js_1.sprintf)("%04x", parseInt(octet, 16));
      }
      function unsignByte(b) {
        return b & 255;
      }
      class Address6 {
        constructor(address, optionalGroups) {
          this.addressMinusSuffix = "";
          this.parsedSubnet = "";
          this.subnet = "/128";
          this.subnetMask = 128;
          this.v4 = false;
          this.zone = "";
          this.isInSubnet = common.isInSubnet;
          this.isCorrect = common.isCorrect(constants6.BITS);
          if (optionalGroups === undefined) {
            this.groups = constants6.GROUPS;
          } else {
            this.groups = optionalGroups;
          }
          this.address = address;
          const subnet = constants6.RE_SUBNET_STRING.exec(address);
          if (subnet) {
            this.parsedSubnet = subnet[0].replace("/", "");
            this.subnetMask = parseInt(this.parsedSubnet, 10);
            this.subnet = `/${this.subnetMask}`;
            if (
              Number.isNaN(this.subnetMask) ||
              this.subnetMask < 0 ||
              this.subnetMask > constants6.BITS
            ) {
              throw new address_error_1.AddressError("Invalid subnet mask.");
            }
            address = address.replace(constants6.RE_SUBNET_STRING, "");
          } else if (/\//.test(address)) {
            throw new address_error_1.AddressError("Invalid subnet mask.");
          }
          const zone = constants6.RE_ZONE_STRING.exec(address);
          if (zone) {
            this.zone = zone[0];
            address = address.replace(constants6.RE_ZONE_STRING, "");
          }
          this.addressMinusSuffix = address;
          this.parsedAddress = this.parse(this.addressMinusSuffix);
        }
        static isValid(address) {
          try {
            new Address6(address);
            return true;
          } catch (e) {
            return false;
          }
        }
        static fromBigInteger(bigInteger) {
          const hex = bigInteger.toString(16).padStart(32, "0");
          const groups = [];
          let i;
          for (i = 0; i < constants6.GROUPS; i++) {
            groups.push(hex.slice(i * 4, (i + 1) * 4));
          }
          return new Address6(groups.join(":"));
        }
        static fromURL(url) {
          let host;
          let port = null;
          let result;
          if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
            result = constants6.RE_URL_WITH_PORT.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address with port",
                address: null,
                port: null,
              };
            }
            host = result[1];
            port = result[2];
          } else if (url.indexOf("/") !== -1) {
            url = url.replace(/^[a-z0-9]+:\/\//, "");
            result = constants6.RE_URL.exec(url);
            if (result === null) {
              return {
                error: "failed to parse address from URL",
                address: null,
                port: null,
              };
            }
            host = result[1];
          } else {
            host = url;
          }
          if (port) {
            port = parseInt(port, 10);
            if (port < 0 || port > 65536) {
              port = null;
            }
          } else {
            port = null;
          }
          return { address: new Address6(host), port };
        }
        static fromAddress4(address) {
          const address4 = new ipv4_1.Address4(address);
          const mask6 =
            constants6.BITS - (constants4.BITS - address4.subnetMask);
          return new Address6(`::ffff:${address4.correctForm()}/${mask6}`);
        }
        static fromArpa(arpaFormAddress) {
          let address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
          const semicolonAmount = 7;
          if (address.length !== 63) {
            throw new address_error_1.AddressError("Invalid 'ip6.arpa' form.");
          }
          const parts = address.split(".").reverse();
          for (let i = semicolonAmount; i > 0; i--) {
            const insertIndex = i * 4;
            parts.splice(insertIndex, 0, ":");
          }
          address = parts.join("");
          return new Address6(address);
        }
        microsoftTranscription() {
          return (0, sprintf_js_1.sprintf)(
            "%s.ipv6-literal.net",
            this.correctForm().replace(/:/g, "-"),
          );
        }
        mask(mask = this.subnetMask) {
          return this.getBitsBase2(0, mask);
        }
        possibleSubnets(subnetSize = 128) {
          const availableBits = constants6.BITS - this.subnetMask;
          const subnetBits = Math.abs(subnetSize - constants6.BITS);
          const subnetPowers = availableBits - subnetBits;
          if (subnetPowers < 0) {
            return "0";
          }
          return addCommas(
            new jsbn_1.BigInteger("2", 10).pow(subnetPowers).toString(10),
          );
        }
        _startAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "0".repeat(constants6.BITS - this.subnetMask),
            2,
          );
        }
        startAddress() {
          return Address6.fromBigInteger(this._startAddress());
        }
        startAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address6.fromBigInteger(this._startAddress().add(adjust));
        }
        _endAddress() {
          return new jsbn_1.BigInteger(
            this.mask() + "1".repeat(constants6.BITS - this.subnetMask),
            2,
          );
        }
        endAddress() {
          return Address6.fromBigInteger(this._endAddress());
        }
        endAddressExclusive() {
          const adjust = new jsbn_1.BigInteger("1");
          return Address6.fromBigInteger(this._endAddress().subtract(adjust));
        }
        getScope() {
          let scope = constants6.SCOPES[this.getBits(12, 16).intValue()];
          if (this.getType() === "Global unicast" && scope !== "Link local") {
            scope = "Global";
          }
          return scope || "Unknown";
        }
        getType() {
          for (const subnet of Object.keys(constants6.TYPES)) {
            if (this.isInSubnet(new Address6(subnet))) {
              return constants6.TYPES[subnet];
            }
          }
          return "Global unicast";
        }
        getBits(start, end) {
          return new jsbn_1.BigInteger(this.getBitsBase2(start, end), 2);
        }
        getBitsBase2(start, end) {
          return this.binaryZeroPad().slice(start, end);
        }
        getBitsBase16(start, end) {
          const length = end - start;
          if (length % 4 !== 0) {
            throw new Error(
              "Length of bits to retrieve must be divisible by four",
            );
          }
          return this.getBits(start, end)
            .toString(16)
            .padStart(length / 4, "0");
        }
        getBitsPastSubnet() {
          return this.getBitsBase2(this.subnetMask, constants6.BITS);
        }
        reverseForm(options) {
          if (!options) {
            options = {};
          }
          const characters = Math.floor(this.subnetMask / 4);
          const reversed = this.canonicalForm()
            .replace(/:/g, "")
            .split("")
            .slice(0, characters)
            .reverse()
            .join(".");
          if (characters > 0) {
            if (options.omitSuffix) {
              return reversed;
            }
            return (0, sprintf_js_1.sprintf)("%s.ip6.arpa.", reversed);
          }
          if (options.omitSuffix) {
            return "";
          }
          return "ip6.arpa.";
        }
        correctForm() {
          let i;
          let groups = [];
          let zeroCounter = 0;
          const zeroes = [];
          for (i = 0; i < this.parsedAddress.length; i++) {
            const value = parseInt(this.parsedAddress[i], 16);
            if (value === 0) {
              zeroCounter++;
            }
            if (value !== 0 && zeroCounter > 0) {
              if (zeroCounter > 1) {
                zeroes.push([i - zeroCounter, i - 1]);
              }
              zeroCounter = 0;
            }
          }
          if (zeroCounter > 1) {
            zeroes.push([
              this.parsedAddress.length - zeroCounter,
              this.parsedAddress.length - 1,
            ]);
          }
          const zeroLengths = zeroes.map((n) => n[1] - n[0] + 1);
          if (zeroes.length > 0) {
            const index = zeroLengths.indexOf(Math.max(...zeroLengths));
            groups = compact(this.parsedAddress, zeroes[index]);
          } else {
            groups = this.parsedAddress;
          }
          for (i = 0; i < groups.length; i++) {
            if (groups[i] !== "compact") {
              groups[i] = parseInt(groups[i], 16).toString(16);
            }
          }
          let correct = groups.join(":");
          correct = correct.replace(/^compact$/, "::");
          correct = correct.replace(/^compact|compact$/, ":");
          correct = correct.replace(/compact/, "");
          return correct;
        }
        binaryZeroPad() {
          return this.bigInteger().toString(2).padStart(constants6.BITS, "0");
        }
        parse4in6(address) {
          const groups = address.split(":");
          const lastGroup = groups.slice(-1)[0];
          const address4 = lastGroup.match(constants4.RE_ADDRESS);
          if (address4) {
            this.parsedAddress4 = address4[0];
            this.address4 = new ipv4_1.Address4(this.parsedAddress4);
            for (let i = 0; i < this.address4.groups; i++) {
              if (/^0[0-9]+/.test(this.address4.parsedAddress[i])) {
                throw new address_error_1.AddressError(
                  "IPv4 addresses can't have leading zeroes.",
                  address.replace(
                    constants4.RE_ADDRESS,
                    this.address4.parsedAddress
                      .map(spanLeadingZeroes4)
                      .join("."),
                  ),
                );
              }
            }
            this.v4 = true;
            groups[groups.length - 1] = this.address4.toGroup6();
            address = groups.join(":");
          }
          return address;
        }
        parse(address) {
          address = this.parse4in6(address);
          const badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
          if (badCharacters) {
            throw new address_error_1.AddressError(
              (0, sprintf_js_1.sprintf)(
                "Bad character%s detected in address: %s",
                badCharacters.length > 1 ? "s" : "",
                badCharacters.join(""),
              ),
              address.replace(
                constants6.RE_BAD_CHARACTERS,
                '<span class="parse-error">$1</span>',
              ),
            );
          }
          const badAddress = address.match(constants6.RE_BAD_ADDRESS);
          if (badAddress) {
            throw new address_error_1.AddressError(
              (0, sprintf_js_1.sprintf)(
                "Address failed regex: %s",
                badAddress.join(""),
              ),
              address.replace(
                constants6.RE_BAD_ADDRESS,
                '<span class="parse-error">$1</span>',
              ),
            );
          }
          let groups = [];
          const halves = address.split("::");
          if (halves.length === 2) {
            let first = halves[0].split(":");
            let last = halves[1].split(":");
            if (first.length === 1 && first[0] === "") {
              first = [];
            }
            if (last.length === 1 && last[0] === "") {
              last = [];
            }
            const remaining = this.groups - (first.length + last.length);
            if (!remaining) {
              throw new address_error_1.AddressError("Error parsing groups");
            }
            this.elidedGroups = remaining;
            this.elisionBegin = first.length;
            this.elisionEnd = first.length + this.elidedGroups;
            groups = groups.concat(first);
            for (let i = 0; i < remaining; i++) {
              groups.push("0");
            }
            groups = groups.concat(last);
          } else if (halves.length === 1) {
            groups = address.split(":");
            this.elidedGroups = 0;
          } else {
            throw new address_error_1.AddressError("Too many :: groups found");
          }
          groups = groups.map((group) =>
            (0, sprintf_js_1.sprintf)("%x", parseInt(group, 16)),
          );
          if (groups.length !== this.groups) {
            throw new address_error_1.AddressError(
              "Incorrect number of groups found",
            );
          }
          return groups;
        }
        canonicalForm() {
          return this.parsedAddress.map(paddedHex).join(":");
        }
        decimal() {
          return this.parsedAddress
            .map((n) => (0, sprintf_js_1.sprintf)("%05d", parseInt(n, 16)))
            .join(":");
        }
        bigInteger() {
          return new jsbn_1.BigInteger(
            this.parsedAddress.map(paddedHex).join(""),
            16,
          );
        }
        to4() {
          const binary = this.binaryZeroPad().split("");
          return ipv4_1.Address4.fromHex(
            new jsbn_1.BigInteger(binary.slice(96, 128).join(""), 2).toString(
              16,
            ),
          );
        }
        to4in6() {
          const address4 = this.to4();
          const address6 = new Address6(
            this.parsedAddress.slice(0, 6).join(":"),
            6,
          );
          const correct = address6.correctForm();
          let infix = "";
          if (!/:$/.test(correct)) {
            infix = ":";
          }
          return correct + infix + address4.address;
        }
        inspectTeredo() {
          const prefix = this.getBitsBase16(0, 32);
          const udpPort = this.getBits(80, 96)
            .xor(new jsbn_1.BigInteger("ffff", 16))
            .toString();
          const server4 = ipv4_1.Address4.fromHex(this.getBitsBase16(32, 64));
          const client4 = ipv4_1.Address4.fromHex(
            this.getBits(96, 128)
              .xor(new jsbn_1.BigInteger("ffffffff", 16))
              .toString(16),
          );
          const flags = this.getBits(64, 80);
          const flagsBase2 = this.getBitsBase2(64, 80);
          const coneNat = flags.testBit(15);
          const reserved = flags.testBit(14);
          const groupIndividual = flags.testBit(8);
          const universalLocal = flags.testBit(9);
          const nonce = new jsbn_1.BigInteger(
            flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16),
            2,
          ).toString(10);
          return {
            prefix: (0, sprintf_js_1.sprintf)(
              "%s:%s",
              prefix.slice(0, 4),
              prefix.slice(4, 8),
            ),
            server4: server4.address,
            client4: client4.address,
            flags: flagsBase2,
            coneNat,
            microsoft: { reserved, universalLocal, groupIndividual, nonce },
            udpPort,
          };
        }
        inspect6to4() {
          const prefix = this.getBitsBase16(0, 16);
          const gateway = ipv4_1.Address4.fromHex(this.getBitsBase16(16, 48));
          return {
            prefix: (0, sprintf_js_1.sprintf)("%s", prefix.slice(0, 4)),
            gateway: gateway.address,
          };
        }
        to6to4() {
          if (!this.is4()) {
            return null;
          }
          const addr6to4 = [
            "2002",
            this.getBitsBase16(96, 112),
            this.getBitsBase16(112, 128),
            "",
            "/16",
          ].join(":");
          return new Address6(addr6to4);
        }
        toByteArray() {
          const byteArray = this.bigInteger().toByteArray();
          if (byteArray.length === 17 && byteArray[0] === 0) {
            return byteArray.slice(1);
          }
          return byteArray;
        }
        toUnsignedByteArray() {
          return this.toByteArray().map(unsignByte);
        }
        static fromByteArray(bytes) {
          return this.fromUnsignedByteArray(bytes.map(unsignByte));
        }
        static fromUnsignedByteArray(bytes) {
          const BYTE_MAX = new jsbn_1.BigInteger("256", 10);
          let result = new jsbn_1.BigInteger("0", 10);
          let multiplier = new jsbn_1.BigInteger("1", 10);
          for (let i = bytes.length - 1; i >= 0; i--) {
            result = result.add(
              multiplier.multiply(
                new jsbn_1.BigInteger(bytes[i].toString(10), 10),
              ),
            );
            multiplier = multiplier.multiply(BYTE_MAX);
          }
          return Address6.fromBigInteger(result);
        }
        isCanonical() {
          return this.addressMinusSuffix === this.canonicalForm();
        }
        isLinkLocal() {
          if (
            this.getBitsBase2(0, 64) ===
            "1111111010000000000000000000000000000000000000000000000000000000"
          ) {
            return true;
          }
          return false;
        }
        isMulticast() {
          return this.getType() === "Multicast";
        }
        is4() {
          return this.v4;
        }
        isTeredo() {
          return this.isInSubnet(new Address6("2001::/32"));
        }
        is6to4() {
          return this.isInSubnet(new Address6("2002::/16"));
        }
        isLoopback() {
          return this.getType() === "Loopback";
        }
        href(optionalPort) {
          if (optionalPort === undefined) {
            optionalPort = "";
          } else {
            optionalPort = (0, sprintf_js_1.sprintf)(":%s", optionalPort);
          }
          return (0, sprintf_js_1.sprintf)(
            "http://[%s]%s/",
            this.correctForm(),
            optionalPort,
          );
        }
        link(options) {
          if (!options) {
            options = {};
          }
          if (options.className === undefined) {
            options.className = "";
          }
          if (options.prefix === undefined) {
            options.prefix = "/#address=";
          }
          if (options.v4 === undefined) {
            options.v4 = false;
          }
          let formFunction = this.correctForm;
          if (options.v4) {
            formFunction = this.to4in6;
          }
          if (options.className) {
            return (0, sprintf_js_1.sprintf)(
              '<a href="%1$s%2$s" class="%3$s">%2$s</a>',
              options.prefix,
              formFunction.call(this),
              options.className,
            );
          }
          return (0, sprintf_js_1.sprintf)(
            '<a href="%1$s%2$s">%2$s</a>',
            options.prefix,
            formFunction.call(this),
          );
        }
        group() {
          if (this.elidedGroups === 0) {
            return helpers.simpleGroup(this.address).join(":");
          }
          assert(typeof this.elidedGroups === "number");
          assert(typeof this.elisionBegin === "number");
          const output = [];
          const [left, right] = this.address.split("::");
          if (left.length) {
            output.push(...helpers.simpleGroup(left));
          } else {
            output.push("");
          }
          const classes = ["hover-group"];
          for (
            let i = this.elisionBegin;
            i < this.elisionBegin + this.elidedGroups;
            i++
          ) {
            classes.push((0, sprintf_js_1.sprintf)("group-%d", i));
          }
          output.push(
            (0, sprintf_js_1.sprintf)(
              '<span class="%s"></span>',
              classes.join(" "),
            ),
          );
          if (right.length) {
            output.push(...helpers.simpleGroup(right, this.elisionEnd));
          } else {
            output.push("");
          }
          if (this.is4()) {
            assert(this.address4 instanceof ipv4_1.Address4);
            output.pop();
            output.push(this.address4.groupForV6());
          }
          return output.join(":");
        }
        regularExpressionString(substringSearch = false) {
          let output = [];
          const address6 = new Address6(this.correctForm());
          if (address6.elidedGroups === 0) {
            output.push(
              (0, regular_expressions_1.simpleRegularExpression)(
                address6.parsedAddress,
              ),
            );
          } else if (address6.elidedGroups === constants6.GROUPS) {
            output.push(
              (0, regular_expressions_1.possibleElisions)(constants6.GROUPS),
            );
          } else {
            const halves = address6.address.split("::");
            if (halves[0].length) {
              output.push(
                (0, regular_expressions_1.simpleRegularExpression)(
                  halves[0].split(":"),
                ),
              );
            }
            assert(typeof address6.elidedGroups === "number");
            output.push(
              (0, regular_expressions_1.possibleElisions)(
                address6.elidedGroups,
                halves[0].length !== 0,
                halves[1].length !== 0,
              ),
            );
            if (halves[1].length) {
              output.push(
                (0, regular_expressions_1.simpleRegularExpression)(
                  halves[1].split(":"),
                ),
              );
            }
            output = [output.join(":")];
          }
          if (!substringSearch) {
            output = [
              "(?=^|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|[^\\w\\:])(",
              ...output,
              ")(?=[^\\w\\:]|",
              regular_expressions_1.ADDRESS_BOUNDARY,
              "|$)",
            ];
          }
          return output.join("");
        }
        regularExpression(substringSearch = false) {
          return new RegExp(this.regularExpressionString(substringSearch), "i");
        }
      }
      exports.Address6 = Address6;
    },
    6417: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RE_SUBNET_STRING =
        exports.RE_ADDRESS =
        exports.GROUPS =
        exports.BITS =
          void 0;
      exports.BITS = 32;
      exports.GROUPS = 4;
      exports.RE_ADDRESS =
        /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
      exports.RE_SUBNET_STRING = /\/\d{1,2}$/;
    },
    7674: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.RE_URL_WITH_PORT =
        exports.RE_URL =
        exports.RE_ZONE_STRING =
        exports.RE_SUBNET_STRING =
        exports.RE_BAD_ADDRESS =
        exports.RE_BAD_CHARACTERS =
        exports.TYPES =
        exports.SCOPES =
        exports.GROUPS =
        exports.BITS =
          void 0;
      exports.BITS = 128;
      exports.GROUPS = 8;
      exports.SCOPES = {
        0: "Reserved",
        1: "Interface local",
        2: "Link local",
        4: "Admin local",
        5: "Site local",
        8: "Organization local",
        14: "Global",
        15: "Reserved",
      };
      exports.TYPES = {
        "ff01::1/128": "Multicast (All nodes on this interface)",
        "ff01::2/128": "Multicast (All routers on this interface)",
        "ff02::1/128": "Multicast (All nodes on this link)",
        "ff02::2/128": "Multicast (All routers on this link)",
        "ff05::2/128": "Multicast (All routers in this site)",
        "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
        "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
        "ff02::9/128": "Multicast (RIP routers)",
        "ff02::a/128": "Multicast (EIGRP routers)",
        "ff02::d/128": "Multicast (PIM routers)",
        "ff02::16/128": "Multicast (MLDv2 reports)",
        "ff01::fb/128": "Multicast (mDNSv6)",
        "ff02::fb/128": "Multicast (mDNSv6)",
        "ff05::fb/128": "Multicast (mDNSv6)",
        "ff02::1:2/128":
          "Multicast (All DHCP servers and relay agents on this link)",
        "ff05::1:2/128":
          "Multicast (All DHCP servers and relay agents in this site)",
        "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
        "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
        "::/128": "Unspecified",
        "::1/128": "Loopback",
        "ff00::/8": "Multicast",
        "fe80::/10": "Link-local unicast",
      };
      exports.RE_BAD_CHARACTERS = /([^0-9a-f:/%])/gi;
      exports.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/gi;
      exports.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
      exports.RE_ZONE_STRING = /%.*$/;
      exports.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
      exports.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
    },
    945: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.simpleGroup =
        exports.spanLeadingZeroes =
        exports.spanAll =
        exports.spanAllZeroes =
          void 0;
      const sprintf_js_1 = __nccwpck_require__(3988);
      function spanAllZeroes(s) {
        return s.replace(/(0+)/g, '<span class="zero">$1</span>');
      }
      exports.spanAllZeroes = spanAllZeroes;
      function spanAll(s, offset = 0) {
        const letters = s.split("");
        return letters
          .map((n, i) =>
            (0, sprintf_js_1.sprintf)(
              '<span class="digit value-%s position-%d">%s</span>',
              n,
              i + offset,
              spanAllZeroes(n),
            ),
          )
          .join("");
      }
      exports.spanAll = spanAll;
      function spanLeadingZeroesSimple(group) {
        return group.replace(/^(0+)/, '<span class="zero">$1</span>');
      }
      function spanLeadingZeroes(address) {
        const groups = address.split(":");
        return groups.map((g) => spanLeadingZeroesSimple(g)).join(":");
      }
      exports.spanLeadingZeroes = spanLeadingZeroes;
      function simpleGroup(addressString, offset = 0) {
        const groups = addressString.split(":");
        return groups.map((g, i) => {
          if (/group-v4/.test(g)) {
            return g;
          }
          return (0, sprintf_js_1.sprintf)(
            '<span class="hover-group group-%d">%s</span>',
            i + offset,
            spanLeadingZeroesSimple(g),
          );
        });
      }
      exports.simpleGroup = simpleGroup;
    },
    6738: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.possibleElisions =
        exports.simpleRegularExpression =
        exports.ADDRESS_BOUNDARY =
        exports.padGroup =
        exports.groupPossibilities =
          void 0;
      const v6 = __importStar(__nccwpck_require__(7674));
      const sprintf_js_1 = __nccwpck_require__(3988);
      function groupPossibilities(possibilities) {
        return (0, sprintf_js_1.sprintf)("(%s)", possibilities.join("|"));
      }
      exports.groupPossibilities = groupPossibilities;
      function padGroup(group) {
        if (group.length < 4) {
          return (0, sprintf_js_1.sprintf)(
            "0{0,%d}%s",
            4 - group.length,
            group,
          );
        }
        return group;
      }
      exports.padGroup = padGroup;
      exports.ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
      function simpleRegularExpression(groups) {
        const zeroIndexes = [];
        groups.forEach((group, i) => {
          const groupInteger = parseInt(group, 16);
          if (groupInteger === 0) {
            zeroIndexes.push(i);
          }
        });
        const possibilities = zeroIndexes.map((zeroIndex) =>
          groups
            .map((group, i) => {
              if (i === zeroIndex) {
                const elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
                return groupPossibilities([padGroup(group), elision]);
              }
              return padGroup(group);
            })
            .join(":"),
        );
        possibilities.push(groups.map(padGroup).join(":"));
        return groupPossibilities(possibilities);
      }
      exports.simpleRegularExpression = simpleRegularExpression;
      function possibleElisions(elidedGroups, moreLeft, moreRight) {
        const left = moreLeft ? "" : ":";
        const right = moreRight ? "" : ":";
        const possibilities = [];
        if (!moreLeft && !moreRight) {
          possibilities.push("::");
        }
        if (moreLeft && moreRight) {
          possibilities.push("");
        }
        if ((moreRight && !moreLeft) || (!moreRight && moreLeft)) {
          possibilities.push(":");
        }
        possibilities.push(
          (0, sprintf_js_1.sprintf)(
            "%s(:0{1,4}){1,%d}",
            left,
            elidedGroups - 1,
          ),
        );
        possibilities.push(
          (0, sprintf_js_1.sprintf)(
            "(0{1,4}:){1,%d}%s",
            elidedGroups - 1,
            right,
          ),
        );
        possibilities.push(
          (0, sprintf_js_1.sprintf)("(0{1,4}:){%d}0{1,4}", elidedGroups - 1),
        );
        for (let groups = 1; groups < elidedGroups - 1; groups++) {
          for (let position = 1; position < elidedGroups - groups; position++) {
            possibilities.push(
              (0, sprintf_js_1.sprintf)(
                "(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}",
                position,
                elidedGroups - position - groups - 1,
              ),
            );
          }
        }
        return groupPossibilities(possibilities);
      }
      exports.possibleElisions = possibleElisions;
    },
    5587: function (module, exports) {
      (function () {
        var dbits;
        var canary = 0xdeadbeefcafe;
        var j_lm = (canary & 16777215) == 15715070;
        function BigInteger(a, b, c) {
          if (a != null)
            if ("number" == typeof a) this.fromNumber(a, b, c);
            else if (b == null && "string" != typeof a) this.fromString(a, 256);
            else this.fromString(a, b);
        }
        function nbi() {
          return new BigInteger(null);
        }
        function am1(i, x, w, j, c, n) {
          while (--n >= 0) {
            var v = x * this[i++] + w[j] + c;
            c = Math.floor(v / 67108864);
            w[j++] = v & 67108863;
          }
          return c;
        }
        function am2(i, x, w, j, c, n) {
          var xl = x & 32767,
            xh = x >> 15;
          while (--n >= 0) {
            var l = this[i] & 32767;
            var h = this[i++] >> 15;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
            c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
            w[j++] = l & 1073741823;
          }
          return c;
        }
        function am3(i, x, w, j, c, n) {
          var xl = x & 16383,
            xh = x >> 14;
          while (--n >= 0) {
            var l = this[i] & 16383;
            var h = this[i++] >> 14;
            var m = xh * l + h * xl;
            l = xl * l + ((m & 16383) << 14) + w[j] + c;
            c = (l >> 28) + (m >> 14) + xh * h;
            w[j++] = l & 268435455;
          }
          return c;
        }
        var inBrowser = typeof navigator !== "undefined";
        if (
          inBrowser &&
          j_lm &&
          navigator.appName == "Microsoft Internet Explorer"
        ) {
          BigInteger.prototype.am = am2;
          dbits = 30;
        } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
          BigInteger.prototype.am = am1;
          dbits = 26;
        } else {
          BigInteger.prototype.am = am3;
          dbits = 28;
        }
        BigInteger.prototype.DB = dbits;
        BigInteger.prototype.DM = (1 << dbits) - 1;
        BigInteger.prototype.DV = 1 << dbits;
        var BI_FP = 52;
        BigInteger.prototype.FV = Math.pow(2, BI_FP);
        BigInteger.prototype.F1 = BI_FP - dbits;
        BigInteger.prototype.F2 = 2 * dbits - BI_FP;
        var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
        var BI_RC = new Array();
        var rr, vv;
        rr = "0".charCodeAt(0);
        for (vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
        rr = "a".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        rr = "A".charCodeAt(0);
        for (vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
        function int2char(n) {
          return BI_RM.charAt(n);
        }
        function intAt(s, i) {
          var c = BI_RC[s.charCodeAt(i)];
          return c == null ? -1 : c;
        }
        function bnpCopyTo(r) {
          for (var i = this.t - 1; i >= 0; --i) r[i] = this[i];
          r.t = this.t;
          r.s = this.s;
        }
        function bnpFromInt(x) {
          this.t = 1;
          this.s = x < 0 ? -1 : 0;
          if (x > 0) this[0] = x;
          else if (x < -1) this[0] = x + this.DV;
          else this.t = 0;
        }
        function nbv(i) {
          var r = nbi();
          r.fromInt(i);
          return r;
        }
        function bnpFromString(s, b) {
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 256) k = 8;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else {
            this.fromRadix(s, b);
            return;
          }
          this.t = 0;
          this.s = 0;
          var i = s.length,
            mi = false,
            sh = 0;
          while (--i >= 0) {
            var x = k == 8 ? s[i] & 255 : intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-") mi = true;
              continue;
            }
            mi = false;
            if (sh == 0) this[this.t++] = x;
            else if (sh + k > this.DB) {
              this[this.t - 1] |= (x & ((1 << (this.DB - sh)) - 1)) << sh;
              this[this.t++] = x >> (this.DB - sh);
            } else this[this.t - 1] |= x << sh;
            sh += k;
            if (sh >= this.DB) sh -= this.DB;
          }
          if (k == 8 && (s[0] & 128) != 0) {
            this.s = -1;
            if (sh > 0) this[this.t - 1] |= ((1 << (this.DB - sh)) - 1) << sh;
          }
          this.clamp();
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpClamp() {
          var c = this.s & this.DM;
          while (this.t > 0 && this[this.t - 1] == c) --this.t;
        }
        function bnToString(b) {
          if (this.s < 0) return "-" + this.negate().toString(b);
          var k;
          if (b == 16) k = 4;
          else if (b == 8) k = 3;
          else if (b == 2) k = 1;
          else if (b == 32) k = 5;
          else if (b == 4) k = 2;
          else return this.toRadix(b);
          var km = (1 << k) - 1,
            d,
            m = false,
            r = "",
            i = this.t;
          var p = this.DB - ((i * this.DB) % k);
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) > 0) {
              m = true;
              r = int2char(d);
            }
            while (i >= 0) {
              if (p < k) {
                d = (this[i] & ((1 << p) - 1)) << (k - p);
                d |= this[--i] >> (p += this.DB - k);
              } else {
                d = (this[i] >> (p -= k)) & km;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if (d > 0) m = true;
              if (m) r += int2char(d);
            }
          }
          return m ? r : "0";
        }
        function bnNegate() {
          var r = nbi();
          BigInteger.ZERO.subTo(this, r);
          return r;
        }
        function bnAbs() {
          return this.s < 0 ? this.negate() : this;
        }
        function bnCompareTo(a) {
          var r = this.s - a.s;
          if (r != 0) return r;
          var i = this.t;
          r = i - a.t;
          if (r != 0) return this.s < 0 ? -r : r;
          while (--i >= 0) if ((r = this[i] - a[i]) != 0) return r;
          return 0;
        }
        function nbits(x) {
          var r = 1,
            t;
          if ((t = x >>> 16) != 0) {
            x = t;
            r += 16;
          }
          if ((t = x >> 8) != 0) {
            x = t;
            r += 8;
          }
          if ((t = x >> 4) != 0) {
            x = t;
            r += 4;
          }
          if ((t = x >> 2) != 0) {
            x = t;
            r += 2;
          }
          if ((t = x >> 1) != 0) {
            x = t;
            r += 1;
          }
          return r;
        }
        function bnBitLength() {
          if (this.t <= 0) return 0;
          return (
            this.DB * (this.t - 1) +
            nbits(this[this.t - 1] ^ (this.s & this.DM))
          );
        }
        function bnpDLShiftTo(n, r) {
          var i;
          for (i = this.t - 1; i >= 0; --i) r[i + n] = this[i];
          for (i = n - 1; i >= 0; --i) r[i] = 0;
          r.t = this.t + n;
          r.s = this.s;
        }
        function bnpDRShiftTo(n, r) {
          for (var i = n; i < this.t; ++i) r[i - n] = this[i];
          r.t = Math.max(this.t - n, 0);
          r.s = this.s;
        }
        function bnpLShiftTo(n, r) {
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << cbs) - 1;
          var ds = Math.floor(n / this.DB),
            c = (this.s << bs) & this.DM,
            i;
          for (i = this.t - 1; i >= 0; --i) {
            r[i + ds + 1] = (this[i] >> cbs) | c;
            c = (this[i] & bm) << bs;
          }
          for (i = ds - 1; i >= 0; --i) r[i] = 0;
          r[ds] = c;
          r.t = this.t + ds + 1;
          r.s = this.s;
          r.clamp();
        }
        function bnpRShiftTo(n, r) {
          r.s = this.s;
          var ds = Math.floor(n / this.DB);
          if (ds >= this.t) {
            r.t = 0;
            return;
          }
          var bs = n % this.DB;
          var cbs = this.DB - bs;
          var bm = (1 << bs) - 1;
          r[0] = this[ds] >> bs;
          for (var i = ds + 1; i < this.t; ++i) {
            r[i - ds - 1] |= (this[i] & bm) << cbs;
            r[i - ds] = this[i] >> bs;
          }
          if (bs > 0) r[this.t - ds - 1] |= (this.s & bm) << cbs;
          r.t = this.t - ds;
          r.clamp();
        }
        function bnpSubTo(a, r) {
          var i = 0,
            c = 0,
            m = Math.min(a.t, this.t);
          while (i < m) {
            c += this[i] - a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c -= a.s;
            while (i < this.t) {
              c += this[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c -= a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c -= a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c < -1) r[i++] = this.DV + c;
          else if (c > 0) r[i++] = c;
          r.t = i;
          r.clamp();
        }
        function bnpMultiplyTo(a, r) {
          var x = this.abs(),
            y = a.abs();
          var i = x.t;
          r.t = i + y.t;
          while (--i >= 0) r[i] = 0;
          for (i = 0; i < y.t; ++i) r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
          r.s = 0;
          r.clamp();
          if (this.s != a.s) BigInteger.ZERO.subTo(r, r);
        }
        function bnpSquareTo(r) {
          var x = this.abs();
          var i = (r.t = 2 * x.t);
          while (--i >= 0) r[i] = 0;
          for (i = 0; i < x.t - 1; ++i) {
            var c = x.am(i, x[i], r, 2 * i, 0, 1);
            if (
              (r[i + x.t] += x.am(
                i + 1,
                2 * x[i],
                r,
                2 * i + 1,
                c,
                x.t - i - 1,
              )) >= x.DV
            ) {
              r[i + x.t] -= x.DV;
              r[i + x.t + 1] = 1;
            }
          }
          if (r.t > 0) r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
          r.s = 0;
          r.clamp();
        }
        function bnpDivRemTo(m, q, r) {
          var pm = m.abs();
          if (pm.t <= 0) return;
          var pt = this.abs();
          if (pt.t < pm.t) {
            if (q != null) q.fromInt(0);
            if (r != null) this.copyTo(r);
            return;
          }
          if (r == null) r = nbi();
          var y = nbi(),
            ts = this.s,
            ms = m.s;
          var nsh = this.DB - nbits(pm[pm.t - 1]);
          if (nsh > 0) {
            pm.lShiftTo(nsh, y);
            pt.lShiftTo(nsh, r);
          } else {
            pm.copyTo(y);
            pt.copyTo(r);
          }
          var ys = y.t;
          var y0 = y[ys - 1];
          if (y0 == 0) return;
          var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
          var d1 = this.FV / yt,
            d2 = (1 << this.F1) / yt,
            e = 1 << this.F2;
          var i = r.t,
            j = i - ys,
            t = q == null ? nbi() : q;
          y.dlShiftTo(j, t);
          if (r.compareTo(t) >= 0) {
            r[r.t++] = 1;
            r.subTo(t, r);
          }
          BigInteger.ONE.dlShiftTo(ys, t);
          t.subTo(y, y);
          while (y.t < ys) y[y.t++] = 0;
          while (--j >= 0) {
            var qd =
              r[--i] == y0
                ? this.DM
                : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
            if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
              y.dlShiftTo(j, t);
              r.subTo(t, r);
              while (r[i] < --qd) r.subTo(t, r);
            }
          }
          if (q != null) {
            r.drShiftTo(ys, q);
            if (ts != ms) BigInteger.ZERO.subTo(q, q);
          }
          r.t = ys;
          r.clamp();
          if (nsh > 0) r.rShiftTo(nsh, r);
          if (ts < 0) BigInteger.ZERO.subTo(r, r);
        }
        function bnMod(a) {
          var r = nbi();
          this.abs().divRemTo(a, null, r);
          if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r, r);
          return r;
        }
        function Classic(m) {
          this.m = m;
        }
        function cConvert(x) {
          if (x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
          else return x;
        }
        function cRevert(x) {
          return x;
        }
        function cReduce(x) {
          x.divRemTo(this.m, null, x);
        }
        function cMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        function cSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        Classic.prototype.convert = cConvert;
        Classic.prototype.revert = cRevert;
        Classic.prototype.reduce = cReduce;
        Classic.prototype.mulTo = cMulTo;
        Classic.prototype.sqrTo = cSqrTo;
        function bnpInvDigit() {
          if (this.t < 1) return 0;
          var x = this[0];
          if ((x & 1) == 0) return 0;
          var y = x & 3;
          y = (y * (2 - (x & 15) * y)) & 15;
          y = (y * (2 - (x & 255) * y)) & 255;
          y = (y * (2 - (((x & 65535) * y) & 65535))) & 65535;
          y = (y * (2 - ((x * y) % this.DV))) % this.DV;
          return y > 0 ? this.DV - y : -y;
        }
        function Montgomery(m) {
          this.m = m;
          this.mp = m.invDigit();
          this.mpl = this.mp & 32767;
          this.mph = this.mp >> 15;
          this.um = (1 << (m.DB - 15)) - 1;
          this.mt2 = 2 * m.t;
        }
        function montConvert(x) {
          var r = nbi();
          x.abs().dlShiftTo(this.m.t, r);
          r.divRemTo(this.m, null, r);
          if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r, r);
          return r;
        }
        function montRevert(x) {
          var r = nbi();
          x.copyTo(r);
          this.reduce(r);
          return r;
        }
        function montReduce(x) {
          while (x.t <= this.mt2) x[x.t++] = 0;
          for (var i = 0; i < this.m.t; ++i) {
            var j = x[i] & 32767;
            var u0 =
              (j * this.mpl +
                (((j * this.mph + (x[i] >> 15) * this.mpl) & this.um) << 15)) &
              x.DM;
            j = i + this.m.t;
            x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
            while (x[j] >= x.DV) {
              x[j] -= x.DV;
              x[++j]++;
            }
          }
          x.clamp();
          x.drShiftTo(this.m.t, x);
          if (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function montSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function montMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Montgomery.prototype.convert = montConvert;
        Montgomery.prototype.revert = montRevert;
        Montgomery.prototype.reduce = montReduce;
        Montgomery.prototype.mulTo = montMulTo;
        Montgomery.prototype.sqrTo = montSqrTo;
        function bnpIsEven() {
          return (this.t > 0 ? this[0] & 1 : this.s) == 0;
        }
        function bnpExp(e, z) {
          if (e > 4294967295 || e < 1) return BigInteger.ONE;
          var r = nbi(),
            r2 = nbi(),
            g = z.convert(this),
            i = nbits(e) - 1;
          g.copyTo(r);
          while (--i >= 0) {
            z.sqrTo(r, r2);
            if ((e & (1 << i)) > 0) z.mulTo(r2, g, r);
            else {
              var t = r;
              r = r2;
              r2 = t;
            }
          }
          return z.revert(r);
        }
        function bnModPowInt(e, m) {
          var z;
          if (e < 256 || m.isEven()) z = new Classic(m);
          else z = new Montgomery(m);
          return this.exp(e, z);
        }
        BigInteger.prototype.copyTo = bnpCopyTo;
        BigInteger.prototype.fromInt = bnpFromInt;
        BigInteger.prototype.fromString = bnpFromString;
        BigInteger.prototype.clamp = bnpClamp;
        BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
        BigInteger.prototype.drShiftTo = bnpDRShiftTo;
        BigInteger.prototype.lShiftTo = bnpLShiftTo;
        BigInteger.prototype.rShiftTo = bnpRShiftTo;
        BigInteger.prototype.subTo = bnpSubTo;
        BigInteger.prototype.multiplyTo = bnpMultiplyTo;
        BigInteger.prototype.squareTo = bnpSquareTo;
        BigInteger.prototype.divRemTo = bnpDivRemTo;
        BigInteger.prototype.invDigit = bnpInvDigit;
        BigInteger.prototype.isEven = bnpIsEven;
        BigInteger.prototype.exp = bnpExp;
        BigInteger.prototype.toString = bnToString;
        BigInteger.prototype.negate = bnNegate;
        BigInteger.prototype.abs = bnAbs;
        BigInteger.prototype.compareTo = bnCompareTo;
        BigInteger.prototype.bitLength = bnBitLength;
        BigInteger.prototype.mod = bnMod;
        BigInteger.prototype.modPowInt = bnModPowInt;
        BigInteger.ZERO = nbv(0);
        BigInteger.ONE = nbv(1);
        function bnClone() {
          var r = nbi();
          this.copyTo(r);
          return r;
        }
        function bnIntValue() {
          if (this.s < 0) {
            if (this.t == 1) return this[0] - this.DV;
            else if (this.t == 0) return -1;
          } else if (this.t == 1) return this[0];
          else if (this.t == 0) return 0;
          return ((this[1] & ((1 << (32 - this.DB)) - 1)) << this.DB) | this[0];
        }
        function bnByteValue() {
          return this.t == 0 ? this.s : (this[0] << 24) >> 24;
        }
        function bnShortValue() {
          return this.t == 0 ? this.s : (this[0] << 16) >> 16;
        }
        function bnpChunkSize(r) {
          return Math.floor((Math.LN2 * this.DB) / Math.log(r));
        }
        function bnSigNum() {
          if (this.s < 0) return -1;
          else if (this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
          else return 1;
        }
        function bnpToRadix(b) {
          if (b == null) b = 10;
          if (this.signum() == 0 || b < 2 || b > 36) return "0";
          var cs = this.chunkSize(b);
          var a = Math.pow(b, cs);
          var d = nbv(a),
            y = nbi(),
            z = nbi(),
            r = "";
          this.divRemTo(d, y, z);
          while (y.signum() > 0) {
            r = (a + z.intValue()).toString(b).substr(1) + r;
            y.divRemTo(d, y, z);
          }
          return z.intValue().toString(b) + r;
        }
        function bnpFromRadix(s, b) {
          this.fromInt(0);
          if (b == null) b = 10;
          var cs = this.chunkSize(b);
          var d = Math.pow(b, cs),
            mi = false,
            j = 0,
            w = 0;
          for (var i = 0; i < s.length; ++i) {
            var x = intAt(s, i);
            if (x < 0) {
              if (s.charAt(i) == "-" && this.signum() == 0) mi = true;
              continue;
            }
            w = b * w + x;
            if (++j >= cs) {
              this.dMultiply(d);
              this.dAddOffset(w, 0);
              j = 0;
              w = 0;
            }
          }
          if (j > 0) {
            this.dMultiply(Math.pow(b, j));
            this.dAddOffset(w, 0);
          }
          if (mi) BigInteger.ZERO.subTo(this, this);
        }
        function bnpFromNumber(a, b, c) {
          if ("number" == typeof b) {
            if (a < 2) this.fromInt(1);
            else {
              this.fromNumber(a, c);
              if (!this.testBit(a - 1))
                this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
              if (this.isEven()) this.dAddOffset(1, 0);
              while (!this.isProbablePrime(b)) {
                this.dAddOffset(2, 0);
                if (this.bitLength() > a)
                  this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
              }
            }
          } else {
            var x = new Array(),
              t = a & 7;
            x.length = (a >> 3) + 1;
            b.nextBytes(x);
            if (t > 0) x[0] &= (1 << t) - 1;
            else x[0] = 0;
            this.fromString(x, 256);
          }
        }
        function bnToByteArray() {
          var i = this.t,
            r = new Array();
          r[0] = this.s;
          var p = this.DB - ((i * this.DB) % 8),
            d,
            k = 0;
          if (i-- > 0) {
            if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
              r[k++] = d | (this.s << (this.DB - p));
            while (i >= 0) {
              if (p < 8) {
                d = (this[i] & ((1 << p) - 1)) << (8 - p);
                d |= this[--i] >> (p += this.DB - 8);
              } else {
                d = (this[i] >> (p -= 8)) & 255;
                if (p <= 0) {
                  p += this.DB;
                  --i;
                }
              }
              if ((d & 128) != 0) d |= -256;
              if (k == 0 && (this.s & 128) != (d & 128)) ++k;
              if (k > 0 || d != this.s) r[k++] = d;
            }
          }
          return r;
        }
        function bnEquals(a) {
          return this.compareTo(a) == 0;
        }
        function bnMin(a) {
          return this.compareTo(a) < 0 ? this : a;
        }
        function bnMax(a) {
          return this.compareTo(a) > 0 ? this : a;
        }
        function bnpBitwiseTo(a, op, r) {
          var i,
            f,
            m = Math.min(a.t, this.t);
          for (i = 0; i < m; ++i) r[i] = op(this[i], a[i]);
          if (a.t < this.t) {
            f = a.s & this.DM;
            for (i = m; i < this.t; ++i) r[i] = op(this[i], f);
            r.t = this.t;
          } else {
            f = this.s & this.DM;
            for (i = m; i < a.t; ++i) r[i] = op(f, a[i]);
            r.t = a.t;
          }
          r.s = op(this.s, a.s);
          r.clamp();
        }
        function op_and(x, y) {
          return x & y;
        }
        function bnAnd(a) {
          var r = nbi();
          this.bitwiseTo(a, op_and, r);
          return r;
        }
        function op_or(x, y) {
          return x | y;
        }
        function bnOr(a) {
          var r = nbi();
          this.bitwiseTo(a, op_or, r);
          return r;
        }
        function op_xor(x, y) {
          return x ^ y;
        }
        function bnXor(a) {
          var r = nbi();
          this.bitwiseTo(a, op_xor, r);
          return r;
        }
        function op_andnot(x, y) {
          return x & ~y;
        }
        function bnAndNot(a) {
          var r = nbi();
          this.bitwiseTo(a, op_andnot, r);
          return r;
        }
        function bnNot() {
          var r = nbi();
          for (var i = 0; i < this.t; ++i) r[i] = this.DM & ~this[i];
          r.t = this.t;
          r.s = ~this.s;
          return r;
        }
        function bnShiftLeft(n) {
          var r = nbi();
          if (n < 0) this.rShiftTo(-n, r);
          else this.lShiftTo(n, r);
          return r;
        }
        function bnShiftRight(n) {
          var r = nbi();
          if (n < 0) this.lShiftTo(-n, r);
          else this.rShiftTo(n, r);
          return r;
        }
        function lbit(x) {
          if (x == 0) return -1;
          var r = 0;
          if ((x & 65535) == 0) {
            x >>= 16;
            r += 16;
          }
          if ((x & 255) == 0) {
            x >>= 8;
            r += 8;
          }
          if ((x & 15) == 0) {
            x >>= 4;
            r += 4;
          }
          if ((x & 3) == 0) {
            x >>= 2;
            r += 2;
          }
          if ((x & 1) == 0) ++r;
          return r;
        }
        function bnGetLowestSetBit() {
          for (var i = 0; i < this.t; ++i)
            if (this[i] != 0) return i * this.DB + lbit(this[i]);
          if (this.s < 0) return this.t * this.DB;
          return -1;
        }
        function cbit(x) {
          var r = 0;
          while (x != 0) {
            x &= x - 1;
            ++r;
          }
          return r;
        }
        function bnBitCount() {
          var r = 0,
            x = this.s & this.DM;
          for (var i = 0; i < this.t; ++i) r += cbit(this[i] ^ x);
          return r;
        }
        function bnTestBit(n) {
          var j = Math.floor(n / this.DB);
          if (j >= this.t) return this.s != 0;
          return (this[j] & (1 << n % this.DB)) != 0;
        }
        function bnpChangeBit(n, op) {
          var r = BigInteger.ONE.shiftLeft(n);
          this.bitwiseTo(r, op, r);
          return r;
        }
        function bnSetBit(n) {
          return this.changeBit(n, op_or);
        }
        function bnClearBit(n) {
          return this.changeBit(n, op_andnot);
        }
        function bnFlipBit(n) {
          return this.changeBit(n, op_xor);
        }
        function bnpAddTo(a, r) {
          var i = 0,
            c = 0,
            m = Math.min(a.t, this.t);
          while (i < m) {
            c += this[i] + a[i];
            r[i++] = c & this.DM;
            c >>= this.DB;
          }
          if (a.t < this.t) {
            c += a.s;
            while (i < this.t) {
              c += this[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += this.s;
          } else {
            c += this.s;
            while (i < a.t) {
              c += a[i];
              r[i++] = c & this.DM;
              c >>= this.DB;
            }
            c += a.s;
          }
          r.s = c < 0 ? -1 : 0;
          if (c > 0) r[i++] = c;
          else if (c < -1) r[i++] = this.DV + c;
          r.t = i;
          r.clamp();
        }
        function bnAdd(a) {
          var r = nbi();
          this.addTo(a, r);
          return r;
        }
        function bnSubtract(a) {
          var r = nbi();
          this.subTo(a, r);
          return r;
        }
        function bnMultiply(a) {
          var r = nbi();
          this.multiplyTo(a, r);
          return r;
        }
        function bnSquare() {
          var r = nbi();
          this.squareTo(r);
          return r;
        }
        function bnDivide(a) {
          var r = nbi();
          this.divRemTo(a, r, null);
          return r;
        }
        function bnRemainder(a) {
          var r = nbi();
          this.divRemTo(a, null, r);
          return r;
        }
        function bnDivideAndRemainder(a) {
          var q = nbi(),
            r = nbi();
          this.divRemTo(a, q, r);
          return new Array(q, r);
        }
        function bnpDMultiply(n) {
          this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
          ++this.t;
          this.clamp();
        }
        function bnpDAddOffset(n, w) {
          if (n == 0) return;
          while (this.t <= w) this[this.t++] = 0;
          this[w] += n;
          while (this[w] >= this.DV) {
            this[w] -= this.DV;
            if (++w >= this.t) this[this.t++] = 0;
            ++this[w];
          }
        }
        function NullExp() {}
        function nNop(x) {
          return x;
        }
        function nMulTo(x, y, r) {
          x.multiplyTo(y, r);
        }
        function nSqrTo(x, r) {
          x.squareTo(r);
        }
        NullExp.prototype.convert = nNop;
        NullExp.prototype.revert = nNop;
        NullExp.prototype.mulTo = nMulTo;
        NullExp.prototype.sqrTo = nSqrTo;
        function bnPow(e) {
          return this.exp(e, new NullExp());
        }
        function bnpMultiplyLowerTo(a, n, r) {
          var i = Math.min(this.t + a.t, n);
          r.s = 0;
          r.t = i;
          while (i > 0) r[--i] = 0;
          var j;
          for (j = r.t - this.t; i < j; ++i)
            r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
          for (j = Math.min(a.t, n); i < j; ++i)
            this.am(0, a[i], r, i, 0, n - i);
          r.clamp();
        }
        function bnpMultiplyUpperTo(a, n, r) {
          --n;
          var i = (r.t = this.t + a.t - n);
          r.s = 0;
          while (--i >= 0) r[i] = 0;
          for (i = Math.max(n - this.t, 0); i < a.t; ++i)
            r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
          r.clamp();
          r.drShiftTo(1, r);
        }
        function Barrett(m) {
          this.r2 = nbi();
          this.q3 = nbi();
          BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
          this.mu = this.r2.divide(m);
          this.m = m;
        }
        function barrettConvert(x) {
          if (x.s < 0 || x.t > 2 * this.m.t) return x.mod(this.m);
          else if (x.compareTo(this.m) < 0) return x;
          else {
            var r = nbi();
            x.copyTo(r);
            this.reduce(r);
            return r;
          }
        }
        function barrettRevert(x) {
          return x;
        }
        function barrettReduce(x) {
          x.drShiftTo(this.m.t - 1, this.r2);
          if (x.t > this.m.t + 1) {
            x.t = this.m.t + 1;
            x.clamp();
          }
          this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
          this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
          while (x.compareTo(this.r2) < 0) x.dAddOffset(1, this.m.t + 1);
          x.subTo(this.r2, x);
          while (x.compareTo(this.m) >= 0) x.subTo(this.m, x);
        }
        function barrettSqrTo(x, r) {
          x.squareTo(r);
          this.reduce(r);
        }
        function barrettMulTo(x, y, r) {
          x.multiplyTo(y, r);
          this.reduce(r);
        }
        Barrett.prototype.convert = barrettConvert;
        Barrett.prototype.revert = barrettRevert;
        Barrett.prototype.reduce = barrettReduce;
        Barrett.prototype.mulTo = barrettMulTo;
        Barrett.prototype.sqrTo = barrettSqrTo;
        function bnModPow(e, m) {
          var i = e.bitLength(),
            k,
            r = nbv(1),
            z;
          if (i <= 0) return r;
          else if (i < 18) k = 1;
          else if (i < 48) k = 3;
          else if (i < 144) k = 4;
          else if (i < 768) k = 5;
          else k = 6;
          if (i < 8) z = new Classic(m);
          else if (m.isEven()) z = new Barrett(m);
          else z = new Montgomery(m);
          var g = new Array(),
            n = 3,
            k1 = k - 1,
            km = (1 << k) - 1;
          g[1] = z.convert(this);
          if (k > 1) {
            var g2 = nbi();
            z.sqrTo(g[1], g2);
            while (n <= km) {
              g[n] = nbi();
              z.mulTo(g2, g[n - 2], g[n]);
              n += 2;
            }
          }
          var j = e.t - 1,
            w,
            is1 = true,
            r2 = nbi(),
            t;
          i = nbits(e[j]) - 1;
          while (j >= 0) {
            if (i >= k1) w = (e[j] >> (i - k1)) & km;
            else {
              w = (e[j] & ((1 << (i + 1)) - 1)) << (k1 - i);
              if (j > 0) w |= e[j - 1] >> (this.DB + i - k1);
            }
            n = k;
            while ((w & 1) == 0) {
              w >>= 1;
              --n;
            }
            if ((i -= n) < 0) {
              i += this.DB;
              --j;
            }
            if (is1) {
              g[w].copyTo(r);
              is1 = false;
            } else {
              while (n > 1) {
                z.sqrTo(r, r2);
                z.sqrTo(r2, r);
                n -= 2;
              }
              if (n > 0) z.sqrTo(r, r2);
              else {
                t = r;
                r = r2;
                r2 = t;
              }
              z.mulTo(r2, g[w], r);
            }
            while (j >= 0 && (e[j] & (1 << i)) == 0) {
              z.sqrTo(r, r2);
              t = r;
              r = r2;
              r2 = t;
              if (--i < 0) {
                i = this.DB - 1;
                --j;
              }
            }
          }
          return z.revert(r);
        }
        function bnGCD(a) {
          var x = this.s < 0 ? this.negate() : this.clone();
          var y = a.s < 0 ? a.negate() : a.clone();
          if (x.compareTo(y) < 0) {
            var t = x;
            x = y;
            y = t;
          }
          var i = x.getLowestSetBit(),
            g = y.getLowestSetBit();
          if (g < 0) return x;
          if (i < g) g = i;
          if (g > 0) {
            x.rShiftTo(g, x);
            y.rShiftTo(g, y);
          }
          while (x.signum() > 0) {
            if ((i = x.getLowestSetBit()) > 0) x.rShiftTo(i, x);
            if ((i = y.getLowestSetBit()) > 0) y.rShiftTo(i, y);
            if (x.compareTo(y) >= 0) {
              x.subTo(y, x);
              x.rShiftTo(1, x);
            } else {
              y.subTo(x, y);
              y.rShiftTo(1, y);
            }
          }
          if (g > 0) y.lShiftTo(g, y);
          return y;
        }
        function bnpModInt(n) {
          if (n <= 0) return 0;
          var d = this.DV % n,
            r = this.s < 0 ? n - 1 : 0;
          if (this.t > 0)
            if (d == 0) r = this[0] % n;
            else
              for (var i = this.t - 1; i >= 0; --i) r = (d * r + this[i]) % n;
          return r;
        }
        function bnModInverse(m) {
          var ac = m.isEven();
          if ((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
          var u = m.clone(),
            v = this.clone();
          var a = nbv(1),
            b = nbv(0),
            c = nbv(0),
            d = nbv(1);
          while (u.signum() != 0) {
            while (u.isEven()) {
              u.rShiftTo(1, u);
              if (ac) {
                if (!a.isEven() || !b.isEven()) {
                  a.addTo(this, a);
                  b.subTo(m, b);
                }
                a.rShiftTo(1, a);
              } else if (!b.isEven()) b.subTo(m, b);
              b.rShiftTo(1, b);
            }
            while (v.isEven()) {
              v.rShiftTo(1, v);
              if (ac) {
                if (!c.isEven() || !d.isEven()) {
                  c.addTo(this, c);
                  d.subTo(m, d);
                }
                c.rShiftTo(1, c);
              } else if (!d.isEven()) d.subTo(m, d);
              d.rShiftTo(1, d);
            }
            if (u.compareTo(v) >= 0) {
              u.subTo(v, u);
              if (ac) a.subTo(c, a);
              b.subTo(d, b);
            } else {
              v.subTo(u, v);
              if (ac) c.subTo(a, c);
              d.subTo(b, d);
            }
          }
          if (v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
          if (d.compareTo(m) >= 0) return d.subtract(m);
          if (d.signum() < 0) d.addTo(m, d);
          else return d;
          if (d.signum() < 0) return d.add(m);
          else return d;
        }
        var lowprimes = [
          2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61,
          67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137,
          139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211,
          223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283,
          293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379,
          383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461,
          463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563,
          569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643,
          647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739,
          743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829,
          839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937,
          941, 947, 953, 967, 971, 977, 983, 991, 997,
        ];
        var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
        function bnIsProbablePrime(t) {
          var i,
            x = this.abs();
          if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
            for (i = 0; i < lowprimes.length; ++i)
              if (x[0] == lowprimes[i]) return true;
            return false;
          }
          if (x.isEven()) return false;
          i = 1;
          while (i < lowprimes.length) {
            var m = lowprimes[i],
              j = i + 1;
            while (j < lowprimes.length && m < lplim) m *= lowprimes[j++];
            m = x.modInt(m);
            while (i < j) if (m % lowprimes[i++] == 0) return false;
          }
          return x.millerRabin(t);
        }
        function bnpMillerRabin(t) {
          var n1 = this.subtract(BigInteger.ONE);
          var k = n1.getLowestSetBit();
          if (k <= 0) return false;
          var r = n1.shiftRight(k);
          t = (t + 1) >> 1;
          if (t > lowprimes.length) t = lowprimes.length;
          var a = nbi();
          for (var i = 0; i < t; ++i) {
            a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
            var y = a.modPow(r, this);
            if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
              var j = 1;
              while (j++ < k && y.compareTo(n1) != 0) {
                y = y.modPowInt(2, this);
                if (y.compareTo(BigInteger.ONE) == 0) return false;
              }
              if (y.compareTo(n1) != 0) return false;
            }
          }
          return true;
        }
        BigInteger.prototype.chunkSize = bnpChunkSize;
        BigInteger.prototype.toRadix = bnpToRadix;
        BigInteger.prototype.fromRadix = bnpFromRadix;
        BigInteger.prototype.fromNumber = bnpFromNumber;
        BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
        BigInteger.prototype.changeBit = bnpChangeBit;
        BigInteger.prototype.addTo = bnpAddTo;
        BigInteger.prototype.dMultiply = bnpDMultiply;
        BigInteger.prototype.dAddOffset = bnpDAddOffset;
        BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
        BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
        BigInteger.prototype.modInt = bnpModInt;
        BigInteger.prototype.millerRabin = bnpMillerRabin;
        BigInteger.prototype.clone = bnClone;
        BigInteger.prototype.intValue = bnIntValue;
        BigInteger.prototype.byteValue = bnByteValue;
        BigInteger.prototype.shortValue = bnShortValue;
        BigInteger.prototype.signum = bnSigNum;
        BigInteger.prototype.toByteArray = bnToByteArray;
        BigInteger.prototype.equals = bnEquals;
        BigInteger.prototype.min = bnMin;
        BigInteger.prototype.max = bnMax;
        BigInteger.prototype.and = bnAnd;
        BigInteger.prototype.or = bnOr;
        BigInteger.prototype.xor = bnXor;
        BigInteger.prototype.andNot = bnAndNot;
        BigInteger.prototype.not = bnNot;
        BigInteger.prototype.shiftLeft = bnShiftLeft;
        BigInteger.prototype.shiftRight = bnShiftRight;
        BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
        BigInteger.prototype.bitCount = bnBitCount;
        BigInteger.prototype.testBit = bnTestBit;
        BigInteger.prototype.setBit = bnSetBit;
        BigInteger.prototype.clearBit = bnClearBit;
        BigInteger.prototype.flipBit = bnFlipBit;
        BigInteger.prototype.add = bnAdd;
        BigInteger.prototype.subtract = bnSubtract;
        BigInteger.prototype.multiply = bnMultiply;
        BigInteger.prototype.divide = bnDivide;
        BigInteger.prototype.remainder = bnRemainder;
        BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
        BigInteger.prototype.modPow = bnModPow;
        BigInteger.prototype.modInverse = bnModInverse;
        BigInteger.prototype.pow = bnPow;
        BigInteger.prototype.gcd = bnGCD;
        BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
        BigInteger.prototype.square = bnSquare;
        BigInteger.prototype.Barrett = Barrett;
        var rng_state;
        var rng_pool;
        var rng_pptr;
        function rng_seed_int(x) {
          rng_pool[rng_pptr++] ^= x & 255;
          rng_pool[rng_pptr++] ^= (x >> 8) & 255;
          rng_pool[rng_pptr++] ^= (x >> 16) & 255;
          rng_pool[rng_pptr++] ^= (x >> 24) & 255;
          if (rng_pptr >= rng_psize) rng_pptr -= rng_psize;
        }
        function rng_seed_time() {
          rng_seed_int(new Date().getTime());
        }
        if (rng_pool == null) {
          rng_pool = new Array();
          rng_pptr = 0;
          var t;
          if (typeof window !== "undefined" && window.crypto) {
            if (window.crypto.getRandomValues) {
              var ua = new Uint8Array(32);
              window.crypto.getRandomValues(ua);
              for (t = 0; t < 32; ++t) rng_pool[rng_pptr++] = ua[t];
            } else if (
              navigator.appName == "Netscape" &&
              navigator.appVersion < "5"
            ) {
              var z = window.crypto.random(32);
              for (t = 0; t < z.length; ++t)
                rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
            }
          }
          while (rng_pptr < rng_psize) {
            t = Math.floor(65536 * Math.random());
            rng_pool[rng_pptr++] = t >>> 8;
            rng_pool[rng_pptr++] = t & 255;
          }
          rng_pptr = 0;
          rng_seed_time();
        }
        function rng_get_byte() {
          if (rng_state == null) {
            rng_seed_time();
            rng_state = prng_newstate();
            rng_state.init(rng_pool);
            for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
              rng_pool[rng_pptr] = 0;
            rng_pptr = 0;
          }
          return rng_state.next();
        }
        function rng_get_bytes(ba) {
          var i;
          for (i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
        }
        function SecureRandom() {}
        SecureRandom.prototype.nextBytes = rng_get_bytes;
        function Arcfour() {
          this.i = 0;
          this.j = 0;
          this.S = new Array();
        }
        function ARC4init(key) {
          var i, j, t;
          for (i = 0; i < 256; ++i) this.S[i] = i;
          j = 0;
          for (i = 0; i < 256; ++i) {
            j = (j + this.S[i] + key[i % key.length]) & 255;
            t = this.S[i];
            this.S[i] = this.S[j];
            this.S[j] = t;
          }
          this.i = 0;
          this.j = 0;
        }
        function ARC4next() {
          var t;
          this.i = (this.i + 1) & 255;
          this.j = (this.j + this.S[this.i]) & 255;
          t = this.S[this.i];
          this.S[this.i] = this.S[this.j];
          this.S[this.j] = t;
          return this.S[(t + this.S[this.i]) & 255];
        }
        Arcfour.prototype.init = ARC4init;
        Arcfour.prototype.next = ARC4next;
        function prng_newstate() {
          return new Arcfour();
        }
        var rng_psize = 256;
        if (true) {
          exports = module.exports = {
            default: BigInteger,
            BigInteger,
            SecureRandom,
          };
        } else {
        }
      }).call(this);
    },
    1991: (module) => {
      var C = {};
      var LEFT_BRACE = (C.LEFT_BRACE = 1);
      var RIGHT_BRACE = (C.RIGHT_BRACE = 2);
      var LEFT_BRACKET = (C.LEFT_BRACKET = 3);
      var RIGHT_BRACKET = (C.RIGHT_BRACKET = 4);
      var COLON = (C.COLON = 5);
      var COMMA = (C.COMMA = 6);
      var TRUE = (C.TRUE = 7);
      var FALSE = (C.FALSE = 8);
      var NULL = (C.NULL = 9);
      var STRING = (C.STRING = 10);
      var NUMBER = (C.NUMBER = 11);
      var START = (C.START = 17);
      var STOP = (C.STOP = 18);
      var TRUE1 = (C.TRUE1 = 33);
      var TRUE2 = (C.TRUE2 = 34);
      var TRUE3 = (C.TRUE3 = 35);
      var FALSE1 = (C.FALSE1 = 49);
      var FALSE2 = (C.FALSE2 = 50);
      var FALSE3 = (C.FALSE3 = 51);
      var FALSE4 = (C.FALSE4 = 52);
      var NULL1 = (C.NULL1 = 65);
      var NULL2 = (C.NULL2 = 66);
      var NULL3 = (C.NULL3 = 67);
      var NUMBER1 = (C.NUMBER1 = 81);
      var NUMBER3 = (C.NUMBER3 = 83);
      var STRING1 = (C.STRING1 = 97);
      var STRING2 = (C.STRING2 = 98);
      var STRING3 = (C.STRING3 = 99);
      var STRING4 = (C.STRING4 = 100);
      var STRING5 = (C.STRING5 = 101);
      var STRING6 = (C.STRING6 = 102);
      var VALUE = (C.VALUE = 113);
      var KEY = (C.KEY = 114);
      var OBJECT = (C.OBJECT = 129);
      var ARRAY = (C.ARRAY = 130);
      var BACK_SLASH = "\\".charCodeAt(0);
      var FORWARD_SLASH = "/".charCodeAt(0);
      var BACKSPACE = "\b".charCodeAt(0);
      var FORM_FEED = "\f".charCodeAt(0);
      var NEWLINE = "\n".charCodeAt(0);
      var CARRIAGE_RETURN = "\r".charCodeAt(0);
      var TAB = "\t".charCodeAt(0);
      var STRING_BUFFER_SIZE = 64 * 1024;
      function Parser() {
        this.tState = START;
        this.value = undefined;
        this.string = undefined;
        this.stringBuffer = Buffer.alloc
          ? Buffer.alloc(STRING_BUFFER_SIZE)
          : new Buffer(STRING_BUFFER_SIZE);
        this.stringBufferOffset = 0;
        this.unicode = undefined;
        this.highSurrogate = undefined;
        this.key = undefined;
        this.mode = undefined;
        this.stack = [];
        this.state = VALUE;
        this.bytes_remaining = 0;
        this.bytes_in_sequence = 0;
        this.temp_buffs = {
          2: new Buffer(2),
          3: new Buffer(3),
          4: new Buffer(4),
        };
        this.offset = -1;
      }
      Parser.toknam = function (code) {
        var keys = Object.keys(C);
        for (var i = 0, l = keys.length; i < l; i++) {
          var key = keys[i];
          if (C[key] === code) {
            return key;
          }
        }
        return code && "0x" + code.toString(16);
      };
      var proto = Parser.prototype;
      proto.onError = function (err) {
        throw err;
      };
      proto.charError = function (buffer, i) {
        this.tState = STOP;
        this.onError(
          new Error(
            "Unexpected " +
              JSON.stringify(String.fromCharCode(buffer[i])) +
              " at position " +
              i +
              " in state " +
              Parser.toknam(this.tState),
          ),
        );
      };
      proto.appendStringChar = function (char) {
        if (this.stringBufferOffset >= STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString("utf8");
          this.stringBufferOffset = 0;
        }
        this.stringBuffer[this.stringBufferOffset++] = char;
      };
      proto.appendStringBuf = function (buf, start, end) {
        var size = buf.length;
        if (typeof start === "number") {
          if (typeof end === "number") {
            if (end < 0) {
              size = buf.length - start + end;
            } else {
              size = end - start;
            }
          } else {
            size = buf.length - start;
          }
        }
        if (size < 0) {
          size = 0;
        }
        if (this.stringBufferOffset + size > STRING_BUFFER_SIZE) {
          this.string += this.stringBuffer.toString(
            "utf8",
            0,
            this.stringBufferOffset,
          );
          this.stringBufferOffset = 0;
        }
        buf.copy(this.stringBuffer, this.stringBufferOffset, start, end);
        this.stringBufferOffset += size;
      };
      proto.write = function (buffer) {
        if (typeof buffer === "string") buffer = new Buffer(buffer);
        var n;
        for (var i = 0, l = buffer.length; i < l; i++) {
          if (this.tState === START) {
            n = buffer[i];
            this.offset++;
            if (n === 123) {
              this.onToken(LEFT_BRACE, "{");
            } else if (n === 125) {
              this.onToken(RIGHT_BRACE, "}");
            } else if (n === 91) {
              this.onToken(LEFT_BRACKET, "[");
            } else if (n === 93) {
              this.onToken(RIGHT_BRACKET, "]");
            } else if (n === 58) {
              this.onToken(COLON, ":");
            } else if (n === 44) {
              this.onToken(COMMA, ",");
            } else if (n === 116) {
              this.tState = TRUE1;
            } else if (n === 102) {
              this.tState = FALSE1;
            } else if (n === 110) {
              this.tState = NULL1;
            } else if (n === 34) {
              this.string = "";
              this.stringBufferOffset = 0;
              this.tState = STRING1;
            } else if (n === 45) {
              this.string = "-";
              this.tState = NUMBER1;
            } else {
              if (n >= 48 && n < 64) {
                this.string = String.fromCharCode(n);
                this.tState = NUMBER3;
              } else if (n === 32 || n === 9 || n === 10 || n === 13) {
              } else {
                return this.charError(buffer, i);
              }
            }
          } else if (this.tState === STRING1) {
            n = buffer[i];
            if (this.bytes_remaining > 0) {
              for (var j = 0; j < this.bytes_remaining; j++) {
                this.temp_buffs[this.bytes_in_sequence][
                  this.bytes_in_sequence - this.bytes_remaining + j
                ] = buffer[j];
              }
              this.appendStringBuf(this.temp_buffs[this.bytes_in_sequence]);
              this.bytes_in_sequence = this.bytes_remaining = 0;
              i = i + j - 1;
            } else if (this.bytes_remaining === 0 && n >= 128) {
              if (n <= 193 || n > 244) {
                return this.onError(
                  new Error(
                    "Invalid UTF-8 character at position " +
                      i +
                      " in state " +
                      Parser.toknam(this.tState),
                  ),
                );
              }
              if (n >= 194 && n <= 223) this.bytes_in_sequence = 2;
              if (n >= 224 && n <= 239) this.bytes_in_sequence = 3;
              if (n >= 240 && n <= 244) this.bytes_in_sequence = 4;
              if (this.bytes_in_sequence + i > buffer.length) {
                for (var k = 0; k <= buffer.length - 1 - i; k++) {
                  this.temp_buffs[this.bytes_in_sequence][k] = buffer[i + k];
                }
                this.bytes_remaining =
                  i + this.bytes_in_sequence - buffer.length;
                i = buffer.length - 1;
              } else {
                this.appendStringBuf(buffer, i, i + this.bytes_in_sequence);
                i = i + this.bytes_in_sequence - 1;
              }
            } else if (n === 34) {
              this.tState = START;
              this.string += this.stringBuffer.toString(
                "utf8",
                0,
                this.stringBufferOffset,
              );
              this.stringBufferOffset = 0;
              this.onToken(STRING, this.string);
              this.offset += Buffer.byteLength(this.string, "utf8") + 1;
              this.string = undefined;
            } else if (n === 92) {
              this.tState = STRING2;
            } else if (n >= 32) {
              this.appendStringChar(n);
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === STRING2) {
            n = buffer[i];
            if (n === 34) {
              this.appendStringChar(n);
              this.tState = STRING1;
            } else if (n === 92) {
              this.appendStringChar(BACK_SLASH);
              this.tState = STRING1;
            } else if (n === 47) {
              this.appendStringChar(FORWARD_SLASH);
              this.tState = STRING1;
            } else if (n === 98) {
              this.appendStringChar(BACKSPACE);
              this.tState = STRING1;
            } else if (n === 102) {
              this.appendStringChar(FORM_FEED);
              this.tState = STRING1;
            } else if (n === 110) {
              this.appendStringChar(NEWLINE);
              this.tState = STRING1;
            } else if (n === 114) {
              this.appendStringChar(CARRIAGE_RETURN);
              this.tState = STRING1;
            } else if (n === 116) {
              this.appendStringChar(TAB);
              this.tState = STRING1;
            } else if (n === 117) {
              this.unicode = "";
              this.tState = STRING3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (
            this.tState === STRING3 ||
            this.tState === STRING4 ||
            this.tState === STRING5 ||
            this.tState === STRING6
          ) {
            n = buffer[i];
            if (
              (n >= 48 && n < 64) ||
              (n > 64 && n <= 70) ||
              (n > 96 && n <= 102)
            ) {
              this.unicode += String.fromCharCode(n);
              if (this.tState++ === STRING6) {
                var intVal = parseInt(this.unicode, 16);
                this.unicode = undefined;
                if (
                  this.highSurrogate !== undefined &&
                  intVal >= 56320 &&
                  intVal < 57343 + 1
                ) {
                  this.appendStringBuf(
                    new Buffer(String.fromCharCode(this.highSurrogate, intVal)),
                  );
                  this.highSurrogate = undefined;
                } else if (
                  this.highSurrogate === undefined &&
                  intVal >= 55296 &&
                  intVal < 56319 + 1
                ) {
                  this.highSurrogate = intVal;
                } else {
                  if (this.highSurrogate !== undefined) {
                    this.appendStringBuf(
                      new Buffer(String.fromCharCode(this.highSurrogate)),
                    );
                    this.highSurrogate = undefined;
                  }
                  this.appendStringBuf(new Buffer(String.fromCharCode(intVal)));
                }
                this.tState = STRING1;
              }
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NUMBER1 || this.tState === NUMBER3) {
            n = buffer[i];
            switch (n) {
              case 48:
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
              case 46:
              case 101:
              case 69:
              case 43:
              case 45:
                this.string += String.fromCharCode(n);
                this.tState = NUMBER3;
                break;
              default:
                this.tState = START;
                var result = Number(this.string);
                if (isNaN(result)) {
                  return this.charError(buffer, i);
                }
                if (
                  this.string.match(/[0-9]+/) == this.string &&
                  result.toString() != this.string
                ) {
                  this.onToken(STRING, this.string);
                } else {
                  this.onToken(NUMBER, result);
                }
                this.offset += this.string.length - 1;
                this.string = undefined;
                i--;
                break;
            }
          } else if (this.tState === TRUE1) {
            if (buffer[i] === 114) {
              this.tState = TRUE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE2) {
            if (buffer[i] === 117) {
              this.tState = TRUE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === TRUE3) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(TRUE, true);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE1) {
            if (buffer[i] === 97) {
              this.tState = FALSE2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE2) {
            if (buffer[i] === 108) {
              this.tState = FALSE3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE3) {
            if (buffer[i] === 115) {
              this.tState = FALSE4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === FALSE4) {
            if (buffer[i] === 101) {
              this.tState = START;
              this.onToken(FALSE, false);
              this.offset += 4;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL1) {
            if (buffer[i] === 117) {
              this.tState = NULL2;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL2) {
            if (buffer[i] === 108) {
              this.tState = NULL3;
            } else {
              return this.charError(buffer, i);
            }
          } else if (this.tState === NULL3) {
            if (buffer[i] === 108) {
              this.tState = START;
              this.onToken(NULL, null);
              this.offset += 3;
            } else {
              return this.charError(buffer, i);
            }
          }
        }
      };
      proto.onToken = function (token, value) {};
      proto.parseError = function (token, value) {
        this.tState = STOP;
        this.onError(
          new Error(
            "Unexpected " +
              Parser.toknam(token) +
              (value ? "(" + JSON.stringify(value) + ")" : "") +
              " in state " +
              Parser.toknam(this.state),
          ),
        );
      };
      proto.push = function () {
        this.stack.push({ value: this.value, key: this.key, mode: this.mode });
      };
      proto.pop = function () {
        var value = this.value;
        var parent = this.stack.pop();
        this.value = parent.value;
        this.key = parent.key;
        this.mode = parent.mode;
        this.emit(value);
        if (!this.mode) {
          this.state = VALUE;
        }
      };
      proto.emit = function (value) {
        if (this.mode) {
          this.state = COMMA;
        }
        this.onValue(value);
      };
      proto.onValue = function (value) {};
      proto.onToken = function (token, value) {
        if (this.state === VALUE) {
          if (
            token === STRING ||
            token === NUMBER ||
            token === TRUE ||
            token === FALSE ||
            token === NULL
          ) {
            if (this.value) {
              this.value[this.key] = value;
            }
            this.emit(value);
          } else if (token === LEFT_BRACE) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = {};
            } else {
              this.value = {};
            }
            this.key = undefined;
            this.state = KEY;
            this.mode = OBJECT;
          } else if (token === LEFT_BRACKET) {
            this.push();
            if (this.value) {
              this.value = this.value[this.key] = [];
            } else {
              this.value = [];
            }
            this.key = 0;
            this.mode = ARRAY;
            this.state = VALUE;
          } else if (token === RIGHT_BRACE) {
            if (this.mode === OBJECT) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else if (token === RIGHT_BRACKET) {
            if (this.mode === ARRAY) {
              this.pop();
            } else {
              return this.parseError(token, value);
            }
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === KEY) {
          if (token === STRING) {
            this.key = value;
            this.state = COLON;
          } else if (token === RIGHT_BRACE) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COLON) {
          if (token === COLON) {
            this.state = VALUE;
          } else {
            return this.parseError(token, value);
          }
        } else if (this.state === COMMA) {
          if (token === COMMA) {
            if (this.mode === ARRAY) {
              this.key++;
              this.state = VALUE;
            } else if (this.mode === OBJECT) {
              this.state = KEY;
            }
          } else if (
            (token === RIGHT_BRACKET && this.mode === ARRAY) ||
            (token === RIGHT_BRACE && this.mode === OBJECT)
          ) {
            this.pop();
          } else {
            return this.parseError(token, value);
          }
        } else {
          return this.parseError(token, value);
        }
      };
      Parser.C = C;
      module.exports = Parser;
    },
    6763: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = {
        publish: __nccwpck_require__(4302),
        unpublish: __nccwpck_require__(5984),
      };
    },
    7321: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const sigstore = __nccwpck_require__(9149);
      const { readFile } = __nccwpck_require__(3977);
      const ci = __nccwpck_require__(6339);
      const { env } = process;
      const INTOTO_PAYLOAD_TYPE = "application/vnd.in-toto+json";
      const INTOTO_STATEMENT_V01_TYPE = "https://in-toto.io/Statement/v0.1";
      const INTOTO_STATEMENT_V1_TYPE = "https://in-toto.io/Statement/v1";
      const SLSA_PREDICATE_V02_TYPE = "https://slsa.dev/provenance/v0.2";
      const SLSA_PREDICATE_V1_TYPE = "https://slsa.dev/provenance/v1";
      const GITHUB_BUILDER_ID_PREFIX = "https://github.com/actions/runner";
      const GITHUB_BUILD_TYPE =
        "https://slsa-framework.github.io/github-actions-buildtypes/workflow/v1";
      const GITLAB_BUILD_TYPE_PREFIX = "https://github.com/npm/cli/gitlab";
      const GITLAB_BUILD_TYPE_VERSION = "v0alpha1";
      const generateProvenance = async (subject, opts) => {
        let payload;
        if (ci.GITHUB_ACTIONS) {
          const relativeRef = (env.GITHUB_WORKFLOW_REF || "").replace(
            env.GITHUB_REPOSITORY + "/",
            "",
          );
          const delimiterIndex = relativeRef.indexOf("@");
          const workflowPath = relativeRef.slice(0, delimiterIndex);
          const workflowRef = relativeRef.slice(delimiterIndex + 1);
          payload = {
            _type: INTOTO_STATEMENT_V1_TYPE,
            subject,
            predicateType: SLSA_PREDICATE_V1_TYPE,
            predicate: {
              buildDefinition: {
                buildType: GITHUB_BUILD_TYPE,
                externalParameters: {
                  workflow: {
                    ref: workflowRef,
                    repository: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}`,
                    path: workflowPath,
                  },
                },
                internalParameters: {
                  github: {
                    event_name: env.GITHUB_EVENT_NAME,
                    repository_id: env.GITHUB_REPOSITORY_ID,
                    repository_owner_id: env.GITHUB_REPOSITORY_OWNER_ID,
                  },
                },
                resolvedDependencies: [
                  {
                    uri: `git+${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}@${env.GITHUB_REF}`,
                    digest: { gitCommit: env.GITHUB_SHA },
                  },
                ],
              },
              runDetails: {
                builder: {
                  id: `${GITHUB_BUILDER_ID_PREFIX}/${env.RUNNER_ENVIRONMENT}`,
                },
                metadata: {
                  invocationId: `${env.GITHUB_SERVER_URL}/${env.GITHUB_REPOSITORY}/actions/runs/${env.GITHUB_RUN_ID}/attempts/${env.GITHUB_RUN_ATTEMPT}`,
                },
              },
            },
          };
        }
        if (ci.GITLAB) {
          payload = {
            _type: INTOTO_STATEMENT_V01_TYPE,
            subject,
            predicateType: SLSA_PREDICATE_V02_TYPE,
            predicate: {
              buildType: `${GITLAB_BUILD_TYPE_PREFIX}/${GITLAB_BUILD_TYPE_VERSION}`,
              builder: {
                id: `${env.CI_PROJECT_URL}/-/runners/${env.CI_RUNNER_ID}`,
              },
              invocation: {
                configSource: {
                  uri: `git+${env.CI_PROJECT_URL}`,
                  digest: { sha1: env.CI_COMMIT_SHA },
                  entryPoint: env.CI_JOB_NAME,
                },
                parameters: {
                  CI: env.CI,
                  CI_API_GRAPHQL_URL: env.CI_API_GRAPHQL_URL,
                  CI_API_V4_URL: env.CI_API_V4_URL,
                  CI_BUILD_BEFORE_SHA: env.CI_BUILD_BEFORE_SHA,
                  CI_BUILD_ID: env.CI_BUILD_ID,
                  CI_BUILD_NAME: env.CI_BUILD_NAME,
                  CI_BUILD_REF: env.CI_BUILD_REF,
                  CI_BUILD_REF_NAME: env.CI_BUILD_REF_NAME,
                  CI_BUILD_REF_SLUG: env.CI_BUILD_REF_SLUG,
                  CI_BUILD_STAGE: env.CI_BUILD_STAGE,
                  CI_COMMIT_BEFORE_SHA: env.CI_COMMIT_BEFORE_SHA,
                  CI_COMMIT_BRANCH: env.CI_COMMIT_BRANCH,
                  CI_COMMIT_REF_NAME: env.CI_COMMIT_REF_NAME,
                  CI_COMMIT_REF_PROTECTED: env.CI_COMMIT_REF_PROTECTED,
                  CI_COMMIT_REF_SLUG: env.CI_COMMIT_REF_SLUG,
                  CI_COMMIT_SHA: env.CI_COMMIT_SHA,
                  CI_COMMIT_SHORT_SHA: env.CI_COMMIT_SHORT_SHA,
                  CI_COMMIT_TIMESTAMP: env.CI_COMMIT_TIMESTAMP,
                  CI_COMMIT_TITLE: env.CI_COMMIT_TITLE,
                  CI_CONFIG_PATH: env.CI_CONFIG_PATH,
                  CI_DEFAULT_BRANCH: env.CI_DEFAULT_BRANCH,
                  CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX:
                    env.CI_DEPENDENCY_PROXY_DIRECT_GROUP_IMAGE_PREFIX,
                  CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX:
                    env.CI_DEPENDENCY_PROXY_GROUP_IMAGE_PREFIX,
                  CI_DEPENDENCY_PROXY_SERVER: env.CI_DEPENDENCY_PROXY_SERVER,
                  CI_DEPENDENCY_PROXY_USER: env.CI_DEPENDENCY_PROXY_USER,
                  CI_JOB_ID: env.CI_JOB_ID,
                  CI_JOB_NAME: env.CI_JOB_NAME,
                  CI_JOB_NAME_SLUG: env.CI_JOB_NAME_SLUG,
                  CI_JOB_STAGE: env.CI_JOB_STAGE,
                  CI_JOB_STARTED_AT: env.CI_JOB_STARTED_AT,
                  CI_JOB_URL: env.CI_JOB_URL,
                  CI_NODE_TOTAL: env.CI_NODE_TOTAL,
                  CI_PAGES_DOMAIN: env.CI_PAGES_DOMAIN,
                  CI_PAGES_URL: env.CI_PAGES_URL,
                  CI_PIPELINE_CREATED_AT: env.CI_PIPELINE_CREATED_AT,
                  CI_PIPELINE_ID: env.CI_PIPELINE_ID,
                  CI_PIPELINE_IID: env.CI_PIPELINE_IID,
                  CI_PIPELINE_SOURCE: env.CI_PIPELINE_SOURCE,
                  CI_PIPELINE_URL: env.CI_PIPELINE_URL,
                  CI_PROJECT_CLASSIFICATION_LABEL:
                    env.CI_PROJECT_CLASSIFICATION_LABEL,
                  CI_PROJECT_DESCRIPTION: env.CI_PROJECT_DESCRIPTION,
                  CI_PROJECT_ID: env.CI_PROJECT_ID,
                  CI_PROJECT_NAME: env.CI_PROJECT_NAME,
                  CI_PROJECT_NAMESPACE: env.CI_PROJECT_NAMESPACE,
                  CI_PROJECT_NAMESPACE_ID: env.CI_PROJECT_NAMESPACE_ID,
                  CI_PROJECT_PATH: env.CI_PROJECT_PATH,
                  CI_PROJECT_PATH_SLUG: env.CI_PROJECT_PATH_SLUG,
                  CI_PROJECT_REPOSITORY_LANGUAGES:
                    env.CI_PROJECT_REPOSITORY_LANGUAGES,
                  CI_PROJECT_ROOT_NAMESPACE: env.CI_PROJECT_ROOT_NAMESPACE,
                  CI_PROJECT_TITLE: env.CI_PROJECT_TITLE,
                  CI_PROJECT_URL: env.CI_PROJECT_URL,
                  CI_PROJECT_VISIBILITY: env.CI_PROJECT_VISIBILITY,
                  CI_REGISTRY: env.CI_REGISTRY,
                  CI_REGISTRY_IMAGE: env.CI_REGISTRY_IMAGE,
                  CI_REGISTRY_USER: env.CI_REGISTRY_USER,
                  CI_RUNNER_DESCRIPTION: env.CI_RUNNER_DESCRIPTION,
                  CI_RUNNER_ID: env.CI_RUNNER_ID,
                  CI_RUNNER_TAGS: env.CI_RUNNER_TAGS,
                  CI_SERVER_HOST: env.CI_SERVER_HOST,
                  CI_SERVER_NAME: env.CI_SERVER_NAME,
                  CI_SERVER_PORT: env.CI_SERVER_PORT,
                  CI_SERVER_PROTOCOL: env.CI_SERVER_PROTOCOL,
                  CI_SERVER_REVISION: env.CI_SERVER_REVISION,
                  CI_SERVER_SHELL_SSH_HOST: env.CI_SERVER_SHELL_SSH_HOST,
                  CI_SERVER_SHELL_SSH_PORT: env.CI_SERVER_SHELL_SSH_PORT,
                  CI_SERVER_URL: env.CI_SERVER_URL,
                  CI_SERVER_VERSION: env.CI_SERVER_VERSION,
                  CI_SERVER_VERSION_MAJOR: env.CI_SERVER_VERSION_MAJOR,
                  CI_SERVER_VERSION_MINOR: env.CI_SERVER_VERSION_MINOR,
                  CI_SERVER_VERSION_PATCH: env.CI_SERVER_VERSION_PATCH,
                  CI_TEMPLATE_REGISTRY_HOST: env.CI_TEMPLATE_REGISTRY_HOST,
                  GITLAB_CI: env.GITLAB_CI,
                  GITLAB_FEATURES: env.GITLAB_FEATURES,
                  GITLAB_USER_ID: env.GITLAB_USER_ID,
                  GITLAB_USER_LOGIN: env.GITLAB_USER_LOGIN,
                  RUNNER_GENERATE_ARTIFACTS_METADATA:
                    env.RUNNER_GENERATE_ARTIFACTS_METADATA,
                },
                environment: {
                  name: env.CI_RUNNER_DESCRIPTION,
                  architecture: env.CI_RUNNER_EXECUTABLE_ARCH,
                  server: env.CI_SERVER_URL,
                  project: env.CI_PROJECT_PATH,
                  job: { id: env.CI_JOB_ID },
                  pipeline: { id: env.CI_PIPELINE_ID, ref: env.CI_CONFIG_PATH },
                },
              },
              metadata: {
                buildInvocationId: `${env.CI_JOB_URL}`,
                completeness: {
                  parameters: true,
                  environment: true,
                  materials: false,
                },
                reproducible: false,
              },
              materials: [
                {
                  uri: `git+${env.CI_PROJECT_URL}`,
                  digest: { sha1: env.CI_COMMIT_SHA },
                },
              ],
            },
          };
        }
        return sigstore.attest(
          Buffer.from(JSON.stringify(payload)),
          INTOTO_PAYLOAD_TYPE,
          opts,
        );
      };
      const verifyProvenance = async (subject, provenancePath) => {
        let provenanceBundle;
        try {
          provenanceBundle = JSON.parse(await readFile(provenancePath));
        } catch (err) {
          err.message = `Invalid provenance provided: ${err.message}`;
          throw err;
        }
        const payload = extractProvenance(provenanceBundle);
        if (!payload.subject || !payload.subject.length) {
          throw new Error("No subject found in sigstore bundle payload");
        }
        if (payload.subject.length > 1) {
          throw new Error(
            "Found more than one subject in the sigstore bundle payload",
          );
        }
        const bundleSubject = payload.subject[0];
        if (subject.name !== bundleSubject.name) {
          throw new Error(
            `Provenance subject ${bundleSubject.name} does not match the package: ${subject.name}`,
          );
        }
        if (subject.digest.sha512 !== bundleSubject.digest.sha512) {
          throw new Error(
            "Provenance subject digest does not match the package",
          );
        }
        await sigstore.verify(provenanceBundle);
        return provenanceBundle;
      };
      const extractProvenance = (bundle) => {
        if (!bundle?.dsseEnvelope?.payload) {
          throw new Error(
            "No dsseEnvelope with payload found in sigstore bundle",
          );
        }
        try {
          return JSON.parse(
            Buffer.from(bundle.dsseEnvelope.payload, "base64").toString("utf8"),
          );
        } catch (err) {
          err.message = `Failed to parse payload from dsseEnvelope: ${err.message}`;
          throw err;
        }
      };
      module.exports = { generateProvenance, verifyProvenance };
    },
    4302: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { fixer } = __nccwpck_require__(3188);
      const npmFetch = __nccwpck_require__(5902);
      const npa = __nccwpck_require__(680);
      const { log } = __nccwpck_require__(6528);
      const semver = __nccwpck_require__(4541);
      const { URL } = __nccwpck_require__(1041);
      const ssri = __nccwpck_require__(4406);
      const ciInfo = __nccwpck_require__(6339);
      const { generateProvenance, verifyProvenance } =
        __nccwpck_require__(7321);
      const TLOG_BASE_URL = "https://search.sigstore.dev/";
      const publish = async (manifest, tarballData, opts) => {
        if (manifest.private) {
          throw Object.assign(
            new Error(
              `This package has been marked as private\nRemove the 'private' field from the package.json to publish it.`,
            ),
            { code: "EPRIVATE" },
          );
        }
        const spec = npa.resolve(manifest.name, manifest.version);
        opts = {
          access: "public",
          algorithms: ["sha512"],
          defaultTag: "latest",
          ...opts,
          spec,
        };
        const reg = npmFetch.pickRegistry(spec, opts);
        const pubManifest = patchManifest(manifest, opts);
        if (!spec.scope && opts.access === "restricted") {
          throw Object.assign(
            new Error("Can't restrict access to unscoped packages."),
            { code: "EUNSCOPED" },
          );
        }
        const { metadata, transparencyLogUrl } = await buildMetadata(
          reg,
          pubManifest,
          tarballData,
          spec,
          opts,
        );
        const res = await npmFetch(spec.escapedName, {
          ...opts,
          method: "PUT",
          body: metadata,
          ignoreBody: true,
        });
        if (transparencyLogUrl) {
          res.transparencyLogUrl = transparencyLogUrl;
        }
        return res;
      };
      const patchManifest = (_manifest, opts) => {
        const { npmVersion } = opts;
        const manifest = { ..._manifest };
        manifest._nodeVersion = process.versions.node;
        if (npmVersion) {
          manifest._npmVersion = npmVersion;
        }
        fixer.fixNameField(manifest, { strict: true, allowLegacyCase: true });
        const version = semver.clean(manifest.version);
        if (!version) {
          throw Object.assign(
            new Error("invalid semver: " + manifest.version),
            { code: "EBADSEMVER" },
          );
        }
        manifest.version = version;
        return manifest;
      };
      const buildMetadata = async (
        registry,
        manifest,
        tarballData,
        spec,
        opts,
      ) => {
        const { access, defaultTag, algorithms, provenance, provenanceFile } =
          opts;
        const root = {
          _id: manifest.name,
          name: manifest.name,
          description: manifest.description,
          "dist-tags": {},
          versions: {},
          access,
        };
        root.versions[manifest.version] = manifest;
        const tag = manifest.tag || defaultTag;
        root["dist-tags"][tag] = manifest.version;
        const tarballName = `${manifest.name}-${manifest.version}.tgz`;
        const provenanceBundleName = `${manifest.name}-${manifest.version}.sigstore`;
        const tarballURI = `${manifest.name}/-/${tarballName}`;
        const integrity = ssri.fromData(tarballData, {
          algorithms: [...new Set(["sha1"].concat(algorithms))],
        });
        manifest._id = `${manifest.name}@${manifest.version}`;
        manifest.dist = { ...manifest.dist };
        manifest.dist.integrity = integrity.sha512[0].toString();
        manifest.dist.shasum = integrity.sha1[0].hexDigest();
        manifest.dist.tarball = new URL(tarballURI, registry).href.replace(
          /^https:\/\//,
          "http://",
        );
        root._attachments = {};
        root._attachments[tarballName] = {
          content_type: "application/octet-stream",
          data: tarballData.toString("base64"),
          length: tarballData.length,
        };
        let transparencyLogUrl;
        if (provenance === true || provenanceFile) {
          let provenanceBundle;
          const subject = {
            name: npa.toPurl(spec),
            digest: { sha512: integrity.sha512[0].hexDigest() },
          };
          if (provenance === true) {
            await ensureProvenanceGeneration(registry, spec, opts);
            provenanceBundle = await generateProvenance([subject], opts);
            log.notice(
              "publish",
              `Signed provenance statement with source and build information from ${ciInfo.name}`,
            );
            const tlogEntry =
              provenanceBundle?.verificationMaterial?.tlogEntries[0];
            if (tlogEntry) {
              transparencyLogUrl = `${TLOG_BASE_URL}?logIndex=${tlogEntry.logIndex}`;
              log.notice(
                "publish",
                `Provenance statement published to transparency log: ${transparencyLogUrl}`,
              );
            }
          } else {
            provenanceBundle = await verifyProvenance(subject, provenanceFile);
          }
          const serializedBundle = JSON.stringify(provenanceBundle);
          root._attachments[provenanceBundleName] = {
            content_type: provenanceBundle.mediaType,
            data: serializedBundle,
            length: serializedBundle.length,
          };
        }
        return { metadata: root, transparencyLogUrl };
      };
      const ensureProvenanceGeneration = async (registry, spec, opts) => {
        if (ciInfo.GITHUB_ACTIONS) {
          if (!process.env.ACTIONS_ID_TOKEN_REQUEST_URL) {
            throw Object.assign(
              new Error(
                'Provenance generation in GitHub Actions requires "write" access to the "id-token" permission',
              ),
              { code: "EUSAGE" },
            );
          }
        } else if (ciInfo.GITLAB) {
          if (!process.env.SIGSTORE_ID_TOKEN) {
            throw Object.assign(
              new Error(
                'Provenance generation in GitLab CI requires "SIGSTORE_ID_TOKEN" with "sigstore" audience to be present in "id_tokens". For more info see:\nhttps://docs.gitlab.com/ee/ci/secrets/id_token_authentication.html',
              ),
              { code: "EUSAGE" },
            );
          }
        } else {
          throw Object.assign(
            new Error(
              "Automatic provenance generation not supported for provider: " +
                ciInfo.name,
            ),
            { code: "EUSAGE" },
          );
        }
        let visibility = { public: false };
        if (opts.access !== "public") {
          try {
            const res = await npmFetch.json(
              `${registry}/-/package/${spec.escapedName}/visibility`,
              opts,
            );
            visibility = res;
          } catch (err) {
            if (err.code !== "E404") {
              throw err;
            }
          }
        }
        if (
          !visibility.public &&
          opts.provenance === true &&
          opts.access !== "public"
        ) {
          throw Object.assign(
            new Error(
              "Can't generate provenance for new or private package, you must set `access` to public.",
            ),
            { code: "EUSAGE" },
          );
        }
      };
      module.exports = publish;
    },
    5984: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(1041);
      const npa = __nccwpck_require__(680);
      const npmFetch = __nccwpck_require__(5902);
      const semver = __nccwpck_require__(4541);
      const getPathname = (tarball, registry) => {
        const registryUrl = new URL(registry).pathname.slice(1);
        let tarballUrl = new URL(tarball).pathname.slice(1);
        if (registryUrl) {
          tarballUrl = tarballUrl.slice(registryUrl.length);
        }
        return tarballUrl;
      };
      const unpublish = async (spec, opts) => {
        spec = npa(spec);
        opts = { force: false, ...opts, spec };
        try {
          const pkgUri = spec.escapedName;
          const pkg = await npmFetch.json(pkgUri, {
            ...opts,
            query: { write: true },
          });
          const version = spec.rawSpec;
          const allVersions = pkg.versions || {};
          const versionData = allVersions[version];
          const rawSpecs = !spec.rawSpec || spec.rawSpec === "*";
          const onlyVersion = Object.keys(allVersions).length === 1;
          const noVersions = !Object.keys(allVersions).length;
          if (!versionData && !rawSpecs && !noVersions) {
            return true;
          }
          if (rawSpecs || onlyVersion || noVersions) {
            await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {
              ...opts,
              method: "DELETE",
              ignoreBody: true,
            });
            return true;
          } else {
            const dist = allVersions[version].dist;
            delete allVersions[version];
            const latestVer = pkg["dist-tags"].latest;
            Object.keys(pkg["dist-tags"]).forEach((tag) => {
              if (pkg["dist-tags"][tag] === version) {
                delete pkg["dist-tags"][tag];
              }
            });
            if (latestVer === version) {
              pkg["dist-tags"].latest = Object.keys(allVersions)
                .sort(semver.compareLoose)
                .pop();
            }
            delete pkg._revisions;
            delete pkg._attachments;
            await npmFetch(`${pkgUri}/-rev/${pkg._rev}`, {
              ...opts,
              method: "PUT",
              body: pkg,
              ignoreBody: true,
            });
            const { _rev } = await npmFetch.json(pkgUri, {
              ...opts,
              query: { write: true },
            });
            const tarballUrl = getPathname(dist.tarball, opts.registry);
            await npmFetch(`${tarballUrl}/-rev/${_rev}`, {
              ...opts,
              method: "DELETE",
              ignoreBody: true,
            });
            return true;
          }
        } catch (err) {
          if (err.code !== "E404") {
            throw err;
          }
          return true;
        }
      };
      module.exports = unpublish;
    },
    7943: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { Request, Response } = __nccwpck_require__(8998);
      const { Minipass } = __nccwpck_require__(4968);
      const MinipassFlush = __nccwpck_require__(4181);
      const cacache = __nccwpck_require__(7129);
      const url = __nccwpck_require__(7310);
      const CachingMinipassPipeline = __nccwpck_require__(1064);
      const CachePolicy = __nccwpck_require__(7986);
      const cacheKey = __nccwpck_require__(2147);
      const remote = __nccwpck_require__(2619);
      const hasOwnProperty = (obj, prop) =>
        Object.prototype.hasOwnProperty.call(obj, prop);
      const KEEP_REQUEST_HEADERS = [
        "accept-charset",
        "accept-encoding",
        "accept-language",
        "accept",
        "cache-control",
      ];
      const KEEP_RESPONSE_HEADERS = [
        "cache-control",
        "content-encoding",
        "content-language",
        "content-type",
        "date",
        "etag",
        "expires",
        "last-modified",
        "link",
        "location",
        "pragma",
        "vary",
      ];
      const getMetadata = (request, response, options) => {
        const metadata = {
          time: Date.now(),
          url: request.url,
          reqHeaders: {},
          resHeaders: {},
          options: {
            compress:
              options.compress != null ? options.compress : request.compress,
          },
        };
        if (response.status !== 200 && response.status !== 304) {
          metadata.status = response.status;
        }
        for (const name of KEEP_REQUEST_HEADERS) {
          if (request.headers.has(name)) {
            metadata.reqHeaders[name] = request.headers.get(name);
          }
        }
        const host = request.headers.get("host");
        const parsedUrl = new url.URL(request.url);
        if (host && parsedUrl.host !== host) {
          metadata.reqHeaders.host = host;
        }
        if (response.headers.has("vary")) {
          const vary = response.headers.get("vary");
          if (vary !== "*") {
            const varyHeaders = vary
              .trim()
              .toLowerCase()
              .split(/\s*,\s*/);
            for (const name of varyHeaders) {
              if (request.headers.has(name)) {
                metadata.reqHeaders[name] = request.headers.get(name);
              }
            }
          }
        }
        for (const name of KEEP_RESPONSE_HEADERS) {
          if (response.headers.has(name)) {
            metadata.resHeaders[name] = response.headers.get(name);
          }
        }
        for (const name of options.cacheAdditionalHeaders) {
          if (response.headers.has(name)) {
            metadata.resHeaders[name] = response.headers.get(name);
          }
        }
        return metadata;
      };
      const _request = Symbol("request");
      const _response = Symbol("response");
      const _policy = Symbol("policy");
      class CacheEntry {
        constructor({ entry, request, response, options }) {
          if (entry) {
            this.key = entry.key;
            this.entry = entry;
            this.entry.metadata.time =
              this.entry.metadata.time || this.entry.time;
          } else {
            this.key = cacheKey(request);
          }
          this.options = options;
          this[_request] = request;
          this[_response] = response;
          this[_policy] = null;
        }
        static async find(request, options) {
          try {
            var matches = await cacache.index.compact(
              options.cachePath,
              cacheKey(request),
              (A, B) => {
                const entryA = new CacheEntry({ entry: A, options });
                const entryB = new CacheEntry({ entry: B, options });
                return entryA.policy.satisfies(entryB.request);
              },
              {
                validateEntry: (entry) => {
                  if (
                    entry.metadata &&
                    entry.metadata.resHeaders &&
                    entry.metadata.resHeaders["content-encoding"] === null
                  ) {
                    return false;
                  }
                  if (entry.integrity === null) {
                    return !!(entry.metadata && entry.metadata.status);
                  }
                  return true;
                },
              },
            );
          } catch (err) {
            return;
          }
          if (options.cache === "reload") {
            return;
          }
          let match;
          for (const entry of matches) {
            const _entry = new CacheEntry({ entry, options });
            if (_entry.policy.satisfies(request)) {
              match = _entry;
              break;
            }
          }
          return match;
        }
        static async invalidate(request, options) {
          const key = cacheKey(request);
          try {
            await cacache.rm.entry(options.cachePath, key, {
              removeFully: true,
            });
          } catch (err) {}
        }
        get request() {
          if (!this[_request]) {
            this[_request] = new Request(this.entry.metadata.url, {
              method: "GET",
              headers: this.entry.metadata.reqHeaders,
              ...this.entry.metadata.options,
            });
          }
          return this[_request];
        }
        get response() {
          if (!this[_response]) {
            this[_response] = new Response(null, {
              url: this.entry.metadata.url,
              counter: this.options.counter,
              status: this.entry.metadata.status || 200,
              headers: {
                ...this.entry.metadata.resHeaders,
                "content-length": this.entry.size,
              },
            });
          }
          return this[_response];
        }
        get policy() {
          if (!this[_policy]) {
            this[_policy] = new CachePolicy({
              entry: this.entry,
              request: this.request,
              response: this.response,
              options: this.options,
            });
          }
          return this[_policy];
        }
        async store(status) {
          if (
            this.request.method !== "GET" ||
            ![200, 301, 308].includes(this.response.status) ||
            !this.policy.storable()
          ) {
            this.response.headers.set("x-local-cache-status", "skip");
            return this.response;
          }
          const size = this.response.headers.get("content-length");
          const cacheOpts = {
            algorithms: this.options.algorithms,
            metadata: getMetadata(this.request, this.response, this.options),
            size,
            integrity: this.options.integrity,
            integrityEmitter:
              this.response.body.hasIntegrityEmitter && this.response.body,
          };
          let body = null;
          if (this.response.status === 200) {
            let cacheWriteResolve, cacheWriteReject;
            const cacheWritePromise = new Promise((resolve, reject) => {
              cacheWriteResolve = resolve;
              cacheWriteReject = reject;
            }).catch((err) => {
              body.emit("error", err);
            });
            body = new CachingMinipassPipeline(
              { events: ["integrity", "size"] },
              new MinipassFlush({
                flush() {
                  return cacheWritePromise;
                },
              }),
            );
            body.hasIntegrityEmitter = true;
            const onResume = () => {
              const tee = new Minipass();
              const cacheStream = cacache.put.stream(
                this.options.cachePath,
                this.key,
                cacheOpts,
              );
              cacheStream.on("integrity", (i) => body.emit("integrity", i));
              cacheStream.on("size", (s) => body.emit("size", s));
              tee.pipe(cacheStream);
              cacheStream.promise().then(cacheWriteResolve, cacheWriteReject);
              body.unshift(tee);
              body.unshift(this.response.body);
            };
            body.once("resume", onResume);
            body.once("end", () => body.removeListener("resume", onResume));
          } else {
            await cacache.index.insert(
              this.options.cachePath,
              this.key,
              null,
              cacheOpts,
            );
          }
          this.response.headers.set(
            "x-local-cache",
            encodeURIComponent(this.options.cachePath),
          );
          this.response.headers.set(
            "x-local-cache-key",
            encodeURIComponent(this.key),
          );
          this.response.headers.set("x-local-cache-mode", "stream");
          this.response.headers.set("x-local-cache-status", status);
          this.response.headers.set(
            "x-local-cache-time",
            new Date().toISOString(),
          );
          const newResponse = new Response(body, {
            url: this.response.url,
            status: this.response.status,
            headers: this.response.headers,
            counter: this.options.counter,
          });
          return newResponse;
        }
        async respond(method, options, status) {
          let response;
          if (method === "HEAD" || [301, 308].includes(this.response.status)) {
            response = this.response;
          } else {
            const body = new Minipass();
            const headers = { ...this.policy.responseHeaders() };
            const onResume = () => {
              const cacheStream = cacache.get.stream.byDigest(
                this.options.cachePath,
                this.entry.integrity,
                { memoize: this.options.memoize },
              );
              cacheStream.on("error", async (err) => {
                cacheStream.pause();
                if (err.code === "EINTEGRITY") {
                  await cacache.rm.content(
                    this.options.cachePath,
                    this.entry.integrity,
                    { memoize: this.options.memoize },
                  );
                }
                if (err.code === "ENOENT" || err.code === "EINTEGRITY") {
                  await CacheEntry.invalidate(this.request, this.options);
                }
                body.emit("error", err);
                cacheStream.resume();
              });
              body.emit("integrity", this.entry.integrity);
              body.emit("size", Number(headers["content-length"]));
              cacheStream.pipe(body);
            };
            body.once("resume", onResume);
            body.once("end", () => body.removeListener("resume", onResume));
            response = new Response(body, {
              url: this.entry.metadata.url,
              counter: options.counter,
              status: 200,
              headers,
            });
          }
          response.headers.set(
            "x-local-cache",
            encodeURIComponent(this.options.cachePath),
          );
          response.headers.set(
            "x-local-cache-hash",
            encodeURIComponent(this.entry.integrity),
          );
          response.headers.set(
            "x-local-cache-key",
            encodeURIComponent(this.key),
          );
          response.headers.set("x-local-cache-mode", "stream");
          response.headers.set("x-local-cache-status", status);
          response.headers.set(
            "x-local-cache-time",
            new Date(this.entry.metadata.time).toUTCString(),
          );
          return response;
        }
        async revalidate(request, options) {
          const revalidateRequest = new Request(request, {
            headers: this.policy.revalidationHeaders(request),
          });
          try {
            var response = await remote(revalidateRequest, {
              ...options,
              headers: undefined,
            });
          } catch (err) {
            if (!this.policy.mustRevalidate) {
              return this.respond(request.method, options, "stale");
            }
            throw err;
          }
          if (this.policy.revalidated(revalidateRequest, response)) {
            const metadata = getMetadata(request, response, options);
            for (const name of KEEP_RESPONSE_HEADERS) {
              if (
                !hasOwnProperty(metadata.resHeaders, name) &&
                hasOwnProperty(this.entry.metadata.resHeaders, name)
              ) {
                metadata.resHeaders[name] =
                  this.entry.metadata.resHeaders[name];
              }
            }
            for (const name of options.cacheAdditionalHeaders) {
              const inMeta = hasOwnProperty(metadata.resHeaders, name);
              const inEntry = hasOwnProperty(
                this.entry.metadata.resHeaders,
                name,
              );
              const inPolicy = hasOwnProperty(
                this.policy.response.headers,
                name,
              );
              if (!inMeta && inEntry) {
                metadata.resHeaders[name] =
                  this.entry.metadata.resHeaders[name];
              }
              if (!inPolicy && inMeta) {
                this.policy.response.headers[name] = metadata.resHeaders[name];
              }
            }
            try {
              await cacache.index.insert(
                options.cachePath,
                this.key,
                this.entry.integrity,
                { size: this.entry.size, metadata },
              );
            } catch (err) {}
            return this.respond(request.method, options, "revalidated");
          }
          const newEntry = new CacheEntry({ request, response, options });
          return newEntry.store("updated");
        }
      }
      module.exports = CacheEntry;
    },
    3104: (module) => {
      class NotCachedError extends Error {
        constructor(url) {
          super(
            `request to ${url} failed: cache mode is 'only-if-cached' but no cached response is available.`,
          );
          this.code = "ENOTCACHED";
        }
      }
      module.exports = { NotCachedError };
    },
    3189: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { NotCachedError } = __nccwpck_require__(3104);
      const CacheEntry = __nccwpck_require__(7943);
      const remote = __nccwpck_require__(2619);
      const cacheFetch = async (request, options) => {
        const entry = await CacheEntry.find(request, options);
        if (!entry) {
          if (options.cache === "only-if-cached") {
            throw new NotCachedError(request.url);
          }
          const response = await remote(request, options);
          const newEntry = new CacheEntry({ request, response, options });
          return newEntry.store("miss");
        }
        if (options.cache === "no-cache") {
          return entry.revalidate(request, options);
        }
        const _needsRevalidation = entry.policy.needsRevalidation(request);
        if (
          options.cache === "force-cache" ||
          options.cache === "only-if-cached" ||
          !_needsRevalidation
        ) {
          return entry.respond(
            request.method,
            options,
            _needsRevalidation ? "stale" : "hit",
          );
        }
        return entry.revalidate(request, options);
      };
      cacheFetch.invalidate = async (request, options) => {
        if (!options.cachePath) {
          return;
        }
        return CacheEntry.invalidate(request, options);
      };
      module.exports = cacheFetch;
    },
    2147: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { URL, format } = __nccwpck_require__(7310);
      const formatOptions = {
        auth: false,
        fragment: false,
        search: true,
        unicode: false,
      };
      const cacheKey = (request) => {
        const parsed = new URL(request.url);
        return `make-fetch-happen:request-cache:${format(parsed, formatOptions)}`;
      };
      module.exports = cacheKey;
    },
    7986: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const CacheSemantics = __nccwpck_require__(1002);
      const Negotiator = __nccwpck_require__(5385);
      const ssri = __nccwpck_require__(4406);
      const policyOptions = { shared: false, ignoreCargoCult: true };
      const emptyResponse = { status: 200, headers: {} };
      const requestObject = (request) => {
        const _obj = {
          method: request.method,
          url: request.url,
          headers: {},
          compress: request.compress,
        };
        request.headers.forEach((value, key) => {
          _obj.headers[key] = value;
        });
        return _obj;
      };
      const responseObject = (response) => {
        const _obj = { status: response.status, headers: {} };
        response.headers.forEach((value, key) => {
          _obj.headers[key] = value;
        });
        return _obj;
      };
      class CachePolicy {
        constructor({ entry, request, response, options }) {
          this.entry = entry;
          this.request = requestObject(request);
          this.response = responseObject(response);
          this.options = options;
          this.policy = new CacheSemantics(
            this.request,
            this.response,
            policyOptions,
          );
          if (this.entry) {
            this.policy._responseTime = this.entry.metadata.time;
          }
        }
        static storable(request, options) {
          if (!options.cachePath) {
            return false;
          }
          if (options.cache === "no-store") {
            return false;
          }
          if (!["GET", "HEAD"].includes(request.method)) {
            return false;
          }
          const policy = new CacheSemantics(
            requestObject(request),
            emptyResponse,
            policyOptions,
          );
          return policy.storable();
        }
        satisfies(request) {
          const _req = requestObject(request);
          if (this.request.headers.host !== _req.headers.host) {
            return false;
          }
          if (this.request.compress !== _req.compress) {
            return false;
          }
          const negotiatorA = new Negotiator(this.request);
          const negotiatorB = new Negotiator(_req);
          if (
            JSON.stringify(negotiatorA.mediaTypes()) !==
            JSON.stringify(negotiatorB.mediaTypes())
          ) {
            return false;
          }
          if (
            JSON.stringify(negotiatorA.languages()) !==
            JSON.stringify(negotiatorB.languages())
          ) {
            return false;
          }
          if (
            JSON.stringify(negotiatorA.encodings()) !==
            JSON.stringify(negotiatorB.encodings())
          ) {
            return false;
          }
          if (this.options.integrity) {
            return ssri
              .parse(this.options.integrity)
              .match(this.entry.integrity);
          }
          return true;
        }
        storable() {
          return this.policy.storable();
        }
        get mustRevalidate() {
          return !!this.policy._rescc["must-revalidate"];
        }
        needsRevalidation(request) {
          const _req = requestObject(request);
          _req.method = "GET";
          return !this.policy.satisfiesWithoutRevalidation(_req);
        }
        responseHeaders() {
          return this.policy.responseHeaders();
        }
        revalidationHeaders(request) {
          const _req = requestObject(request);
          return this.policy.revalidationHeaders(_req);
        }
        revalidated(request, response) {
          const _req = requestObject(request);
          const _res = responseObject(response);
          const policy = this.policy.revalidatedPolicy(_req, _res);
          return !policy.modified;
        }
      }
      module.exports = CachePolicy;
    },
    1371: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { FetchError, Request, isRedirect } = __nccwpck_require__(8998);
      const url = __nccwpck_require__(7310);
      const CachePolicy = __nccwpck_require__(7986);
      const cache = __nccwpck_require__(3189);
      const remote = __nccwpck_require__(2619);
      const canFollowRedirect = (request, response, options) => {
        if (!isRedirect(response.status)) {
          return false;
        }
        if (options.redirect === "manual") {
          return false;
        }
        if (options.redirect === "error") {
          throw new FetchError(
            `redirect mode is set to error: ${request.url}`,
            "no-redirect",
            { code: "ENOREDIRECT" },
          );
        }
        if (!response.headers.has("location")) {
          throw new FetchError(
            `redirect location header missing for: ${request.url}`,
            "no-location",
            { code: "EINVALIDREDIRECT" },
          );
        }
        if (request.counter >= request.follow) {
          throw new FetchError(
            `maximum redirect reached at: ${request.url}`,
            "max-redirect",
            { code: "EMAXREDIRECT" },
          );
        }
        return true;
      };
      const getRedirect = (request, response, options) => {
        const _opts = { ...options };
        const location = response.headers.get("location");
        const redirectUrl = new url.URL(
          location,
          /^https?:/.test(location) ? undefined : request.url,
        );
        /**
         * @license
         * Copyright (c) 2010-2012 Mikeal Rogers
         * Licensed under the Apache License, Version 2.0 (the "License");
         * you may not use this file except in compliance with the License.
         * You may obtain a copy of the License at
         * http://www.apache.org/licenses/LICENSE-2.0
         * Unless required by applicable law or agreed to in writing,
         * software distributed under the License is distributed on an "AS
         * IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either
         * express or implied. See the License for the specific language
         * governing permissions and limitations under the License.
         */ if (new url.URL(request.url).hostname !== redirectUrl.hostname) {
          request.headers.delete("authorization");
          request.headers.delete("cookie");
        }
        if (
          response.status === 303 ||
          (request.method === "POST" && [301, 302].includes(response.status))
        ) {
          _opts.method = "GET";
          _opts.body = null;
          request.headers.delete("content-length");
        }
        _opts.headers = {};
        request.headers.forEach((value, key) => {
          _opts.headers[key] = value;
        });
        _opts.counter = ++request.counter;
        const redirectReq = new Request(url.format(redirectUrl), _opts);
        return { request: redirectReq, options: _opts };
      };
      const fetch = async (request, options) => {
        const response = CachePolicy.storable(request, options)
          ? await cache(request, options)
          : await remote(request, options);
        if (
          !["GET", "HEAD"].includes(request.method) &&
          response.status >= 200 &&
          response.status <= 399
        ) {
          await cache.invalidate(request, options);
        }
        if (!canFollowRedirect(request, response, options)) {
          return response;
        }
        const redirect = getRedirect(request, response, options);
        return fetch(redirect.request, redirect.options);
      };
      module.exports = fetch;
    },
    9525: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { FetchError, Headers, Request, Response } =
        __nccwpck_require__(8998);
      const configureOptions = __nccwpck_require__(5530);
      const fetch = __nccwpck_require__(1371);
      const makeFetchHappen = (url, opts) => {
        const options = configureOptions(opts);
        const request = new Request(url, options);
        return fetch(request, options);
      };
      makeFetchHappen.defaults = (
        defaultUrl,
        defaultOptions = {},
        wrappedFetch = makeFetchHappen,
      ) => {
        if (typeof defaultUrl === "object") {
          defaultOptions = defaultUrl;
          defaultUrl = null;
        }
        const defaultedFetch = (url, options = {}) => {
          const finalUrl = url || defaultUrl;
          const finalOptions = {
            ...defaultOptions,
            ...options,
            headers: { ...defaultOptions.headers, ...options.headers },
          };
          return wrappedFetch(finalUrl, finalOptions);
        };
        defaultedFetch.defaults = (defaultUrl1, defaultOptions1 = {}) =>
          makeFetchHappen.defaults(
            defaultUrl1,
            defaultOptions1,
            defaultedFetch,
          );
        return defaultedFetch;
      };
      module.exports = makeFetchHappen;
      module.exports.FetchError = FetchError;
      module.exports.Headers = Headers;
      module.exports.Request = Request;
      module.exports.Response = Response;
    },
    5530: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const dns = __nccwpck_require__(7578);
      const conditionalHeaders = [
        "if-modified-since",
        "if-none-match",
        "if-unmodified-since",
        "if-match",
        "if-range",
      ];
      const configureOptions = (opts) => {
        const { strictSSL, ...options } = { ...opts };
        options.method = options.method ? options.method.toUpperCase() : "GET";
        options.rejectUnauthorized = strictSSL !== false;
        if (!options.retry) {
          options.retry = { retries: 0 };
        } else if (typeof options.retry === "string") {
          const retries = parseInt(options.retry, 10);
          if (isFinite(retries)) {
            options.retry = { retries };
          } else {
            options.retry = { retries: 0 };
          }
        } else if (typeof options.retry === "number") {
          options.retry = { retries: options.retry };
        } else {
          options.retry = { retries: 0, ...options.retry };
        }
        options.dns = { ttl: 5 * 60 * 1e3, lookup: dns.lookup, ...options.dns };
        options.cache = options.cache || "default";
        if (options.cache === "default") {
          const hasConditionalHeader = Object.keys(options.headers || {}).some(
            (name) => conditionalHeaders.includes(name.toLowerCase()),
          );
          if (hasConditionalHeader) {
            options.cache = "no-store";
          }
        }
        options.cacheAdditionalHeaders = options.cacheAdditionalHeaders || [];
        if (options.cacheManager && !options.cachePath) {
          options.cachePath = options.cacheManager;
        }
        return options;
      };
      module.exports = configureOptions;
    },
    1064: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const MinipassPipeline = __nccwpck_require__(9891);
      class CachingMinipassPipeline extends MinipassPipeline {
        #events = [];
        #data = new Map();
        constructor(opts, ...streams) {
          super();
          this.#events = opts.events;
          if (streams.length) {
            this.push(...streams);
          }
        }
        on(event, handler) {
          if (this.#events.includes(event) && this.#data.has(event)) {
            return handler(...this.#data.get(event));
          }
          return super.on(event, handler);
        }
        emit(event, ...data) {
          if (this.#events.includes(event)) {
            this.#data.set(event, data);
          }
          return super.emit(event, ...data);
        }
      }
      module.exports = CachingMinipassPipeline;
    },
    2619: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const { Minipass } = __nccwpck_require__(4968);
      const fetch = __nccwpck_require__(8998);
      const promiseRetry = __nccwpck_require__(4742);
      const ssri = __nccwpck_require__(4406);
      const { log } = __nccwpck_require__(6528);
      const CachingMinipassPipeline = __nccwpck_require__(1064);
      const { getAgent } = __nccwpck_require__(9907);
      const pkg = __nccwpck_require__(3684);
      const USER_AGENT = `${pkg.name}/${pkg.version} (+https://npm.im/${pkg.name})`;
      const RETRY_ERRORS = [
        "ECONNRESET",
        "ECONNREFUSED",
        "EADDRINUSE",
        "ETIMEDOUT",
        "ECONNECTIONTIMEOUT",
        "EIDLETIMEOUT",
        "ERESPONSETIMEOUT",
        "ETRANSFERTIMEOUT",
      ];
      const RETRY_TYPES = ["request-timeout"];
      const remoteFetch = (request, options) => {
        const agent = getAgent(request.url, options);
        if (!request.headers.has("connection")) {
          request.headers.set("connection", agent ? "keep-alive" : "close");
        }
        if (!request.headers.has("user-agent")) {
          request.headers.set("user-agent", USER_AGENT);
        }
        const _opts = { ...options, agent, redirect: "manual" };
        return promiseRetry(async (retryHandler, attemptNum) => {
          const req = new fetch.Request(request, _opts);
          try {
            let res = await fetch(req, _opts);
            if (_opts.integrity && res.status === 200) {
              const integrityStream = ssri.integrityStream({
                algorithms: _opts.algorithms,
                integrity: _opts.integrity,
                size: _opts.size,
              });
              const pipeline = new CachingMinipassPipeline(
                { events: ["integrity", "size"] },
                res.body,
                integrityStream,
              );
              integrityStream.on("integrity", (i) =>
                pipeline.emit("integrity", i),
              );
              integrityStream.on("size", (s) => pipeline.emit("size", s));
              res = new fetch.Response(pipeline, res);
              res.body.hasIntegrityEmitter = true;
            }
            res.headers.set("x-fetch-attempts", attemptNum);
            const isStream = Minipass.isStream(req.body);
            const isRetriable =
              req.method !== "POST" &&
              !isStream &&
              ([408, 420, 429].includes(res.status) || res.status >= 500);
            if (isRetriable) {
              if (typeof options.onRetry === "function") {
                options.onRetry(res);
              }
              log.http(
                "fetch",
                `${req.method} ${req.url} attempt ${attemptNum} failed with ${res.status}`,
              );
              return retryHandler(res);
            }
            return res;
          } catch (err) {
            const code =
              err.code === "EPROMISERETRY" ? err.retried.code : err.code;
            const isRetryError =
              err.retried instanceof fetch.Response ||
              (RETRY_ERRORS.includes(code) && RETRY_TYPES.includes(err.type));
            if (req.method === "POST" || isRetryError) {
              throw err;
            }
            if (typeof options.onRetry === "function") {
              options.onRetry(err);
            }
            log.http(
              "fetch",
              `${req.method} ${req.url} attempt ${attemptNum} failed with ${err.code}`,
            );
            return retryHandler(err);
          }
        }, options.retry).catch((err) => {
          if (err.status >= 400 && err.type !== "system") {
            return err;
          }
          throw err;
        });
      };
      module.exports = remoteFetch;
    },
    8184: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var balanced = __nccwpck_require__(9417);
      module.exports = expandTop;
      var escSlash = "\0SLASH" + Math.random() + "\0";
      var escOpen = "\0OPEN" + Math.random() + "\0";
      var escClose = "\0CLOSE" + Math.random() + "\0";
      var escComma = "\0COMMA" + Math.random() + "\0";
      var escPeriod = "\0PERIOD" + Math.random() + "\0";
      function numeric(str) {
        return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
      }
      function escapeBraces(str) {
        return str
          .split("\\\\")
          .join(escSlash)
          .split("\\{")
          .join(escOpen)
          .split("\\}")
          .join(escClose)
          .split("\\,")
          .join(escComma)
          .split("\\.")
          .join(escPeriod);
      }
      function unescapeBraces(str) {
        return str
          .split(escSlash)
          .join("\\")
          .split(escOpen)
          .join("{")
          .split(escClose)
          .join("}")
          .split(escComma)
          .join(",")
          .split(escPeriod)
          .join(".");
      }
      function parseCommaParts(str) {
        if (!str) return [""];
        var parts = [];
        var m = balanced("{", "}", str);
        if (!m) return str.split(",");
        var pre = m.pre;
        var body = m.body;
        var post = m.post;
        var p = pre.split(",");
        p[p.length - 1] += "{" + body + "}";
        var postParts = parseCommaParts(post);
        if (post.length) {
          p[p.length - 1] += postParts.shift();
          p.push.apply(p, postParts);
        }
        parts.push.apply(parts, p);
        return parts;
      }
      function expandTop(str) {
        if (!str) return [];
        if (str.substr(0, 2) === "{}") {
          str = "\\{\\}" + str.substr(2);
        }
        return expand(escapeBraces(str), true).map(unescapeBraces);
      }
      function embrace(str) {
        return "{" + str + "}";
      }
      function isPadded(el) {
        return /^-?0\d/.test(el);
      }
      function lte(i, y) {
        return i <= y;
      }
      function gte(i, y) {
        return i >= y;
      }
      function expand(str, isTop) {
        var expansions = [];
        var m = balanced("{", "}", str);
        if (!m) return [str];
        var pre = m.pre;
        var post = m.post.length ? expand(m.post, false) : [""];
        if (/\$$/.test(m.pre)) {
          for (var k = 0; k < post.length; k++) {
            var expansion = pre + "{" + m.body + "}" + post[k];
            expansions.push(expansion);
          }
        } else {
          var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
          var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(
            m.body,
          );
          var isSequence = isNumericSequence || isAlphaSequence;
          var isOptions = m.body.indexOf(",") >= 0;
          if (!isSequence && !isOptions) {
            if (m.post.match(/,.*\}/)) {
              str = m.pre + "{" + m.body + escClose + m.post;
              return expand(str);
            }
            return [str];
          }
          var n;
          if (isSequence) {
            n = m.body.split(/\.\./);
          } else {
            n = parseCommaParts(m.body);
            if (n.length === 1) {
              n = expand(n[0], false).map(embrace);
              if (n.length === 1) {
                return post.map(function (p) {
                  return m.pre + n[0] + p;
                });
              }
            }
          }
          var N;
          if (isSequence) {
            var x = numeric(n[0]);
            var y = numeric(n[1]);
            var width = Math.max(n[0].length, n[1].length);
            var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
            var test = lte;
            var reverse = y < x;
            if (reverse) {
              incr *= -1;
              test = gte;
            }
            var pad = n.some(isPadded);
            N = [];
            for (var i = x; test(i, y); i += incr) {
              var c;
              if (isAlphaSequence) {
                c = String.fromCharCode(i);
                if (c === "\\") c = "";
              } else {
                c = String(i);
                if (pad) {
                  var need = width - c.length;
                  if (need > 0) {
                    var z = new Array(need + 1).join("0");
                    if (i < 0) c = "-" + z + c.slice(1);
                    else c = z + c;
                  }
                }
              }
              N.push(c);
            }
          } else {
            N = [];
            for (var j = 0; j < n.length; j++) {
              N.push.apply(N, expand(n[j], false));
            }
          }
          for (var j = 0; j < N.length; j++) {
            for (var k = 0; k < post.length; k++) {
              var expansion = pre + N[j] + post[k];
              if (!isTop || isSequence || expansion) expansions.push(expansion);
            }
          }
        }
        return expansions;
      }
    },
    1078: (module) => {
      "use strict";
      class AbortError extends Error {
        constructor(message) {
          super(message);
          this.code = "FETCH_ABORTED";
          this.type = "aborted";
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "AbortError";
        }
        set name(s) {}
      }
      module.exports = AbortError;
    },
    7911: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { Minipass } = __nccwpck_require__(4968);
      const TYPE = Symbol("type");
      const BUFFER = Symbol("buffer");
      class Blob {
        constructor(blobParts, options) {
          this[TYPE] = "";
          const buffers = [];
          let size = 0;
          if (blobParts) {
            const a = blobParts;
            const length = Number(a.length);
            for (let i = 0; i < length; i++) {
              const element = a[i];
              const buffer =
                element instanceof Buffer
                  ? element
                  : ArrayBuffer.isView(element)
                    ? Buffer.from(
                        element.buffer,
                        element.byteOffset,
                        element.byteLength,
                      )
                    : element instanceof ArrayBuffer
                      ? Buffer.from(element)
                      : element instanceof Blob
                        ? element[BUFFER]
                        : typeof element === "string"
                          ? Buffer.from(element)
                          : Buffer.from(String(element));
              size += buffer.length;
              buffers.push(buffer);
            }
          }
          this[BUFFER] = Buffer.concat(buffers, size);
          const type =
            options &&
            options.type !== undefined &&
            String(options.type).toLowerCase();
          if (type && !/[^\u0020-\u007E]/.test(type)) {
            this[TYPE] = type;
          }
        }
        get size() {
          return this[BUFFER].length;
        }
        get type() {
          return this[TYPE];
        }
        text() {
          return Promise.resolve(this[BUFFER].toString());
        }
        arrayBuffer() {
          const buf = this[BUFFER];
          const off = buf.byteOffset;
          const len = buf.byteLength;
          const ab = buf.buffer.slice(off, off + len);
          return Promise.resolve(ab);
        }
        stream() {
          return new Minipass().end(this[BUFFER]);
        }
        slice(start, end, type) {
          const size = this.size;
          const relativeStart =
            start === undefined
              ? 0
              : start < 0
                ? Math.max(size + start, 0)
                : Math.min(start, size);
          const relativeEnd =
            end === undefined
              ? size
              : end < 0
                ? Math.max(size + end, 0)
                : Math.min(end, size);
          const span = Math.max(relativeEnd - relativeStart, 0);
          const buffer = this[BUFFER];
          const slicedBuffer = buffer.slice(
            relativeStart,
            relativeStart + span,
          );
          const blob = new Blob([], { type });
          blob[BUFFER] = slicedBuffer;
          return blob;
        }
        get [Symbol.toStringTag]() {
          return "Blob";
        }
        static get BUFFER() {
          return BUFFER;
        }
      }
      Object.defineProperties(Blob.prototype, {
        size: { enumerable: true },
        type: { enumerable: true },
      });
      module.exports = Blob;
    },
    7223: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { Minipass } = __nccwpck_require__(4968);
      const MinipassSized = __nccwpck_require__(5952);
      const Blob = __nccwpck_require__(7911);
      const { BUFFER } = Blob;
      const FetchError = __nccwpck_require__(2899);
      let convert;
      try {
        convert = __nccwpck_require__(8685).O;
      } catch (e) {}
      const INTERNALS = Symbol("Body internals");
      const CONSUME_BODY = Symbol("consumeBody");
      class Body {
        constructor(bodyArg, options = {}) {
          const { size = 0, timeout = 0 } = options;
          const body =
            bodyArg === undefined || bodyArg === null
              ? null
              : isURLSearchParams(bodyArg)
                ? Buffer.from(bodyArg.toString())
                : isBlob(bodyArg)
                  ? bodyArg
                  : Buffer.isBuffer(bodyArg)
                    ? bodyArg
                    : Object.prototype.toString.call(bodyArg) ===
                        "[object ArrayBuffer]"
                      ? Buffer.from(bodyArg)
                      : ArrayBuffer.isView(bodyArg)
                        ? Buffer.from(
                            bodyArg.buffer,
                            bodyArg.byteOffset,
                            bodyArg.byteLength,
                          )
                        : Minipass.isStream(bodyArg)
                          ? bodyArg
                          : Buffer.from(String(bodyArg));
          this[INTERNALS] = { body, disturbed: false, error: null };
          this.size = size;
          this.timeout = timeout;
          if (Minipass.isStream(body)) {
            body.on("error", (er) => {
              const error =
                er.name === "AbortError"
                  ? er
                  : new FetchError(
                      `Invalid response while trying to fetch ${this.url}: ${er.message}`,
                      "system",
                      er,
                    );
              this[INTERNALS].error = error;
            });
          }
        }
        get body() {
          return this[INTERNALS].body;
        }
        get bodyUsed() {
          return this[INTERNALS].disturbed;
        }
        arrayBuffer() {
          return this[CONSUME_BODY]().then((buf) =>
            buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.byteLength),
          );
        }
        blob() {
          const ct = (this.headers && this.headers.get("content-type")) || "";
          return this[CONSUME_BODY]().then((buf) =>
            Object.assign(new Blob([], { type: ct.toLowerCase() }), {
              [BUFFER]: buf,
            }),
          );
        }
        async json() {
          const buf = await this[CONSUME_BODY]();
          try {
            return JSON.parse(buf.toString());
          } catch (er) {
            throw new FetchError(
              `invalid json response body at ${this.url} reason: ${er.message}`,
              "invalid-json",
            );
          }
        }
        text() {
          return this[CONSUME_BODY]().then((buf) => buf.toString());
        }
        buffer() {
          return this[CONSUME_BODY]();
        }
        textConverted() {
          return this[CONSUME_BODY]().then((buf) =>
            convertBody(buf, this.headers),
          );
        }
        [CONSUME_BODY]() {
          if (this[INTERNALS].disturbed) {
            return Promise.reject(
              new TypeError(`body used already for: ${this.url}`),
            );
          }
          this[INTERNALS].disturbed = true;
          if (this[INTERNALS].error) {
            return Promise.reject(this[INTERNALS].error);
          }
          if (this.body === null) {
            return Promise.resolve(Buffer.alloc(0));
          }
          if (Buffer.isBuffer(this.body)) {
            return Promise.resolve(this.body);
          }
          const upstream = isBlob(this.body) ? this.body.stream() : this.body;
          if (!Minipass.isStream(upstream)) {
            return Promise.resolve(Buffer.alloc(0));
          }
          const stream =
            this.size && upstream instanceof MinipassSized
              ? upstream
              : !this.size &&
                  upstream instanceof Minipass &&
                  !(upstream instanceof MinipassSized)
                ? upstream
                : this.size
                  ? new MinipassSized({ size: this.size })
                  : new Minipass();
          const resTimeout =
            this.timeout && stream.writable
              ? setTimeout(() => {
                  stream.emit(
                    "error",
                    new FetchError(
                      `Response timeout while trying to fetch ${this.url} (over ${this.timeout}ms)`,
                      "body-timeout",
                    ),
                  );
                }, this.timeout)
              : null;
          if (resTimeout && resTimeout.unref) {
            resTimeout.unref();
          }
          return new Promise((resolve) => {
            if (stream !== upstream) {
              upstream.on("error", (er) => stream.emit("error", er));
              upstream.pipe(stream);
            }
            resolve();
          })
            .then(() => stream.concat())
            .then((buf) => {
              clearTimeout(resTimeout);
              return buf;
            })
            .catch((er) => {
              clearTimeout(resTimeout);
              if (er.name === "AbortError" || er.name === "FetchError") {
                throw er;
              } else if (er.name === "RangeError") {
                throw new FetchError(
                  `Could not create Buffer from response body for ${this.url}: ${er.message}`,
                  "system",
                  er,
                );
              } else {
                throw new FetchError(
                  `Invalid response body while trying to fetch ${this.url}: ${er.message}`,
                  "system",
                  er,
                );
              }
            });
        }
        static clone(instance) {
          if (instance.bodyUsed) {
            throw new Error("cannot clone body after it is used");
          }
          const body = instance.body;
          if (
            Minipass.isStream(body) &&
            typeof body.getBoundary !== "function"
          ) {
            const tee = new Minipass();
            const p1 = new Minipass();
            const p2 = new Minipass();
            tee.on("error", (er) => {
              p1.emit("error", er);
              p2.emit("error", er);
            });
            body.on("error", (er) => tee.emit("error", er));
            tee.pipe(p1);
            tee.pipe(p2);
            body.pipe(tee);
            instance[INTERNALS].body = p1;
            return p2;
          } else {
            return instance.body;
          }
        }
        static extractContentType(body) {
          return body === null || body === undefined
            ? null
            : typeof body === "string"
              ? "text/plain;charset=UTF-8"
              : isURLSearchParams(body)
                ? "application/x-www-form-urlencoded;charset=UTF-8"
                : isBlob(body)
                  ? body.type || null
                  : Buffer.isBuffer(body)
                    ? null
                    : Object.prototype.toString.call(body) ===
                        "[object ArrayBuffer]"
                      ? null
                      : ArrayBuffer.isView(body)
                        ? null
                        : typeof body.getBoundary === "function"
                          ? `multipart/form-data;boundary=${body.getBoundary()}`
                          : Minipass.isStream(body)
                            ? null
                            : "text/plain;charset=UTF-8";
        }
        static getTotalBytes(instance) {
          const { body } = instance;
          return body === null || body === undefined
            ? 0
            : isBlob(body)
              ? body.size
              : Buffer.isBuffer(body)
                ? body.length
                : body &&
                    typeof body.getLengthSync === "function" &&
                    ((body._lengthRetrievers &&
                      body._lengthRetrievers.length === 0) ||
                      (body.hasKnownLength && body.hasKnownLength()))
                  ? body.getLengthSync()
                  : null;
        }
        static writeToStream(dest, instance) {
          const { body } = instance;
          if (body === null || body === undefined) {
            dest.end();
          } else if (Buffer.isBuffer(body) || typeof body === "string") {
            dest.end(body);
          } else {
            const stream = isBlob(body) ? body.stream() : body;
            stream.on("error", (er) => dest.emit("error", er)).pipe(dest);
          }
          return dest;
        }
      }
      Object.defineProperties(Body.prototype, {
        body: { enumerable: true },
        bodyUsed: { enumerable: true },
        arrayBuffer: { enumerable: true },
        blob: { enumerable: true },
        json: { enumerable: true },
        text: { enumerable: true },
      });
      const isURLSearchParams = (obj) =>
        typeof obj !== "object" ||
        typeof obj.append !== "function" ||
        typeof obj.delete !== "function" ||
        typeof obj.get !== "function" ||
        typeof obj.getAll !== "function" ||
        typeof obj.has !== "function" ||
        typeof obj.set !== "function"
          ? false
          : obj.constructor.name === "URLSearchParams" ||
            Object.prototype.toString.call(obj) ===
              "[object URLSearchParams]" ||
            typeof obj.sort === "function";
      const isBlob = (obj) =>
        typeof obj === "object" &&
        typeof obj.arrayBuffer === "function" &&
        typeof obj.type === "string" &&
        typeof obj.stream === "function" &&
        typeof obj.constructor === "function" &&
        typeof obj.constructor.name === "string" &&
        /^(Blob|File)$/.test(obj.constructor.name) &&
        /^(Blob|File)$/.test(obj[Symbol.toStringTag]);
      const convertBody = (buffer, headers) => {
        if (typeof convert !== "function") {
          throw new Error(
            "The package `encoding` must be installed to use the textConverted() function",
          );
        }
        const ct = headers && headers.get("content-type");
        let charset = "utf-8";
        let res;
        if (ct) {
          res = /charset=([^;]*)/i.exec(ct);
        }
        const str = buffer.slice(0, 1024).toString();
        if (!res && str) {
          res = /<meta.+?charset=(['"])(.+?)\1/i.exec(str);
        }
        if (!res && str) {
          res =
            /<meta[\s]+?http-equiv=(['"])content-type\1[\s]+?content=(['"])(.+?)\2/i.exec(
              str,
            );
          if (!res) {
            res =
              /<meta[\s]+?content=(['"])(.+?)\1[\s]+?http-equiv=(['"])content-type\3/i.exec(
                str,
              );
            if (res) {
              res.pop();
            }
          }
          if (res) {
            res = /charset=(.*)/i.exec(res.pop());
          }
        }
        if (!res && str) {
          res = /<\?xml.+?encoding=(['"])(.+?)\1/i.exec(str);
        }
        if (res) {
          charset = res.pop();
          if (charset === "gb2312" || charset === "gbk") {
            charset = "gb18030";
          }
        }
        return convert(buffer, "UTF-8", charset).toString();
      };
      module.exports = Body;
    },
    2899: (module) => {
      "use strict";
      class FetchError extends Error {
        constructor(message, type, systemError) {
          super(message);
          this.code = "FETCH_ERROR";
          if (systemError) {
            Object.assign(this, systemError);
          }
          this.errno = this.code;
          this.type =
            this.code === "EBADSIZE" && this.found > this.expect
              ? "max-size"
              : type;
          this.message = message;
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "FetchError";
        }
        set name(n) {}
        get [Symbol.toStringTag]() {
          return "FetchError";
        }
      }
      module.exports = FetchError;
    },
    1504: (module) => {
      "use strict";
      const invalidTokenRegex = /[^^_`a-zA-Z\-0-9!#$%&'*+.|~]/;
      const invalidHeaderCharRegex = /[^\t\x20-\x7e\x80-\xff]/;
      const validateName = (name) => {
        name = `${name}`;
        if (invalidTokenRegex.test(name) || name === "") {
          throw new TypeError(`${name} is not a legal HTTP header name`);
        }
      };
      const validateValue = (value) => {
        value = `${value}`;
        if (invalidHeaderCharRegex.test(value)) {
          throw new TypeError(`${value} is not a legal HTTP header value`);
        }
      };
      const find = (map, name) => {
        name = name.toLowerCase();
        for (const key in map) {
          if (key.toLowerCase() === name) {
            return key;
          }
        }
        return undefined;
      };
      const MAP = Symbol("map");
      class Headers {
        constructor(init = undefined) {
          this[MAP] = Object.create(null);
          if (init instanceof Headers) {
            const rawHeaders = init.raw();
            const headerNames = Object.keys(rawHeaders);
            for (const headerName of headerNames) {
              for (const value of rawHeaders[headerName]) {
                this.append(headerName, value);
              }
            }
            return;
          }
          if (init === undefined || init === null) {
            return;
          }
          if (typeof init === "object") {
            const method = init[Symbol.iterator];
            if (method !== null && method !== undefined) {
              if (typeof method !== "function") {
                throw new TypeError("Header pairs must be iterable");
              }
              const pairs = [];
              for (const pair of init) {
                if (
                  typeof pair !== "object" ||
                  typeof pair[Symbol.iterator] !== "function"
                ) {
                  throw new TypeError("Each header pair must be iterable");
                }
                const arrPair = Array.from(pair);
                if (arrPair.length !== 2) {
                  throw new TypeError(
                    "Each header pair must be a name/value tuple",
                  );
                }
                pairs.push(arrPair);
              }
              for (const pair of pairs) {
                this.append(pair[0], pair[1]);
              }
            } else {
              for (const key of Object.keys(init)) {
                this.append(key, init[key]);
              }
            }
          } else {
            throw new TypeError("Provided initializer must be an object");
          }
        }
        get(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key === undefined) {
            return null;
          }
          return this[MAP][key].join(", ");
        }
        forEach(callback, thisArg = undefined) {
          let pairs = getHeaders(this);
          for (let i = 0; i < pairs.length; i++) {
            const [name, value] = pairs[i];
            callback.call(thisArg, value, name, this);
            pairs = getHeaders(this);
          }
        }
        set(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          this[MAP][key !== undefined ? key : name] = [value];
        }
        append(name, value) {
          name = `${name}`;
          value = `${value}`;
          validateName(name);
          validateValue(value);
          const key = find(this[MAP], name);
          if (key !== undefined) {
            this[MAP][key].push(value);
          } else {
            this[MAP][name] = [value];
          }
        }
        has(name) {
          name = `${name}`;
          validateName(name);
          return find(this[MAP], name) !== undefined;
        }
        delete(name) {
          name = `${name}`;
          validateName(name);
          const key = find(this[MAP], name);
          if (key !== undefined) {
            delete this[MAP][key];
          }
        }
        raw() {
          return this[MAP];
        }
        keys() {
          return new HeadersIterator(this, "key");
        }
        values() {
          return new HeadersIterator(this, "value");
        }
        [Symbol.iterator]() {
          return new HeadersIterator(this, "key+value");
        }
        entries() {
          return new HeadersIterator(this, "key+value");
        }
        get [Symbol.toStringTag]() {
          return "Headers";
        }
        static exportNodeCompatibleHeaders(headers) {
          const obj = Object.assign(Object.create(null), headers[MAP]);
          const hostHeaderKey = find(headers[MAP], "Host");
          if (hostHeaderKey !== undefined) {
            obj[hostHeaderKey] = obj[hostHeaderKey][0];
          }
          return obj;
        }
        static createHeadersLenient(obj) {
          const headers = new Headers();
          for (const name of Object.keys(obj)) {
            if (invalidTokenRegex.test(name)) {
              continue;
            }
            if (Array.isArray(obj[name])) {
              for (const val of obj[name]) {
                if (invalidHeaderCharRegex.test(val)) {
                  continue;
                }
                if (headers[MAP][name] === undefined) {
                  headers[MAP][name] = [val];
                } else {
                  headers[MAP][name].push(val);
                }
              }
            } else if (!invalidHeaderCharRegex.test(obj[name])) {
              headers[MAP][name] = [obj[name]];
            }
          }
          return headers;
        }
      }
      Object.defineProperties(Headers.prototype, {
        get: { enumerable: true },
        forEach: { enumerable: true },
        set: { enumerable: true },
        append: { enumerable: true },
        has: { enumerable: true },
        delete: { enumerable: true },
        keys: { enumerable: true },
        values: { enumerable: true },
        entries: { enumerable: true },
      });
      const getHeaders = (headers, kind = "key+value") =>
        Object.keys(headers[MAP])
          .sort()
          .map(
            kind === "key"
              ? (k) => k.toLowerCase()
              : kind === "value"
                ? (k) => headers[MAP][k].join(", ")
                : (k) => [k.toLowerCase(), headers[MAP][k].join(", ")],
          );
      const INTERNAL = Symbol("internal");
      class HeadersIterator {
        constructor(target, kind) {
          this[INTERNAL] = { target, kind, index: 0 };
        }
        get [Symbol.toStringTag]() {
          return "HeadersIterator";
        }
        next() {
          if (
            !this ||
            Object.getPrototypeOf(this) !== HeadersIterator.prototype
          ) {
            throw new TypeError("Value of `this` is not a HeadersIterator");
          }
          const { target, kind, index } = this[INTERNAL];
          const values = getHeaders(target, kind);
          const len = values.length;
          if (index >= len) {
            return { value: undefined, done: true };
          }
          this[INTERNAL].index++;
          return { value: values[index], done: false };
        }
      }
      Object.setPrototypeOf(
        HeadersIterator.prototype,
        Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]())),
      );
      module.exports = Headers;
    },
    8998: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(7310);
      const http = __nccwpck_require__(3685);
      const https = __nccwpck_require__(5687);
      const zlib = __nccwpck_require__(3486);
      const { Minipass } = __nccwpck_require__(4968);
      const Body = __nccwpck_require__(7223);
      const { writeToStream, getTotalBytes } = Body;
      const Response = __nccwpck_require__(2587);
      const Headers = __nccwpck_require__(1504);
      const { createHeadersLenient } = Headers;
      const Request = __nccwpck_require__(4410);
      const { getNodeRequestOptions } = Request;
      const FetchError = __nccwpck_require__(2899);
      const AbortError = __nccwpck_require__(1078);
      const fetch = async (url, opts) => {
        if (/^data:/.test(url)) {
          const request = new Request(url, opts);
          return Promise.resolve().then(
            () =>
              new Promise((resolve, reject) => {
                let type, data;
                try {
                  const { pathname, search } = new URL(url);
                  const split = pathname.split(",");
                  if (split.length < 2) {
                    throw new Error("invalid data: URI");
                  }
                  const mime = split.shift();
                  const base64 = /;base64$/.test(mime);
                  type = base64 ? mime.slice(0, -1 * ";base64".length) : mime;
                  const rawData = decodeURIComponent(split.join(",") + search);
                  data = base64
                    ? Buffer.from(rawData, "base64")
                    : Buffer.from(rawData);
                } catch (er) {
                  return reject(
                    new FetchError(
                      `[${request.method}] ${request.url} invalid URL, ${er.message}`,
                      "system",
                      er,
                    ),
                  );
                }
                const { signal } = request;
                if (signal && signal.aborted) {
                  return reject(new AbortError("The user aborted a request."));
                }
                const headers = { "Content-Length": data.length };
                if (type) {
                  headers["Content-Type"] = type;
                }
                return resolve(new Response(data, { headers }));
              }),
          );
        }
        return new Promise((resolve, reject) => {
          const request = new Request(url, opts);
          let options;
          try {
            options = getNodeRequestOptions(request);
          } catch (er) {
            return reject(er);
          }
          const send = (options.protocol === "https:" ? https : http).request;
          const { signal } = request;
          let response = null;
          const abort = () => {
            const error = new AbortError("The user aborted a request.");
            reject(error);
            if (
              Minipass.isStream(request.body) &&
              typeof request.body.destroy === "function"
            ) {
              request.body.destroy(error);
            }
            if (response && response.body) {
              response.body.emit("error", error);
            }
          };
          if (signal && signal.aborted) {
            return abort();
          }
          const abortAndFinalize = () => {
            abort();
            finalize();
          };
          const finalize = () => {
            req.abort();
            if (signal) {
              signal.removeEventListener("abort", abortAndFinalize);
            }
            clearTimeout(reqTimeout);
          };
          const req = send(options);
          if (signal) {
            signal.addEventListener("abort", abortAndFinalize);
          }
          let reqTimeout = null;
          if (request.timeout) {
            req.once("socket", () => {
              reqTimeout = setTimeout(() => {
                reject(
                  new FetchError(
                    `network timeout at: ${request.url}`,
                    "request-timeout",
                  ),
                );
                finalize();
              }, request.timeout);
            });
          }
          req.on("error", (er) => {
            if (req.res) {
              req.res.emit("error", er);
            }
            reject(
              new FetchError(
                `request to ${request.url} failed, reason: ${er.message}`,
                "system",
                er,
              ),
            );
            finalize();
          });
          req.on("response", (res) => {
            clearTimeout(reqTimeout);
            const headers = createHeadersLenient(res.headers);
            if (fetch.isRedirect(res.statusCode)) {
              const location = headers.get("Location");
              let locationURL = null;
              try {
                locationURL =
                  location === null
                    ? null
                    : new URL(location, request.url).toString();
              } catch {
                if (request.redirect !== "manual") {
                  reject(
                    new FetchError(
                      `uri requested responds with an invalid redirect URL: ${location}`,
                      "invalid-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
              }
              if (request.redirect === "error") {
                reject(
                  new FetchError(
                    "uri requested responds with a redirect, " +
                      `redirect mode is set to error: ${request.url}`,
                    "no-redirect",
                  ),
                );
                finalize();
                return;
              } else if (request.redirect === "manual") {
                if (locationURL !== null) {
                  try {
                    headers.set("Location", locationURL);
                  } catch (err) {
                    reject(err);
                  }
                }
              } else if (
                request.redirect === "follow" &&
                locationURL !== null
              ) {
                if (request.counter >= request.follow) {
                  reject(
                    new FetchError(
                      `maximum redirect reached at: ${request.url}`,
                      "max-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
                if (
                  res.statusCode !== 303 &&
                  request.body &&
                  getTotalBytes(request) === null
                ) {
                  reject(
                    new FetchError(
                      "Cannot follow redirect with body being a readable stream",
                      "unsupported-redirect",
                    ),
                  );
                  finalize();
                  return;
                }
                request.headers.set("host", new URL(locationURL).host);
                const requestOpts = {
                  headers: new Headers(request.headers),
                  follow: request.follow,
                  counter: request.counter + 1,
                  agent: request.agent,
                  compress: request.compress,
                  method: request.method,
                  body: request.body,
                  signal: request.signal,
                  timeout: request.timeout,
                };
                const parsedOriginal = new URL(request.url);
                const parsedRedirect = new URL(locationURL);
                if (parsedOriginal.hostname !== parsedRedirect.hostname) {
                  requestOpts.headers.delete("authorization");
                  requestOpts.headers.delete("cookie");
                }
                if (
                  res.statusCode === 303 ||
                  ((res.statusCode === 301 || res.statusCode === 302) &&
                    request.method === "POST")
                ) {
                  requestOpts.method = "GET";
                  requestOpts.body = undefined;
                  requestOpts.headers.delete("content-length");
                }
                resolve(fetch(new Request(locationURL, requestOpts)));
                finalize();
                return;
              }
            }
            res.once(
              "end",
              () =>
                signal && signal.removeEventListener("abort", abortAndFinalize),
            );
            const body = new Minipass();
            body.on("error", finalize);
            res.on("error", (er) => body.emit("error", er));
            res.on("data", (chunk) => body.write(chunk));
            res.on("end", () => body.end());
            const responseOptions = {
              url: request.url,
              status: res.statusCode,
              statusText: res.statusMessage,
              headers,
              size: request.size,
              timeout: request.timeout,
              counter: request.counter,
              trailer: new Promise((resolveTrailer) =>
                res.on("end", () =>
                  resolveTrailer(createHeadersLenient(res.trailers)),
                ),
              ),
            };
            const codings = headers.get("Content-Encoding");
            if (
              !request.compress ||
              request.method === "HEAD" ||
              codings === null ||
              res.statusCode === 204 ||
              res.statusCode === 304
            ) {
              response = new Response(body, responseOptions);
              resolve(response);
              return;
            }
            const zlibOptions = {
              flush: zlib.constants.Z_SYNC_FLUSH,
              finishFlush: zlib.constants.Z_SYNC_FLUSH,
            };
            if (codings === "gzip" || codings === "x-gzip") {
              const unzip = new zlib.Gunzip(zlibOptions);
              response = new Response(
                body.on("error", (er) => unzip.emit("error", er)).pipe(unzip),
                responseOptions,
              );
              resolve(response);
              return;
            }
            if (codings === "deflate" || codings === "x-deflate") {
              const raw = res.pipe(new Minipass());
              raw.once("data", (chunk) => {
                const decoder =
                  (chunk[0] & 15) === 8
                    ? new zlib.Inflate()
                    : new zlib.InflateRaw();
                body
                  .on("error", (er) => decoder.emit("error", er))
                  .pipe(decoder);
                response = new Response(decoder, responseOptions);
                resolve(response);
              });
              return;
            }
            if (codings === "br") {
              try {
                var decoder = new zlib.BrotliDecompress();
              } catch (err) {
                reject(err);
                finalize();
                return;
              }
              body.on("error", (er) => decoder.emit("error", er)).pipe(decoder);
              response = new Response(decoder, responseOptions);
              resolve(response);
              return;
            }
            response = new Response(body, responseOptions);
            resolve(response);
          });
          writeToStream(req, request);
        });
      };
      module.exports = fetch;
      fetch.isRedirect = (code) =>
        code === 301 ||
        code === 302 ||
        code === 303 ||
        code === 307 ||
        code === 308;
      fetch.Headers = Headers;
      fetch.Request = Request;
      fetch.Response = Response;
      fetch.FetchError = FetchError;
      fetch.AbortError = AbortError;
    },
    4410: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(7310);
      const { Minipass } = __nccwpck_require__(4968);
      const Headers = __nccwpck_require__(1504);
      const { exportNodeCompatibleHeaders } = Headers;
      const Body = __nccwpck_require__(7223);
      const { clone, extractContentType, getTotalBytes } = Body;
      const version = __nccwpck_require__(3684).version;
      const defaultUserAgent = `minipass-fetch/${version} (+https://github.com/isaacs/minipass-fetch)`;
      const INTERNALS = Symbol("Request internals");
      const isRequest = (input) =>
        typeof input === "object" && typeof input[INTERNALS] === "object";
      const isAbortSignal = (signal) => {
        const proto =
          signal && typeof signal === "object" && Object.getPrototypeOf(signal);
        return !!(proto && proto.constructor.name === "AbortSignal");
      };
      class Request extends Body {
        constructor(input, init = {}) {
          const parsedURL = isRequest(input)
            ? new URL(input.url)
            : input && input.href
              ? new URL(input.href)
              : new URL(`${input}`);
          if (isRequest(input)) {
            init = { ...input[INTERNALS], ...init };
          } else if (!input || typeof input === "string") {
            input = {};
          }
          const method = (init.method || input.method || "GET").toUpperCase();
          const isGETHEAD = method === "GET" || method === "HEAD";
          if (
            ((init.body !== null && init.body !== undefined) ||
              (isRequest(input) && input.body !== null)) &&
            isGETHEAD
          ) {
            throw new TypeError(
              "Request with GET/HEAD method cannot have body",
            );
          }
          const inputBody =
            init.body !== null && init.body !== undefined
              ? init.body
              : isRequest(input) && input.body !== null
                ? clone(input)
                : null;
          super(inputBody, {
            timeout: init.timeout || input.timeout || 0,
            size: init.size || input.size || 0,
          });
          const headers = new Headers(init.headers || input.headers || {});
          if (
            inputBody !== null &&
            inputBody !== undefined &&
            !headers.has("Content-Type")
          ) {
            const contentType = extractContentType(inputBody);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          const signal = "signal" in init ? init.signal : null;
          if (
            signal !== null &&
            signal !== undefined &&
            !isAbortSignal(signal)
          ) {
            throw new TypeError(
              "Expected signal must be an instanceof AbortSignal",
            );
          }
          const {
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized = process.env.NODE_TLS_REJECT_UNAUTHORIZED !==
              "0",
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
          } = init;
          this[INTERNALS] = {
            method,
            redirect: init.redirect || input.redirect || "follow",
            headers,
            parsedURL,
            signal,
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized,
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
          };
          this.follow =
            init.follow !== undefined
              ? init.follow
              : input.follow !== undefined
                ? input.follow
                : 20;
          this.compress =
            init.compress !== undefined
              ? init.compress
              : input.compress !== undefined
                ? input.compress
                : true;
          this.counter = init.counter || input.counter || 0;
          this.agent = init.agent || input.agent;
        }
        get method() {
          return this[INTERNALS].method;
        }
        get url() {
          return this[INTERNALS].parsedURL.toString();
        }
        get headers() {
          return this[INTERNALS].headers;
        }
        get redirect() {
          return this[INTERNALS].redirect;
        }
        get signal() {
          return this[INTERNALS].signal;
        }
        clone() {
          return new Request(this);
        }
        get [Symbol.toStringTag]() {
          return "Request";
        }
        static getNodeRequestOptions(request) {
          const parsedURL = request[INTERNALS].parsedURL;
          const headers = new Headers(request[INTERNALS].headers);
          if (!headers.has("Accept")) {
            headers.set("Accept", "*/*");
          }
          if (!/^https?:$/.test(parsedURL.protocol)) {
            throw new TypeError("Only HTTP(S) protocols are supported");
          }
          if (
            request.signal &&
            Minipass.isStream(request.body) &&
            typeof request.body.destroy !== "function"
          ) {
            throw new Error(
              "Cancellation of streamed requests with AbortSignal is not supported",
            );
          }
          const contentLengthValue =
            (request.body === null || request.body === undefined) &&
            /^(POST|PUT)$/i.test(request.method)
              ? "0"
              : request.body !== null && request.body !== undefined
                ? getTotalBytes(request)
                : null;
          if (contentLengthValue) {
            headers.set("Content-Length", contentLengthValue + "");
          }
          if (!headers.has("User-Agent")) {
            headers.set("User-Agent", defaultUserAgent);
          }
          if (request.compress && !headers.has("Accept-Encoding")) {
            headers.set("Accept-Encoding", "gzip,deflate");
          }
          const agent =
            typeof request.agent === "function"
              ? request.agent(parsedURL)
              : request.agent;
          if (!headers.has("Connection") && !agent) {
            headers.set("Connection", "close");
          }
          const {
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized,
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
          } = request[INTERNALS];
          const urlProps = {
            auth:
              parsedURL.username || parsedURL.password
                ? `${parsedURL.username}:${parsedURL.password}`
                : "",
            host: parsedURL.host,
            hostname: parsedURL.hostname,
            path: `${parsedURL.pathname}${parsedURL.search}`,
            port: parsedURL.port,
            protocol: parsedURL.protocol,
          };
          return {
            ...urlProps,
            method: request.method,
            headers: exportNodeCompatibleHeaders(headers),
            agent,
            ca,
            cert,
            ciphers,
            clientCertEngine,
            crl,
            dhparam,
            ecdhCurve,
            family,
            honorCipherOrder,
            key,
            passphrase,
            pfx,
            rejectUnauthorized,
            secureOptions,
            secureProtocol,
            servername,
            sessionIdContext,
            timeout: request.timeout,
          };
        }
      }
      module.exports = Request;
      Object.defineProperties(Request.prototype, {
        method: { enumerable: true },
        url: { enumerable: true },
        headers: { enumerable: true },
        redirect: { enumerable: true },
        clone: { enumerable: true },
        signal: { enumerable: true },
      });
    },
    2587: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const http = __nccwpck_require__(3685);
      const { STATUS_CODES } = http;
      const Headers = __nccwpck_require__(1504);
      const Body = __nccwpck_require__(7223);
      const { clone, extractContentType } = Body;
      const INTERNALS = Symbol("Response internals");
      class Response extends Body {
        constructor(body = null, opts = {}) {
          super(body, opts);
          const status = opts.status || 200;
          const headers = new Headers(opts.headers);
          if (
            body !== null &&
            body !== undefined &&
            !headers.has("Content-Type")
          ) {
            const contentType = extractContentType(body);
            if (contentType) {
              headers.append("Content-Type", contentType);
            }
          }
          this[INTERNALS] = {
            url: opts.url,
            status,
            statusText: opts.statusText || STATUS_CODES[status],
            headers,
            counter: opts.counter,
            trailer: Promise.resolve(opts.trailer || new Headers()),
          };
        }
        get trailer() {
          return this[INTERNALS].trailer;
        }
        get url() {
          return this[INTERNALS].url || "";
        }
        get status() {
          return this[INTERNALS].status;
        }
        get ok() {
          return this[INTERNALS].status >= 200 && this[INTERNALS].status < 300;
        }
        get redirected() {
          return this[INTERNALS].counter > 0;
        }
        get statusText() {
          return this[INTERNALS].statusText;
        }
        get headers() {
          return this[INTERNALS].headers;
        }
        clone() {
          return new Response(clone(this), {
            url: this.url,
            status: this.status,
            statusText: this.statusText,
            headers: this.headers,
            ok: this.ok,
            redirected: this.redirected,
            trailer: this.trailer,
          });
        }
        get [Symbol.toStringTag]() {
          return "Response";
        }
      }
      module.exports = Response;
      Object.defineProperties(Response.prototype, {
        url: { enumerable: true },
        status: { enumerable: true },
        ok: { enumerable: true },
        redirected: { enumerable: true },
        statusText: { enumerable: true },
        headers: { enumerable: true },
        clone: { enumerable: true },
      });
    },
    4181: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Minipass = __nccwpck_require__(7818);
      const _flush = Symbol("_flush");
      const _flushed = Symbol("_flushed");
      const _flushing = Symbol("_flushing");
      class Flush extends Minipass {
        constructor(opt = {}) {
          if (typeof opt === "function") opt = { flush: opt };
          super(opt);
          if (
            typeof opt.flush !== "function" &&
            typeof this.flush !== "function"
          )
            throw new TypeError("must provide flush function in options");
          this[_flush] = opt.flush || this.flush;
        }
        emit(ev, ...data) {
          if ((ev !== "end" && ev !== "finish") || this[_flushed])
            return super.emit(ev, ...data);
          if (this[_flushing]) return;
          this[_flushing] = true;
          const afterFlush = (er) => {
            this[_flushed] = true;
            er ? super.emit("error", er) : super.emit("end");
          };
          const ret = this[_flush](afterFlush);
          if (ret && ret.then)
            ret.then(
              () => afterFlush(),
              (er) => afterFlush(er),
            );
        }
      }
      module.exports = Flush;
    },
    7818: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    9891: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Minipass = __nccwpck_require__(3392);
      const EE = __nccwpck_require__(2361);
      const isStream = (s) =>
        s &&
        s instanceof EE &&
        (typeof s.pipe === "function" ||
          (typeof s.write === "function" && typeof s.end === "function"));
      const _head = Symbol("_head");
      const _tail = Symbol("_tail");
      const _linkStreams = Symbol("_linkStreams");
      const _setHead = Symbol("_setHead");
      const _setTail = Symbol("_setTail");
      const _onError = Symbol("_onError");
      const _onData = Symbol("_onData");
      const _onEnd = Symbol("_onEnd");
      const _onDrain = Symbol("_onDrain");
      const _streams = Symbol("_streams");
      class Pipeline extends Minipass {
        constructor(opts, ...streams) {
          if (isStream(opts)) {
            streams.unshift(opts);
            opts = {};
          }
          super(opts);
          this[_streams] = [];
          if (streams.length) this.push(...streams);
        }
        [_linkStreams](streams) {
          return streams.reduce((src, dest) => {
            src.on("error", (er) => dest.emit("error", er));
            src.pipe(dest);
            return dest;
          });
        }
        push(...streams) {
          this[_streams].push(...streams);
          if (this[_tail]) streams.unshift(this[_tail]);
          const linkRet = this[_linkStreams](streams);
          this[_setTail](linkRet);
          if (!this[_head]) this[_setHead](streams[0]);
        }
        unshift(...streams) {
          this[_streams].unshift(...streams);
          if (this[_head]) streams.push(this[_head]);
          const linkRet = this[_linkStreams](streams);
          this[_setHead](streams[0]);
          if (!this[_tail]) this[_setTail](linkRet);
        }
        destroy(er) {
          this[_streams].forEach(
            (s) => typeof s.destroy === "function" && s.destroy(),
          );
          return super.destroy(er);
        }
        [_setTail](stream) {
          this[_tail] = stream;
          stream.on("error", (er) => this[_onError](stream, er));
          stream.on("data", (chunk) => this[_onData](stream, chunk));
          stream.on("end", () => this[_onEnd](stream));
          stream.on("finish", () => this[_onEnd](stream));
        }
        [_onError](stream, er) {
          if (stream === this[_tail]) this.emit("error", er);
        }
        [_onData](stream, chunk) {
          if (stream === this[_tail]) super.write(chunk);
        }
        [_onEnd](stream) {
          if (stream === this[_tail]) super.end();
        }
        pause() {
          super.pause();
          return this[_tail] && this[_tail].pause && this[_tail].pause();
        }
        emit(ev, ...args) {
          if (ev === "resume" && this[_tail] && this[_tail].resume)
            this[_tail].resume();
          return super.emit(ev, ...args);
        }
        [_setHead](stream) {
          this[_head] = stream;
          stream.on("drain", () => this[_onDrain](stream));
        }
        [_onDrain](stream) {
          if (stream === this[_head]) this.emit("drain");
        }
        write(chunk, enc, cb) {
          return (
            this[_head].write(chunk, enc, cb) &&
            (this.flowing || this.buffer.length === 0)
          );
        }
        end(chunk, enc, cb) {
          this[_head].end(chunk, enc, cb);
          return this;
        }
      }
      module.exports = Pipeline;
    },
    3392: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    5952: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Minipass = __nccwpck_require__(8024);
      class SizeError extends Error {
        constructor(found, expect) {
          super(`Bad data size: expected ${expect} bytes, but got ${found}`);
          this.expect = expect;
          this.found = found;
          this.code = "EBADSIZE";
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "SizeError";
        }
      }
      class MinipassSized extends Minipass {
        constructor(options = {}) {
          super(options);
          if (options.objectMode)
            throw new TypeError(
              `${this.constructor.name} streams only work with string and buffer data`,
            );
          this.found = 0;
          this.expect = options.size;
          if (
            typeof this.expect !== "number" ||
            this.expect > Number.MAX_SAFE_INTEGER ||
            isNaN(this.expect) ||
            this.expect < 0 ||
            !isFinite(this.expect) ||
            this.expect !== Math.floor(this.expect)
          )
            throw new Error("invalid expected size: " + this.expect);
        }
        write(chunk, encoding, cb) {
          const buffer = Buffer.isBuffer(chunk)
            ? chunk
            : typeof chunk === "string"
              ? Buffer.from(
                  chunk,
                  typeof encoding === "string" ? encoding : "utf8",
                )
              : chunk;
          if (!Buffer.isBuffer(buffer)) {
            this.emit(
              "error",
              new TypeError(
                `${this.constructor.name} streams only work with string and buffer data`,
              ),
            );
            return false;
          }
          this.found += buffer.length;
          if (this.found > this.expect)
            this.emit("error", new SizeError(this.found, this.expect));
          return super.write(chunk, encoding, cb);
        }
        emit(ev, ...data) {
          if (ev === "end") {
            if (this.found !== this.expect)
              this.emit("error", new SizeError(this.found, this.expect));
          }
          return super.emit(ev, ...data);
        }
      }
      MinipassSized.SizeError = SizeError;
      module.exports = MinipassSized;
    },
    8024: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    6769: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const realZlibConstants = __nccwpck_require__(9796).constants || {
        ZLIB_VERNUM: 4736,
      };
      module.exports = Object.freeze(
        Object.assign(
          Object.create(null),
          {
            Z_NO_FLUSH: 0,
            Z_PARTIAL_FLUSH: 1,
            Z_SYNC_FLUSH: 2,
            Z_FULL_FLUSH: 3,
            Z_FINISH: 4,
            Z_BLOCK: 5,
            Z_OK: 0,
            Z_STREAM_END: 1,
            Z_NEED_DICT: 2,
            Z_ERRNO: -1,
            Z_STREAM_ERROR: -2,
            Z_DATA_ERROR: -3,
            Z_MEM_ERROR: -4,
            Z_BUF_ERROR: -5,
            Z_VERSION_ERROR: -6,
            Z_NO_COMPRESSION: 0,
            Z_BEST_SPEED: 1,
            Z_BEST_COMPRESSION: 9,
            Z_DEFAULT_COMPRESSION: -1,
            Z_FILTERED: 1,
            Z_HUFFMAN_ONLY: 2,
            Z_RLE: 3,
            Z_FIXED: 4,
            Z_DEFAULT_STRATEGY: 0,
            DEFLATE: 1,
            INFLATE: 2,
            GZIP: 3,
            GUNZIP: 4,
            DEFLATERAW: 5,
            INFLATERAW: 6,
            UNZIP: 7,
            BROTLI_DECODE: 8,
            BROTLI_ENCODE: 9,
            Z_MIN_WINDOWBITS: 8,
            Z_MAX_WINDOWBITS: 15,
            Z_DEFAULT_WINDOWBITS: 15,
            Z_MIN_CHUNK: 64,
            Z_MAX_CHUNK: Infinity,
            Z_DEFAULT_CHUNK: 16384,
            Z_MIN_MEMLEVEL: 1,
            Z_MAX_MEMLEVEL: 9,
            Z_DEFAULT_MEMLEVEL: 8,
            Z_MIN_LEVEL: -1,
            Z_MAX_LEVEL: 9,
            Z_DEFAULT_LEVEL: -1,
            BROTLI_OPERATION_PROCESS: 0,
            BROTLI_OPERATION_FLUSH: 1,
            BROTLI_OPERATION_FINISH: 2,
            BROTLI_OPERATION_EMIT_METADATA: 3,
            BROTLI_MODE_GENERIC: 0,
            BROTLI_MODE_TEXT: 1,
            BROTLI_MODE_FONT: 2,
            BROTLI_DEFAULT_MODE: 0,
            BROTLI_MIN_QUALITY: 0,
            BROTLI_MAX_QUALITY: 11,
            BROTLI_DEFAULT_QUALITY: 11,
            BROTLI_MIN_WINDOW_BITS: 10,
            BROTLI_MAX_WINDOW_BITS: 24,
            BROTLI_LARGE_MAX_WINDOW_BITS: 30,
            BROTLI_DEFAULT_WINDOW: 22,
            BROTLI_MIN_INPUT_BLOCK_BITS: 16,
            BROTLI_MAX_INPUT_BLOCK_BITS: 24,
            BROTLI_PARAM_MODE: 0,
            BROTLI_PARAM_QUALITY: 1,
            BROTLI_PARAM_LGWIN: 2,
            BROTLI_PARAM_LGBLOCK: 3,
            BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,
            BROTLI_PARAM_SIZE_HINT: 5,
            BROTLI_PARAM_LARGE_WINDOW: 6,
            BROTLI_PARAM_NPOSTFIX: 7,
            BROTLI_PARAM_NDIRECT: 8,
            BROTLI_DECODER_RESULT_ERROR: 0,
            BROTLI_DECODER_RESULT_SUCCESS: 1,
            BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,
            BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,
            BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,
            BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,
            BROTLI_DECODER_NO_ERROR: 0,
            BROTLI_DECODER_SUCCESS: 1,
            BROTLI_DECODER_NEEDS_MORE_INPUT: 2,
            BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,
            BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,
            BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,
            BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,
            BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,
            BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,
            BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,
            BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,
            BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,
            BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,
            BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,
            BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,
            BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,
            BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,
            BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,
            BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,
            BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,
            BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,
            BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,
            BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,
            BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,
            BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,
            BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,
            BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,
            BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,
            BROTLI_DECODER_ERROR_UNREACHABLE: -31,
          },
          realZlibConstants,
        ),
      );
    },
    3486: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      const assert = __nccwpck_require__(9491);
      const Buffer = __nccwpck_require__(4300).Buffer;
      const realZlib = __nccwpck_require__(9796);
      const constants = (exports.constants = __nccwpck_require__(6769));
      const Minipass = __nccwpck_require__(7557);
      const OriginalBufferConcat = Buffer.concat;
      const _superWrite = Symbol("_superWrite");
      class ZlibError extends Error {
        constructor(err) {
          super("zlib: " + err.message);
          this.code = err.code;
          this.errno = err.errno;
          if (!this.code) this.code = "ZLIB_ERROR";
          this.message = "zlib: " + err.message;
          Error.captureStackTrace(this, this.constructor);
        }
        get name() {
          return "ZlibError";
        }
      }
      const _opts = Symbol("opts");
      const _flushFlag = Symbol("flushFlag");
      const _finishFlushFlag = Symbol("finishFlushFlag");
      const _fullFlushFlag = Symbol("fullFlushFlag");
      const _handle = Symbol("handle");
      const _onError = Symbol("onError");
      const _sawError = Symbol("sawError");
      const _level = Symbol("level");
      const _strategy = Symbol("strategy");
      const _ended = Symbol("ended");
      const _defaultFullFlush = Symbol("_defaultFullFlush");
      class ZlibBase extends Minipass {
        constructor(opts, mode) {
          if (!opts || typeof opts !== "object")
            throw new TypeError("invalid options for ZlibBase constructor");
          super(opts);
          this[_sawError] = false;
          this[_ended] = false;
          this[_opts] = opts;
          this[_flushFlag] = opts.flush;
          this[_finishFlushFlag] = opts.finishFlush;
          try {
            this[_handle] = new realZlib[mode](opts);
          } catch (er) {
            throw new ZlibError(er);
          }
          this[_onError] = (err) => {
            if (this[_sawError]) return;
            this[_sawError] = true;
            this.close();
            this.emit("error", err);
          };
          this[_handle].on("error", (er) => this[_onError](new ZlibError(er)));
          this.once("end", () => this.close);
        }
        close() {
          if (this[_handle]) {
            this[_handle].close();
            this[_handle] = null;
            this.emit("close");
          }
        }
        reset() {
          if (!this[_sawError]) {
            assert(this[_handle], "zlib binding closed");
            return this[_handle].reset();
          }
        }
        flush(flushFlag) {
          if (this.ended) return;
          if (typeof flushFlag !== "number") flushFlag = this[_fullFlushFlag];
          this.write(
            Object.assign(Buffer.alloc(0), { [_flushFlag]: flushFlag }),
          );
        }
        end(chunk, encoding, cb) {
          if (chunk) this.write(chunk, encoding);
          this.flush(this[_finishFlushFlag]);
          this[_ended] = true;
          return super.end(null, null, cb);
        }
        get ended() {
          return this[_ended];
        }
        write(chunk, encoding, cb) {
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (typeof chunk === "string") chunk = Buffer.from(chunk, encoding);
          if (this[_sawError]) return;
          assert(this[_handle], "zlib binding closed");
          const nativeHandle = this[_handle]._handle;
          const originalNativeClose = nativeHandle.close;
          nativeHandle.close = () => {};
          const originalClose = this[_handle].close;
          this[_handle].close = () => {};
          Buffer.concat = (args) => args;
          let result;
          try {
            const flushFlag =
              typeof chunk[_flushFlag] === "number"
                ? chunk[_flushFlag]
                : this[_flushFlag];
            result = this[_handle]._processChunk(chunk, flushFlag);
            Buffer.concat = OriginalBufferConcat;
          } catch (err) {
            Buffer.concat = OriginalBufferConcat;
            this[_onError](new ZlibError(err));
          } finally {
            if (this[_handle]) {
              this[_handle]._handle = nativeHandle;
              nativeHandle.close = originalNativeClose;
              this[_handle].close = originalClose;
              this[_handle].removeAllListeners("error");
            }
          }
          if (this[_handle])
            this[_handle].on("error", (er) =>
              this[_onError](new ZlibError(er)),
            );
          let writeReturn;
          if (result) {
            if (Array.isArray(result) && result.length > 0) {
              writeReturn = this[_superWrite](Buffer.from(result[0]));
              for (let i = 1; i < result.length; i++) {
                writeReturn = this[_superWrite](result[i]);
              }
            } else {
              writeReturn = this[_superWrite](Buffer.from(result));
            }
          }
          if (cb) cb();
          return writeReturn;
        }
        [_superWrite](data) {
          return super.write(data);
        }
      }
      class Zlib extends ZlibBase {
        constructor(opts, mode) {
          opts = opts || {};
          opts.flush = opts.flush || constants.Z_NO_FLUSH;
          opts.finishFlush = opts.finishFlush || constants.Z_FINISH;
          super(opts, mode);
          this[_fullFlushFlag] = constants.Z_FULL_FLUSH;
          this[_level] = opts.level;
          this[_strategy] = opts.strategy;
        }
        params(level, strategy) {
          if (this[_sawError]) return;
          if (!this[_handle])
            throw new Error("cannot switch params when binding is closed");
          if (!this[_handle].params)
            throw new Error("not supported in this implementation");
          if (this[_level] !== level || this[_strategy] !== strategy) {
            this.flush(constants.Z_SYNC_FLUSH);
            assert(this[_handle], "zlib binding closed");
            const origFlush = this[_handle].flush;
            this[_handle].flush = (flushFlag, cb) => {
              this.flush(flushFlag);
              cb();
            };
            try {
              this[_handle].params(level, strategy);
            } finally {
              this[_handle].flush = origFlush;
            }
            if (this[_handle]) {
              this[_level] = level;
              this[_strategy] = strategy;
            }
          }
        }
      }
      class Deflate extends Zlib {
        constructor(opts) {
          super(opts, "Deflate");
        }
      }
      class Inflate extends Zlib {
        constructor(opts) {
          super(opts, "Inflate");
        }
      }
      const _portable = Symbol("_portable");
      class Gzip extends Zlib {
        constructor(opts) {
          super(opts, "Gzip");
          this[_portable] = opts && !!opts.portable;
        }
        [_superWrite](data) {
          if (!this[_portable]) return super[_superWrite](data);
          this[_portable] = false;
          data[9] = 255;
          return super[_superWrite](data);
        }
      }
      class Gunzip extends Zlib {
        constructor(opts) {
          super(opts, "Gunzip");
        }
      }
      class DeflateRaw extends Zlib {
        constructor(opts) {
          super(opts, "DeflateRaw");
        }
      }
      class InflateRaw extends Zlib {
        constructor(opts) {
          super(opts, "InflateRaw");
        }
      }
      class Unzip extends Zlib {
        constructor(opts) {
          super(opts, "Unzip");
        }
      }
      class Brotli extends ZlibBase {
        constructor(opts, mode) {
          opts = opts || {};
          opts.flush = opts.flush || constants.BROTLI_OPERATION_PROCESS;
          opts.finishFlush =
            opts.finishFlush || constants.BROTLI_OPERATION_FINISH;
          super(opts, mode);
          this[_fullFlushFlag] = constants.BROTLI_OPERATION_FLUSH;
        }
      }
      class BrotliCompress extends Brotli {
        constructor(opts) {
          super(opts, "BrotliCompress");
        }
      }
      class BrotliDecompress extends Brotli {
        constructor(opts) {
          super(opts, "BrotliDecompress");
        }
      }
      exports.Deflate = Deflate;
      exports.Inflate = Inflate;
      exports.Gzip = Gzip;
      exports.Gunzip = Gunzip;
      exports.DeflateRaw = DeflateRaw;
      exports.InflateRaw = InflateRaw;
      exports.Unzip = Unzip;
      if (typeof realZlib.BrotliCompress === "function") {
        exports.BrotliCompress = BrotliCompress;
        exports.BrotliDecompress = BrotliDecompress;
      } else {
        exports.BrotliCompress = exports.BrotliDecompress = class {
          constructor() {
            throw new Error(
              "Brotli is not supported in this version of Node.js",
            );
          }
        };
      }
    },
    7557: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const EE = __nccwpck_require__(2361);
      const Stream = __nccwpck_require__(2781);
      const SD = __nccwpck_require__(1576).StringDecoder;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const defer = (fn) => Promise.resolve().then(fn);
      const doIter = global._MP_NO_ITERATOR_SYMBOLS_ !== "1";
      const ASYNCITERATOR =
        (doIter && Symbol.asyncIterator) ||
        Symbol("asyncIterator not implemented");
      const ITERATOR =
        (doIter && Symbol.iterator) || Symbol("iterator not implemented");
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBuffer = (b) =>
        b instanceof ArrayBuffer ||
        (typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors() {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      module.exports = class Minipass extends Stream {
        constructor(options) {
          super();
          this[FLOWING] = false;
          this[PAUSED] = false;
          this.pipes = [];
          this.buffer = [];
          this[OBJECTMODE] = (options && options.objectMode) || false;
          if (this[OBJECTMODE]) this[ENCODING] = null;
          else this[ENCODING] = (options && options.encoding) || null;
          if (this[ENCODING] === "buffer") this[ENCODING] = null;
          this[ASYNC] = (options && !!options.async) || false;
          this[DECODER] = this[ENCODING] ? new SD(this[ENCODING]) : null;
          this[EOF] = false;
          this[EMITTED_END] = false;
          this[EMITTING_END] = false;
          this[CLOSED] = false;
          this[EMITTED_ERROR] = null;
          this.writable = true;
          this.readable = true;
          this[BUFFERLENGTH] = 0;
          this[DESTROYED] = false;
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(enc) {
          if (this[OBJECTMODE])
            throw new Error("cannot set encoding in objectMode");
          if (
            this[ENCODING] &&
            enc !== this[ENCODING] &&
            ((this[DECODER] && this[DECODER].lastNeed) || this[BUFFERLENGTH])
          )
            throw new Error("cannot change encoding");
          if (this[ENCODING] !== enc) {
            this[DECODER] = enc ? new SD(enc) : null;
            if (this.buffer.length)
              this.buffer = this.buffer.map((chunk) =>
                this[DECODER].write(chunk),
              );
          }
          this[ENCODING] = enc;
        }
        setEncoding(enc) {
          this.encoding = enc;
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(om) {
          this[OBJECTMODE] = this[OBJECTMODE] || !!om;
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        write(chunk, encoding, cb) {
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : (f) => f();
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk))
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            else if (isArrayBuffer(chunk)) chunk = Buffer.from(chunk);
            else if (typeof chunk !== "string") this.objectMode = true;
          }
          if (this[OBJECTMODE]) {
            if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this.flowing) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this.flowing;
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER].lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING])
            chunk = this[DECODER].write(chunk);
          if (this.flowing && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this.flowing) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this.flowing;
        }
        read(n) {
          if (this[DESTROYED]) return null;
          if (this[BUFFERLENGTH] === 0 || n === 0 || n > this[BUFFERLENGTH]) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this.buffer.length > 1 && !this[OBJECTMODE]) {
            if (this.encoding) this.buffer = [this.buffer.join("")];
            else this.buffer = [Buffer.concat(this.buffer, this[BUFFERLENGTH])];
          }
          const ret = this[READ](n || null, this.buffer[0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (n === chunk.length || n === null) this[BUFFERSHIFT]();
          else {
            this.buffer[0] = chunk.slice(n);
            chunk = chunk.slice(0, n);
            this[BUFFERLENGTH] -= n;
          }
          this.emit("data", chunk);
          if (!this.buffer.length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") (cb = chunk), (chunk = null);
          if (typeof encoding === "function")
            (cb = encoding), (encoding = "utf8");
          if (chunk) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this.flowing || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this.buffer.length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this.buffer.push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this.buffer.length) {
            if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
            else this[BUFFERLENGTH] -= this.buffer[0].length;
          }
          return this.buffer.shift();
        }
        [FLUSH](noDrain) {
          do {} while (this[FLUSHCHUNK](this[BUFFERSHIFT]()));
          if (!noDrain && !this.buffer.length && !this[EOF]) this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          return chunk ? (this.emit("data", chunk), this.flowing) : false;
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this.pipes.push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this.pipes.find((p) => p.dest === dest);
          if (p) {
            this.pipes.splice(this.pipes.indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, fn) {
          return this.on(ev, fn);
        }
        on(ev, fn) {
          const ret = super.on(ev, fn);
          if (ev === "data" && !this.pipes.length && !this.flowing)
            this[RESUME]();
          else if (ev === "readable" && this[BUFFERLENGTH] !== 0)
            super.emit("readable");
          else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            if (this[ASYNC]) defer(() => fn.call(this, this[EMITTED_ERROR]));
            else fn.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this.buffer.length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, data, ...extra) {
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          )
            return;
          else if (ev === "data") {
            return !data
              ? false
              : this[ASYNC]
                ? defer(() => this[EMITDATA](data))
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            const ret = super.emit("error", data);
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, data, ...extra);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this.pipes) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return;
          this[EMITTED_END] = true;
          this.readable = false;
          if (this[ASYNC]) defer(() => this[EMITEND2]());
          else this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this.pipes) {
                p.dest.write(data);
              }
              super.emit("data", data);
            }
          }
          for (const p of this.pipes) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        collect() {
          const buf = [];
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          return p.then(() => buf);
        }
        concat() {
          return this[OBJECTMODE]
            ? Promise.reject(new Error("cannot concat in objectMode"))
            : this.collect().then((buf) =>
                this[OBJECTMODE]
                  ? Promise.reject(new Error("cannot concat in objectMode"))
                  : this[ENCODING]
                    ? buf.join("")
                    : Buffer.concat(buf, buf.dataLength),
              );
        }
        promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [ASYNCITERATOR]() {
          const next = () => {
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return Promise.resolve({ done: true });
            let resolve = null;
            let reject = null;
            const onerr = (er) => {
              this.removeListener("data", ondata);
              this.removeListener("end", onend);
              reject(er);
            };
            const ondata = (value) => {
              this.removeListener("error", onerr);
              this.removeListener("end", onend);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.removeListener("error", onerr);
              this.removeListener("data", ondata);
              resolve({ done: true });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return { next };
        }
        [ITERATOR]() {
          const next = () => {
            const value = this.read();
            const done = value === null;
            return { value, done };
          };
          return { next };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this.buffer.length = 0;
          this[BUFFERLENGTH] = 0;
          if (typeof this.close === "function" && !this[CLOSED]) this.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static isStream(s) {
          return (
            !!s &&
            (s instanceof Minipass ||
              s instanceof Stream ||
              (s instanceof EE &&
                (typeof s.pipe === "function" ||
                  (typeof s.write === "function" &&
                    typeof s.end === "function"))))
          );
        }
      };
    },
    900: (module) => {
      var s = 1e3;
      var m = s * 60;
      var h = m * 60;
      var d = h * 24;
      var w = d * 7;
      var y = d * 365.25;
      module.exports = function (val, options) {
        options = options || {};
        var type = typeof val;
        if (type === "string" && val.length > 0) {
          return parse(val);
        } else if (type === "number" && isFinite(val)) {
          return options.long ? fmtLong(val) : fmtShort(val);
        }
        throw new Error(
          "val is not a non-empty string or a valid number. val=" +
            JSON.stringify(val),
        );
      };
      function parse(str) {
        str = String(str);
        if (str.length > 100) {
          return;
        }
        var match =
          /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
            str,
          );
        if (!match) {
          return;
        }
        var n = parseFloat(match[1]);
        var type = (match[2] || "ms").toLowerCase();
        switch (type) {
          case "years":
          case "year":
          case "yrs":
          case "yr":
          case "y":
            return n * y;
          case "weeks":
          case "week":
          case "w":
            return n * w;
          case "days":
          case "day":
          case "d":
            return n * d;
          case "hours":
          case "hour":
          case "hrs":
          case "hr":
          case "h":
            return n * h;
          case "minutes":
          case "minute":
          case "mins":
          case "min":
          case "m":
            return n * m;
          case "seconds":
          case "second":
          case "secs":
          case "sec":
          case "s":
            return n * s;
          case "milliseconds":
          case "millisecond":
          case "msecs":
          case "msec":
          case "ms":
            return n;
          default:
            return undefined;
        }
      }
      function fmtShort(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return Math.round(ms / d) + "d";
        }
        if (msAbs >= h) {
          return Math.round(ms / h) + "h";
        }
        if (msAbs >= m) {
          return Math.round(ms / m) + "m";
        }
        if (msAbs >= s) {
          return Math.round(ms / s) + "s";
        }
        return ms + "ms";
      }
      function fmtLong(ms) {
        var msAbs = Math.abs(ms);
        if (msAbs >= d) {
          return plural(ms, msAbs, d, "day");
        }
        if (msAbs >= h) {
          return plural(ms, msAbs, h, "hour");
        }
        if (msAbs >= m) {
          return plural(ms, msAbs, m, "minute");
        }
        if (msAbs >= s) {
          return plural(ms, msAbs, s, "second");
        }
        return ms + " ms";
      }
      function plural(ms, msAbs, n, name) {
        var isPlural = msAbs >= n * 1.5;
        return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
      }
    },
    5385: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      /*!
       * negotiator
       * Copyright(c) 2012 Federico Romero
       * Copyright(c) 2012-2014 Isaac Z. Schlueter
       * Copyright(c) 2015 Douglas Christopher Wilson
       * MIT Licensed
       */ var preferredCharsets = __nccwpck_require__(9296);
      var preferredEncodings = __nccwpck_require__(5297);
      var preferredLanguages = __nccwpck_require__(9722);
      var preferredMediaTypes = __nccwpck_require__(2563);
      module.exports = Negotiator;
      module.exports.Negotiator = Negotiator;
      function Negotiator(request) {
        if (!(this instanceof Negotiator)) {
          return new Negotiator(request);
        }
        this.request = request;
      }
      Negotiator.prototype.charset = function charset(available) {
        var set = this.charsets(available);
        return set && set[0];
      };
      Negotiator.prototype.charsets = function charsets(available) {
        return preferredCharsets(
          this.request.headers["accept-charset"],
          available,
        );
      };
      Negotiator.prototype.encoding = function encoding(available, preferred) {
        var set = this.encodings(available, preferred);
        return set && set[0];
      };
      Negotiator.prototype.encodings = function encodings(
        available,
        preferred,
      ) {
        return preferredEncodings(
          this.request.headers["accept-encoding"],
          available,
          preferred,
        );
      };
      Negotiator.prototype.language = function language(available) {
        var set = this.languages(available);
        return set && set[0];
      };
      Negotiator.prototype.languages = function languages(available) {
        return preferredLanguages(
          this.request.headers["accept-language"],
          available,
        );
      };
      Negotiator.prototype.mediaType = function mediaType(available) {
        var set = this.mediaTypes(available);
        return set && set[0];
      };
      Negotiator.prototype.mediaTypes = function mediaTypes(available) {
        return preferredMediaTypes(this.request.headers.accept, available);
      };
      Negotiator.prototype.preferredCharset = Negotiator.prototype.charset;
      Negotiator.prototype.preferredCharsets = Negotiator.prototype.charsets;
      Negotiator.prototype.preferredEncoding = Negotiator.prototype.encoding;
      Negotiator.prototype.preferredEncodings = Negotiator.prototype.encodings;
      Negotiator.prototype.preferredLanguage = Negotiator.prototype.language;
      Negotiator.prototype.preferredLanguages = Negotiator.prototype.languages;
      Negotiator.prototype.preferredMediaType = Negotiator.prototype.mediaType;
      Negotiator.prototype.preferredMediaTypes =
        Negotiator.prototype.mediaTypes;
    },
    9296: (module) => {
      "use strict";
      module.exports = preferredCharsets;
      module.exports.preferredCharsets = preferredCharsets;
      var simpleCharsetRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
      function parseAcceptCharset(accept) {
        var accepts = accept.split(",");
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var charset = parseCharset(accepts[i].trim(), i);
          if (charset) {
            accepts[j++] = charset;
          }
        }
        accepts.length = j;
        return accepts;
      }
      function parseCharset(str, i) {
        var match = simpleCharsetRegExp.exec(str);
        if (!match) return null;
        var charset = match[1];
        var q = 1;
        if (match[2]) {
          var params = match[2].split(";");
          for (var j = 0; j < params.length; j++) {
            var p = params[j].trim().split("=");
            if (p[0] === "q") {
              q = parseFloat(p[1]);
              break;
            }
          }
        }
        return { charset, q, i };
      }
      function getCharsetPriority(charset, accepted, index) {
        var priority = { o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(charset, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(charset, spec, index) {
        var s = 0;
        if (spec.charset.toLowerCase() === charset.toLowerCase()) {
          s |= 1;
        } else if (spec.charset !== "*") {
          return null;
        }
        return { i: index, o: spec.i, q: spec.q, s };
      }
      function preferredCharsets(accept, provided) {
        var accepts = parseAcceptCharset(
          accept === undefined ? "*" : accept || "",
        );
        if (!provided) {
          return accepts
            .filter(isQuality)
            .sort(compareSpecs)
            .map(getFullCharset);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getCharsetPriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(compareSpecs)
          .map(function getCharset(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
      }
      function getFullCharset(spec) {
        return spec.charset;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
    },
    5297: (module) => {
      "use strict";
      module.exports = preferredEncodings;
      module.exports.preferredEncodings = preferredEncodings;
      var simpleEncodingRegExp = /^\s*([^\s;]+)\s*(?:;(.*))?$/;
      function parseAcceptEncoding(accept) {
        var accepts = accept.split(",");
        var hasIdentity = false;
        var minQuality = 1;
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var encoding = parseEncoding(accepts[i].trim(), i);
          if (encoding) {
            accepts[j++] = encoding;
            hasIdentity = hasIdentity || specify("identity", encoding);
            minQuality = Math.min(minQuality, encoding.q || 1);
          }
        }
        if (!hasIdentity) {
          accepts[j++] = { encoding: "identity", q: minQuality, i };
        }
        accepts.length = j;
        return accepts;
      }
      function parseEncoding(str, i) {
        var match = simpleEncodingRegExp.exec(str);
        if (!match) return null;
        var encoding = match[1];
        var q = 1;
        if (match[2]) {
          var params = match[2].split(";");
          for (var j = 0; j < params.length; j++) {
            var p = params[j].trim().split("=");
            if (p[0] === "q") {
              q = parseFloat(p[1]);
              break;
            }
          }
        }
        return { encoding, q, i };
      }
      function getEncodingPriority(encoding, accepted, index) {
        var priority = { encoding, o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(encoding, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(encoding, spec, index) {
        var s = 0;
        if (spec.encoding.toLowerCase() === encoding.toLowerCase()) {
          s |= 1;
        } else if (spec.encoding !== "*") {
          return null;
        }
        return { encoding, i: index, o: spec.i, q: spec.q, s };
      }
      function preferredEncodings(accept, provided, preferred) {
        var accepts = parseAcceptEncoding(accept || "");
        var comparator = preferred
          ? function comparator(a, b) {
              if (a.q !== b.q) {
                return b.q - a.q;
              }
              var aPreferred = preferred.indexOf(a.encoding);
              var bPreferred = preferred.indexOf(b.encoding);
              if (aPreferred === -1 && bPreferred === -1) {
                return b.s - a.s || a.o - b.o || a.i - b.i;
              }
              if (aPreferred !== -1 && bPreferred !== -1) {
                return aPreferred - bPreferred;
              }
              return aPreferred === -1 ? 1 : -1;
            }
          : compareSpecs;
        if (!provided) {
          return accepts
            .filter(isQuality)
            .sort(comparator)
            .map(getFullEncoding);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getEncodingPriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(comparator)
          .map(function getEncoding(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i;
      }
      function getFullEncoding(spec) {
        return spec.encoding;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
    },
    9722: (module) => {
      "use strict";
      module.exports = preferredLanguages;
      module.exports.preferredLanguages = preferredLanguages;
      var simpleLanguageRegExp = /^\s*([^\s\-;]+)(?:-([^\s;]+))?\s*(?:;(.*))?$/;
      function parseAcceptLanguage(accept) {
        var accepts = accept.split(",");
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var language = parseLanguage(accepts[i].trim(), i);
          if (language) {
            accepts[j++] = language;
          }
        }
        accepts.length = j;
        return accepts;
      }
      function parseLanguage(str, i) {
        var match = simpleLanguageRegExp.exec(str);
        if (!match) return null;
        var prefix = match[1];
        var suffix = match[2];
        var full = prefix;
        if (suffix) full += "-" + suffix;
        var q = 1;
        if (match[3]) {
          var params = match[3].split(";");
          for (var j = 0; j < params.length; j++) {
            var p = params[j].split("=");
            if (p[0] === "q") q = parseFloat(p[1]);
          }
        }
        return { prefix, suffix, q, i, full };
      }
      function getLanguagePriority(language, accepted, index) {
        var priority = { o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(language, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(language, spec, index) {
        var p = parseLanguage(language);
        if (!p) return null;
        var s = 0;
        if (spec.full.toLowerCase() === p.full.toLowerCase()) {
          s |= 4;
        } else if (spec.prefix.toLowerCase() === p.full.toLowerCase()) {
          s |= 2;
        } else if (spec.full.toLowerCase() === p.prefix.toLowerCase()) {
          s |= 1;
        } else if (spec.full !== "*") {
          return null;
        }
        return { i: index, o: spec.i, q: spec.q, s };
      }
      function preferredLanguages(accept, provided) {
        var accepts = parseAcceptLanguage(
          accept === undefined ? "*" : accept || "",
        );
        if (!provided) {
          return accepts
            .filter(isQuality)
            .sort(compareSpecs)
            .map(getFullLanguage);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getLanguagePriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(compareSpecs)
          .map(function getLanguage(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
      }
      function getFullLanguage(spec) {
        return spec.full;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
    },
    2563: (module) => {
      "use strict";
      module.exports = preferredMediaTypes;
      module.exports.preferredMediaTypes = preferredMediaTypes;
      var simpleMediaTypeRegExp = /^\s*([^\s\/;]+)\/([^;\s]+)\s*(?:;(.*))?$/;
      function parseAccept(accept) {
        var accepts = splitMediaTypes(accept);
        for (var i = 0, j = 0; i < accepts.length; i++) {
          var mediaType = parseMediaType(accepts[i].trim(), i);
          if (mediaType) {
            accepts[j++] = mediaType;
          }
        }
        accepts.length = j;
        return accepts;
      }
      function parseMediaType(str, i) {
        var match = simpleMediaTypeRegExp.exec(str);
        if (!match) return null;
        var params = Object.create(null);
        var q = 1;
        var subtype = match[2];
        var type = match[1];
        if (match[3]) {
          var kvps = splitParameters(match[3]).map(splitKeyValuePair);
          for (var j = 0; j < kvps.length; j++) {
            var pair = kvps[j];
            var key = pair[0].toLowerCase();
            var val = pair[1];
            var value =
              val && val[0] === '"' && val[val.length - 1] === '"'
                ? val.slice(1, -1)
                : val;
            if (key === "q") {
              q = parseFloat(value);
              break;
            }
            params[key] = value;
          }
        }
        return { type, subtype, params, q, i };
      }
      function getMediaTypePriority(type, accepted, index) {
        var priority = { o: -1, q: 0, s: 0 };
        for (var i = 0; i < accepted.length; i++) {
          var spec = specify(type, accepted[i], index);
          if (
            spec &&
            (priority.s - spec.s ||
              priority.q - spec.q ||
              priority.o - spec.o) < 0
          ) {
            priority = spec;
          }
        }
        return priority;
      }
      function specify(type, spec, index) {
        var p = parseMediaType(type);
        var s = 0;
        if (!p) {
          return null;
        }
        if (spec.type.toLowerCase() == p.type.toLowerCase()) {
          s |= 4;
        } else if (spec.type != "*") {
          return null;
        }
        if (spec.subtype.toLowerCase() == p.subtype.toLowerCase()) {
          s |= 2;
        } else if (spec.subtype != "*") {
          return null;
        }
        var keys = Object.keys(spec.params);
        if (keys.length > 0) {
          if (
            keys.every(function (k) {
              return (
                spec.params[k] == "*" ||
                (spec.params[k] || "").toLowerCase() ==
                  (p.params[k] || "").toLowerCase()
              );
            })
          ) {
            s |= 1;
          } else {
            return null;
          }
        }
        return { i: index, o: spec.i, q: spec.q, s };
      }
      function preferredMediaTypes(accept, provided) {
        var accepts = parseAccept(accept === undefined ? "*/*" : accept || "");
        if (!provided) {
          return accepts.filter(isQuality).sort(compareSpecs).map(getFullType);
        }
        var priorities = provided.map(function getPriority(type, index) {
          return getMediaTypePriority(type, accepts, index);
        });
        return priorities
          .filter(isQuality)
          .sort(compareSpecs)
          .map(function getType(priority) {
            return provided[priorities.indexOf(priority)];
          });
      }
      function compareSpecs(a, b) {
        return b.q - a.q || b.s - a.s || a.o - b.o || a.i - b.i || 0;
      }
      function getFullType(spec) {
        return spec.type + "/" + spec.subtype;
      }
      function isQuality(spec) {
        return spec.q > 0;
      }
      function quoteCount(string) {
        var count = 0;
        var index = 0;
        while ((index = string.indexOf('"', index)) !== -1) {
          count++;
          index++;
        }
        return count;
      }
      function splitKeyValuePair(str) {
        var index = str.indexOf("=");
        var key;
        var val;
        if (index === -1) {
          key = str;
        } else {
          key = str.slice(0, index);
          val = str.slice(index + 1);
        }
        return [key, val];
      }
      function splitMediaTypes(accept) {
        var accepts = accept.split(",");
        for (var i = 1, j = 0; i < accepts.length; i++) {
          if (quoteCount(accepts[j]) % 2 == 0) {
            accepts[++j] = accepts[i];
          } else {
            accepts[j] += "," + accepts[i];
          }
        }
        accepts.length = j + 1;
        return accepts;
      }
      function splitParameters(str) {
        var parameters = str.split(";");
        for (var i = 1, j = 0; i < parameters.length; i++) {
          if (quoteCount(parameters[j]) % 2 == 0) {
            parameters[++j] = parameters[i];
          } else {
            parameters[j] += ";" + parameters[i];
          }
        }
        parameters.length = j + 1;
        for (var i = 0; i < parameters.length; i++) {
          parameters[i] = parameters[i].trim();
        }
        return parameters;
      }
    },
    6976: (module) => {
      module.exports = extractDescription;
      function extractDescription(d) {
        if (!d) {
          return;
        }
        if (d === "ERROR: No README data found!") {
          return;
        }
        d = d.trim().split("\n");
        let s = 0;
        while (d[s] && d[s].trim().match(/^(#|$)/)) {
          s++;
        }
        const l = d.length;
        let e = s + 1;
        while (e < l && d[e].trim()) {
          e++;
        }
        return d.slice(s, e).join(" ").trim();
      }
    },
    3492: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var isValidSemver = __nccwpck_require__(9601);
      var cleanSemver = __nccwpck_require__(8848);
      var validateLicense = __nccwpck_require__(2524);
      var hostedGitInfo = __nccwpck_require__(167);
      var moduleBuiltin = __nccwpck_require__(2033);
      var depTypes = [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
      ];
      var extractDescription = __nccwpck_require__(6976);
      var url = __nccwpck_require__(7310);
      var typos = __nccwpck_require__(1947);
      var isEmail = (str) =>
        str.includes("@") && str.indexOf("@") < str.lastIndexOf(".");
      module.exports = {
        warn: function () {},
        fixRepositoryField: function (data) {
          if (data.repositories) {
            this.warn("repositories");
            data.repository = data.repositories[0];
          }
          if (!data.repository) {
            return this.warn("missingRepository");
          }
          if (typeof data.repository === "string") {
            data.repository = { type: "git", url: data.repository };
          }
          var r = data.repository.url || "";
          if (r) {
            var hosted = hostedGitInfo.fromUrl(r);
            if (hosted) {
              r = data.repository.url =
                hosted.getDefaultRepresentation() === "shortcut"
                  ? hosted.https()
                  : hosted.toString();
            }
          }
          if (r.match(/github.com\/[^/]+\/[^/]+\.git\.git$/)) {
            this.warn("brokenGitUrl", r);
          }
        },
        fixTypos: function (data) {
          Object.keys(typos.topLevel).forEach(function (d) {
            if (Object.prototype.hasOwnProperty.call(data, d)) {
              this.warn("typo", d, typos.topLevel[d]);
            }
          }, this);
        },
        fixScriptsField: function (data) {
          if (!data.scripts) {
            return;
          }
          if (typeof data.scripts !== "object") {
            this.warn("nonObjectScripts");
            delete data.scripts;
            return;
          }
          Object.keys(data.scripts).forEach(function (k) {
            if (typeof data.scripts[k] !== "string") {
              this.warn("nonStringScript");
              delete data.scripts[k];
            } else if (typos.script[k] && !data.scripts[typos.script[k]]) {
              this.warn("typo", k, typos.script[k], "scripts");
            }
          }, this);
        },
        fixFilesField: function (data) {
          var files = data.files;
          if (files && !Array.isArray(files)) {
            this.warn("nonArrayFiles");
            delete data.files;
          } else if (data.files) {
            data.files = data.files.filter(function (file) {
              if (!file || typeof file !== "string") {
                this.warn("invalidFilename", file);
                return false;
              } else {
                return true;
              }
            }, this);
          }
        },
        fixBinField: function (data) {
          if (!data.bin) {
            return;
          }
          if (typeof data.bin === "string") {
            var b = {};
            var match;
            if ((match = data.name.match(/^@[^/]+[/](.*)$/))) {
              b[match[1]] = data.bin;
            } else {
              b[data.name] = data.bin;
            }
            data.bin = b;
          }
        },
        fixManField: function (data) {
          if (!data.man) {
            return;
          }
          if (typeof data.man === "string") {
            data.man = [data.man];
          }
        },
        fixBundleDependenciesField: function (data) {
          var bdd = "bundledDependencies";
          var bd = "bundleDependencies";
          if (data[bdd] && !data[bd]) {
            data[bd] = data[bdd];
            delete data[bdd];
          }
          if (data[bd] && !Array.isArray(data[bd])) {
            this.warn("nonArrayBundleDependencies");
            delete data[bd];
          } else if (data[bd]) {
            data[bd] = data[bd].filter(function (filtered) {
              if (!filtered || typeof filtered !== "string") {
                this.warn("nonStringBundleDependency", filtered);
                return false;
              } else {
                if (!data.dependencies) {
                  data.dependencies = {};
                }
                if (
                  !Object.prototype.hasOwnProperty.call(
                    data.dependencies,
                    filtered,
                  )
                ) {
                  this.warn("nonDependencyBundleDependency", filtered);
                  data.dependencies[filtered] = "*";
                }
                return true;
              }
            }, this);
          }
        },
        fixDependencies: function (data) {
          objectifyDeps(data, this.warn);
          addOptionalDepsToDeps(data, this.warn);
          this.fixBundleDependenciesField(data);
          ["dependencies", "devDependencies"].forEach(function (deps) {
            if (!(deps in data)) {
              return;
            }
            if (!data[deps] || typeof data[deps] !== "object") {
              this.warn("nonObjectDependencies", deps);
              delete data[deps];
              return;
            }
            Object.keys(data[deps]).forEach(function (d) {
              var r = data[deps][d];
              if (typeof r !== "string") {
                this.warn("nonStringDependency", d, JSON.stringify(r));
                delete data[deps][d];
              }
              var hosted = hostedGitInfo.fromUrl(data[deps][d]);
              if (hosted) {
                data[deps][d] = hosted.toString();
              }
            }, this);
          }, this);
        },
        fixModulesField: function (data) {
          if (data.modules) {
            this.warn("deprecatedModules");
            delete data.modules;
          }
        },
        fixKeywordsField: function (data) {
          if (typeof data.keywords === "string") {
            data.keywords = data.keywords.split(/,\s+/);
          }
          if (data.keywords && !Array.isArray(data.keywords)) {
            delete data.keywords;
            this.warn("nonArrayKeywords");
          } else if (data.keywords) {
            data.keywords = data.keywords.filter(function (kw) {
              if (typeof kw !== "string" || !kw) {
                this.warn("nonStringKeyword");
                return false;
              } else {
                return true;
              }
            }, this);
          }
        },
        fixVersionField: function (data, strict) {
          var loose = !strict;
          if (!data.version) {
            data.version = "";
            return true;
          }
          if (!isValidSemver(data.version, loose)) {
            throw new Error('Invalid version: "' + data.version + '"');
          }
          data.version = cleanSemver(data.version, loose);
          return true;
        },
        fixPeople: function (data) {
          modifyPeople(data, unParsePerson);
          modifyPeople(data, parsePerson);
        },
        fixNameField: function (data, options) {
          if (typeof options === "boolean") {
            options = { strict: options };
          } else if (typeof options === "undefined") {
            options = {};
          }
          var strict = options.strict;
          if (!data.name && !strict) {
            data.name = "";
            return;
          }
          if (typeof data.name !== "string") {
            throw new Error("name field must be a string.");
          }
          if (!strict) {
            data.name = data.name.trim();
          }
          ensureValidName(data.name, strict, options.allowLegacyCase);
          if (moduleBuiltin.builtinModules.includes(data.name)) {
            this.warn("conflictingName", data.name);
          }
        },
        fixDescriptionField: function (data) {
          if (data.description && typeof data.description !== "string") {
            this.warn("nonStringDescription");
            delete data.description;
          }
          if (data.readme && !data.description) {
            data.description = extractDescription(data.readme);
          }
          if (data.description === undefined) {
            delete data.description;
          }
          if (!data.description) {
            this.warn("missingDescription");
          }
        },
        fixReadmeField: function (data) {
          if (!data.readme) {
            this.warn("missingReadme");
            data.readme = "ERROR: No README data found!";
          }
        },
        fixBugsField: function (data) {
          if (!data.bugs && data.repository && data.repository.url) {
            var hosted = hostedGitInfo.fromUrl(data.repository.url);
            if (hosted && hosted.bugs()) {
              data.bugs = { url: hosted.bugs() };
            }
          } else if (data.bugs) {
            if (typeof data.bugs === "string") {
              if (isEmail(data.bugs)) {
                data.bugs = { email: data.bugs };
              } else if (url.parse(data.bugs).protocol) {
                data.bugs = { url: data.bugs };
              } else {
                this.warn("nonEmailUrlBugsString");
              }
            } else {
              bugsTypos(data.bugs, this.warn);
              var oldBugs = data.bugs;
              data.bugs = {};
              if (oldBugs.url) {
                if (
                  typeof oldBugs.url === "string" &&
                  url.parse(oldBugs.url).protocol
                ) {
                  data.bugs.url = oldBugs.url;
                } else {
                  this.warn("nonUrlBugsUrlField");
                }
              }
              if (oldBugs.email) {
                if (
                  typeof oldBugs.email === "string" &&
                  isEmail(oldBugs.email)
                ) {
                  data.bugs.email = oldBugs.email;
                } else {
                  this.warn("nonEmailBugsEmailField");
                }
              }
            }
            if (!data.bugs.email && !data.bugs.url) {
              delete data.bugs;
              this.warn("emptyNormalizedBugs");
            }
          }
        },
        fixHomepageField: function (data) {
          if (!data.homepage && data.repository && data.repository.url) {
            var hosted = hostedGitInfo.fromUrl(data.repository.url);
            if (hosted && hosted.docs()) {
              data.homepage = hosted.docs();
            }
          }
          if (!data.homepage) {
            return;
          }
          if (typeof data.homepage !== "string") {
            this.warn("nonUrlHomepage");
            return delete data.homepage;
          }
          if (!url.parse(data.homepage).protocol) {
            data.homepage = "http://" + data.homepage;
          }
        },
        fixLicenseField: function (data) {
          const license = data.license || data.licence;
          if (!license) {
            return this.warn("missingLicense");
          }
          if (
            typeof license !== "string" ||
            license.length < 1 ||
            license.trim() === ""
          ) {
            return this.warn("invalidLicense");
          }
          if (!validateLicense(license).validForNewPackages) {
            return this.warn("invalidLicense");
          }
        },
      };
      function isValidScopedPackageName(spec) {
        if (spec.charAt(0) !== "@") {
          return false;
        }
        var rest = spec.slice(1).split("/");
        if (rest.length !== 2) {
          return false;
        }
        return (
          rest[0] &&
          rest[1] &&
          rest[0] === encodeURIComponent(rest[0]) &&
          rest[1] === encodeURIComponent(rest[1])
        );
      }
      function isCorrectlyEncodedName(spec) {
        return !spec.match(/[/@\s+%:]/) && spec === encodeURIComponent(spec);
      }
      function ensureValidName(name, strict, allowLegacyCase) {
        if (
          name.charAt(0) === "." ||
          !(isValidScopedPackageName(name) || isCorrectlyEncodedName(name)) ||
          (strict && !allowLegacyCase && name !== name.toLowerCase()) ||
          name.toLowerCase() === "node_modules" ||
          name.toLowerCase() === "favicon.ico"
        ) {
          throw new Error("Invalid name: " + JSON.stringify(name));
        }
      }
      function modifyPeople(data, fn) {
        if (data.author) {
          data.author = fn(data.author);
        }
        ["maintainers", "contributors"].forEach(function (set) {
          if (!Array.isArray(data[set])) {
            return;
          }
          data[set] = data[set].map(fn);
        });
        return data;
      }
      function unParsePerson(person) {
        if (typeof person === "string") {
          return person;
        }
        var name = person.name || "";
        var u = person.url || person.web;
        var wrappedUrl = u ? " (" + u + ")" : "";
        var e = person.email || person.mail;
        var wrappedEmail = e ? " <" + e + ">" : "";
        return name + wrappedEmail + wrappedUrl;
      }
      function parsePerson(person) {
        if (typeof person !== "string") {
          return person;
        }
        var matchedName = person.match(/^([^(<]+)/);
        var matchedUrl = person.match(/\(([^()]+)\)/);
        var matchedEmail = person.match(/<([^<>]+)>/);
        var obj = {};
        if (matchedName && matchedName[0].trim()) {
          obj.name = matchedName[0].trim();
        }
        if (matchedEmail) {
          obj.email = matchedEmail[1];
        }
        if (matchedUrl) {
          obj.url = matchedUrl[1];
        }
        return obj;
      }
      function addOptionalDepsToDeps(data) {
        var o = data.optionalDependencies;
        if (!o) {
          return;
        }
        var d = data.dependencies || {};
        Object.keys(o).forEach(function (k) {
          d[k] = o[k];
        });
        data.dependencies = d;
      }
      function depObjectify(deps, type, warn) {
        if (!deps) {
          return {};
        }
        if (typeof deps === "string") {
          deps = deps.trim().split(/[\n\r\s\t ,]+/);
        }
        if (!Array.isArray(deps)) {
          return deps;
        }
        warn("deprecatedArrayDependencies", type);
        var o = {};
        deps
          .filter(function (d) {
            return typeof d === "string";
          })
          .forEach(function (d) {
            d = d.trim().split(/(:?[@\s><=])/);
            var dn = d.shift();
            var dv = d.join("");
            dv = dv.trim();
            dv = dv.replace(/^@/, "");
            o[dn] = dv;
          });
        return o;
      }
      function objectifyDeps(data, warn) {
        depTypes.forEach(function (type) {
          if (!data[type]) {
            return;
          }
          data[type] = depObjectify(data[type], type, warn);
        });
      }
      function bugsTypos(bugs, warn) {
        if (!bugs) {
          return;
        }
        Object.keys(bugs).forEach(function (k) {
          if (typos.bugs[k]) {
            warn("typo", k, typos.bugs[k], "bugs");
            bugs[typos.bugs[k]] = bugs[k];
            delete bugs[k];
          }
        });
      }
    },
    9671: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var util = __nccwpck_require__(3837);
      var messages = __nccwpck_require__(6271);
      module.exports = function () {
        var args = Array.prototype.slice.call(arguments, 0);
        var warningName = args.shift();
        if (warningName === "typo") {
          return makeTypoWarning.apply(null, args);
        } else {
          var msgTemplate = messages[warningName]
            ? messages[warningName]
            : warningName + ": '%s'";
          args.unshift(msgTemplate);
          return util.format.apply(null, args);
        }
      };
      function makeTypoWarning(providedName, probableName, field) {
        if (field) {
          providedName = field + "['" + providedName + "']";
          probableName = field + "['" + probableName + "']";
        }
        return util.format(messages.typo, providedName, probableName);
      }
    },
    3188: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = normalize;
      var fixer = __nccwpck_require__(3492);
      normalize.fixer = fixer;
      var makeWarning = __nccwpck_require__(9671);
      var fieldsToFix = [
        "name",
        "version",
        "description",
        "repository",
        "modules",
        "scripts",
        "files",
        "bin",
        "man",
        "bugs",
        "keywords",
        "readme",
        "homepage",
        "license",
      ];
      var otherThingsToFix = ["dependencies", "people", "typos"];
      var thingsToFix = fieldsToFix.map(function (fieldName) {
        return ucFirst(fieldName) + "Field";
      });
      thingsToFix = thingsToFix.concat(otherThingsToFix);
      function normalize(data, warn, strict) {
        if (warn === true) {
          warn = null;
          strict = true;
        }
        if (!strict) {
          strict = false;
        }
        if (!warn || data.private) {
          warn = function () {};
        }
        if (
          data.scripts &&
          data.scripts.install === "node-gyp rebuild" &&
          !data.scripts.preinstall
        ) {
          data.gypfile = true;
        }
        fixer.warn = function () {
          warn(makeWarning.apply(null, arguments));
        };
        thingsToFix.forEach(function (thingName) {
          fixer["fix" + ucFirst(thingName)](data, strict);
        });
        data._id = data.name + "@" + data.version;
      }
      function ucFirst(string) {
        return string.charAt(0).toUpperCase() + string.slice(1);
      }
    },
    680: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      module.exports = npa;
      module.exports.resolve = resolve;
      module.exports.toPurl = toPurl;
      module.exports.Result = Result;
      const { URL } = __nccwpck_require__(7310);
      const HostedGit = __nccwpck_require__(167);
      const semver = __nccwpck_require__(4541);
      const path = global.FAKE_WINDOWS
        ? __nccwpck_require__(1017).win32
        : __nccwpck_require__(1017);
      const validatePackageName = __nccwpck_require__(4006);
      const { homedir } = __nccwpck_require__(2037);
      const { log } = __nccwpck_require__(6528);
      const isWindows = process.platform === "win32" || global.FAKE_WINDOWS;
      const hasSlashes = isWindows ? /\\|[/]/ : /[/]/;
      const isURL = /^(?:git[+])?[a-z]+:/i;
      const isGit = /^[^@]+@[^:.]+\.[^:]+:.+$/i;
      const isFilename = /[.](?:tgz|tar.gz|tar)$/i;
      function npa(arg, where) {
        let name;
        let spec;
        if (typeof arg === "object") {
          if (arg instanceof Result && (!where || where === arg.where)) {
            return arg;
          } else if (arg.name && arg.rawSpec) {
            return npa.resolve(arg.name, arg.rawSpec, where || arg.where);
          } else {
            return npa(arg.raw, where || arg.where);
          }
        }
        const nameEndsAt =
          arg[0] === "@" ? arg.slice(1).indexOf("@") + 1 : arg.indexOf("@");
        const namePart = nameEndsAt > 0 ? arg.slice(0, nameEndsAt) : arg;
        if (isURL.test(arg)) {
          spec = arg;
        } else if (isGit.test(arg)) {
          spec = `git+ssh://${arg}`;
        } else if (
          namePart[0] !== "@" &&
          (hasSlashes.test(namePart) || isFilename.test(namePart))
        ) {
          spec = arg;
        } else if (nameEndsAt > 0) {
          name = namePart;
          spec = arg.slice(nameEndsAt + 1) || "*";
        } else {
          const valid = validatePackageName(arg);
          if (valid.validForOldPackages) {
            name = arg;
            spec = "*";
          } else {
            spec = arg;
          }
        }
        return resolve(name, spec, where, arg);
      }
      const isFilespec = isWindows
        ? /^(?:[.]|~[/]|[/\\]|[a-zA-Z]:)/
        : /^(?:[.]|~[/]|[/]|[a-zA-Z]:)/;
      function resolve(name, spec, where, arg) {
        const res = new Result({
          raw: arg,
          name,
          rawSpec: spec,
          fromArgument: arg != null,
        });
        if (name) {
          res.setName(name);
        }
        if (spec && (isFilespec.test(spec) || /^file:/i.test(spec))) {
          return fromFile(res, where);
        } else if (spec && /^npm:/i.test(spec)) {
          return fromAlias(res, where);
        }
        const hosted = HostedGit.fromUrl(spec, {
          noGitPlus: true,
          noCommittish: true,
        });
        if (hosted) {
          return fromHostedGit(res, hosted);
        } else if (spec && isURL.test(spec)) {
          return fromURL(res);
        } else if (spec && (hasSlashes.test(spec) || isFilename.test(spec))) {
          return fromFile(res, where);
        } else {
          return fromRegistry(res);
        }
      }
      const defaultRegistry = "https://registry.npmjs.org";
      function toPurl(arg, reg = defaultRegistry) {
        const res = npa(arg);
        if (res.type !== "version") {
          throw invalidPurlType(res.type, res.raw);
        }
        let purl =
          "pkg:npm/" + res.name.replace(/^@/, "%40") + "@" + res.rawSpec;
        if (reg !== defaultRegistry) {
          purl += "?repository_url=" + reg;
        }
        return purl;
      }
      function invalidPackageName(name, valid, raw) {
        const err = new Error(
          `Invalid package name "${name}" of package "${raw}": ${valid.errors.join("; ")}.`,
        );
        err.code = "EINVALIDPACKAGENAME";
        return err;
      }
      function invalidTagName(name, raw) {
        const err = new Error(
          `Invalid tag name "${name}" of package "${raw}": Tags may not have any characters that encodeURIComponent encodes.`,
        );
        err.code = "EINVALIDTAGNAME";
        return err;
      }
      function invalidPurlType(type, raw) {
        const err = new Error(
          `Invalid type "${type}" of package "${raw}": Purl can only be generated for "version" types.`,
        );
        err.code = "EINVALIDPURLTYPE";
        return err;
      }
      function Result(opts) {
        this.type = opts.type;
        this.registry = opts.registry;
        this.where = opts.where;
        if (opts.raw == null) {
          this.raw = opts.name ? opts.name + "@" + opts.rawSpec : opts.rawSpec;
        } else {
          this.raw = opts.raw;
        }
        this.name = undefined;
        this.escapedName = undefined;
        this.scope = undefined;
        this.rawSpec = opts.rawSpec || "";
        this.saveSpec = opts.saveSpec;
        this.fetchSpec = opts.fetchSpec;
        if (opts.name) {
          this.setName(opts.name);
        }
        this.gitRange = opts.gitRange;
        this.gitCommittish = opts.gitCommittish;
        this.gitSubdir = opts.gitSubdir;
        this.hosted = opts.hosted;
      }
      Result.prototype.setName = function (name) {
        const valid = validatePackageName(name);
        if (!valid.validForOldPackages) {
          throw invalidPackageName(name, valid, this.raw);
        }
        this.name = name;
        this.scope =
          name[0] === "@" ? name.slice(0, name.indexOf("/")) : undefined;
        this.escapedName = name.replace("/", "%2f");
        return this;
      };
      Result.prototype.toString = function () {
        const full = [];
        if (this.name != null && this.name !== "") {
          full.push(this.name);
        }
        const spec = this.saveSpec || this.fetchSpec || this.rawSpec;
        if (spec != null && spec !== "") {
          full.push(spec);
        }
        return full.length ? full.join("@") : this.raw;
      };
      Result.prototype.toJSON = function () {
        const result = Object.assign({}, this);
        delete result.hosted;
        return result;
      };
      function setGitAttrs(res, committish) {
        if (!committish) {
          res.gitCommittish = null;
          return;
        }
        for (const part of committish.split("::")) {
          if (!part.includes(":")) {
            if (res.gitRange) {
              throw new Error(
                "cannot override existing semver range with a committish",
              );
            }
            if (res.gitCommittish) {
              throw new Error(
                "cannot override existing committish with a second committish",
              );
            }
            res.gitCommittish = part;
            continue;
          }
          const [name, value] = part.split(":");
          if (name === "semver") {
            if (res.gitCommittish) {
              throw new Error(
                "cannot override existing committish with a semver range",
              );
            }
            if (res.gitRange) {
              throw new Error(
                "cannot override existing semver range with a second semver range",
              );
            }
            res.gitRange = decodeURIComponent(value);
            continue;
          }
          if (name === "path") {
            if (res.gitSubdir) {
              throw new Error(
                "cannot override existing path with a second path",
              );
            }
            res.gitSubdir = `/${value}`;
            continue;
          }
          log.warn("npm-package-arg", `ignoring unknown key "${name}"`);
        }
      }
      function fromFile(res, where) {
        if (!where) {
          where = process.cwd();
        }
        res.type = isFilename.test(res.rawSpec) ? "file" : "directory";
        res.where = where;
        let specUrl;
        let resolvedUrl;
        const prefix = !/^file:/.test(res.rawSpec) ? "file:" : "";
        const rawWithPrefix = prefix + res.rawSpec;
        let rawNoPrefix = rawWithPrefix.replace(/^file:/, "");
        try {
          resolvedUrl = new URL(
            rawWithPrefix,
            `file://${path.resolve(where)}/`,
          );
          specUrl = new URL(rawWithPrefix);
        } catch (originalError) {
          const er = new Error("Invalid file: URL, must comply with RFC 8089");
          throw Object.assign(er, {
            raw: res.rawSpec,
            spec: res,
            where,
            originalError,
          });
        }
        if (resolvedUrl.host && resolvedUrl.host !== "localhost") {
          const rawSpec = res.rawSpec.replace(/^file:\/\//, "file:///");
          resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`);
          specUrl = new URL(rawSpec);
          rawNoPrefix = rawSpec.replace(/^file:/, "");
        }
        if (/^\/{1,3}\.\.?(\/|$)/.test(rawNoPrefix)) {
          const rawSpec = res.rawSpec.replace(/^file:\/{1,3}/, "file:");
          resolvedUrl = new URL(rawSpec, `file://${path.resolve(where)}/`);
          specUrl = new URL(rawSpec);
          rawNoPrefix = rawSpec.replace(/^file:/, "");
        }
        let specPath = decodeURIComponent(specUrl.pathname);
        let resolvedPath = decodeURIComponent(resolvedUrl.pathname);
        if (isWindows) {
          specPath = specPath.replace(/^\/+([a-z]:\/)/i, "$1");
          resolvedPath = resolvedPath.replace(/^\/+([a-z]:\/)/i, "$1");
        }
        if (/^\/~(\/|$)/.test(specPath)) {
          res.saveSpec = `file:${specPath.substr(1)}`;
          resolvedPath = path.resolve(homedir(), specPath.substr(3));
        } else if (!path.isAbsolute(rawNoPrefix)) {
          res.saveSpec = `file:${path.relative(where, resolvedPath)}`;
        } else {
          res.saveSpec = `file:${path.resolve(resolvedPath)}`;
        }
        res.fetchSpec = path.resolve(where, resolvedPath);
        return res;
      }
      function fromHostedGit(res, hosted) {
        res.type = "git";
        res.hosted = hosted;
        res.saveSpec = hosted.toString({
          noGitPlus: false,
          noCommittish: false,
        });
        res.fetchSpec =
          hosted.getDefaultRepresentation() === "shortcut"
            ? null
            : hosted.toString();
        setGitAttrs(res, hosted.committish);
        return res;
      }
      function unsupportedURLType(protocol, spec) {
        const err = new Error(`Unsupported URL Type "${protocol}": ${spec}`);
        err.code = "EUNSUPPORTEDPROTOCOL";
        return err;
      }
      function fromURL(res) {
        let rawSpec = res.rawSpec;
        res.saveSpec = rawSpec;
        if (rawSpec.startsWith("git+ssh:")) {
          const matched = rawSpec.match(
            /^git\+ssh:\/\/([^:#]+:[^#]+(?:\.git)?)(?:#(.*))?$/i,
          );
          if (matched && !matched[1].match(/:[0-9]+\/?.*$/i)) {
            res.type = "git";
            setGitAttrs(res, matched[2]);
            res.fetchSpec = matched[1];
            return res;
          }
        } else if (rawSpec.startsWith("git+file://")) {
          rawSpec = rawSpec.replace(/\\/g, "/");
        }
        const parsedUrl = new URL(rawSpec);
        switch (parsedUrl.protocol) {
          case "git:":
          case "git+http:":
          case "git+https:":
          case "git+rsync:":
          case "git+ftp:":
          case "git+file:":
          case "git+ssh:":
            res.type = "git";
            setGitAttrs(res, parsedUrl.hash.slice(1));
            if (
              parsedUrl.protocol === "git+file:" &&
              /^git\+file:\/\/[a-z]:/i.test(rawSpec)
            ) {
              res.fetchSpec = `git+file://${parsedUrl.host.toLowerCase()}:${parsedUrl.pathname}`;
            } else {
              parsedUrl.hash = "";
              res.fetchSpec = parsedUrl.toString();
            }
            if (res.fetchSpec.startsWith("git+")) {
              res.fetchSpec = res.fetchSpec.slice(4);
            }
            break;
          case "http:":
          case "https:":
            res.type = "remote";
            res.fetchSpec = res.saveSpec;
            break;
          default:
            throw unsupportedURLType(parsedUrl.protocol, rawSpec);
        }
        return res;
      }
      function fromAlias(res, where) {
        const subSpec = npa(res.rawSpec.substr(4), where);
        if (subSpec.type === "alias") {
          throw new Error("nested aliases not supported");
        }
        if (!subSpec.registry) {
          throw new Error("aliases only work for registry deps");
        }
        if (!subSpec.name) {
          throw new Error("aliases must have a name");
        }
        res.subSpec = subSpec;
        res.registry = true;
        res.type = "alias";
        res.saveSpec = null;
        res.fetchSpec = null;
        return res;
      }
      function fromRegistry(res) {
        res.registry = true;
        const spec = res.rawSpec.trim();
        res.saveSpec = null;
        res.fetchSpec = spec;
        const version = semver.valid(spec, true);
        const range = semver.validRange(spec, true);
        if (version) {
          res.type = "version";
        } else if (range) {
          res.type = "range";
        } else {
          if (encodeURIComponent(spec) !== spec) {
            throw invalidTagName(spec, res.raw);
          }
          res.type = "tag";
        }
        return res;
      }
    },
    7570: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const fs = __nccwpck_require__(7147);
      const npa = __nccwpck_require__(680);
      const { URL } = __nccwpck_require__(7310);
      const regFromURI = (uri, opts) => {
        const parsed = new URL(uri);
        let regKey = `//${parsed.host}${parsed.pathname}`;
        while (regKey.length > "//".length) {
          const authKey = hasAuth(regKey, opts);
          if (authKey) {
            return { regKey, authKey };
          }
          regKey = regKey.replace(/([^/]+|\/)$/, "");
        }
        return { regKey: false, authKey: null };
      };
      const hasAuth = (regKey, opts) => {
        if (opts[`${regKey}:_authToken`]) {
          return "_authToken";
        }
        if (opts[`${regKey}:_auth`]) {
          return "_auth";
        }
        if (opts[`${regKey}:username`] && opts[`${regKey}:_password`]) {
          return "username";
        }
        if (opts[`${regKey}:certfile`] && opts[`${regKey}:keyfile`]) {
          return "certfile";
        }
        return false;
      };
      const sameHost = (a, b) => {
        const parsedA = new URL(a);
        const parsedB = new URL(b);
        return parsedA.host === parsedB.host;
      };
      const getRegistry = (opts) => {
        const { spec } = opts;
        const { scope: specScope, subSpec } = spec ? npa(spec) : {};
        const subSpecScope = subSpec && subSpec.scope;
        const scope = subSpec ? subSpecScope : specScope;
        const scopeReg = scope && opts[`${scope}:registry`];
        return scopeReg || opts.registry;
      };
      const maybeReadFile = (file) => {
        try {
          return fs.readFileSync(file, "utf8");
        } catch (er) {
          if (er.code !== "ENOENT") {
            throw er;
          }
          return null;
        }
      };
      const getAuth = (uri, opts = {}) => {
        const { forceAuth } = opts;
        if (!uri) {
          throw new Error("URI is required");
        }
        const { regKey, authKey } = regFromURI(uri, forceAuth || opts);
        if (forceAuth && !regKey) {
          return new Auth({
            regKey: false,
            authKey: null,
            scopeAuthKey: null,
            token: forceAuth._authToken || forceAuth.token,
            username: forceAuth.username,
            password: forceAuth._password || forceAuth.password,
            auth: forceAuth._auth || forceAuth.auth,
            certfile: forceAuth.certfile,
            keyfile: forceAuth.keyfile,
          });
        }
        if (!regKey) {
          const registry = getRegistry(opts);
          if (registry && uri !== registry && sameHost(uri, registry)) {
            return getAuth(registry, opts);
          } else if (registry !== opts.registry) {
            const { regKey: scopeAuthKey, authKey: _authKey } = regFromURI(
              registry,
              opts,
            );
            return new Auth({
              scopeAuthKey,
              regKey: scopeAuthKey,
              authKey: _authKey,
            });
          }
        }
        const {
          [`${regKey}:_authToken`]: token,
          [`${regKey}:username`]: username,
          [`${regKey}:_password`]: password,
          [`${regKey}:_auth`]: auth,
          [`${regKey}:certfile`]: certfile,
          [`${regKey}:keyfile`]: keyfile,
        } = opts;
        return new Auth({
          scopeAuthKey: null,
          regKey,
          authKey,
          token,
          auth,
          username,
          password,
          certfile,
          keyfile,
        });
      };
      class Auth {
        constructor({
          token,
          auth,
          username,
          password,
          scopeAuthKey,
          certfile,
          keyfile,
          regKey,
          authKey,
        }) {
          this.scopeAuthKey = scopeAuthKey;
          this.regKey = regKey;
          this.authKey = authKey;
          this.token = null;
          this.auth = null;
          this.isBasicAuth = false;
          this.cert = null;
          this.key = null;
          if (token) {
            this.token = token;
          } else if (auth) {
            this.auth = auth;
          } else if (username && password) {
            const p = Buffer.from(password, "base64").toString("utf8");
            this.auth = Buffer.from(`${username}:${p}`, "utf8").toString(
              "base64",
            );
            this.isBasicAuth = true;
          }
          if (certfile && keyfile) {
            const cert = maybeReadFile(certfile, "utf-8");
            const key = maybeReadFile(keyfile, "utf-8");
            if (cert && key) {
              this.cert = cert;
              this.key = key;
            }
          }
        }
      }
      module.exports = getAuth;
    },
    6302: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const errors = __nccwpck_require__(3774);
      const { Response } = __nccwpck_require__(8998);
      const defaultOpts = __nccwpck_require__(305);
      const { log } = __nccwpck_require__(6528);
      const { redact: cleanUrl } = __nccwpck_require__(8217);
      const moreInfoUrl =
        "https://github.com/npm/cli/wiki/No-auth-for-URI,-but-auth-present-for-scoped-registry";
      const checkResponse = async ({
        method,
        uri,
        res,
        startTime,
        auth,
        opts,
      }) => {
        opts = { ...defaultOpts, ...opts };
        if (
          res.headers.has("npm-notice") &&
          !res.headers.has("x-local-cache")
        ) {
          log.notice("", res.headers.get("npm-notice"));
        }
        if (res.status >= 400) {
          logRequest(method, res, startTime);
          if (auth && auth.scopeAuthKey && !auth.token && !auth.auth) {
            log.warn(
              "registry",
              `No auth for URI, but auth present for scoped registry.\n\nURI: ${uri}\nScoped Registry Key: ${auth.scopeAuthKey}\n\nMore info here: ${moreInfoUrl}`,
            );
          }
          return checkErrors(method, res, startTime, opts);
        } else {
          res.body.on("end", () => logRequest(method, res, startTime, opts));
          if (opts.ignoreBody) {
            res.body.resume();
            return new Response(null, res);
          }
          return res;
        }
      };
      module.exports = checkResponse;
      function logRequest(method, res, startTime) {
        const elapsedTime = Date.now() - startTime;
        const attempt = res.headers.get("x-fetch-attempts");
        const attemptStr = attempt && attempt > 1 ? ` attempt #${attempt}` : "";
        const cacheStatus = res.headers.get("x-local-cache-status");
        const cacheStr = cacheStatus ? ` (cache ${cacheStatus})` : "";
        const urlStr = cleanUrl(res.url);
        log.http(
          "fetch",
          `${method.toUpperCase()} ${res.status} ${urlStr} ${elapsedTime}ms${attemptStr}${cacheStr}`,
        );
      }
      function checkErrors(method, res, startTime, opts) {
        return res
          .buffer()
          .catch(() => null)
          .then((body) => {
            let parsed = body;
            try {
              parsed = JSON.parse(body.toString("utf8"));
            } catch {}
            if (res.status === 401 && res.headers.get("www-authenticate")) {
              const auth = res.headers
                .get("www-authenticate")
                .split(/,\s*/)
                .map((s) => s.toLowerCase());
              if (auth.indexOf("ipaddress") !== -1) {
                throw new errors.HttpErrorAuthIPAddress(
                  method,
                  res,
                  parsed,
                  opts.spec,
                );
              } else if (auth.indexOf("otp") !== -1) {
                throw new errors.HttpErrorAuthOTP(
                  method,
                  res,
                  parsed,
                  opts.spec,
                );
              } else {
                throw new errors.HttpErrorAuthUnknown(
                  method,
                  res,
                  parsed,
                  opts.spec,
                );
              }
            } else if (
              res.status === 401 &&
              body != null &&
              /one-time pass/.test(body.toString("utf8"))
            ) {
              throw new errors.HttpErrorAuthOTP(method, res, parsed, opts.spec);
            } else {
              throw new errors.HttpErrorGeneral(method, res, parsed, opts.spec);
            }
          });
      }
    },
    305: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const pkg = __nccwpck_require__(3684);
      module.exports = {
        maxSockets: 12,
        method: "GET",
        registry: "https://registry.npmjs.org/",
        timeout: 5 * 60 * 1e3,
        strictSSL: true,
        noProxy: process.env.NOPROXY,
        userAgent: `${pkg.name}@${pkg.version}/node@${process.version}+${process.arch} (${process.platform})`,
      };
    },
    3774: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { URL } = __nccwpck_require__(1041);
      function packageName(href) {
        try {
          let basePath = new URL(href).pathname.slice(1);
          if (!basePath.match(/^-/)) {
            basePath = basePath.split("/");
            var index = basePath.indexOf("_rewrite");
            if (index === -1) {
              index = basePath.length - 1;
            } else {
              index++;
            }
            return decodeURIComponent(basePath[index]);
          }
        } catch {}
      }
      class HttpErrorBase extends Error {
        constructor(method, res, body, spec) {
          super();
          this.name = this.constructor.name;
          this.headers =
            typeof res.headers?.raw === "function"
              ? res.headers.raw()
              : res.headers;
          this.statusCode = res.status;
          this.code = `E${res.status}`;
          this.method = method;
          this.uri = res.url;
          this.body = body;
          this.pkgid = spec ? spec.toString() : packageName(res.url);
          Error.captureStackTrace(this, this.constructor);
        }
      }
      class HttpErrorGeneral extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message = `${res.status} ${res.statusText} - ${this.method.toUpperCase()} ${this.spec || this.uri}${body && body.error ? " - " + body.error : ""}`;
        }
      }
      class HttpErrorAuthOTP extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message = "OTP required for authentication";
          this.code = "EOTP";
        }
      }
      class HttpErrorAuthIPAddress extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message = "Login is not allowed from your IP address";
          this.code = "EAUTHIP";
        }
      }
      class HttpErrorAuthUnknown extends HttpErrorBase {
        constructor(method, res, body, spec) {
          super(method, res, body, spec);
          this.message =
            "Unable to authenticate, need: " +
            res.headers.get("www-authenticate");
        }
      }
      module.exports = {
        HttpErrorBase,
        HttpErrorGeneral,
        HttpErrorAuthOTP,
        HttpErrorAuthIPAddress,
        HttpErrorAuthUnknown,
      };
    },
    5902: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { HttpErrorAuthOTP } = __nccwpck_require__(3774);
      const checkResponse = __nccwpck_require__(6302);
      const getAuth = __nccwpck_require__(7570);
      const fetch = __nccwpck_require__(9525);
      const JSONStream = __nccwpck_require__(965);
      const npa = __nccwpck_require__(680);
      const qs = __nccwpck_require__(3477);
      const url = __nccwpck_require__(7310);
      const zlib = __nccwpck_require__(3486);
      const { Minipass } = __nccwpck_require__(4968);
      const defaultOpts = __nccwpck_require__(305);
      const urlIsValid = (u) => {
        try {
          return !!new url.URL(u);
        } catch (_) {
          return false;
        }
      };
      module.exports = regFetch;
      function regFetch(uri, opts_ = {}) {
        const opts = { ...defaultOpts, ...opts_ };
        const uriValid = urlIsValid(uri);
        let registry = opts.registry || defaultOpts.registry;
        if (!uriValid) {
          registry = opts.registry =
            (opts.spec && pickRegistry(opts.spec, opts)) ||
            opts.registry ||
            registry;
          uri = `${registry.trim().replace(/\/?$/g, "")}/${uri.trim().replace(/^\//, "")}`;
          new url.URL(uri);
        }
        const method = opts.method || "GET";
        const startTime = Date.now();
        const auth = getAuth(uri, opts);
        const headers = getHeaders(uri, auth, opts);
        let body = opts.body;
        const bodyIsStream = Minipass.isStream(body);
        const bodyIsPromise =
          body && typeof body === "object" && typeof body.then === "function";
        if (
          body &&
          !bodyIsStream &&
          !bodyIsPromise &&
          typeof body !== "string" &&
          !Buffer.isBuffer(body)
        ) {
          headers["content-type"] =
            headers["content-type"] || "application/json";
          body = JSON.stringify(body);
        } else if (body && !headers["content-type"]) {
          headers["content-type"] = "application/octet-stream";
        }
        if (opts.gzip) {
          headers["content-encoding"] = "gzip";
          if (bodyIsStream) {
            const gz = new zlib.Gzip();
            body.on("error", (err) => gz.emit("error", err));
            body = body.pipe(gz);
          } else if (!bodyIsPromise) {
            body = new zlib.Gzip().end(body).concat();
          }
        }
        const parsed = new url.URL(uri);
        if (opts.query) {
          const q =
            typeof opts.query === "string" ? qs.parse(opts.query) : opts.query;
          Object.keys(q).forEach((key) => {
            if (q[key] !== undefined) {
              parsed.searchParams.set(key, q[key]);
            }
          });
          uri = url.format(parsed);
        }
        if (parsed.searchParams.get("write") === "true" && method === "GET") {
          opts.offline = false;
          opts.preferOffline = false;
          opts.preferOnline = true;
        }
        const doFetch = async (fetchBody) => {
          const p = fetch(uri, {
            agent: opts.agent,
            algorithms: opts.algorithms,
            body: fetchBody,
            cache: getCacheMode(opts),
            cachePath: opts.cache,
            ca: opts.ca,
            cert: auth.cert || opts.cert,
            headers,
            integrity: opts.integrity,
            key: auth.key || opts.key,
            localAddress: opts.localAddress,
            maxSockets: opts.maxSockets,
            memoize: opts.memoize,
            method,
            noProxy: opts.noProxy,
            proxy: opts.httpsProxy || opts.proxy,
            retry: opts.retry
              ? opts.retry
              : {
                  retries: opts.fetchRetries,
                  factor: opts.fetchRetryFactor,
                  minTimeout: opts.fetchRetryMintimeout,
                  maxTimeout: opts.fetchRetryMaxtimeout,
                },
            strictSSL: opts.strictSSL,
            timeout: opts.timeout || 30 * 1e3,
          }).then((res) =>
            checkResponse({
              method,
              uri,
              res,
              registry,
              startTime,
              auth,
              opts,
            }),
          );
          if (typeof opts.otpPrompt === "function") {
            return p.catch(async (er) => {
              if (er instanceof HttpErrorAuthOTP) {
                let otp;
                try {
                  otp = await opts.otpPrompt();
                } catch (_) {}
                if (!otp) {
                  throw er;
                }
                return regFetch(uri, { ...opts, otp });
              }
              throw er;
            });
          } else {
            return p;
          }
        };
        return Promise.resolve(body).then(doFetch);
      }
      module.exports.getAuth = getAuth;
      module.exports.json = fetchJSON;
      function fetchJSON(uri, opts) {
        return regFetch(uri, opts).then((res) => res.json());
      }
      module.exports.json.stream = fetchJSONStream;
      function fetchJSONStream(uri, jsonPath, opts_ = {}) {
        const opts = { ...defaultOpts, ...opts_ };
        const parser = JSONStream.parse(jsonPath, opts.mapJSON);
        regFetch(uri, opts)
          .then((res) =>
            res.body.on("error", (er) => parser.emit("error", er)).pipe(parser),
          )
          .catch((er) => parser.emit("error", er));
        return parser;
      }
      module.exports.pickRegistry = pickRegistry;
      function pickRegistry(spec, opts = {}) {
        spec = npa(spec);
        let registry =
          spec.scope && opts[spec.scope.replace(/^@?/, "@") + ":registry"];
        if (!registry && opts.scope) {
          registry = opts[opts.scope.replace(/^@?/, "@") + ":registry"];
        }
        if (!registry) {
          registry = opts.registry || defaultOpts.registry;
        }
        return registry;
      }
      function getCacheMode(opts) {
        return opts.offline
          ? "only-if-cached"
          : opts.preferOffline
            ? "force-cache"
            : opts.preferOnline
              ? "no-cache"
              : "default";
      }
      function getHeaders(uri, auth, opts) {
        const headers = Object.assign(
          { "user-agent": opts.userAgent },
          opts.headers || {},
        );
        if (opts.authType) {
          headers["npm-auth-type"] = opts.authType;
        }
        if (opts.scope) {
          headers["npm-scope"] = opts.scope;
        }
        if (opts.npmSession) {
          headers["npm-session"] = opts.npmSession;
        }
        if (opts.npmCommand) {
          headers["npm-command"] = opts.npmCommand;
        }
        if (auth.token) {
          headers.authorization = `Bearer ${auth.token}`;
        } else if (auth.auth) {
          headers.authorization = `Basic ${auth.auth}`;
        }
        if (opts.otp) {
          headers["npm-otp"] = opts.otp;
        }
        return headers;
      }
    },
    965: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const Parser = __nccwpck_require__(1991);
      const { Minipass } = __nccwpck_require__(4968);
      class JSONStreamError extends Error {
        constructor(err, caller) {
          super(err.message);
          Error.captureStackTrace(this, caller || this.constructor);
        }
        get name() {
          return "JSONStreamError";
        }
      }
      const check = (x, y) =>
        typeof x === "string"
          ? String(y) === x
          : x && typeof x.test === "function"
            ? x.test(y)
            : typeof x === "boolean" || typeof x === "object"
              ? x
              : typeof x === "function"
                ? x(y)
                : false;
      class JSONStream extends Minipass {
        #count = 0;
        #ending = false;
        #footer = null;
        #header = null;
        #map = null;
        #onTokenOriginal;
        #parser;
        #path = null;
        #root = null;
        constructor(opts) {
          super({ ...opts, objectMode: true });
          const parser = (this.#parser = new Parser());
          parser.onValue = (value) => this.#onValue(value);
          this.#onTokenOriginal = parser.onToken;
          parser.onToken = (token, value) => this.#onToken(token, value);
          parser.onError = (er) => this.#onError(er);
          this.#path =
            typeof opts.path === "string"
              ? opts.path
                  .split(".")
                  .map((e) =>
                    e === "$*"
                      ? { emitKey: true }
                      : e === "*"
                        ? true
                        : e === ""
                          ? { recurse: true }
                          : e,
                  )
              : Array.isArray(opts.path) && opts.path.length
                ? opts.path
                : null;
          if (typeof opts.map === "function") {
            this.#map = opts.map;
          }
        }
        #setHeaderFooter(key, value) {
          if (this.#header !== false) {
            this.#header = this.#header || {};
            this.#header[key] = value;
          }
          if (this.#footer !== false && this.#header === false) {
            this.#footer = this.#footer || {};
            this.#footer[key] = value;
          }
        }
        #onError(er) {
          const caller = this.#ending ? this.end : this.write;
          this.#ending = false;
          return this.emit("error", new JSONStreamError(er, caller));
        }
        #onToken(token, value) {
          const parser = this.#parser;
          this.#onTokenOriginal.call(this.#parser, token, value);
          if (parser.stack.length === 0) {
            if (this.#root) {
              const root = this.#root;
              if (!this.#path) {
                super.write(root);
              }
              this.#root = null;
              this.#count = 0;
            }
          }
        }
        #onValue(value) {
          const parser = this.#parser;
          this.#root = value;
          if (!this.#path) {
            return;
          }
          let i = 0;
          let j = 0;
          let emitKey = false;
          while (i < this.#path.length) {
            const key = this.#path[i];
            j++;
            if (key && !key.recurse) {
              const c = j === parser.stack.length ? parser : parser.stack[j];
              if (!c) {
                return;
              }
              if (!check(key, c.key)) {
                this.#setHeaderFooter(c.key, value);
                return;
              }
              emitKey = !!key.emitKey;
              i++;
            } else {
              i++;
              if (i >= this.#path.length) {
                return;
              }
              const nextKey = this.#path[i];
              if (!nextKey) {
                return;
              }
              while (true) {
                const c = j === parser.stack.length ? parser : parser.stack[j];
                if (!c) {
                  return;
                }
                if (check(nextKey, c.key)) {
                  i++;
                  if (!Object.isFrozen(parser.stack[j])) {
                    parser.stack[j].value = null;
                  }
                  break;
                } else {
                  this.#setHeaderFooter(c.key, value);
                }
                j++;
              }
            }
          }
          if (this.#header) {
            const header = this.#header;
            this.#header = false;
            this.emit("header", header);
          }
          if (j !== parser.stack.length) {
            return;
          }
          this.#count++;
          const actualPath = parser.stack
            .slice(1)
            .map((e) => e.key)
            .concat([parser.key]);
          if (value !== null && value !== undefined) {
            const data = this.#map ? this.#map(value, actualPath) : value;
            if (data !== null && data !== undefined) {
              const emit = emitKey ? { value: data } : data;
              if (emitKey) {
                emit.key = parser.key;
              }
              super.write(emit);
            }
          }
          if (parser.value) {
            delete parser.value[parser.key];
          }
          for (const k of parser.stack) {
            k.value = null;
          }
        }
        write(chunk, encoding) {
          if (typeof chunk === "string") {
            chunk = Buffer.from(chunk, encoding);
          } else if (!Buffer.isBuffer(chunk)) {
            return this.emit(
              "error",
              new TypeError("Can only parse JSON from string or buffer input"),
            );
          }
          this.#parser.write(chunk);
          return this.flowing;
        }
        end(chunk, encoding) {
          this.#ending = true;
          if (chunk) {
            this.write(chunk, encoding);
          }
          const h = this.#header;
          this.#header = null;
          const f = this.#footer;
          this.#footer = null;
          if (h) {
            this.emit("header", h);
          }
          if (f) {
            this.emit("footer", f);
          }
          return super.end();
        }
        static get JSONStreamError() {
          return JSONStreamError;
        }
        static parse(path, map) {
          return new JSONStream({ path, map });
        }
      }
      module.exports = JSONStream;
    },
    6528: (module) => {
      const META = Symbol("proc-log.meta");
      module.exports = {
        META,
        output: {
          LEVELS: ["standard", "error", "buffer", "flush"],
          KEYS: {
            standard: "standard",
            error: "error",
            buffer: "buffer",
            flush: "flush",
          },
          standard: function (...args) {
            return process.emit("output", "standard", ...args);
          },
          error: function (...args) {
            return process.emit("output", "error", ...args);
          },
          buffer: function (...args) {
            return process.emit("output", "buffer", ...args);
          },
          flush: function (...args) {
            return process.emit("output", "flush", ...args);
          },
        },
        log: {
          LEVELS: [
            "notice",
            "error",
            "warn",
            "info",
            "verbose",
            "http",
            "silly",
            "timing",
            "pause",
            "resume",
          ],
          KEYS: {
            notice: "notice",
            error: "error",
            warn: "warn",
            info: "info",
            verbose: "verbose",
            http: "http",
            silly: "silly",
            timing: "timing",
            pause: "pause",
            resume: "resume",
          },
          error: function (...args) {
            return process.emit("log", "error", ...args);
          },
          notice: function (...args) {
            return process.emit("log", "notice", ...args);
          },
          warn: function (...args) {
            return process.emit("log", "warn", ...args);
          },
          info: function (...args) {
            return process.emit("log", "info", ...args);
          },
          verbose: function (...args) {
            return process.emit("log", "verbose", ...args);
          },
          http: function (...args) {
            return process.emit("log", "http", ...args);
          },
          silly: function (...args) {
            return process.emit("log", "silly", ...args);
          },
          timing: function (...args) {
            return process.emit("log", "timing", ...args);
          },
          pause: function () {
            return process.emit("log", "pause");
          },
          resume: function () {
            return process.emit("log", "resume");
          },
        },
        time: {
          LEVELS: ["start", "end"],
          KEYS: { start: "start", end: "end" },
          start: function (name, fn) {
            process.emit("time", "start", name);
            function end() {
              return process.emit("time", "end", name);
            }
            if (typeof fn === "function") {
              const res = fn();
              if (res && res.finally) {
                return res.finally(end);
              }
              end();
              return res;
            }
            return end;
          },
          end: function (name) {
            return process.emit("time", "end", name);
          },
        },
        input: {
          LEVELS: ["start", "end", "read"],
          KEYS: { start: "start", end: "end", read: "read" },
          start: function (fn) {
            process.emit("input", "start");
            function end() {
              return process.emit("input", "end");
            }
            if (typeof fn === "function") {
              const res = fn();
              if (res && res.finally) {
                return res.finally(end);
              }
              end();
              return res;
            }
            return end;
          },
          end: function () {
            return process.emit("input", "end");
          },
          read: function (...args) {
            let resolve, reject;
            const promise = new Promise((_resolve, _reject) => {
              resolve = _resolve;
              reject = _reject;
            });
            process.emit("input", "read", resolve, reject, ...args);
            return promise;
          },
        },
      };
    },
    4742: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var errcode = __nccwpck_require__(2997);
      var retry = __nccwpck_require__(4347);
      var hasOwn = Object.prototype.hasOwnProperty;
      function isRetryError(err) {
        return (
          err && err.code === "EPROMISERETRY" && hasOwn.call(err, "retried")
        );
      }
      function promiseRetry(fn, options) {
        var temp;
        var operation;
        if (typeof fn === "object" && typeof options === "function") {
          temp = options;
          options = fn;
          fn = temp;
        }
        operation = retry.operation(options);
        return new Promise(function (resolve, reject) {
          operation.attempt(function (number) {
            Promise.resolve()
              .then(function () {
                return fn(function (err) {
                  if (isRetryError(err)) {
                    err = err.retried;
                  }
                  throw errcode(new Error("Retrying"), "EPROMISERETRY", {
                    retried: err,
                  });
                }, number);
              })
              .then(resolve, function (err) {
                if (isRetryError(err)) {
                  err = err.retried;
                  if (operation.retry(err || new Error())) {
                    return;
                  }
                }
                reject(err);
              });
          });
        });
      }
      module.exports = promiseRetry;
    },
    4347: (module, __unused_webpack_exports, __nccwpck_require__) => {
      module.exports = __nccwpck_require__(6244);
    },
    6244: (__unused_webpack_module, exports, __nccwpck_require__) => {
      var RetryOperation = __nccwpck_require__(5369);
      exports.operation = function (options) {
        var timeouts = exports.timeouts(options);
        return new RetryOperation(timeouts, {
          forever: options && options.forever,
          unref: options && options.unref,
          maxRetryTime: options && options.maxRetryTime,
        });
      };
      exports.timeouts = function (options) {
        if (options instanceof Array) {
          return [].concat(options);
        }
        var opts = {
          retries: 10,
          factor: 2,
          minTimeout: 1 * 1e3,
          maxTimeout: Infinity,
          randomize: false,
        };
        for (var key in options) {
          opts[key] = options[key];
        }
        if (opts.minTimeout > opts.maxTimeout) {
          throw new Error("minTimeout is greater than maxTimeout");
        }
        var timeouts = [];
        for (var i = 0; i < opts.retries; i++) {
          timeouts.push(this.createTimeout(i, opts));
        }
        if (options && options.forever && !timeouts.length) {
          timeouts.push(this.createTimeout(i, opts));
        }
        timeouts.sort(function (a, b) {
          return a - b;
        });
        return timeouts;
      };
      exports.createTimeout = function (attempt, opts) {
        var random = opts.randomize ? Math.random() + 1 : 1;
        var timeout = Math.round(
          random * opts.minTimeout * Math.pow(opts.factor, attempt),
        );
        timeout = Math.min(timeout, opts.maxTimeout);
        return timeout;
      };
      exports.wrap = function (obj, options, methods) {
        if (options instanceof Array) {
          methods = options;
          options = null;
        }
        if (!methods) {
          methods = [];
          for (var key in obj) {
            if (typeof obj[key] === "function") {
              methods.push(key);
            }
          }
        }
        for (var i = 0; i < methods.length; i++) {
          var method = methods[i];
          var original = obj[method];
          obj[method] = function retryWrapper(original) {
            var op = exports.operation(options);
            var args = Array.prototype.slice.call(arguments, 1);
            var callback = args.pop();
            args.push(function (err) {
              if (op.retry(err)) {
                return;
              }
              if (err) {
                arguments[0] = op.mainError();
              }
              callback.apply(this, arguments);
            });
            op.attempt(function () {
              original.apply(obj, args);
            });
          }.bind(obj, original);
          obj[method].options = options;
        }
      };
    },
    5369: (module) => {
      function RetryOperation(timeouts, options) {
        if (typeof options === "boolean") {
          options = { forever: options };
        }
        this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
        this._timeouts = timeouts;
        this._options = options || {};
        this._maxRetryTime = (options && options.maxRetryTime) || Infinity;
        this._fn = null;
        this._errors = [];
        this._attempts = 1;
        this._operationTimeout = null;
        this._operationTimeoutCb = null;
        this._timeout = null;
        this._operationStart = null;
        if (this._options.forever) {
          this._cachedTimeouts = this._timeouts.slice(0);
        }
      }
      module.exports = RetryOperation;
      RetryOperation.prototype.reset = function () {
        this._attempts = 1;
        this._timeouts = this._originalTimeouts;
      };
      RetryOperation.prototype.stop = function () {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        this._timeouts = [];
        this._cachedTimeouts = null;
      };
      RetryOperation.prototype.retry = function (err) {
        if (this._timeout) {
          clearTimeout(this._timeout);
        }
        if (!err) {
          return false;
        }
        var currentTime = new Date().getTime();
        if (err && currentTime - this._operationStart >= this._maxRetryTime) {
          this._errors.unshift(new Error("RetryOperation timeout occurred"));
          return false;
        }
        this._errors.push(err);
        var timeout = this._timeouts.shift();
        if (timeout === undefined) {
          if (this._cachedTimeouts) {
            this._errors.splice(this._errors.length - 1, this._errors.length);
            this._timeouts = this._cachedTimeouts.slice(0);
            timeout = this._timeouts.shift();
          } else {
            return false;
          }
        }
        var self = this;
        var timer = setTimeout(function () {
          self._attempts++;
          if (self._operationTimeoutCb) {
            self._timeout = setTimeout(function () {
              self._operationTimeoutCb(self._attempts);
            }, self._operationTimeout);
            if (self._options.unref) {
              self._timeout.unref();
            }
          }
          self._fn(self._attempts);
        }, timeout);
        if (this._options.unref) {
          timer.unref();
        }
        return true;
      };
      RetryOperation.prototype.attempt = function (fn, timeoutOps) {
        this._fn = fn;
        if (timeoutOps) {
          if (timeoutOps.timeout) {
            this._operationTimeout = timeoutOps.timeout;
          }
          if (timeoutOps.cb) {
            this._operationTimeoutCb = timeoutOps.cb;
          }
        }
        var self = this;
        if (this._operationTimeoutCb) {
          this._timeout = setTimeout(function () {
            self._operationTimeoutCb();
          }, self._operationTimeout);
        }
        this._operationStart = new Date().getTime();
        this._fn(this._attempts);
      };
      RetryOperation.prototype.try = function (fn) {
        console.log("Using RetryOperation.try() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = function (fn) {
        console.log("Using RetryOperation.start() is deprecated");
        this.attempt(fn);
      };
      RetryOperation.prototype.start = RetryOperation.prototype.try;
      RetryOperation.prototype.errors = function () {
        return this._errors;
      };
      RetryOperation.prototype.attempts = function () {
        return this._attempts;
      };
      RetryOperation.prototype.mainError = function () {
        if (this._errors.length === 0) {
          return null;
        }
        var counts = {};
        var mainError = null;
        var mainErrorCount = 0;
        for (var i = 0; i < this._errors.length; i++) {
          var error = this._errors[i];
          var message = error.message;
          var count = (counts[message] || 0) + 1;
          counts[message] = count;
          if (count >= mainErrorCount) {
            mainError = error;
            mainErrorCount = count;
          }
        }
        return mainError;
      };
    },
    5118: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var buffer = __nccwpck_require__(4300);
      var Buffer = buffer.Buffer;
      var safer = {};
      var key;
      for (key in buffer) {
        if (!buffer.hasOwnProperty(key)) continue;
        if (key === "SlowBuffer" || key === "Buffer") continue;
        safer[key] = buffer[key];
      }
      var Safer = (safer.Buffer = {});
      for (key in Buffer) {
        if (!Buffer.hasOwnProperty(key)) continue;
        if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
        Safer[key] = Buffer[key];
      }
      safer.Buffer.prototype = Buffer.prototype;
      if (!Safer.from || Safer.from === Uint8Array.from) {
        Safer.from = function (value, encodingOrOffset, length) {
          if (typeof value === "number") {
            throw new TypeError(
              'The "value" argument must not be of type number. Received type ' +
                typeof value,
            );
          }
          if (value && typeof value.length === "undefined") {
            throw new TypeError(
              "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " +
                typeof value,
            );
          }
          return Buffer(value, encodingOrOffset, length);
        };
      }
      if (!Safer.alloc) {
        Safer.alloc = function (size, fill, encoding) {
          if (typeof size !== "number") {
            throw new TypeError(
              'The "size" argument must be of type number. Received type ' +
                typeof size,
            );
          }
          if (size < 0 || size >= 2 * (1 << 30)) {
            throw new RangeError(
              'The value "' + size + '" is invalid for option "size"',
            );
          }
          var buf = Buffer(size);
          if (!fill || fill.length === 0) {
            buf.fill(0);
          } else if (typeof encoding === "string") {
            buf.fill(fill, encoding);
          } else {
            buf.fill(fill);
          }
          return buf;
        };
      }
      if (!safer.kStringMaxLength) {
        try {
          safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
        } catch (e) {}
      }
      if (!safer.constants) {
        safer.constants = { MAX_LENGTH: safer.kMaxLength };
        if (safer.kStringMaxLength) {
          safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
        }
      }
      module.exports = safer;
    },
    8088: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const debug = __nccwpck_require__(427);
      const { MAX_LENGTH, MAX_SAFE_INTEGER } = __nccwpck_require__(2293);
      const { safeRe: re, t } = __nccwpck_require__(9523);
      const parseOptions = __nccwpck_require__(785);
      const { compareIdentifiers } = __nccwpck_require__(2463);
      class SemVer {
        constructor(version, options) {
          options = parseOptions(options);
          if (version instanceof SemVer) {
            if (
              version.loose === !!options.loose &&
              version.includePrerelease === !!options.includePrerelease
            ) {
              return version;
            } else {
              version = version.version;
            }
          } else if (typeof version !== "string") {
            throw new TypeError(
              `Invalid version. Must be a string. Got type "${typeof version}".`,
            );
          }
          if (version.length > MAX_LENGTH) {
            throw new TypeError(
              `version is longer than ${MAX_LENGTH} characters`,
            );
          }
          debug("SemVer", version, options);
          this.options = options;
          this.loose = !!options.loose;
          this.includePrerelease = !!options.includePrerelease;
          const m = version
            .trim()
            .match(options.loose ? re[t.LOOSE] : re[t.FULL]);
          if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
          }
          this.raw = version;
          this.major = +m[1];
          this.minor = +m[2];
          this.patch = +m[3];
          if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
          }
          if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
          }
          if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
          }
          if (!m[4]) {
            this.prerelease = [];
          } else {
            this.prerelease = m[4].split(".").map((id) => {
              if (/^[0-9]+$/.test(id)) {
                const num = +id;
                if (num >= 0 && num < MAX_SAFE_INTEGER) {
                  return num;
                }
              }
              return id;
            });
          }
          this.build = m[5] ? m[5].split(".") : [];
          this.format();
        }
        format() {
          this.version = `${this.major}.${this.minor}.${this.patch}`;
          if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
          }
          return this.version;
        }
        toString() {
          return this.version;
        }
        compare(other) {
          debug("SemVer.compare", this.version, this.options, other);
          if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
              return 0;
            }
            other = new SemVer(other, this.options);
          }
          if (other.version === this.version) {
            return 0;
          }
          return this.compareMain(other) || this.comparePre(other);
        }
        compareMain(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          return (
            compareIdentifiers(this.major, other.major) ||
            compareIdentifiers(this.minor, other.minor) ||
            compareIdentifiers(this.patch, other.patch)
          );
        }
        comparePre(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          if (this.prerelease.length && !other.prerelease.length) {
            return -1;
          } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
          } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
          }
          let i = 0;
          do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        compareBuild(other) {
          if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
          }
          let i = 0;
          do {
            const a = this.build[i];
            const b = other.build[i];
            debug("build compare", i, a, b);
            if (a === undefined && b === undefined) {
              return 0;
            } else if (b === undefined) {
              return 1;
            } else if (a === undefined) {
              return -1;
            } else if (a === b) {
              continue;
            } else {
              return compareIdentifiers(a, b);
            }
          } while (++i);
        }
        inc(release, identifier, identifierBase) {
          switch (release) {
            case "premajor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor = 0;
              this.major++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "preminor":
              this.prerelease.length = 0;
              this.patch = 0;
              this.minor++;
              this.inc("pre", identifier, identifierBase);
              break;
            case "prepatch":
              this.prerelease.length = 0;
              this.inc("patch", identifier, identifierBase);
              this.inc("pre", identifier, identifierBase);
              break;
            case "prerelease":
              if (this.prerelease.length === 0) {
                this.inc("patch", identifier, identifierBase);
              }
              this.inc("pre", identifier, identifierBase);
              break;
            case "major":
              if (
                this.minor !== 0 ||
                this.patch !== 0 ||
                this.prerelease.length === 0
              ) {
                this.major++;
              }
              this.minor = 0;
              this.patch = 0;
              this.prerelease = [];
              break;
            case "minor":
              if (this.patch !== 0 || this.prerelease.length === 0) {
                this.minor++;
              }
              this.patch = 0;
              this.prerelease = [];
              break;
            case "patch":
              if (this.prerelease.length === 0) {
                this.patch++;
              }
              this.prerelease = [];
              break;
            case "pre": {
              const base = Number(identifierBase) ? 1 : 0;
              if (!identifier && identifierBase === false) {
                throw new Error(
                  "invalid increment argument: identifier is empty",
                );
              }
              if (this.prerelease.length === 0) {
                this.prerelease = [base];
              } else {
                let i = this.prerelease.length;
                while (--i >= 0) {
                  if (typeof this.prerelease[i] === "number") {
                    this.prerelease[i]++;
                    i = -2;
                  }
                }
                if (i === -1) {
                  if (
                    identifier === this.prerelease.join(".") &&
                    identifierBase === false
                  ) {
                    throw new Error(
                      "invalid increment argument: identifier already exists",
                    );
                  }
                  this.prerelease.push(base);
                }
              }
              if (identifier) {
                let prerelease = [identifier, base];
                if (identifierBase === false) {
                  prerelease = [identifier];
                }
                if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                  if (isNaN(this.prerelease[1])) {
                    this.prerelease = prerelease;
                  }
                } else {
                  this.prerelease = prerelease;
                }
              }
              break;
            }
            default:
              throw new Error(`invalid increment argument: ${release}`);
          }
          this.raw = this.format();
          if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
          }
          return this;
        }
      }
      module.exports = SemVer;
    },
    8848: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const parse = __nccwpck_require__(5925);
      const clean = (version, options) => {
        const s = parse(version.trim().replace(/^[=v]+/, ""), options);
        return s ? s.version : null;
      };
      module.exports = clean;
    },
    5925: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const SemVer = __nccwpck_require__(8088);
      const parse = (version, options, throwErrors = false) => {
        if (version instanceof SemVer) {
          return version;
        }
        try {
          return new SemVer(version, options);
        } catch (er) {
          if (!throwErrors) {
            return null;
          }
          throw er;
        }
      };
      module.exports = parse;
    },
    9601: (module, __unused_webpack_exports, __nccwpck_require__) => {
      const parse = __nccwpck_require__(5925);
      const valid = (version, options) => {
        const v = parse(version, options);
        return v ? v.version : null;
      };
      module.exports = valid;
    },
    2293: (module) => {
      const SEMVER_SPEC_VERSION = "2.0.0";
      const MAX_LENGTH = 256;
      const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
      const MAX_SAFE_COMPONENT_LENGTH = 16;
      const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
      const RELEASE_TYPES = [
        "major",
        "premajor",
        "minor",
        "preminor",
        "patch",
        "prepatch",
        "prerelease",
      ];
      module.exports = {
        MAX_LENGTH,
        MAX_SAFE_COMPONENT_LENGTH,
        MAX_SAFE_BUILD_LENGTH,
        MAX_SAFE_INTEGER,
        RELEASE_TYPES,
        SEMVER_SPEC_VERSION,
        FLAG_INCLUDE_PRERELEASE: 1,
        FLAG_LOOSE: 2,
      };
    },
    427: (module) => {
      const debug =
        typeof process === "object" &&
        process.env &&
        process.env.NODE_DEBUG &&
        /\bsemver\b/i.test(process.env.NODE_DEBUG)
          ? (...args) => console.error("SEMVER", ...args)
          : () => {};
      module.exports = debug;
    },
    2463: (module) => {
      const numeric = /^[0-9]+$/;
      const compareIdentifiers = (a, b) => {
        const anum = numeric.test(a);
        const bnum = numeric.test(b);
        if (anum && bnum) {
          a = +a;
          b = +b;
        }
        return a === b
          ? 0
          : anum && !bnum
            ? -1
            : bnum && !anum
              ? 1
              : a < b
                ? -1
                : 1;
      };
      const rcompareIdentifiers = (a, b) => compareIdentifiers(b, a);
      module.exports = { compareIdentifiers, rcompareIdentifiers };
    },
    785: (module) => {
      const looseOption = Object.freeze({ loose: true });
      const emptyOpts = Object.freeze({});
      const parseOptions = (options) => {
        if (!options) {
          return emptyOpts;
        }
        if (typeof options !== "object") {
          return looseOption;
        }
        return options;
      };
      module.exports = parseOptions;
    },
    9523: (module, exports, __nccwpck_require__) => {
      const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } =
        __nccwpck_require__(2293);
      const debug = __nccwpck_require__(427);
      exports = module.exports = {};
      const re = (exports.re = []);
      const safeRe = (exports.safeRe = []);
      const src = (exports.src = []);
      const t = (exports.t = {});
      let R = 0;
      const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
      const safeRegexReplacements = [
        ["\\s", 1],
        ["\\d", MAX_LENGTH],
        [LETTERDASHNUMBER, MAX_SAFE_BUILD_LENGTH],
      ];
      const makeSafeRegex = (value) => {
        for (const [token, max] of safeRegexReplacements) {
          value = value
            .split(`${token}*`)
            .join(`${token}{0,${max}}`)
            .split(`${token}+`)
            .join(`${token}{1,${max}}`);
        }
        return value;
      };
      const createToken = (name, value, isGlobal) => {
        const safe = makeSafeRegex(value);
        const index = R++;
        debug(name, index, value);
        t[name] = index;
        src[index] = value;
        re[index] = new RegExp(value, isGlobal ? "g" : undefined);
        safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
      };
      createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
      createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
      createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
      createToken(
        "MAINVERSION",
        `(${src[t.NUMERICIDENTIFIER]})\\.` +
          `(${src[t.NUMERICIDENTIFIER]})\\.` +
          `(${src[t.NUMERICIDENTIFIER]})`,
      );
      createToken(
        "MAINVERSIONLOOSE",
        `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
          `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` +
          `(${src[t.NUMERICIDENTIFIERLOOSE]})`,
      );
      createToken(
        "PRERELEASEIDENTIFIER",
        `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`,
      );
      createToken(
        "PRERELEASEIDENTIFIERLOOSE",
        `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`,
      );
      createToken(
        "PRERELEASE",
        `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`,
      );
      createToken(
        "PRERELEASELOOSE",
        `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`,
      );
      createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
      createToken(
        "BUILD",
        `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`,
      );
      createToken(
        "FULLPLAIN",
        `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`,
      );
      createToken("FULL", `^${src[t.FULLPLAIN]}$`);
      createToken(
        "LOOSEPLAIN",
        `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`,
      );
      createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
      createToken("GTLT", "((?:<|>)?=?)");
      createToken(
        "XRANGEIDENTIFIERLOOSE",
        `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`,
      );
      createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
      createToken(
        "XRANGEPLAIN",
        `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIER]})` +
          `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` +
          `)?)?`,
      );
      createToken(
        "XRANGEPLAINLOOSE",
        `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` +
          `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` +
          `)?)?`,
      );
      createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
      createToken(
        "XRANGELOOSE",
        `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`,
      );
      createToken(
        "COERCEPLAIN",
        `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` +
          `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` +
          `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?`,
      );
      createToken("COERCE", `${src[t.COERCEPLAIN]}(?:$|[^\\d])`);
      createToken(
        "COERCEFULL",
        src[t.COERCEPLAIN] +
          `(?:${src[t.PRERELEASE]})?` +
          `(?:${src[t.BUILD]})?` +
          `(?:$|[^\\d])`,
      );
      createToken("COERCERTL", src[t.COERCE], true);
      createToken("COERCERTLFULL", src[t.COERCEFULL], true);
      createToken("LONETILDE", "(?:~>?)");
      createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
      exports.tildeTrimReplace = "$1~";
      createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
      createToken(
        "TILDELOOSE",
        `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`,
      );
      createToken("LONECARET", "(?:\\^)");
      createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
      exports.caretTrimReplace = "$1^";
      createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
      createToken(
        "CARETLOOSE",
        `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`,
      );
      createToken(
        "COMPARATORLOOSE",
        `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`,
      );
      createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
      createToken(
        "COMPARATORTRIM",
        `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`,
        true,
      );
      exports.comparatorTrimReplace = "$1$2$3";
      createToken(
        "HYPHENRANGE",
        `^\\s*(${src[t.XRANGEPLAIN]})` +
          `\\s+-\\s+` +
          `(${src[t.XRANGEPLAIN]})` +
          `\\s*$`,
      );
      createToken(
        "HYPHENRANGELOOSE",
        `^\\s*(${src[t.XRANGEPLAINLOOSE]})` +
          `\\s+-\\s+` +
          `(${src[t.XRANGEPLAINLOOSE]})` +
          `\\s*$`,
      );
      createToken("STAR", "(<|>)?=?\\s*\\*");
      createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
      createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");
    },
    3430: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createVerificationPolicy =
        exports.createKeyFinder =
        exports.createBundleBuilder =
        exports.DEFAULT_TIMEOUT =
        exports.DEFAULT_RETRY =
          void 0;
      const core_1 = __nccwpck_require__(3352);
      const sign_1 = __nccwpck_require__(2071);
      const verify_1 = __nccwpck_require__(666);
      exports.DEFAULT_RETRY = { retries: 2 };
      exports.DEFAULT_TIMEOUT = 5e3;
      function createBundleBuilder(bundleType, options) {
        const bundlerOptions = {
          signer: initSigner(options),
          witnesses: initWitnesses(options),
        };
        switch (bundleType) {
          case "messageSignature":
            return new sign_1.MessageSignatureBundleBuilder(bundlerOptions);
          case "dsseEnvelope":
            return new sign_1.DSSEBundleBuilder(bundlerOptions);
        }
      }
      exports.createBundleBuilder = createBundleBuilder;
      function createKeyFinder(keySelector) {
        return (hint) => {
          const key = keySelector(hint);
          if (!key) {
            throw new verify_1.VerificationError({
              code: "PUBLIC_KEY_ERROR",
              message: `key not found: ${hint}`,
            });
          }
          return {
            publicKey: core_1.crypto.createPublicKey(key),
            validFor: () => true,
          };
        };
      }
      exports.createKeyFinder = createKeyFinder;
      function createVerificationPolicy(options) {
        const policy = {};
        const san =
          options.certificateIdentityEmail || options.certificateIdentityURI;
        if (san) {
          policy.subjectAlternativeName = san;
        }
        if (options.certificateIssuer) {
          policy.extensions = { issuer: options.certificateIssuer };
        }
        return policy;
      }
      exports.createVerificationPolicy = createVerificationPolicy;
      function initSigner(options) {
        return new sign_1.FulcioSigner({
          fulcioBaseURL: options.fulcioURL,
          identityProvider:
            options.identityProvider || initIdentityProvider(options),
          retry: options.retry ?? exports.DEFAULT_RETRY,
          timeout: options.timeout ?? exports.DEFAULT_TIMEOUT,
        });
      }
      function initIdentityProvider(options) {
        const token = options.identityToken;
        if (token) {
          return { getToken: () => Promise.resolve(token) };
        } else {
          return new sign_1.CIContextProvider("sigstore");
        }
      }
      function initWitnesses(options) {
        const witnesses = [];
        if (isRekorEnabled(options)) {
          witnesses.push(
            new sign_1.RekorWitness({
              rekorBaseURL: options.rekorURL,
              fetchOnConflict: false,
              retry: options.retry ?? exports.DEFAULT_RETRY,
              timeout: options.timeout ?? exports.DEFAULT_TIMEOUT,
            }),
          );
        }
        if (isTSAEnabled(options)) {
          witnesses.push(
            new sign_1.TSAWitness({
              tsaBaseURL: options.tsaServerURL,
              retry: options.retry ?? exports.DEFAULT_RETRY,
              timeout: options.timeout ?? exports.DEFAULT_TIMEOUT,
            }),
          );
        }
        return witnesses;
      }
      function isRekorEnabled(options) {
        return options.tlogUpload !== false;
      }
      function isTSAEnabled(options) {
        return options.tsaServerURL !== undefined;
      }
    },
    9149: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.verify =
        exports.sign =
        exports.createVerifier =
        exports.attest =
        exports.VerificationError =
        exports.PolicyError =
        exports.TUFError =
        exports.InternalError =
        exports.DEFAULT_REKOR_URL =
        exports.DEFAULT_FULCIO_URL =
        exports.ValidationError =
          void 0;
      var bundle_1 = __nccwpck_require__(9715);
      Object.defineProperty(exports, "ValidationError", {
        enumerable: true,
        get: function () {
          return bundle_1.ValidationError;
        },
      });
      var sign_1 = __nccwpck_require__(2071);
      Object.defineProperty(exports, "DEFAULT_FULCIO_URL", {
        enumerable: true,
        get: function () {
          return sign_1.DEFAULT_FULCIO_URL;
        },
      });
      Object.defineProperty(exports, "DEFAULT_REKOR_URL", {
        enumerable: true,
        get: function () {
          return sign_1.DEFAULT_REKOR_URL;
        },
      });
      Object.defineProperty(exports, "InternalError", {
        enumerable: true,
        get: function () {
          return sign_1.InternalError;
        },
      });
      var tuf_1 = __nccwpck_require__(8567);
      Object.defineProperty(exports, "TUFError", {
        enumerable: true,
        get: function () {
          return tuf_1.TUFError;
        },
      });
      var verify_1 = __nccwpck_require__(666);
      Object.defineProperty(exports, "PolicyError", {
        enumerable: true,
        get: function () {
          return verify_1.PolicyError;
        },
      });
      Object.defineProperty(exports, "VerificationError", {
        enumerable: true,
        get: function () {
          return verify_1.VerificationError;
        },
      });
      var sigstore_1 = __nccwpck_require__(1111);
      Object.defineProperty(exports, "attest", {
        enumerable: true,
        get: function () {
          return sigstore_1.attest;
        },
      });
      Object.defineProperty(exports, "createVerifier", {
        enumerable: true,
        get: function () {
          return sigstore_1.createVerifier;
        },
      });
      Object.defineProperty(exports, "sign", {
        enumerable: true,
        get: function () {
          return sigstore_1.sign;
        },
      });
      Object.defineProperty(exports, "verify", {
        enumerable: true,
        get: function () {
          return sigstore_1.verify;
        },
      });
    },
    1111: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.createVerifier =
        exports.verify =
        exports.attest =
        exports.sign =
          void 0;
      const bundle_1 = __nccwpck_require__(9715);
      const tuf = __importStar(__nccwpck_require__(8567));
      const verify_1 = __nccwpck_require__(666);
      const config = __importStar(__nccwpck_require__(3430));
      async function sign(payload, options = {}) {
        const bundler = config.createBundleBuilder("messageSignature", options);
        const bundle = await bundler.create({ data: payload });
        return (0, bundle_1.bundleToJSON)(bundle);
      }
      exports.sign = sign;
      async function attest(payload, payloadType, options = {}) {
        const bundler = config.createBundleBuilder("dsseEnvelope", options);
        const bundle = await bundler.create({
          data: payload,
          type: payloadType,
        });
        return (0, bundle_1.bundleToJSON)(bundle);
      }
      exports.attest = attest;
      async function verify(bundle, dataOrOptions, options) {
        let data;
        if (Buffer.isBuffer(dataOrOptions)) {
          data = dataOrOptions;
        } else {
          options = dataOrOptions;
        }
        return createVerifier(options).then((verifier) =>
          verifier.verify(bundle, data),
        );
      }
      exports.verify = verify;
      async function createVerifier(options = {}) {
        const trustedRoot = await tuf.getTrustedRoot({
          mirrorURL: options.tufMirrorURL,
          rootPath: options.tufRootPath,
          cachePath: options.tufCachePath,
          forceCache: options.tufForceCache,
          retry: options.retry ?? config.DEFAULT_RETRY,
          timeout: options.timeout ?? config.DEFAULT_TIMEOUT,
        });
        const keyFinder = options.keySelector
          ? config.createKeyFinder(options.keySelector)
          : undefined;
        const trustMaterial = (0, verify_1.toTrustMaterial)(
          trustedRoot,
          keyFinder,
        );
        const verifierOptions = {
          ctlogThreshold: options.ctLogThreshold,
          tlogThreshold: options.tlogThreshold,
        };
        const verifier = new verify_1.Verifier(trustMaterial, verifierOptions);
        const policy = config.createVerificationPolicy(options);
        return {
          verify: (bundle, payload) => {
            const deserializedBundle = (0, bundle_1.bundleFromJSON)(bundle);
            const signedEntity = (0, verify_1.toSignedEntity)(
              deserializedBundle,
              payload,
            );
            verifier.verify(signedEntity, policy);
            return;
          },
        };
      }
      exports.createVerifier = createVerifier;
    },
    1062: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      const utils_1 = __nccwpck_require__(8132);
      const DEFAULT_SMARTBUFFER_SIZE = 4096;
      const DEFAULT_SMARTBUFFER_ENCODING = "utf8";
      class SmartBuffer {
        constructor(options) {
          this.length = 0;
          this._encoding = DEFAULT_SMARTBUFFER_ENCODING;
          this._writeOffset = 0;
          this._readOffset = 0;
          if (SmartBuffer.isSmartBufferOptions(options)) {
            if (options.encoding) {
              utils_1.checkEncoding(options.encoding);
              this._encoding = options.encoding;
            }
            if (options.size) {
              if (utils_1.isFiniteInteger(options.size) && options.size > 0) {
                this._buff = Buffer.allocUnsafe(options.size);
              } else {
                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_SIZE);
              }
            } else if (options.buff) {
              if (Buffer.isBuffer(options.buff)) {
                this._buff = options.buff;
                this.length = options.buff.length;
              } else {
                throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_BUFFER);
              }
            } else {
              this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
            }
          } else {
            if (typeof options !== "undefined") {
              throw new Error(utils_1.ERRORS.INVALID_SMARTBUFFER_OBJECT);
            }
            this._buff = Buffer.allocUnsafe(DEFAULT_SMARTBUFFER_SIZE);
          }
        }
        static fromSize(size, encoding) {
          return new this({ size, encoding });
        }
        static fromBuffer(buff, encoding) {
          return new this({ buff, encoding });
        }
        static fromOptions(options) {
          return new this(options);
        }
        static isSmartBufferOptions(options) {
          const castOptions = options;
          return (
            castOptions &&
            (castOptions.encoding !== undefined ||
              castOptions.size !== undefined ||
              castOptions.buff !== undefined)
          );
        }
        readInt8(offset) {
          return this._readNumberValue(Buffer.prototype.readInt8, 1, offset);
        }
        readInt16BE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt16BE, 2, offset);
        }
        readInt16LE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt16LE, 2, offset);
        }
        readInt32BE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt32BE, 4, offset);
        }
        readInt32LE(offset) {
          return this._readNumberValue(Buffer.prototype.readInt32LE, 4, offset);
        }
        readBigInt64BE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigInt64BE");
          return this._readNumberValue(
            Buffer.prototype.readBigInt64BE,
            8,
            offset,
          );
        }
        readBigInt64LE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigInt64LE");
          return this._readNumberValue(
            Buffer.prototype.readBigInt64LE,
            8,
            offset,
          );
        }
        writeInt8(value, offset) {
          this._writeNumberValue(Buffer.prototype.writeInt8, 1, value, offset);
          return this;
        }
        insertInt8(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt8,
            1,
            value,
            offset,
          );
        }
        writeInt16BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt16BE,
            2,
            value,
            offset,
          );
        }
        insertInt16BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt16BE,
            2,
            value,
            offset,
          );
        }
        writeInt16LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt16LE,
            2,
            value,
            offset,
          );
        }
        insertInt16LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt16LE,
            2,
            value,
            offset,
          );
        }
        writeInt32BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt32BE,
            4,
            value,
            offset,
          );
        }
        insertInt32BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt32BE,
            4,
            value,
            offset,
          );
        }
        writeInt32LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeInt32LE,
            4,
            value,
            offset,
          );
        }
        insertInt32LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeInt32LE,
            4,
            value,
            offset,
          );
        }
        writeBigInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigInt64BE,
            8,
            value,
            offset,
          );
        }
        insertBigInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64BE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigInt64BE,
            8,
            value,
            offset,
          );
        }
        writeBigInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigInt64LE,
            8,
            value,
            offset,
          );
        }
        insertBigInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigInt64LE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigInt64LE,
            8,
            value,
            offset,
          );
        }
        readUInt8(offset) {
          return this._readNumberValue(Buffer.prototype.readUInt8, 1, offset);
        }
        readUInt16BE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt16BE,
            2,
            offset,
          );
        }
        readUInt16LE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt16LE,
            2,
            offset,
          );
        }
        readUInt32BE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt32BE,
            4,
            offset,
          );
        }
        readUInt32LE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readUInt32LE,
            4,
            offset,
          );
        }
        readBigUInt64BE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigUInt64BE");
          return this._readNumberValue(
            Buffer.prototype.readBigUInt64BE,
            8,
            offset,
          );
        }
        readBigUInt64LE(offset) {
          utils_1.bigIntAndBufferInt64Check("readBigUInt64LE");
          return this._readNumberValue(
            Buffer.prototype.readBigUInt64LE,
            8,
            offset,
          );
        }
        writeUInt8(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt8,
            1,
            value,
            offset,
          );
        }
        insertUInt8(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt8,
            1,
            value,
            offset,
          );
        }
        writeUInt16BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt16BE,
            2,
            value,
            offset,
          );
        }
        insertUInt16BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt16BE,
            2,
            value,
            offset,
          );
        }
        writeUInt16LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt16LE,
            2,
            value,
            offset,
          );
        }
        insertUInt16LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt16LE,
            2,
            value,
            offset,
          );
        }
        writeUInt32BE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt32BE,
            4,
            value,
            offset,
          );
        }
        insertUInt32BE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt32BE,
            4,
            value,
            offset,
          );
        }
        writeUInt32LE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeUInt32LE,
            4,
            value,
            offset,
          );
        }
        insertUInt32LE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeUInt32LE,
            4,
            value,
            offset,
          );
        }
        writeBigUInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigUInt64BE,
            8,
            value,
            offset,
          );
        }
        insertBigUInt64BE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64BE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigUInt64BE,
            8,
            value,
            offset,
          );
        }
        writeBigUInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
          return this._writeNumberValue(
            Buffer.prototype.writeBigUInt64LE,
            8,
            value,
            offset,
          );
        }
        insertBigUInt64LE(value, offset) {
          utils_1.bigIntAndBufferInt64Check("writeBigUInt64LE");
          return this._insertNumberValue(
            Buffer.prototype.writeBigUInt64LE,
            8,
            value,
            offset,
          );
        }
        readFloatBE(offset) {
          return this._readNumberValue(Buffer.prototype.readFloatBE, 4, offset);
        }
        readFloatLE(offset) {
          return this._readNumberValue(Buffer.prototype.readFloatLE, 4, offset);
        }
        writeFloatBE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeFloatBE,
            4,
            value,
            offset,
          );
        }
        insertFloatBE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeFloatBE,
            4,
            value,
            offset,
          );
        }
        writeFloatLE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeFloatLE,
            4,
            value,
            offset,
          );
        }
        insertFloatLE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeFloatLE,
            4,
            value,
            offset,
          );
        }
        readDoubleBE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readDoubleBE,
            8,
            offset,
          );
        }
        readDoubleLE(offset) {
          return this._readNumberValue(
            Buffer.prototype.readDoubleLE,
            8,
            offset,
          );
        }
        writeDoubleBE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeDoubleBE,
            8,
            value,
            offset,
          );
        }
        insertDoubleBE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeDoubleBE,
            8,
            value,
            offset,
          );
        }
        writeDoubleLE(value, offset) {
          return this._writeNumberValue(
            Buffer.prototype.writeDoubleLE,
            8,
            value,
            offset,
          );
        }
        insertDoubleLE(value, offset) {
          return this._insertNumberValue(
            Buffer.prototype.writeDoubleLE,
            8,
            value,
            offset,
          );
        }
        readString(arg1, encoding) {
          let lengthVal;
          if (typeof arg1 === "number") {
            utils_1.checkLengthValue(arg1);
            lengthVal = Math.min(arg1, this.length - this._readOffset);
          } else {
            encoding = arg1;
            lengthVal = this.length - this._readOffset;
          }
          if (typeof encoding !== "undefined") {
            utils_1.checkEncoding(encoding);
          }
          const value = this._buff
            .slice(this._readOffset, this._readOffset + lengthVal)
            .toString(encoding || this._encoding);
          this._readOffset += lengthVal;
          return value;
        }
        insertString(value, offset, encoding) {
          utils_1.checkOffsetValue(offset);
          return this._handleString(value, true, offset, encoding);
        }
        writeString(value, arg2, encoding) {
          return this._handleString(value, false, arg2, encoding);
        }
        readStringNT(encoding) {
          if (typeof encoding !== "undefined") {
            utils_1.checkEncoding(encoding);
          }
          let nullPos = this.length;
          for (let i = this._readOffset; i < this.length; i++) {
            if (this._buff[i] === 0) {
              nullPos = i;
              break;
            }
          }
          const value = this._buff.slice(this._readOffset, nullPos);
          this._readOffset = nullPos + 1;
          return value.toString(encoding || this._encoding);
        }
        insertStringNT(value, offset, encoding) {
          utils_1.checkOffsetValue(offset);
          this.insertString(value, offset, encoding);
          this.insertUInt8(0, offset + value.length);
          return this;
        }
        writeStringNT(value, arg2, encoding) {
          this.writeString(value, arg2, encoding);
          this.writeUInt8(
            0,
            typeof arg2 === "number" ? arg2 + value.length : this.writeOffset,
          );
          return this;
        }
        readBuffer(length) {
          if (typeof length !== "undefined") {
            utils_1.checkLengthValue(length);
          }
          const lengthVal = typeof length === "number" ? length : this.length;
          const endPoint = Math.min(this.length, this._readOffset + lengthVal);
          const value = this._buff.slice(this._readOffset, endPoint);
          this._readOffset = endPoint;
          return value;
        }
        insertBuffer(value, offset) {
          utils_1.checkOffsetValue(offset);
          return this._handleBuffer(value, true, offset);
        }
        writeBuffer(value, offset) {
          return this._handleBuffer(value, false, offset);
        }
        readBufferNT() {
          let nullPos = this.length;
          for (let i = this._readOffset; i < this.length; i++) {
            if (this._buff[i] === 0) {
              nullPos = i;
              break;
            }
          }
          const value = this._buff.slice(this._readOffset, nullPos);
          this._readOffset = nullPos + 1;
          return value;
        }
        insertBufferNT(value, offset) {
          utils_1.checkOffsetValue(offset);
          this.insertBuffer(value, offset);
          this.insertUInt8(0, offset + value.length);
          return this;
        }
        writeBufferNT(value, offset) {
          if (typeof offset !== "undefined") {
            utils_1.checkOffsetValue(offset);
          }
          this.writeBuffer(value, offset);
          this.writeUInt8(
            0,
            typeof offset === "number"
              ? offset + value.length
              : this._writeOffset,
          );
          return this;
        }
        clear() {
          this._writeOffset = 0;
          this._readOffset = 0;
          this.length = 0;
          return this;
        }
        remaining() {
          return this.length - this._readOffset;
        }
        get readOffset() {
          return this._readOffset;
        }
        set readOffset(offset) {
          utils_1.checkOffsetValue(offset);
          utils_1.checkTargetOffset(offset, this);
          this._readOffset = offset;
        }
        get writeOffset() {
          return this._writeOffset;
        }
        set writeOffset(offset) {
          utils_1.checkOffsetValue(offset);
          utils_1.checkTargetOffset(offset, this);
          this._writeOffset = offset;
        }
        get encoding() {
          return this._encoding;
        }
        set encoding(encoding) {
          utils_1.checkEncoding(encoding);
          this._encoding = encoding;
        }
        get internalBuffer() {
          return this._buff;
        }
        toBuffer() {
          return this._buff.slice(0, this.length);
        }
        toString(encoding) {
          const encodingVal =
            typeof encoding === "string" ? encoding : this._encoding;
          utils_1.checkEncoding(encodingVal);
          return this._buff.toString(encodingVal, 0, this.length);
        }
        destroy() {
          this.clear();
          return this;
        }
        _handleString(value, isInsert, arg3, encoding) {
          let offsetVal = this._writeOffset;
          let encodingVal = this._encoding;
          if (typeof arg3 === "number") {
            offsetVal = arg3;
          } else if (typeof arg3 === "string") {
            utils_1.checkEncoding(arg3);
            encodingVal = arg3;
          }
          if (typeof encoding === "string") {
            utils_1.checkEncoding(encoding);
            encodingVal = encoding;
          }
          const byteLength = Buffer.byteLength(value, encodingVal);
          if (isInsert) {
            this.ensureInsertable(byteLength, offsetVal);
          } else {
            this._ensureWriteable(byteLength, offsetVal);
          }
          this._buff.write(value, offsetVal, byteLength, encodingVal);
          if (isInsert) {
            this._writeOffset += byteLength;
          } else {
            if (typeof arg3 === "number") {
              this._writeOffset = Math.max(
                this._writeOffset,
                offsetVal + byteLength,
              );
            } else {
              this._writeOffset += byteLength;
            }
          }
          return this;
        }
        _handleBuffer(value, isInsert, offset) {
          const offsetVal =
            typeof offset === "number" ? offset : this._writeOffset;
          if (isInsert) {
            this.ensureInsertable(value.length, offsetVal);
          } else {
            this._ensureWriteable(value.length, offsetVal);
          }
          value.copy(this._buff, offsetVal);
          if (isInsert) {
            this._writeOffset += value.length;
          } else {
            if (typeof offset === "number") {
              this._writeOffset = Math.max(
                this._writeOffset,
                offsetVal + value.length,
              );
            } else {
              this._writeOffset += value.length;
            }
          }
          return this;
        }
        ensureReadable(length, offset) {
          let offsetVal = this._readOffset;
          if (typeof offset !== "undefined") {
            utils_1.checkOffsetValue(offset);
            offsetVal = offset;
          }
          if (offsetVal < 0 || offsetVal + length > this.length) {
            throw new Error(utils_1.ERRORS.INVALID_READ_BEYOND_BOUNDS);
          }
        }
        ensureInsertable(dataLength, offset) {
          utils_1.checkOffsetValue(offset);
          this._ensureCapacity(this.length + dataLength);
          if (offset < this.length) {
            this._buff.copy(
              this._buff,
              offset + dataLength,
              offset,
              this._buff.length,
            );
          }
          if (offset + dataLength > this.length) {
            this.length = offset + dataLength;
          } else {
            this.length += dataLength;
          }
        }
        _ensureWriteable(dataLength, offset) {
          const offsetVal =
            typeof offset === "number" ? offset : this._writeOffset;
          this._ensureCapacity(offsetVal + dataLength);
          if (offsetVal + dataLength > this.length) {
            this.length = offsetVal + dataLength;
          }
        }
        _ensureCapacity(minLength) {
          const oldLength = this._buff.length;
          if (minLength > oldLength) {
            let data = this._buff;
            let newLength = (oldLength * 3) / 2 + 1;
            if (newLength < minLength) {
              newLength = minLength;
            }
            this._buff = Buffer.allocUnsafe(newLength);
            data.copy(this._buff, 0, 0, oldLength);
          }
        }
        _readNumberValue(func, byteSize, offset) {
          this.ensureReadable(byteSize, offset);
          const value = func.call(
            this._buff,
            typeof offset === "number" ? offset : this._readOffset,
          );
          if (typeof offset === "undefined") {
            this._readOffset += byteSize;
          }
          return value;
        }
        _insertNumberValue(func, byteSize, value, offset) {
          utils_1.checkOffsetValue(offset);
          this.ensureInsertable(byteSize, offset);
          func.call(this._buff, value, offset);
          this._writeOffset += byteSize;
          return this;
        }
        _writeNumberValue(func, byteSize, value, offset) {
          if (typeof offset === "number") {
            if (offset < 0) {
              throw new Error(utils_1.ERRORS.INVALID_WRITE_BEYOND_BOUNDS);
            }
            utils_1.checkOffsetValue(offset);
          }
          const offsetVal =
            typeof offset === "number" ? offset : this._writeOffset;
          this._ensureWriteable(byteSize, offsetVal);
          func.call(this._buff, value, offsetVal);
          if (typeof offset === "number") {
            this._writeOffset = Math.max(
              this._writeOffset,
              offsetVal + byteSize,
            );
          } else {
            this._writeOffset += byteSize;
          }
          return this;
        }
      }
      exports.SmartBuffer = SmartBuffer;
    },
    8132: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      const buffer_1 = __nccwpck_require__(4300);
      const ERRORS = {
        INVALID_ENCODING:
          "Invalid encoding provided. Please specify a valid encoding the internal Node.js Buffer supports.",
        INVALID_SMARTBUFFER_SIZE:
          "Invalid size provided. Size must be a valid integer greater than zero.",
        INVALID_SMARTBUFFER_BUFFER:
          "Invalid Buffer provided in SmartBufferOptions.",
        INVALID_SMARTBUFFER_OBJECT:
          "Invalid SmartBufferOptions object supplied to SmartBuffer constructor or factory methods.",
        INVALID_OFFSET: "An invalid offset value was provided.",
        INVALID_OFFSET_NON_NUMBER:
          "An invalid offset value was provided. A numeric value is required.",
        INVALID_LENGTH: "An invalid length value was provided.",
        INVALID_LENGTH_NON_NUMBER:
          "An invalid length value was provived. A numeric value is required.",
        INVALID_TARGET_OFFSET:
          "Target offset is beyond the bounds of the internal SmartBuffer data.",
        INVALID_TARGET_LENGTH:
          "Specified length value moves cursor beyong the bounds of the internal SmartBuffer data.",
        INVALID_READ_BEYOND_BOUNDS:
          "Attempted to read beyond the bounds of the managed data.",
        INVALID_WRITE_BEYOND_BOUNDS:
          "Attempted to write beyond the bounds of the managed data.",
      };
      exports.ERRORS = ERRORS;
      function checkEncoding(encoding) {
        if (!buffer_1.Buffer.isEncoding(encoding)) {
          throw new Error(ERRORS.INVALID_ENCODING);
        }
      }
      exports.checkEncoding = checkEncoding;
      function isFiniteInteger(value) {
        return typeof value === "number" && isFinite(value) && isInteger(value);
      }
      exports.isFiniteInteger = isFiniteInteger;
      function checkOffsetOrLengthValue(value, offset) {
        if (typeof value === "number") {
          if (!isFiniteInteger(value) || value < 0) {
            throw new Error(
              offset ? ERRORS.INVALID_OFFSET : ERRORS.INVALID_LENGTH,
            );
          }
        } else {
          throw new Error(
            offset
              ? ERRORS.INVALID_OFFSET_NON_NUMBER
              : ERRORS.INVALID_LENGTH_NON_NUMBER,
          );
        }
      }
      function checkLengthValue(length) {
        checkOffsetOrLengthValue(length, false);
      }
      exports.checkLengthValue = checkLengthValue;
      function checkOffsetValue(offset) {
        checkOffsetOrLengthValue(offset, true);
      }
      exports.checkOffsetValue = checkOffsetValue;
      function checkTargetOffset(offset, buff) {
        if (offset < 0 || offset > buff.length) {
          throw new Error(ERRORS.INVALID_TARGET_OFFSET);
        }
      }
      exports.checkTargetOffset = checkTargetOffset;
      function isInteger(value) {
        return (
          typeof value === "number" &&
          isFinite(value) &&
          Math.floor(value) === value
        );
      }
      function bigIntAndBufferInt64Check(bufferMethod) {
        if (typeof BigInt === "undefined") {
          throw new Error("Platform does not support JS BigInt type.");
        }
        if (typeof buffer_1.Buffer.prototype[bufferMethod] === "undefined") {
          throw new Error(
            `Platform does not support Buffer.prototype.${bufferMethod}.`,
          );
        }
      }
      exports.bigIntAndBufferInt64Check = bigIntAndBufferInt64Check;
    },
    5038: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SocksProxyAgent = void 0;
      const socks_1 = __nccwpck_require__(4754);
      const agent_base_1 = __nccwpck_require__(694);
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const dns = __importStar(__nccwpck_require__(7578));
      const tls = __importStar(__nccwpck_require__(4404));
      const url_1 = __nccwpck_require__(7310);
      const debug = (0, debug_1.default)("socks-proxy-agent");
      function parseSocksURL(url) {
        let lookup = false;
        let type = 5;
        const host = url.hostname;
        const port = parseInt(url.port, 10) || 1080;
        switch (url.protocol.replace(":", "")) {
          case "socks4":
            lookup = true;
            type = 4;
            break;
          case "socks4a":
            type = 4;
            break;
          case "socks5":
            lookup = true;
            type = 5;
            break;
          case "socks":
            type = 5;
            break;
          case "socks5h":
            type = 5;
            break;
          default:
            throw new TypeError(
              `A "socks" protocol must be specified! Got: ${String(url.protocol)}`,
            );
        }
        const proxy = { host, port, type };
        if (url.username) {
          Object.defineProperty(proxy, "userId", {
            value: decodeURIComponent(url.username),
            enumerable: false,
          });
        }
        if (url.password != null) {
          Object.defineProperty(proxy, "password", {
            value: decodeURIComponent(url.password),
            enumerable: false,
          });
        }
        return { lookup, proxy };
      }
      class SocksProxyAgent extends agent_base_1.Agent {
        constructor(uri, opts) {
          super(opts);
          const url = typeof uri === "string" ? new url_1.URL(uri) : uri;
          const { proxy, lookup } = parseSocksURL(url);
          this.shouldLookup = lookup;
          this.proxy = proxy;
          this.timeout = opts?.timeout ?? null;
          this.socketOptions = opts?.socketOptions ?? null;
        }
        async connect(req, opts) {
          const { shouldLookup, proxy, timeout } = this;
          if (!opts.host) {
            throw new Error("No `host` defined!");
          }
          let { host } = opts;
          const { port, lookup: lookupFn = dns.lookup } = opts;
          if (shouldLookup) {
            host = await new Promise((resolve, reject) => {
              lookupFn(host, {}, (err, res) => {
                if (err) {
                  reject(err);
                } else {
                  resolve(res);
                }
              });
            });
          }
          const socksOpts = {
            proxy,
            destination: {
              host,
              port: typeof port === "number" ? port : parseInt(port, 10),
            },
            command: "connect",
            timeout: timeout ?? undefined,
            socket_options: this.socketOptions ?? undefined,
          };
          const cleanup = (tlsSocket) => {
            req.destroy();
            socket.destroy();
            if (tlsSocket) tlsSocket.destroy();
          };
          debug("Creating socks proxy connection: %o", socksOpts);
          const { socket } =
            await socks_1.SocksClient.createConnection(socksOpts);
          debug("Successfully created socks proxy connection");
          if (timeout !== null) {
            socket.setTimeout(timeout);
            socket.on("timeout", () => cleanup());
          }
          if (opts.secureEndpoint) {
            debug("Upgrading socket connection to TLS");
            const servername = opts.servername || opts.host;
            const tlsSocket = tls.connect({
              ...omit(opts, "host", "path", "port"),
              socket,
              servername,
            });
            tlsSocket.once("error", (error) => {
              debug("Socket TLS error", error.message);
              cleanup(tlsSocket);
            });
            return tlsSocket;
          }
          return socket;
        }
      }
      SocksProxyAgent.protocols = [
        "socks",
        "socks4",
        "socks4a",
        "socks5",
        "socks5h",
      ];
      exports.SocksProxyAgent = SocksProxyAgent;
      function omit(obj, ...keys) {
        const ret = {};
        let key;
        for (key in obj) {
          if (!keys.includes(key)) {
            ret[key] = obj[key];
          }
        }
        return ret;
      }
    },
    6127: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __awaiter =
        (this && this.__awaiter) ||
        function (thisArg, _arguments, P, generator) {
          function adopt(value) {
            return value instanceof P
              ? value
              : new P(function (resolve) {
                  resolve(value);
                });
          }
          return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) {
              try {
                step(generator.next(value));
              } catch (e) {
                reject(e);
              }
            }
            function rejected(value) {
              try {
                step(generator["throw"](value));
              } catch (e) {
                reject(e);
              }
            }
            function step(result) {
              result.done
                ? resolve(result.value)
                : adopt(result.value).then(fulfilled, rejected);
            }
            step(
              (generator = generator.apply(thisArg, _arguments || [])).next(),
            );
          });
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SocksClientError = exports.SocksClient = void 0;
      const events_1 = __nccwpck_require__(2361);
      const net = __nccwpck_require__(1808);
      const smart_buffer_1 = __nccwpck_require__(1062);
      const constants_1 = __nccwpck_require__(9647);
      const helpers_1 = __nccwpck_require__(4324);
      const receivebuffer_1 = __nccwpck_require__(9740);
      const util_1 = __nccwpck_require__(5523);
      Object.defineProperty(exports, "SocksClientError", {
        enumerable: true,
        get: function () {
          return util_1.SocksClientError;
        },
      });
      const ip_address_1 = __nccwpck_require__(8953);
      class SocksClient extends events_1.EventEmitter {
        constructor(options) {
          super();
          this.options = Object.assign({}, options);
          (0, helpers_1.validateSocksClientOptions)(options);
          this.setState(constants_1.SocksClientState.Created);
        }
        static createConnection(options, callback) {
          return new Promise((resolve, reject) => {
            try {
              (0, helpers_1.validateSocksClientOptions)(options, ["connect"]);
            } catch (err) {
              if (typeof callback === "function") {
                callback(err);
                return resolve(err);
              } else {
                return reject(err);
              }
            }
            const client = new SocksClient(options);
            client.connect(options.existing_socket);
            client.once("established", (info) => {
              client.removeAllListeners();
              if (typeof callback === "function") {
                callback(null, info);
                resolve(info);
              } else {
                resolve(info);
              }
            });
            client.once("error", (err) => {
              client.removeAllListeners();
              if (typeof callback === "function") {
                callback(err);
                resolve(err);
              } else {
                reject(err);
              }
            });
          });
        }
        static createConnectionChain(options, callback) {
          return new Promise((resolve, reject) =>
            __awaiter(this, void 0, void 0, function* () {
              try {
                (0, helpers_1.validateSocksClientChainOptions)(options);
              } catch (err) {
                if (typeof callback === "function") {
                  callback(err);
                  return resolve(err);
                } else {
                  return reject(err);
                }
              }
              if (options.randomizeChain) {
                (0, util_1.shuffleArray)(options.proxies);
              }
              try {
                let sock;
                for (let i = 0; i < options.proxies.length; i++) {
                  const nextProxy = options.proxies[i];
                  const nextDestination =
                    i === options.proxies.length - 1
                      ? options.destination
                      : {
                          host:
                            options.proxies[i + 1].host ||
                            options.proxies[i + 1].ipaddress,
                          port: options.proxies[i + 1].port,
                        };
                  const result = yield SocksClient.createConnection({
                    command: "connect",
                    proxy: nextProxy,
                    destination: nextDestination,
                    existing_socket: sock,
                  });
                  sock = sock || result.socket;
                }
                if (typeof callback === "function") {
                  callback(null, { socket: sock });
                  resolve({ socket: sock });
                } else {
                  resolve({ socket: sock });
                }
              } catch (err) {
                if (typeof callback === "function") {
                  callback(err);
                  resolve(err);
                } else {
                  reject(err);
                }
              }
            }),
          );
        }
        static createUDPFrame(options) {
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt16BE(0);
          buff.writeUInt8(options.frameNumber || 0);
          if (net.isIPv4(options.remoteHost.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv4);
            buff.writeUInt32BE(
              (0, helpers_1.ipv4ToInt32)(options.remoteHost.host),
            );
          } else if (net.isIPv6(options.remoteHost.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv6);
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(options.remoteHost.host),
            );
          } else {
            buff.writeUInt8(constants_1.Socks5HostType.Hostname);
            buff.writeUInt8(Buffer.byteLength(options.remoteHost.host));
            buff.writeString(options.remoteHost.host);
          }
          buff.writeUInt16BE(options.remoteHost.port);
          buff.writeBuffer(options.data);
          return buff.toBuffer();
        }
        static parseUDPFrame(data) {
          const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
          buff.readOffset = 2;
          const frameNumber = buff.readUInt8();
          const hostType = buff.readUInt8();
          let remoteHost;
          if (hostType === constants_1.Socks5HostType.IPv4) {
            remoteHost = (0, helpers_1.int32ToIpv4)(buff.readUInt32BE());
          } else if (hostType === constants_1.Socks5HostType.IPv6) {
            remoteHost = ip_address_1.Address6.fromByteArray(
              Array.from(buff.readBuffer(16)),
            ).canonicalForm();
          } else {
            remoteHost = buff.readString(buff.readUInt8());
          }
          const remotePort = buff.readUInt16BE();
          return {
            frameNumber,
            remoteHost: { host: remoteHost, port: remotePort },
            data: buff.readBuffer(),
          };
        }
        setState(newState) {
          if (this.state !== constants_1.SocksClientState.Error) {
            this.state = newState;
          }
        }
        connect(existingSocket) {
          this.onDataReceived = (data) => this.onDataReceivedHandler(data);
          this.onClose = () => this.onCloseHandler();
          this.onError = (err) => this.onErrorHandler(err);
          this.onConnect = () => this.onConnectHandler();
          const timer = setTimeout(
            () => this.onEstablishedTimeout(),
            this.options.timeout || constants_1.DEFAULT_TIMEOUT,
          );
          if (timer.unref && typeof timer.unref === "function") {
            timer.unref();
          }
          if (existingSocket) {
            this.socket = existingSocket;
          } else {
            this.socket = new net.Socket();
          }
          this.socket.once("close", this.onClose);
          this.socket.once("error", this.onError);
          this.socket.once("connect", this.onConnect);
          this.socket.on("data", this.onDataReceived);
          this.setState(constants_1.SocksClientState.Connecting);
          this.receiveBuffer = new receivebuffer_1.ReceiveBuffer();
          if (existingSocket) {
            this.socket.emit("connect");
          } else {
            this.socket.connect(this.getSocketOptions());
            if (
              this.options.set_tcp_nodelay !== undefined &&
              this.options.set_tcp_nodelay !== null
            ) {
              this.socket.setNoDelay(!!this.options.set_tcp_nodelay);
            }
          }
          this.prependOnceListener("established", (info) => {
            setImmediate(() => {
              if (this.receiveBuffer.length > 0) {
                const excessData = this.receiveBuffer.get(
                  this.receiveBuffer.length,
                );
                info.socket.emit("data", excessData);
              }
              info.socket.resume();
            });
          });
        }
        getSocketOptions() {
          return Object.assign(Object.assign({}, this.options.socket_options), {
            host: this.options.proxy.host || this.options.proxy.ipaddress,
            port: this.options.proxy.port,
          });
        }
        onEstablishedTimeout() {
          if (
            this.state !== constants_1.SocksClientState.Established &&
            this.state !==
              constants_1.SocksClientState.BoundWaitingForConnection
          ) {
            this.closeSocket(constants_1.ERRORS.ProxyConnectionTimedOut);
          }
        }
        onConnectHandler() {
          this.setState(constants_1.SocksClientState.Connected);
          if (this.options.proxy.type === 4) {
            this.sendSocks4InitialHandshake();
          } else {
            this.sendSocks5InitialHandshake();
          }
          this.setState(constants_1.SocksClientState.SentInitialHandshake);
        }
        onDataReceivedHandler(data) {
          this.receiveBuffer.append(data);
          this.processData();
        }
        processData() {
          while (
            this.state !== constants_1.SocksClientState.Established &&
            this.state !== constants_1.SocksClientState.Error &&
            this.receiveBuffer.length >= this.nextRequiredPacketBufferSize
          ) {
            if (
              this.state === constants_1.SocksClientState.SentInitialHandshake
            ) {
              if (this.options.proxy.type === 4) {
                this.handleSocks4FinalHandshakeResponse();
              } else {
                this.handleInitialSocks5HandshakeResponse();
              }
            } else if (
              this.state === constants_1.SocksClientState.SentAuthentication
            ) {
              this.handleInitialSocks5AuthenticationHandshakeResponse();
            } else if (
              this.state === constants_1.SocksClientState.SentFinalHandshake
            ) {
              this.handleSocks5FinalHandshakeResponse();
            } else if (
              this.state ===
              constants_1.SocksClientState.BoundWaitingForConnection
            ) {
              if (this.options.proxy.type === 4) {
                this.handleSocks4IncomingConnectionResponse();
              } else {
                this.handleSocks5IncomingConnectionResponse();
              }
            } else {
              this.closeSocket(constants_1.ERRORS.InternalError);
              break;
            }
          }
        }
        onCloseHandler() {
          this.closeSocket(constants_1.ERRORS.SocketClosed);
        }
        onErrorHandler(err) {
          this.closeSocket(err.message);
        }
        removeInternalSocketHandlers() {
          this.socket.pause();
          this.socket.removeListener("data", this.onDataReceived);
          this.socket.removeListener("close", this.onClose);
          this.socket.removeListener("error", this.onError);
          this.socket.removeListener("connect", this.onConnect);
        }
        closeSocket(err) {
          if (this.state !== constants_1.SocksClientState.Error) {
            this.setState(constants_1.SocksClientState.Error);
            this.socket.destroy();
            this.removeInternalSocketHandlers();
            this.emit("error", new util_1.SocksClientError(err, this.options));
          }
        }
        sendSocks4InitialHandshake() {
          const userId = this.options.proxy.userId || "";
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt8(4);
          buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
          buff.writeUInt16BE(this.options.destination.port);
          if (net.isIPv4(this.options.destination.host)) {
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(this.options.destination.host),
            );
            buff.writeStringNT(userId);
          } else {
            buff.writeUInt8(0);
            buff.writeUInt8(0);
            buff.writeUInt8(0);
            buff.writeUInt8(1);
            buff.writeStringNT(userId);
            buff.writeStringNT(this.options.destination.host);
          }
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks4Response;
          this.socket.write(buff.toBuffer());
        }
        handleSocks4FinalHandshakeResponse() {
          const data = this.receiveBuffer.get(8);
          if (data[1] !== constants_1.Socks4Response.Granted) {
            this.closeSocket(
              `${constants_1.ERRORS.Socks4ProxyRejectedConnection} - (${constants_1.Socks4Response[data[1]]})`,
            );
          } else {
            if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.bind
            ) {
              const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
              buff.readOffset = 2;
              const remoteHost = {
                port: buff.readUInt16BE(),
                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
              };
              if (remoteHost.host === "0.0.0.0") {
                remoteHost.host = this.options.proxy.ipaddress;
              }
              this.setState(
                constants_1.SocksClientState.BoundWaitingForConnection,
              );
              this.emit("bound", { remoteHost, socket: this.socket });
            } else {
              this.setState(constants_1.SocksClientState.Established);
              this.removeInternalSocketHandlers();
              this.emit("established", { socket: this.socket });
            }
          }
        }
        handleSocks4IncomingConnectionResponse() {
          const data = this.receiveBuffer.get(8);
          if (data[1] !== constants_1.Socks4Response.Granted) {
            this.closeSocket(
              `${constants_1.ERRORS.Socks4ProxyRejectedIncomingBoundConnection} - (${constants_1.Socks4Response[data[1]]})`,
            );
          } else {
            const buff = smart_buffer_1.SmartBuffer.fromBuffer(data);
            buff.readOffset = 2;
            const remoteHost = {
              port: buff.readUInt16BE(),
              host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
            };
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          }
        }
        sendSocks5InitialHandshake() {
          const buff = new smart_buffer_1.SmartBuffer();
          const supportedAuthMethods = [constants_1.Socks5Auth.NoAuth];
          if (this.options.proxy.userId || this.options.proxy.password) {
            supportedAuthMethods.push(constants_1.Socks5Auth.UserPass);
          }
          if (this.options.proxy.custom_auth_method !== undefined) {
            supportedAuthMethods.push(this.options.proxy.custom_auth_method);
          }
          buff.writeUInt8(5);
          buff.writeUInt8(supportedAuthMethods.length);
          for (const authMethod of supportedAuthMethods) {
            buff.writeUInt8(authMethod);
          }
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5InitialHandshakeResponse;
          this.socket.write(buff.toBuffer());
          this.setState(constants_1.SocksClientState.SentInitialHandshake);
        }
        handleInitialSocks5HandshakeResponse() {
          const data = this.receiveBuffer.get(2);
          if (data[0] !== 5) {
            this.closeSocket(
              constants_1.ERRORS.InvalidSocks5IntiailHandshakeSocksVersion,
            );
          } else if (data[1] === constants_1.SOCKS5_NO_ACCEPTABLE_AUTH) {
            this.closeSocket(
              constants_1.ERRORS
                .InvalidSocks5InitialHandshakeNoAcceptedAuthType,
            );
          } else {
            if (data[1] === constants_1.Socks5Auth.NoAuth) {
              this.socks5ChosenAuthType = constants_1.Socks5Auth.NoAuth;
              this.sendSocks5CommandRequest();
            } else if (data[1] === constants_1.Socks5Auth.UserPass) {
              this.socks5ChosenAuthType = constants_1.Socks5Auth.UserPass;
              this.sendSocks5UserPassAuthentication();
            } else if (data[1] === this.options.proxy.custom_auth_method) {
              this.socks5ChosenAuthType = this.options.proxy.custom_auth_method;
              this.sendSocks5CustomAuthentication();
            } else {
              this.closeSocket(
                constants_1.ERRORS.InvalidSocks5InitialHandshakeUnknownAuthType,
              );
            }
          }
        }
        sendSocks5UserPassAuthentication() {
          const userId = this.options.proxy.userId || "";
          const password = this.options.proxy.password || "";
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt8(1);
          buff.writeUInt8(Buffer.byteLength(userId));
          buff.writeString(userId);
          buff.writeUInt8(Buffer.byteLength(password));
          buff.writeString(password);
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5UserPassAuthenticationResponse;
          this.socket.write(buff.toBuffer());
          this.setState(constants_1.SocksClientState.SentAuthentication);
        }
        sendSocks5CustomAuthentication() {
          return __awaiter(this, void 0, void 0, function* () {
            this.nextRequiredPacketBufferSize =
              this.options.proxy.custom_auth_response_size;
            this.socket.write(
              yield this.options.proxy.custom_auth_request_handler(),
            );
            this.setState(constants_1.SocksClientState.SentAuthentication);
          });
        }
        handleSocks5CustomAuthHandshakeResponse(data) {
          return __awaiter(this, void 0, void 0, function* () {
            return yield this.options.proxy.custom_auth_response_handler(data);
          });
        }
        handleSocks5AuthenticationNoAuthHandshakeResponse(data) {
          return __awaiter(this, void 0, void 0, function* () {
            return data[1] === 0;
          });
        }
        handleSocks5AuthenticationUserPassHandshakeResponse(data) {
          return __awaiter(this, void 0, void 0, function* () {
            return data[1] === 0;
          });
        }
        handleInitialSocks5AuthenticationHandshakeResponse() {
          return __awaiter(this, void 0, void 0, function* () {
            this.setState(
              constants_1.SocksClientState.ReceivedAuthenticationResponse,
            );
            let authResult = false;
            if (this.socks5ChosenAuthType === constants_1.Socks5Auth.NoAuth) {
              authResult =
                yield this.handleSocks5AuthenticationNoAuthHandshakeResponse(
                  this.receiveBuffer.get(2),
                );
            } else if (
              this.socks5ChosenAuthType === constants_1.Socks5Auth.UserPass
            ) {
              authResult =
                yield this.handleSocks5AuthenticationUserPassHandshakeResponse(
                  this.receiveBuffer.get(2),
                );
            } else if (
              this.socks5ChosenAuthType ===
              this.options.proxy.custom_auth_method
            ) {
              authResult = yield this.handleSocks5CustomAuthHandshakeResponse(
                this.receiveBuffer.get(
                  this.options.proxy.custom_auth_response_size,
                ),
              );
            }
            if (!authResult) {
              this.closeSocket(constants_1.ERRORS.Socks5AuthenticationFailed);
            } else {
              this.sendSocks5CommandRequest();
            }
          });
        }
        sendSocks5CommandRequest() {
          const buff = new smart_buffer_1.SmartBuffer();
          buff.writeUInt8(5);
          buff.writeUInt8(constants_1.SocksCommand[this.options.command]);
          buff.writeUInt8(0);
          if (net.isIPv4(this.options.destination.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv4);
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(this.options.destination.host),
            );
          } else if (net.isIPv6(this.options.destination.host)) {
            buff.writeUInt8(constants_1.Socks5HostType.IPv6);
            buff.writeBuffer(
              (0, helpers_1.ipToBuffer)(this.options.destination.host),
            );
          } else {
            buff.writeUInt8(constants_1.Socks5HostType.Hostname);
            buff.writeUInt8(this.options.destination.host.length);
            buff.writeString(this.options.destination.host);
          }
          buff.writeUInt16BE(this.options.destination.port);
          this.nextRequiredPacketBufferSize =
            constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
          this.socket.write(buff.toBuffer());
          this.setState(constants_1.SocksClientState.SentFinalHandshake);
        }
        handleSocks5FinalHandshakeResponse() {
          const header = this.receiveBuffer.peek(5);
          if (
            header[0] !== 5 ||
            header[1] !== constants_1.Socks5Response.Granted
          ) {
            this.closeSocket(
              `${constants_1.ERRORS.InvalidSocks5FinalHandshakeRejected} - ${constants_1.Socks5Response[header[1]]}`,
            );
          } else {
            const addressType = header[3];
            let remoteHost;
            let buff;
            if (addressType === constants_1.Socks5HostType.IPv4) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
                port: buff.readUInt16BE(),
              };
              if (remoteHost.host === "0.0.0.0") {
                remoteHost.host = this.options.proxy.ipaddress;
              }
            } else if (addressType === constants_1.Socks5HostType.Hostname) {
              const hostLength = header[4];
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(
                  hostLength,
                );
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(5),
              );
              remoteHost = {
                host: buff.readString(hostLength),
                port: buff.readUInt16BE(),
              };
            } else if (addressType === constants_1.Socks5HostType.IPv6) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: ip_address_1.Address6.fromByteArray(
                  Array.from(buff.readBuffer(16)),
                ).canonicalForm(),
                port: buff.readUInt16BE(),
              };
            }
            this.setState(constants_1.SocksClientState.ReceivedFinalResponse);
            if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.connect
            ) {
              this.setState(constants_1.SocksClientState.Established);
              this.removeInternalSocketHandlers();
              this.emit("established", { remoteHost, socket: this.socket });
            } else if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.bind
            ) {
              this.setState(
                constants_1.SocksClientState.BoundWaitingForConnection,
              );
              this.nextRequiredPacketBufferSize =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHeader;
              this.emit("bound", { remoteHost, socket: this.socket });
            } else if (
              constants_1.SocksCommand[this.options.command] ===
              constants_1.SocksCommand.associate
            ) {
              this.setState(constants_1.SocksClientState.Established);
              this.removeInternalSocketHandlers();
              this.emit("established", { remoteHost, socket: this.socket });
            }
          }
        }
        handleSocks5IncomingConnectionResponse() {
          const header = this.receiveBuffer.peek(5);
          if (
            header[0] !== 5 ||
            header[1] !== constants_1.Socks5Response.Granted
          ) {
            this.closeSocket(
              `${constants_1.ERRORS.Socks5ProxyRejectedIncomingBoundConnection} - ${constants_1.Socks5Response[header[1]]}`,
            );
          } else {
            const addressType = header[3];
            let remoteHost;
            let buff;
            if (addressType === constants_1.Socks5HostType.IPv4) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv4;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: (0, helpers_1.int32ToIpv4)(buff.readUInt32BE()),
                port: buff.readUInt16BE(),
              };
              if (remoteHost.host === "0.0.0.0") {
                remoteHost.host = this.options.proxy.ipaddress;
              }
            } else if (addressType === constants_1.Socks5HostType.Hostname) {
              const hostLength = header[4];
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseHostname(
                  hostLength,
                );
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(5),
              );
              remoteHost = {
                host: buff.readString(hostLength),
                port: buff.readUInt16BE(),
              };
            } else if (addressType === constants_1.Socks5HostType.IPv6) {
              const dataNeeded =
                constants_1.SOCKS_INCOMING_PACKET_SIZES.Socks5ResponseIPv6;
              if (this.receiveBuffer.length < dataNeeded) {
                this.nextRequiredPacketBufferSize = dataNeeded;
                return;
              }
              buff = smart_buffer_1.SmartBuffer.fromBuffer(
                this.receiveBuffer.get(dataNeeded).slice(4),
              );
              remoteHost = {
                host: ip_address_1.Address6.fromByteArray(
                  Array.from(buff.readBuffer(16)),
                ).canonicalForm(),
                port: buff.readUInt16BE(),
              };
            }
            this.setState(constants_1.SocksClientState.Established);
            this.removeInternalSocketHandlers();
            this.emit("established", { remoteHost, socket: this.socket });
          }
        }
        get socksClientOptions() {
          return Object.assign({}, this.options);
        }
      }
      exports.SocksClient = SocksClient;
    },
    9647: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.SOCKS5_NO_ACCEPTABLE_AUTH =
        exports.SOCKS5_CUSTOM_AUTH_END =
        exports.SOCKS5_CUSTOM_AUTH_START =
        exports.SOCKS_INCOMING_PACKET_SIZES =
        exports.SocksClientState =
        exports.Socks5Response =
        exports.Socks5HostType =
        exports.Socks5Auth =
        exports.Socks4Response =
        exports.SocksCommand =
        exports.ERRORS =
        exports.DEFAULT_TIMEOUT =
          void 0;
      const DEFAULT_TIMEOUT = 3e4;
      exports.DEFAULT_TIMEOUT = DEFAULT_TIMEOUT;
      const ERRORS = {
        InvalidSocksCommand:
          "An invalid SOCKS command was provided. Valid options are connect, bind, and associate.",
        InvalidSocksCommandForOperation:
          "An invalid SOCKS command was provided. Only a subset of commands are supported for this operation.",
        InvalidSocksCommandChain:
          "An invalid SOCKS command was provided. Chaining currently only supports the connect command.",
        InvalidSocksClientOptionsDestination:
          "An invalid destination host was provided.",
        InvalidSocksClientOptionsExistingSocket:
          "An invalid existing socket was provided. This should be an instance of stream.Duplex.",
        InvalidSocksClientOptionsProxy:
          "Invalid SOCKS proxy details were provided.",
        InvalidSocksClientOptionsTimeout:
          "An invalid timeout value was provided. Please enter a value above 0 (in ms).",
        InvalidSocksClientOptionsProxiesLength:
          "At least two socks proxies must be provided for chaining.",
        InvalidSocksClientOptionsCustomAuthRange:
          "Custom auth must be a value between 0x80 and 0xFE.",
        InvalidSocksClientOptionsCustomAuthOptions:
          "When a custom_auth_method is provided, custom_auth_request_handler, custom_auth_response_size, and custom_auth_response_handler must also be provided and valid.",
        NegotiationError: "Negotiation error",
        SocketClosed: "Socket closed",
        ProxyConnectionTimedOut: "Proxy connection timed out",
        InternalError: "SocksClient internal error (this should not happen)",
        InvalidSocks4HandshakeResponse:
          "Received invalid Socks4 handshake response",
        Socks4ProxyRejectedConnection: "Socks4 Proxy rejected connection",
        InvalidSocks4IncomingConnectionResponse:
          "Socks4 invalid incoming connection response",
        Socks4ProxyRejectedIncomingBoundConnection:
          "Socks4 Proxy rejected incoming bound connection",
        InvalidSocks5InitialHandshakeResponse:
          "Received invalid Socks5 initial handshake response",
        InvalidSocks5IntiailHandshakeSocksVersion:
          "Received invalid Socks5 initial handshake (invalid socks version)",
        InvalidSocks5InitialHandshakeNoAcceptedAuthType:
          "Received invalid Socks5 initial handshake (no accepted authentication type)",
        InvalidSocks5InitialHandshakeUnknownAuthType:
          "Received invalid Socks5 initial handshake (unknown authentication type)",
        Socks5AuthenticationFailed: "Socks5 Authentication failed",
        InvalidSocks5FinalHandshake:
          "Received invalid Socks5 final handshake response",
        InvalidSocks5FinalHandshakeRejected: "Socks5 proxy rejected connection",
        InvalidSocks5IncomingConnectionResponse:
          "Received invalid Socks5 incoming connection response",
        Socks5ProxyRejectedIncomingBoundConnection:
          "Socks5 Proxy rejected incoming bound connection",
      };
      exports.ERRORS = ERRORS;
      const SOCKS_INCOMING_PACKET_SIZES = {
        Socks5InitialHandshakeResponse: 2,
        Socks5UserPassAuthenticationResponse: 2,
        Socks5ResponseHeader: 5,
        Socks5ResponseIPv4: 10,
        Socks5ResponseIPv6: 22,
        Socks5ResponseHostname: (hostNameLength) => hostNameLength + 7,
        Socks4Response: 8,
      };
      exports.SOCKS_INCOMING_PACKET_SIZES = SOCKS_INCOMING_PACKET_SIZES;
      var SocksCommand;
      (function (SocksCommand) {
        SocksCommand[(SocksCommand["connect"] = 1)] = "connect";
        SocksCommand[(SocksCommand["bind"] = 2)] = "bind";
        SocksCommand[(SocksCommand["associate"] = 3)] = "associate";
      })(SocksCommand || (exports.SocksCommand = SocksCommand = {}));
      var Socks4Response;
      (function (Socks4Response) {
        Socks4Response[(Socks4Response["Granted"] = 90)] = "Granted";
        Socks4Response[(Socks4Response["Failed"] = 91)] = "Failed";
        Socks4Response[(Socks4Response["Rejected"] = 92)] = "Rejected";
        Socks4Response[(Socks4Response["RejectedIdent"] = 93)] =
          "RejectedIdent";
      })(Socks4Response || (exports.Socks4Response = Socks4Response = {}));
      var Socks5Auth;
      (function (Socks5Auth) {
        Socks5Auth[(Socks5Auth["NoAuth"] = 0)] = "NoAuth";
        Socks5Auth[(Socks5Auth["GSSApi"] = 1)] = "GSSApi";
        Socks5Auth[(Socks5Auth["UserPass"] = 2)] = "UserPass";
      })(Socks5Auth || (exports.Socks5Auth = Socks5Auth = {}));
      const SOCKS5_CUSTOM_AUTH_START = 128;
      exports.SOCKS5_CUSTOM_AUTH_START = SOCKS5_CUSTOM_AUTH_START;
      const SOCKS5_CUSTOM_AUTH_END = 254;
      exports.SOCKS5_CUSTOM_AUTH_END = SOCKS5_CUSTOM_AUTH_END;
      const SOCKS5_NO_ACCEPTABLE_AUTH = 255;
      exports.SOCKS5_NO_ACCEPTABLE_AUTH = SOCKS5_NO_ACCEPTABLE_AUTH;
      var Socks5Response;
      (function (Socks5Response) {
        Socks5Response[(Socks5Response["Granted"] = 0)] = "Granted";
        Socks5Response[(Socks5Response["Failure"] = 1)] = "Failure";
        Socks5Response[(Socks5Response["NotAllowed"] = 2)] = "NotAllowed";
        Socks5Response[(Socks5Response["NetworkUnreachable"] = 3)] =
          "NetworkUnreachable";
        Socks5Response[(Socks5Response["HostUnreachable"] = 4)] =
          "HostUnreachable";
        Socks5Response[(Socks5Response["ConnectionRefused"] = 5)] =
          "ConnectionRefused";
        Socks5Response[(Socks5Response["TTLExpired"] = 6)] = "TTLExpired";
        Socks5Response[(Socks5Response["CommandNotSupported"] = 7)] =
          "CommandNotSupported";
        Socks5Response[(Socks5Response["AddressNotSupported"] = 8)] =
          "AddressNotSupported";
      })(Socks5Response || (exports.Socks5Response = Socks5Response = {}));
      var Socks5HostType;
      (function (Socks5HostType) {
        Socks5HostType[(Socks5HostType["IPv4"] = 1)] = "IPv4";
        Socks5HostType[(Socks5HostType["Hostname"] = 3)] = "Hostname";
        Socks5HostType[(Socks5HostType["IPv6"] = 4)] = "IPv6";
      })(Socks5HostType || (exports.Socks5HostType = Socks5HostType = {}));
      var SocksClientState;
      (function (SocksClientState) {
        SocksClientState[(SocksClientState["Created"] = 0)] = "Created";
        SocksClientState[(SocksClientState["Connecting"] = 1)] = "Connecting";
        SocksClientState[(SocksClientState["Connected"] = 2)] = "Connected";
        SocksClientState[(SocksClientState["SentInitialHandshake"] = 3)] =
          "SentInitialHandshake";
        SocksClientState[
          (SocksClientState["ReceivedInitialHandshakeResponse"] = 4)
        ] = "ReceivedInitialHandshakeResponse";
        SocksClientState[(SocksClientState["SentAuthentication"] = 5)] =
          "SentAuthentication";
        SocksClientState[
          (SocksClientState["ReceivedAuthenticationResponse"] = 6)
        ] = "ReceivedAuthenticationResponse";
        SocksClientState[(SocksClientState["SentFinalHandshake"] = 7)] =
          "SentFinalHandshake";
        SocksClientState[(SocksClientState["ReceivedFinalResponse"] = 8)] =
          "ReceivedFinalResponse";
        SocksClientState[(SocksClientState["BoundWaitingForConnection"] = 9)] =
          "BoundWaitingForConnection";
        SocksClientState[(SocksClientState["Established"] = 10)] =
          "Established";
        SocksClientState[(SocksClientState["Disconnected"] = 11)] =
          "Disconnected";
        SocksClientState[(SocksClientState["Error"] = 99)] = "Error";
      })(
        SocksClientState || (exports.SocksClientState = SocksClientState = {}),
      );
    },
    4324: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ipToBuffer =
        exports.int32ToIpv4 =
        exports.ipv4ToInt32 =
        exports.validateSocksClientChainOptions =
        exports.validateSocksClientOptions =
          void 0;
      const util_1 = __nccwpck_require__(5523);
      const constants_1 = __nccwpck_require__(9647);
      const stream = __nccwpck_require__(2781);
      const ip_address_1 = __nccwpck_require__(8953);
      const net = __nccwpck_require__(1808);
      function validateSocksClientOptions(
        options,
        acceptedCommands = ["connect", "bind", "associate"],
      ) {
        if (!constants_1.SocksCommand[options.command]) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksCommand,
            options,
          );
        }
        if (acceptedCommands.indexOf(options.command) === -1) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksCommandForOperation,
            options,
          );
        }
        if (!isValidSocksRemoteHost(options.destination)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsDestination,
            options,
          );
        }
        if (!isValidSocksProxy(options.proxy)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsProxy,
            options,
          );
        }
        validateCustomProxyAuth(options.proxy, options);
        if (options.timeout && !isValidTimeoutValue(options.timeout)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsTimeout,
            options,
          );
        }
        if (
          options.existing_socket &&
          !(options.existing_socket instanceof stream.Duplex)
        ) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsExistingSocket,
            options,
          );
        }
      }
      exports.validateSocksClientOptions = validateSocksClientOptions;
      function validateSocksClientChainOptions(options) {
        if (options.command !== "connect") {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksCommandChain,
            options,
          );
        }
        if (!isValidSocksRemoteHost(options.destination)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsDestination,
            options,
          );
        }
        if (
          !(
            options.proxies &&
            Array.isArray(options.proxies) &&
            options.proxies.length >= 2
          )
        ) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsProxiesLength,
            options,
          );
        }
        options.proxies.forEach((proxy) => {
          if (!isValidSocksProxy(proxy)) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsProxy,
              options,
            );
          }
          validateCustomProxyAuth(proxy, options);
        });
        if (options.timeout && !isValidTimeoutValue(options.timeout)) {
          throw new util_1.SocksClientError(
            constants_1.ERRORS.InvalidSocksClientOptionsTimeout,
            options,
          );
        }
      }
      exports.validateSocksClientChainOptions = validateSocksClientChainOptions;
      function validateCustomProxyAuth(proxy, options) {
        if (proxy.custom_auth_method !== undefined) {
          if (
            proxy.custom_auth_method < constants_1.SOCKS5_CUSTOM_AUTH_START ||
            proxy.custom_auth_method > constants_1.SOCKS5_CUSTOM_AUTH_END
          ) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthRange,
              options,
            );
          }
          if (
            proxy.custom_auth_request_handler === undefined ||
            typeof proxy.custom_auth_request_handler !== "function"
          ) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,
              options,
            );
          }
          if (proxy.custom_auth_response_size === undefined) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,
              options,
            );
          }
          if (
            proxy.custom_auth_response_handler === undefined ||
            typeof proxy.custom_auth_response_handler !== "function"
          ) {
            throw new util_1.SocksClientError(
              constants_1.ERRORS.InvalidSocksClientOptionsCustomAuthOptions,
              options,
            );
          }
        }
      }
      function isValidSocksRemoteHost(remoteHost) {
        return (
          remoteHost &&
          typeof remoteHost.host === "string" &&
          typeof remoteHost.port === "number" &&
          remoteHost.port >= 0 &&
          remoteHost.port <= 65535
        );
      }
      function isValidSocksProxy(proxy) {
        return (
          proxy &&
          (typeof proxy.host === "string" ||
            typeof proxy.ipaddress === "string") &&
          typeof proxy.port === "number" &&
          proxy.port >= 0 &&
          proxy.port <= 65535 &&
          (proxy.type === 4 || proxy.type === 5)
        );
      }
      function isValidTimeoutValue(value) {
        return typeof value === "number" && value > 0;
      }
      function ipv4ToInt32(ip) {
        const address = new ip_address_1.Address4(ip);
        return address.toArray().reduce((acc, part) => (acc << 8) + part, 0);
      }
      exports.ipv4ToInt32 = ipv4ToInt32;
      function int32ToIpv4(int32) {
        const octet1 = (int32 >>> 24) & 255;
        const octet2 = (int32 >>> 16) & 255;
        const octet3 = (int32 >>> 8) & 255;
        const octet4 = int32 & 255;
        return [octet1, octet2, octet3, octet4].join(".");
      }
      exports.int32ToIpv4 = int32ToIpv4;
      function ipToBuffer(ip) {
        if (net.isIPv4(ip)) {
          const address = new ip_address_1.Address4(ip);
          return Buffer.from(address.toArray());
        } else if (net.isIPv6(ip)) {
          const address = new ip_address_1.Address6(ip);
          return Buffer.from(
            address
              .canonicalForm()
              .split(":")
              .map((segment) => segment.padStart(4, "0"))
              .join(""),
            "hex",
          );
        } else {
          throw new Error("Invalid IP address format");
        }
      }
      exports.ipToBuffer = ipToBuffer;
    },
    9740: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.ReceiveBuffer = void 0;
      class ReceiveBuffer {
        constructor(size = 4096) {
          this.buffer = Buffer.allocUnsafe(size);
          this.offset = 0;
          this.originalSize = size;
        }
        get length() {
          return this.offset;
        }
        append(data) {
          if (!Buffer.isBuffer(data)) {
            throw new Error(
              "Attempted to append a non-buffer instance to ReceiveBuffer.",
            );
          }
          if (this.offset + data.length >= this.buffer.length) {
            const tmp = this.buffer;
            this.buffer = Buffer.allocUnsafe(
              Math.max(
                this.buffer.length + this.originalSize,
                this.buffer.length + data.length,
              ),
            );
            tmp.copy(this.buffer);
          }
          data.copy(this.buffer, this.offset);
          return (this.offset += data.length);
        }
        peek(length) {
          if (length > this.offset) {
            throw new Error(
              "Attempted to read beyond the bounds of the managed internal data.",
            );
          }
          return this.buffer.slice(0, length);
        }
        get(length) {
          if (length > this.offset) {
            throw new Error(
              "Attempted to read beyond the bounds of the managed internal data.",
            );
          }
          const value = Buffer.allocUnsafe(length);
          this.buffer.slice(0, length).copy(value);
          this.buffer.copyWithin(0, length, length + this.offset - length);
          this.offset -= length;
          return value;
        }
      }
      exports.ReceiveBuffer = ReceiveBuffer;
    },
    5523: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.shuffleArray = exports.SocksClientError = void 0;
      class SocksClientError extends Error {
        constructor(message, options) {
          super(message);
          this.options = options;
        }
      }
      exports.SocksClientError = SocksClientError;
      function shuffleArray(array) {
        for (let i = array.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [array[i], array[j]] = [array[j], array[i]];
        }
      }
      exports.shuffleArray = shuffleArray;
    },
    4754: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __exportStar =
        (this && this.__exportStar) ||
        function (m, exports) {
          for (var p in m)
            if (
              p !== "default" &&
              !Object.prototype.hasOwnProperty.call(exports, p)
            )
              __createBinding(exports, m, p);
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      __exportStar(__nccwpck_require__(6127), exports);
    },
    2372: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var parse = __nccwpck_require__(1620);
      var spdxLicenseIds = __nccwpck_require__(6033);
      function valid(string) {
        try {
          parse(string);
          return true;
        } catch (error) {
          return false;
        }
      }
      function sortTranspositions(a, b) {
        var length = b[0].length - a[0].length;
        if (length !== 0) return length;
        return a[0].toUpperCase().localeCompare(b[0].toUpperCase());
      }
      var transpositions = [
        ["APGL", "AGPL"],
        ["Gpl", "GPL"],
        ["GLP", "GPL"],
        ["APL", "Apache"],
        ["ISD", "ISC"],
        ["GLP", "GPL"],
        ["IST", "ISC"],
        ["Claude", "Clause"],
        [" or later", "+"],
        [" International", ""],
        ["GNU", "GPL"],
        ["GUN", "GPL"],
        ["+", ""],
        ["GNU GPL", "GPL"],
        ["GNU LGPL", "LGPL"],
        ["GNU/GPL", "GPL"],
        ["GNU GLP", "GPL"],
        ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL"],
        ["GNU Lesser General Public License", "LGPL"],
        ["GNU LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
        ["GNU Lesser General Public License", "LGPL-2.1"],
        ["LESSER GENERAL PUBLIC LICENSE", "LGPL"],
        ["Lesser General Public License", "LGPL"],
        ["LESSER GENERAL PUBLIC LICENSE", "LGPL-2.1"],
        ["Lesser General Public License", "LGPL-2.1"],
        ["GNU General Public License", "GPL"],
        ["Gnu public license", "GPL"],
        ["GNU Public License", "GPL"],
        ["GNU GENERAL PUBLIC LICENSE", "GPL"],
        ["MTI", "MIT"],
        ["Mozilla Public License", "MPL"],
        ["Universal Permissive License", "UPL"],
        ["WTH", "WTF"],
        ["WTFGPL", "WTFPL"],
        ["-License", ""],
      ].sort(sortTranspositions);
      var TRANSPOSED = 0;
      var CORRECT = 1;
      var transforms = [
        function (argument) {
          return argument.toUpperCase();
        },
        function (argument) {
          return argument.trim();
        },
        function (argument) {
          return argument.replace(/\./g, "");
        },
        function (argument) {
          return argument.replace(/\s+/g, "");
        },
        function (argument) {
          return argument.replace(/\s+/g, "-");
        },
        function (argument) {
          return argument.replace("v", "-");
        },
        function (argument) {
          return argument.replace(/,?\s*(\d)/, "-$1");
        },
        function (argument) {
          return argument.replace(/,?\s*(\d)/, "-$1.0");
        },
        function (argument) {
          return argument.replace(
            /,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/,
            "-$2",
          );
        },
        function (argument) {
          return argument.replace(
            /,?\s*(V\.|v\.|V|v|Version|version)\s*(\d)/,
            "-$2.0",
          );
        },
        function (argument) {
          return argument[0].toUpperCase() + argument.slice(1);
        },
        function (argument) {
          return argument.replace("/", "-");
        },
        function (argument) {
          return argument
            .replace(/\s*V\s*(\d)/, "-$1")
            .replace(/(\d)$/, "$1.0");
        },
        function (argument) {
          if (argument.indexOf("3.0") !== -1) {
            return argument + "-or-later";
          } else {
            return argument + "-only";
          }
        },
        function (argument) {
          return argument + "only";
        },
        function (argument) {
          return argument.replace(/(\d)$/, "-$1.0");
        },
        function (argument) {
          return argument.replace(/(-| )?(\d)$/, "-$2-Clause");
        },
        function (argument) {
          return argument.replace(/(-| )clause(-| )(\d)/, "-$3-Clause");
        },
        function (argument) {
          return argument.replace(
            /\b(Modified|New|Revised)(-| )?BSD((-| )License)?/i,
            "BSD-3-Clause",
          );
        },
        function (argument) {
          return argument.replace(
            /\bSimplified(-| )?BSD((-| )License)?/i,
            "BSD-2-Clause",
          );
        },
        function (argument) {
          return argument.replace(
            /\b(Free|Net)(-| )?BSD((-| )License)?/i,
            "BSD-2-Clause-$1BSD",
          );
        },
        function (argument) {
          return argument.replace(
            /\bClear(-| )?BSD((-| )License)?/i,
            "BSD-3-Clause-Clear",
          );
        },
        function (argument) {
          return argument.replace(
            /\b(Old|Original)(-| )?BSD((-| )License)?/i,
            "BSD-4-Clause",
          );
        },
        function (argument) {
          return "CC-" + argument;
        },
        function (argument) {
          return "CC-" + argument + "-4.0";
        },
        function (argument) {
          return argument
            .replace("Attribution", "BY")
            .replace("NonCommercial", "NC")
            .replace("NoDerivatives", "ND")
            .replace(/ (\d)/, "-$1")
            .replace(/ ?International/, "");
        },
        function (argument) {
          return (
            "CC-" +
            argument
              .replace("Attribution", "BY")
              .replace("NonCommercial", "NC")
              .replace("NoDerivatives", "ND")
              .replace(/ (\d)/, "-$1")
              .replace(/ ?International/, "") +
            "-4.0"
          );
        },
      ];
      var licensesWithVersions = spdxLicenseIds
        .map(function (id) {
          var match = /^(.*)-\d+\.\d+$/.exec(id);
          return match ? [match[0], match[1]] : [id, null];
        })
        .reduce(function (objectMap, item) {
          var key = item[1];
          objectMap[key] = objectMap[key] || [];
          objectMap[key].push(item[0]);
          return objectMap;
        }, {});
      var licensesWithOneVersion = Object.keys(licensesWithVersions)
        .map(function makeEntries(key) {
          return [key, licensesWithVersions[key]];
        })
        .filter(function identifySoleVersions(item) {
          return item[1].length === 1 && item[0] !== null && item[0] !== "APL";
        })
        .map(function createLastResorts(item) {
          return [item[0], item[1][0]];
        });
      licensesWithVersions = undefined;
      var lastResorts = [
        ["UNLI", "Unlicense"],
        ["WTF", "WTFPL"],
        ["2 CLAUSE", "BSD-2-Clause"],
        ["2-CLAUSE", "BSD-2-Clause"],
        ["3 CLAUSE", "BSD-3-Clause"],
        ["3-CLAUSE", "BSD-3-Clause"],
        ["AFFERO", "AGPL-3.0-or-later"],
        ["AGPL", "AGPL-3.0-or-later"],
        ["APACHE", "Apache-2.0"],
        ["ARTISTIC", "Artistic-2.0"],
        ["Affero", "AGPL-3.0-or-later"],
        ["BEER", "Beerware"],
        ["BOOST", "BSL-1.0"],
        ["BSD", "BSD-2-Clause"],
        ["CDDL", "CDDL-1.1"],
        ["ECLIPSE", "EPL-1.0"],
        ["FUCK", "WTFPL"],
        ["GNU", "GPL-3.0-or-later"],
        ["LGPL", "LGPL-3.0-or-later"],
        ["GPLV1", "GPL-1.0-only"],
        ["GPL-1", "GPL-1.0-only"],
        ["GPLV2", "GPL-2.0-only"],
        ["GPL-2", "GPL-2.0-only"],
        ["GPL", "GPL-3.0-or-later"],
        ["MIT +NO-FALSE-ATTRIBS", "MITNFA"],
        ["MIT", "MIT"],
        ["MPL", "MPL-2.0"],
        ["X11", "X11"],
        ["ZLIB", "Zlib"],
      ]
        .concat(licensesWithOneVersion)
        .sort(sortTranspositions);
      var SUBSTRING = 0;
      var IDENTIFIER = 1;
      var validTransformation = function (identifier) {
        for (var i = 0; i < transforms.length; i++) {
          var transformed = transforms[i](identifier).trim();
          if (transformed !== identifier && valid(transformed)) {
            return transformed;
          }
        }
        return null;
      };
      var validLastResort = function (identifier) {
        var upperCased = identifier.toUpperCase();
        for (var i = 0; i < lastResorts.length; i++) {
          var lastResort = lastResorts[i];
          if (upperCased.indexOf(lastResort[SUBSTRING]) > -1) {
            return lastResort[IDENTIFIER];
          }
        }
        return null;
      };
      var anyCorrection = function (identifier, check) {
        for (var i = 0; i < transpositions.length; i++) {
          var transposition = transpositions[i];
          var transposed = transposition[TRANSPOSED];
          if (identifier.indexOf(transposed) > -1) {
            var corrected = identifier.replace(
              transposed,
              transposition[CORRECT],
            );
            var checked = check(corrected);
            if (checked !== null) {
              return checked;
            }
          }
        }
        return null;
      };
      module.exports = function (identifier, options) {
        options = options || {};
        var upgrade = options.upgrade === undefined ? true : !!options.upgrade;
        function postprocess(value) {
          return upgrade ? upgradeGPLs(value) : value;
        }
        var validArugment =
          typeof identifier === "string" && identifier.trim().length !== 0;
        if (!validArugment) {
          throw Error("Invalid argument. Expected non-empty string.");
        }
        identifier = identifier.trim();
        if (valid(identifier)) {
          return postprocess(identifier);
        }
        var noPlus = identifier.replace(/\+$/, "").trim();
        if (valid(noPlus)) {
          return postprocess(noPlus);
        }
        var transformed = validTransformation(identifier);
        if (transformed !== null) {
          return postprocess(transformed);
        }
        transformed = anyCorrection(identifier, function (argument) {
          if (valid(argument)) {
            return argument;
          }
          return validTransformation(argument);
        });
        if (transformed !== null) {
          return postprocess(transformed);
        }
        transformed = validLastResort(identifier);
        if (transformed !== null) {
          return postprocess(transformed);
        }
        transformed = anyCorrection(identifier, validLastResort);
        if (transformed !== null) {
          return postprocess(transformed);
        }
        return null;
      };
      function upgradeGPLs(value) {
        if (
          [
            "GPL-1.0",
            "LGPL-1.0",
            "AGPL-1.0",
            "GPL-2.0",
            "LGPL-2.0",
            "AGPL-2.0",
            "LGPL-2.1",
          ].indexOf(value) !== -1
        ) {
          return value + "-only";
        } else if (
          [
            "GPL-1.0+",
            "GPL-2.0+",
            "GPL-3.0+",
            "LGPL-2.0+",
            "LGPL-2.1+",
            "LGPL-3.0+",
            "AGPL-1.0+",
            "AGPL-3.0+",
          ].indexOf(value) !== -1
        ) {
          return value.replace(/\+$/, "-or-later");
        } else if (["GPL-3.0", "LGPL-3.0", "AGPL-3.0"].indexOf(value) !== -1) {
          return value + "-or-later";
        } else {
          return value;
        }
      }
    },
    1620: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var scan = __nccwpck_require__(7380);
      var parse = __nccwpck_require__(9868);
      module.exports = function (source) {
        return parse(scan(source));
      };
    },
    9868: (module) => {
      "use strict";
      module.exports = function (tokens) {
        var index = 0;
        function hasMore() {
          return index < tokens.length;
        }
        function token() {
          return hasMore() ? tokens[index] : null;
        }
        function next() {
          if (!hasMore()) {
            throw new Error();
          }
          index++;
        }
        function parseOperator(operator) {
          var t = token();
          if (t && t.type === "OPERATOR" && operator === t.string) {
            next();
            return t.string;
          }
        }
        function parseWith() {
          if (parseOperator("WITH")) {
            var t = token();
            if (t && t.type === "EXCEPTION") {
              next();
              return t.string;
            }
            throw new Error("Expected exception after `WITH`");
          }
        }
        function parseLicenseRef() {
          var begin = index;
          var string = "";
          var t = token();
          if (t.type === "DOCUMENTREF") {
            next();
            string += "DocumentRef-" + t.string + ":";
            if (!parseOperator(":")) {
              throw new Error("Expected `:` after `DocumentRef-...`");
            }
          }
          t = token();
          if (t.type === "LICENSEREF") {
            next();
            string += "LicenseRef-" + t.string;
            return { license: string };
          }
          index = begin;
        }
        function parseLicense() {
          var t = token();
          if (t && t.type === "LICENSE") {
            next();
            var node = { license: t.string };
            if (parseOperator("+")) {
              node.plus = true;
            }
            var exception = parseWith();
            if (exception) {
              node.exception = exception;
            }
            return node;
          }
        }
        function parseParenthesizedExpression() {
          var left = parseOperator("(");
          if (!left) {
            return;
          }
          var expr = parseExpression();
          if (!parseOperator(")")) {
            throw new Error("Expected `)`");
          }
          return expr;
        }
        function parseAtom() {
          return (
            parseParenthesizedExpression() ||
            parseLicenseRef() ||
            parseLicense()
          );
        }
        function makeBinaryOpParser(operator, nextParser) {
          return function parseBinaryOp() {
            var left = nextParser();
            if (!left) {
              return;
            }
            if (!parseOperator(operator)) {
              return left;
            }
            var right = parseBinaryOp();
            if (!right) {
              throw new Error("Expected expression");
            }
            return { left, conjunction: operator.toLowerCase(), right };
          };
        }
        var parseAnd = makeBinaryOpParser("AND", parseAtom);
        var parseExpression = makeBinaryOpParser("OR", parseAnd);
        var node = parseExpression();
        if (!node || hasMore()) {
          throw new Error("Syntax error");
        }
        return node;
      };
    },
    7380: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      var licenses = []
        .concat(__nccwpck_require__(6033))
        .concat(__nccwpck_require__(6765));
      var exceptions = __nccwpck_require__(238);
      module.exports = function (source) {
        var index = 0;
        function hasMore() {
          return index < source.length;
        }
        function read(value) {
          if (value instanceof RegExp) {
            var chars = source.slice(index);
            var match = chars.match(value);
            if (match) {
              index += match[0].length;
              return match[0];
            }
          } else {
            if (source.indexOf(value, index) === index) {
              index += value.length;
              return value;
            }
          }
        }
        function skipWhitespace() {
          read(/[ ]*/);
        }
        function operator() {
          var string;
          var possibilities = ["WITH", "AND", "OR", "(", ")", ":", "+"];
          for (var i = 0; i < possibilities.length; i++) {
            string = read(possibilities[i]);
            if (string) {
              break;
            }
          }
          if (string === "+" && index > 1 && source[index - 2] === " ") {
            throw new Error("Space before `+`");
          }
          return string && { type: "OPERATOR", string };
        }
        function idstring() {
          return read(/[A-Za-z0-9-.]+/);
        }
        function expectIdstring() {
          var string = idstring();
          if (!string) {
            throw new Error("Expected idstring at offset " + index);
          }
          return string;
        }
        function documentRef() {
          if (read("DocumentRef-")) {
            var string = expectIdstring();
            return { type: "DOCUMENTREF", string };
          }
        }
        function licenseRef() {
          if (read("LicenseRef-")) {
            var string = expectIdstring();
            return { type: "LICENSEREF", string };
          }
        }
        function identifier() {
          var begin = index;
          var string = idstring();
          if (licenses.indexOf(string) !== -1) {
            return { type: "LICENSE", string };
          } else if (exceptions.indexOf(string) !== -1) {
            return { type: "EXCEPTION", string };
          }
          index = begin;
        }
        function parseToken() {
          return operator() || documentRef() || licenseRef() || identifier();
        }
        var tokens = [];
        while (hasMore()) {
          skipWhitespace();
          if (!hasMore()) {
            break;
          }
          var token = parseToken();
          if (!token) {
            throw new Error(
              "Unexpected `" + source[index] + "` at offset " + index,
            );
          }
          tokens.push(token);
        }
        return tokens;
      };
    },
    3988: (__unused_webpack_module, exports) => {
      !(function () {
        "use strict";
        var re = {
          not_string: /[^s]/,
          not_bool: /[^t]/,
          not_type: /[^T]/,
          not_primitive: /[^v]/,
          number: /[diefg]/,
          numeric_arg: /[bcdiefguxX]/,
          json: /[j]/,
          not_json: /[^j]/,
          text: /^[^\x25]+/,
          modulo: /^\x25{2}/,
          placeholder:
            /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
          key: /^([a-z_][a-z_\d]*)/i,
          key_access: /^\.([a-z_][a-z_\d]*)/i,
          index_access: /^\[(\d+)\]/,
          sign: /^[+-]/,
        };
        function sprintf(key) {
          return sprintf_format(sprintf_parse(key), arguments);
        }
        function vsprintf(fmt, argv) {
          return sprintf.apply(null, [fmt].concat(argv || []));
        }
        function sprintf_format(parse_tree, argv) {
          var cursor = 1,
            tree_length = parse_tree.length,
            arg,
            output = "",
            i,
            k,
            ph,
            pad,
            pad_character,
            pad_length,
            is_positive,
            sign;
          for (i = 0; i < tree_length; i++) {
            if (typeof parse_tree[i] === "string") {
              output += parse_tree[i];
            } else if (typeof parse_tree[i] === "object") {
              ph = parse_tree[i];
              if (ph.keys) {
                arg = argv[cursor];
                for (k = 0; k < ph.keys.length; k++) {
                  if (arg == undefined) {
                    throw new Error(
                      sprintf(
                        '[sprintf] Cannot access property "%s" of undefined value "%s"',
                        ph.keys[k],
                        ph.keys[k - 1],
                      ),
                    );
                  }
                  arg = arg[ph.keys[k]];
                }
              } else if (ph.param_no) {
                arg = argv[ph.param_no];
              } else {
                arg = argv[cursor++];
              }
              if (
                re.not_type.test(ph.type) &&
                re.not_primitive.test(ph.type) &&
                arg instanceof Function
              ) {
                arg = arg();
              }
              if (
                re.numeric_arg.test(ph.type) &&
                typeof arg !== "number" &&
                isNaN(arg)
              ) {
                throw new TypeError(
                  sprintf("[sprintf] expecting number but found %T", arg),
                );
              }
              if (re.number.test(ph.type)) {
                is_positive = arg >= 0;
              }
              switch (ph.type) {
                case "b":
                  arg = parseInt(arg, 10).toString(2);
                  break;
                case "c":
                  arg = String.fromCharCode(parseInt(arg, 10));
                  break;
                case "d":
                case "i":
                  arg = parseInt(arg, 10);
                  break;
                case "j":
                  arg = JSON.stringify(
                    arg,
                    null,
                    ph.width ? parseInt(ph.width) : 0,
                  );
                  break;
                case "e":
                  arg = ph.precision
                    ? parseFloat(arg).toExponential(ph.precision)
                    : parseFloat(arg).toExponential();
                  break;
                case "f":
                  arg = ph.precision
                    ? parseFloat(arg).toFixed(ph.precision)
                    : parseFloat(arg);
                  break;
                case "g":
                  arg = ph.precision
                    ? String(Number(arg.toPrecision(ph.precision)))
                    : parseFloat(arg);
                  break;
                case "o":
                  arg = (parseInt(arg, 10) >>> 0).toString(8);
                  break;
                case "s":
                  arg = String(arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "t":
                  arg = String(!!arg);
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "T":
                  arg = Object.prototype.toString
                    .call(arg)
                    .slice(8, -1)
                    .toLowerCase();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "u":
                  arg = parseInt(arg, 10) >>> 0;
                  break;
                case "v":
                  arg = arg.valueOf();
                  arg = ph.precision ? arg.substring(0, ph.precision) : arg;
                  break;
                case "x":
                  arg = (parseInt(arg, 10) >>> 0).toString(16);
                  break;
                case "X":
                  arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
                  break;
              }
              if (re.json.test(ph.type)) {
                output += arg;
              } else {
                if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
                  sign = is_positive ? "+" : "-";
                  arg = arg.toString().replace(re.sign, "");
                } else {
                  sign = "";
                }
                pad_character = ph.pad_char
                  ? ph.pad_char === "0"
                    ? "0"
                    : ph.pad_char.charAt(1)
                  : " ";
                pad_length = ph.width - (sign + arg).length;
                pad = ph.width
                  ? pad_length > 0
                    ? pad_character.repeat(pad_length)
                    : ""
                  : "";
                output += ph.align
                  ? sign + arg + pad
                  : pad_character === "0"
                    ? sign + pad + arg
                    : pad + sign + arg;
              }
            }
          }
          return output;
        }
        var sprintf_cache = Object.create(null);
        function sprintf_parse(fmt) {
          if (sprintf_cache[fmt]) {
            return sprintf_cache[fmt];
          }
          var _fmt = fmt,
            match,
            parse_tree = [],
            arg_names = 0;
          while (_fmt) {
            if ((match = re.text.exec(_fmt)) !== null) {
              parse_tree.push(match[0]);
            } else if ((match = re.modulo.exec(_fmt)) !== null) {
              parse_tree.push("%");
            } else if ((match = re.placeholder.exec(_fmt)) !== null) {
              if (match[2]) {
                arg_names |= 1;
                var field_list = [],
                  replacement_field = match[2],
                  field_match = [];
                if ((field_match = re.key.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                  while (
                    (replacement_field = replacement_field.substring(
                      field_match[0].length,
                    )) !== ""
                  ) {
                    if (
                      (field_match = re.key_access.exec(replacement_field)) !==
                      null
                    ) {
                      field_list.push(field_match[1]);
                    } else if (
                      (field_match =
                        re.index_access.exec(replacement_field)) !== null
                    ) {
                      field_list.push(field_match[1]);
                    } else {
                      throw new SyntaxError(
                        "[sprintf] failed to parse named argument key",
                      );
                    }
                  }
                } else {
                  throw new SyntaxError(
                    "[sprintf] failed to parse named argument key",
                  );
                }
                match[2] = field_list;
              } else {
                arg_names |= 2;
              }
              if (arg_names === 3) {
                throw new Error(
                  "[sprintf] mixing positional and named placeholders is not (yet) supported",
                );
              }
              parse_tree.push({
                placeholder: match[0],
                param_no: match[1],
                keys: match[2],
                sign: match[3],
                pad_char: match[4],
                align: match[5],
                width: match[6],
                precision: match[7],
                type: match[8],
              });
            } else {
              throw new SyntaxError("[sprintf] unexpected placeholder");
            }
            _fmt = _fmt.substring(match[0].length);
          }
          return (sprintf_cache[fmt] = parse_tree);
        }
        if (true) {
          exports.sprintf = sprintf;
          exports.vsprintf = vsprintf;
        }
        if (typeof window !== "undefined") {
          window["sprintf"] = sprintf;
          window["vsprintf"] = vsprintf;
          if (typeof define === "function" && define["amd"]) {
            define(function () {
              return { sprintf, vsprintf };
            });
          }
        }
      })();
    },
    4406: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const crypto = __nccwpck_require__(6113);
      const { Minipass } = __nccwpck_require__(4968);
      const SPEC_ALGORITHMS = ["sha512", "sha384", "sha256"];
      const DEFAULT_ALGORITHMS = ["sha512"];
      const BASE64_REGEX = /^[a-z0-9+/]+(?:=?=?)$/i;
      const SRI_REGEX = /^([a-z0-9]+)-([^?]+)([?\S*]*)$/;
      const STRICT_SRI_REGEX =
        /^([a-z0-9]+)-([A-Za-z0-9+/=]{44,88})(\?[\x21-\x7E]*)?$/;
      const VCHAR_REGEX = /^[\x21-\x7E]+$/;
      const getOptString = (options) =>
        options?.length ? `?${options.join("?")}` : "";
      class IntegrityStream extends Minipass {
        #emittedIntegrity;
        #emittedSize;
        #emittedVerified;
        constructor(opts) {
          super();
          this.size = 0;
          this.opts = opts;
          this.#getOptions();
          if (opts?.algorithms) {
            this.algorithms = [...opts.algorithms];
          } else {
            this.algorithms = [...DEFAULT_ALGORITHMS];
          }
          if (
            this.algorithm !== null &&
            !this.algorithms.includes(this.algorithm)
          ) {
            this.algorithms.push(this.algorithm);
          }
          this.hashes = this.algorithms.map(crypto.createHash);
        }
        #getOptions() {
          this.sri = this.opts?.integrity
            ? parse(this.opts?.integrity, this.opts)
            : null;
          this.expectedSize = this.opts?.size;
          if (!this.sri) {
            this.algorithm = null;
          } else if (this.sri.isHash) {
            this.goodSri = true;
            this.algorithm = this.sri.algorithm;
          } else {
            this.goodSri = !this.sri.isEmpty();
            this.algorithm = this.sri.pickAlgorithm(this.opts);
          }
          this.digests = this.goodSri ? this.sri[this.algorithm] : null;
          this.optString = getOptString(this.opts?.options);
        }
        on(ev, handler) {
          if (ev === "size" && this.#emittedSize) {
            return handler(this.#emittedSize);
          }
          if (ev === "integrity" && this.#emittedIntegrity) {
            return handler(this.#emittedIntegrity);
          }
          if (ev === "verified" && this.#emittedVerified) {
            return handler(this.#emittedVerified);
          }
          return super.on(ev, handler);
        }
        emit(ev, data) {
          if (ev === "end") {
            this.#onEnd();
          }
          return super.emit(ev, data);
        }
        write(data) {
          this.size += data.length;
          this.hashes.forEach((h) => h.update(data));
          return super.write(data);
        }
        #onEnd() {
          if (!this.goodSri) {
            this.#getOptions();
          }
          const newSri = parse(
            this.hashes
              .map(
                (h, i) =>
                  `${this.algorithms[i]}-${h.digest("base64")}${this.optString}`,
              )
              .join(" "),
            this.opts,
          );
          const match = this.goodSri && newSri.match(this.sri, this.opts);
          if (
            typeof this.expectedSize === "number" &&
            this.size !== this.expectedSize
          ) {
            const err = new Error(
              `stream size mismatch when checking ${this.sri}.\n  Wanted: ${this.expectedSize}\n  Found: ${this.size}`,
            );
            err.code = "EBADSIZE";
            err.found = this.size;
            err.expected = this.expectedSize;
            err.sri = this.sri;
            this.emit("error", err);
          } else if (this.sri && !match) {
            const err = new Error(
              `${this.sri} integrity checksum failed when using ${this.algorithm}: wanted ${this.digests} but got ${newSri}. (${this.size} bytes)`,
            );
            err.code = "EINTEGRITY";
            err.found = newSri;
            err.expected = this.digests;
            err.algorithm = this.algorithm;
            err.sri = this.sri;
            this.emit("error", err);
          } else {
            this.#emittedSize = this.size;
            this.emit("size", this.size);
            this.#emittedIntegrity = newSri;
            this.emit("integrity", newSri);
            if (match) {
              this.#emittedVerified = match;
              this.emit("verified", match);
            }
          }
        }
      }
      class Hash {
        get isHash() {
          return true;
        }
        constructor(hash, opts) {
          const strict = opts?.strict;
          this.source = hash.trim();
          this.digest = "";
          this.algorithm = "";
          this.options = [];
          const match = this.source.match(
            strict ? STRICT_SRI_REGEX : SRI_REGEX,
          );
          if (!match) {
            return;
          }
          if (strict && !SPEC_ALGORITHMS.includes(match[1])) {
            return;
          }
          this.algorithm = match[1];
          this.digest = match[2];
          const rawOpts = match[3];
          if (rawOpts) {
            this.options = rawOpts.slice(1).split("?");
          }
        }
        hexDigest() {
          return (
            this.digest && Buffer.from(this.digest, "base64").toString("hex")
          );
        }
        toJSON() {
          return this.toString();
        }
        match(integrity, opts) {
          const other = parse(integrity, opts);
          if (!other) {
            return false;
          }
          if (other.isIntegrity) {
            const algo = other.pickAlgorithm(opts, [this.algorithm]);
            if (!algo) {
              return false;
            }
            const foundHash = other[algo].find(
              (hash) => hash.digest === this.digest,
            );
            if (foundHash) {
              return foundHash;
            }
            return false;
          }
          return other.digest === this.digest ? other : false;
        }
        toString(opts) {
          if (opts?.strict) {
            if (
              !(
                SPEC_ALGORITHMS.includes(this.algorithm) &&
                this.digest.match(BASE64_REGEX) &&
                this.options.every((opt) => opt.match(VCHAR_REGEX))
              )
            ) {
              return "";
            }
          }
          return `${this.algorithm}-${this.digest}${getOptString(this.options)}`;
        }
      }
      function integrityHashToString(toString, sep, opts, hashes) {
        const toStringIsNotEmpty = toString !== "";
        let shouldAddFirstSep = false;
        let complement = "";
        const lastIndex = hashes.length - 1;
        for (let i = 0; i < lastIndex; i++) {
          const hashString = Hash.prototype.toString.call(hashes[i], opts);
          if (hashString) {
            shouldAddFirstSep = true;
            complement += hashString;
            complement += sep;
          }
        }
        const finalHashString = Hash.prototype.toString.call(
          hashes[lastIndex],
          opts,
        );
        if (finalHashString) {
          shouldAddFirstSep = true;
          complement += finalHashString;
        }
        if (toStringIsNotEmpty && shouldAddFirstSep) {
          return toString + sep + complement;
        }
        return toString + complement;
      }
      class Integrity {
        get isIntegrity() {
          return true;
        }
        toJSON() {
          return this.toString();
        }
        isEmpty() {
          return Object.keys(this).length === 0;
        }
        toString(opts) {
          let sep = opts?.sep || " ";
          let toString = "";
          if (opts?.strict) {
            sep = sep.replace(/\S+/g, " ");
            for (const hash of SPEC_ALGORITHMS) {
              if (this[hash]) {
                toString = integrityHashToString(
                  toString,
                  sep,
                  opts,
                  this[hash],
                );
              }
            }
          } else {
            for (const hash of Object.keys(this)) {
              toString = integrityHashToString(toString, sep, opts, this[hash]);
            }
          }
          return toString;
        }
        concat(integrity, opts) {
          const other =
            typeof integrity === "string"
              ? integrity
              : stringify(integrity, opts);
          return parse(`${this.toString(opts)} ${other}`, opts);
        }
        hexDigest() {
          return parse(this, { single: true }).hexDigest();
        }
        merge(integrity, opts) {
          const other = parse(integrity, opts);
          for (const algo in other) {
            if (this[algo]) {
              if (
                !this[algo].find((hash) =>
                  other[algo].find(
                    (otherhash) => hash.digest === otherhash.digest,
                  ),
                )
              ) {
                throw new Error("hashes do not match, cannot update integrity");
              }
            } else {
              this[algo] = other[algo];
            }
          }
        }
        match(integrity, opts) {
          const other = parse(integrity, opts);
          if (!other) {
            return false;
          }
          const algo = other.pickAlgorithm(opts, Object.keys(this));
          return (
            (!!algo &&
              this[algo] &&
              other[algo] &&
              this[algo].find((hash) =>
                other[algo].find(
                  (otherhash) => hash.digest === otherhash.digest,
                ),
              )) ||
            false
          );
        }
        pickAlgorithm(opts, hashes) {
          const pickAlgorithm = opts?.pickAlgorithm || getPrioritizedHash;
          const keys = Object.keys(this).filter((k) => {
            if (hashes?.length) {
              return hashes.includes(k);
            }
            return true;
          });
          if (keys.length) {
            return keys.reduce((acc, algo) => pickAlgorithm(acc, algo) || acc);
          }
          return null;
        }
      }
      module.exports.parse = parse;
      function parse(sri, opts) {
        if (!sri) {
          return null;
        }
        if (typeof sri === "string") {
          return _parse(sri, opts);
        } else if (sri.algorithm && sri.digest) {
          const fullSri = new Integrity();
          fullSri[sri.algorithm] = [sri];
          return _parse(stringify(fullSri, opts), opts);
        } else {
          return _parse(stringify(sri, opts), opts);
        }
      }
      function _parse(integrity, opts) {
        if (opts?.single) {
          return new Hash(integrity, opts);
        }
        const hashes = integrity
          .trim()
          .split(/\s+/)
          .reduce((acc, string) => {
            const hash = new Hash(string, opts);
            if (hash.algorithm && hash.digest) {
              const algo = hash.algorithm;
              if (!acc[algo]) {
                acc[algo] = [];
              }
              acc[algo].push(hash);
            }
            return acc;
          }, new Integrity());
        return hashes.isEmpty() ? null : hashes;
      }
      module.exports.stringify = stringify;
      function stringify(obj, opts) {
        if (obj.algorithm && obj.digest) {
          return Hash.prototype.toString.call(obj, opts);
        } else if (typeof obj === "string") {
          return stringify(parse(obj, opts), opts);
        } else {
          return Integrity.prototype.toString.call(obj, opts);
        }
      }
      module.exports.fromHex = fromHex;
      function fromHex(hexDigest, algorithm, opts) {
        const optString = getOptString(opts?.options);
        return parse(
          `${algorithm}-${Buffer.from(hexDigest, "hex").toString("base64")}${optString}`,
          opts,
        );
      }
      module.exports.fromData = fromData;
      function fromData(data, opts) {
        const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
        const optString = getOptString(opts?.options);
        return algorithms.reduce((acc, algo) => {
          const digest = crypto.createHash(algo).update(data).digest("base64");
          const hash = new Hash(`${algo}-${digest}${optString}`, opts);
          if (hash.algorithm && hash.digest) {
            const hashAlgo = hash.algorithm;
            if (!acc[hashAlgo]) {
              acc[hashAlgo] = [];
            }
            acc[hashAlgo].push(hash);
          }
          return acc;
        }, new Integrity());
      }
      module.exports.fromStream = fromStream;
      function fromStream(stream, opts) {
        const istream = integrityStream(opts);
        return new Promise((resolve, reject) => {
          stream.pipe(istream);
          stream.on("error", reject);
          istream.on("error", reject);
          let sri;
          istream.on("integrity", (s) => {
            sri = s;
          });
          istream.on("end", () => resolve(sri));
          istream.resume();
        });
      }
      module.exports.checkData = checkData;
      function checkData(data, sri, opts) {
        sri = parse(sri, opts);
        if (!sri || !Object.keys(sri).length) {
          if (opts?.error) {
            throw Object.assign(
              new Error("No valid integrity hashes to check against"),
              { code: "EINTEGRITY" },
            );
          } else {
            return false;
          }
        }
        const algorithm = sri.pickAlgorithm(opts);
        const digest = crypto
          .createHash(algorithm)
          .update(data)
          .digest("base64");
        const newSri = parse({ algorithm, digest });
        const match = newSri.match(sri, opts);
        opts = opts || {};
        if (match || !opts.error) {
          return match;
        } else if (typeof opts.size === "number" && data.length !== opts.size) {
          const err = new Error(
            `data size mismatch when checking ${sri}.\n  Wanted: ${opts.size}\n  Found: ${data.length}`,
          );
          err.code = "EBADSIZE";
          err.found = data.length;
          err.expected = opts.size;
          err.sri = sri;
          throw err;
        } else {
          const err = new Error(
            `Integrity checksum failed when using ${algorithm}: Wanted ${sri}, but got ${newSri}. (${data.length} bytes)`,
          );
          err.code = "EINTEGRITY";
          err.found = newSri;
          err.expected = sri;
          err.algorithm = algorithm;
          err.sri = sri;
          throw err;
        }
      }
      module.exports.checkStream = checkStream;
      function checkStream(stream, sri, opts) {
        opts = opts || Object.create(null);
        opts.integrity = sri;
        sri = parse(sri, opts);
        if (!sri || !Object.keys(sri).length) {
          return Promise.reject(
            Object.assign(
              new Error("No valid integrity hashes to check against"),
              { code: "EINTEGRITY" },
            ),
          );
        }
        const checker = integrityStream(opts);
        return new Promise((resolve, reject) => {
          stream.pipe(checker);
          stream.on("error", reject);
          checker.on("error", reject);
          let verified;
          checker.on("verified", (s) => {
            verified = s;
          });
          checker.on("end", () => resolve(verified));
          checker.resume();
        });
      }
      module.exports.integrityStream = integrityStream;
      function integrityStream(opts = Object.create(null)) {
        return new IntegrityStream(opts);
      }
      module.exports.create = createIntegrity;
      function createIntegrity(opts) {
        const algorithms = opts?.algorithms || [...DEFAULT_ALGORITHMS];
        const optString = getOptString(opts?.options);
        const hashes = algorithms.map(crypto.createHash);
        return {
          update: function (chunk, enc) {
            hashes.forEach((h) => h.update(chunk, enc));
            return this;
          },
          digest: function () {
            const integrity = algorithms.reduce((acc, algo) => {
              const digest = hashes.shift().digest("base64");
              const hash = new Hash(`${algo}-${digest}${optString}`, opts);
              if (hash.algorithm && hash.digest) {
                const hashAlgo = hash.algorithm;
                if (!acc[hashAlgo]) {
                  acc[hashAlgo] = [];
                }
                acc[hashAlgo].push(hash);
              }
              return acc;
            }, new Integrity());
            return integrity;
          },
        };
      }
      const NODE_HASHES = crypto.getHashes();
      const DEFAULT_PRIORITY = [
        "md5",
        "whirlpool",
        "sha1",
        "sha224",
        "sha256",
        "sha384",
        "sha512",
        "sha3",
        "sha3-256",
        "sha3-384",
        "sha3-512",
        "sha3_256",
        "sha3_384",
        "sha3_512",
      ].filter((algo) => NODE_HASHES.includes(algo));
      function getPrioritizedHash(algo1, algo2) {
        return DEFAULT_PRIORITY.indexOf(algo1.toLowerCase()) >=
          DEFAULT_PRIORITY.indexOf(algo2.toLowerCase())
          ? algo1
          : algo2;
      }
    },
    9530: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.defaultConfig = void 0;
      exports.defaultConfig = {
        maxRootRotations: 32,
        maxDelegations: 32,
        rootMaxLength: 512e3,
        timestampMaxLength: 16384,
        snapshotMaxLength: 2e6,
        targetsMaxLength: 5e6,
        prefixTargetsWithHash: true,
        fetchTimeout: 1e5,
        fetchRetries: undefined,
        fetchRetry: 2,
      };
    },
    7040: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DownloadHTTPError =
        exports.DownloadLengthMismatchError =
        exports.DownloadError =
        exports.ExpiredMetadataError =
        exports.EqualVersionError =
        exports.BadVersionError =
        exports.RepositoryError =
        exports.PersistError =
        exports.RuntimeError =
        exports.ValueError =
          void 0;
      class ValueError extends Error {}
      exports.ValueError = ValueError;
      class RuntimeError extends Error {}
      exports.RuntimeError = RuntimeError;
      class PersistError extends Error {}
      exports.PersistError = PersistError;
      class RepositoryError extends Error {}
      exports.RepositoryError = RepositoryError;
      class BadVersionError extends RepositoryError {}
      exports.BadVersionError = BadVersionError;
      class EqualVersionError extends BadVersionError {}
      exports.EqualVersionError = EqualVersionError;
      class ExpiredMetadataError extends RepositoryError {}
      exports.ExpiredMetadataError = ExpiredMetadataError;
      class DownloadError extends Error {}
      exports.DownloadError = DownloadError;
      class DownloadLengthMismatchError extends DownloadError {}
      exports.DownloadLengthMismatchError = DownloadLengthMismatchError;
      class DownloadHTTPError extends DownloadError {
        constructor(message, statusCode) {
          super(message);
          this.statusCode = statusCode;
        }
      }
      exports.DownloadHTTPError = DownloadHTTPError;
    },
    5991: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.DefaultFetcher = exports.BaseFetcher = void 0;
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const fs_1 = __importDefault(__nccwpck_require__(7147));
      const make_fetch_happen_1 = __importDefault(__nccwpck_require__(9525));
      const util_1 = __importDefault(__nccwpck_require__(3837));
      const error_1 = __nccwpck_require__(7040);
      const tmpfile_1 = __nccwpck_require__(6400);
      const log = (0, debug_1.default)("tuf:fetch");
      class BaseFetcher {
        async downloadFile(url, maxLength, handler) {
          return (0, tmpfile_1.withTempFile)(async (tmpFile) => {
            const reader = await this.fetch(url);
            let numberOfBytesReceived = 0;
            const fileStream = fs_1.default.createWriteStream(tmpFile);
            try {
              for await (const chunk of reader) {
                const bufferChunk = Buffer.from(chunk);
                numberOfBytesReceived += bufferChunk.length;
                if (numberOfBytesReceived > maxLength) {
                  throw new error_1.DownloadLengthMismatchError(
                    "Max length reached",
                  );
                }
                await writeBufferToStream(fileStream, bufferChunk);
              }
            } finally {
              await util_1.default
                .promisify(fileStream.close)
                .bind(fileStream)();
            }
            return handler(tmpFile);
          });
        }
        async downloadBytes(url, maxLength) {
          return this.downloadFile(url, maxLength, async (file) => {
            const stream = fs_1.default.createReadStream(file);
            const chunks = [];
            for await (const chunk of stream) {
              chunks.push(chunk);
            }
            return Buffer.concat(chunks);
          });
        }
      }
      exports.BaseFetcher = BaseFetcher;
      class DefaultFetcher extends BaseFetcher {
        constructor(options = {}) {
          super();
          this.timeout = options.timeout;
          this.retry = options.retry;
        }
        async fetch(url) {
          log("GET %s", url);
          const response = await (0, make_fetch_happen_1.default)(url, {
            timeout: this.timeout,
            retry: this.retry,
          });
          if (!response.ok || !response?.body) {
            throw new error_1.DownloadHTTPError(
              "Failed to download",
              response.status,
            );
          }
          return response.body;
        }
      }
      exports.DefaultFetcher = DefaultFetcher;
      const writeBufferToStream = async (stream, buffer) =>
        new Promise((resolve, reject) => {
          stream.write(buffer, (err) => {
            if (err) {
              reject(err);
            }
            resolve(true);
          });
        });
    },
    9475: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Updater = exports.BaseFetcher = exports.TargetFile = void 0;
      var models_1 = __nccwpck_require__(5833);
      Object.defineProperty(exports, "TargetFile", {
        enumerable: true,
        get: function () {
          return models_1.TargetFile;
        },
      });
      var fetcher_1 = __nccwpck_require__(5991);
      Object.defineProperty(exports, "BaseFetcher", {
        enumerable: true,
        get: function () {
          return fetcher_1.BaseFetcher;
        },
      });
      var updater_1 = __nccwpck_require__(7977);
      Object.defineProperty(exports, "Updater", {
        enumerable: true,
        get: function () {
          return updater_1.Updater;
        },
      });
    },
    7001: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.TrustedMetadataStore = void 0;
      const models_1 = __nccwpck_require__(5833);
      const error_1 = __nccwpck_require__(7040);
      class TrustedMetadataStore {
        constructor(rootData) {
          this.trustedSet = {};
          this.referenceTime = new Date();
          this.loadTrustedRoot(rootData);
        }
        get root() {
          if (!this.trustedSet.root) {
            throw new ReferenceError("No trusted root metadata");
          }
          return this.trustedSet.root;
        }
        get timestamp() {
          return this.trustedSet.timestamp;
        }
        get snapshot() {
          return this.trustedSet.snapshot;
        }
        get targets() {
          return this.trustedSet.targets;
        }
        getRole(name) {
          return this.trustedSet[name];
        }
        updateRoot(bytesBuffer) {
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newRoot = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Root,
            data,
          );
          if (newRoot.signed.type != models_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(
              `Expected 'root', got ${newRoot.signed.type}`,
            );
          }
          this.root.verifyDelegate(models_1.MetadataKind.Root, newRoot);
          if (newRoot.signed.version != this.root.signed.version + 1) {
            throw new error_1.BadVersionError(
              `Expected version ${this.root.signed.version + 1}, got ${newRoot.signed.version}`,
            );
          }
          newRoot.verifyDelegate(models_1.MetadataKind.Root, newRoot);
          this.trustedSet.root = newRoot;
          return newRoot;
        }
        updateTimestamp(bytesBuffer) {
          if (this.snapshot) {
            throw new error_1.RuntimeError(
              "Cannot update timestamp after snapshot",
            );
          }
          if (this.root.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(
              "Final root.json is expired",
            );
          }
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newTimestamp = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Timestamp,
            data,
          );
          if (newTimestamp.signed.type != models_1.MetadataKind.Timestamp) {
            throw new error_1.RepositoryError(
              `Expected 'timestamp', got ${newTimestamp.signed.type}`,
            );
          }
          this.root.verifyDelegate(
            models_1.MetadataKind.Timestamp,
            newTimestamp,
          );
          if (this.timestamp) {
            if (newTimestamp.signed.version < this.timestamp.signed.version) {
              throw new error_1.BadVersionError(
                `New timestamp version ${newTimestamp.signed.version} is less than current version ${this.timestamp.signed.version}`,
              );
            }
            if (newTimestamp.signed.version === this.timestamp.signed.version) {
              throw new error_1.EqualVersionError(
                `New timestamp version ${newTimestamp.signed.version} is equal to current version ${this.timestamp.signed.version}`,
              );
            }
            const snapshotMeta = this.timestamp.signed.snapshotMeta;
            const newSnapshotMeta = newTimestamp.signed.snapshotMeta;
            if (newSnapshotMeta.version < snapshotMeta.version) {
              throw new error_1.BadVersionError(
                `New snapshot version ${newSnapshotMeta.version} is less than current version ${snapshotMeta.version}`,
              );
            }
          }
          this.trustedSet.timestamp = newTimestamp;
          this.checkFinalTimestamp();
          return newTimestamp;
        }
        updateSnapshot(bytesBuffer, trusted = false) {
          if (!this.timestamp) {
            throw new error_1.RuntimeError(
              "Cannot update snapshot before timestamp",
            );
          }
          if (this.targets) {
            throw new error_1.RuntimeError(
              "Cannot update snapshot after targets",
            );
          }
          this.checkFinalTimestamp();
          const snapshotMeta = this.timestamp.signed.snapshotMeta;
          if (!trusted) {
            snapshotMeta.verify(bytesBuffer);
          }
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newSnapshot = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Snapshot,
            data,
          );
          if (newSnapshot.signed.type != models_1.MetadataKind.Snapshot) {
            throw new error_1.RepositoryError(
              `Expected 'snapshot', got ${newSnapshot.signed.type}`,
            );
          }
          this.root.verifyDelegate(models_1.MetadataKind.Snapshot, newSnapshot);
          if (this.snapshot) {
            Object.entries(this.snapshot.signed.meta).forEach(
              ([fileName, fileInfo]) => {
                const newFileInfo = newSnapshot.signed.meta[fileName];
                if (!newFileInfo) {
                  throw new error_1.RepositoryError(
                    `Missing file ${fileName} in new snapshot`,
                  );
                }
                if (newFileInfo.version < fileInfo.version) {
                  throw new error_1.BadVersionError(
                    `New version ${newFileInfo.version} of ${fileName} is less than current version ${fileInfo.version}`,
                  );
                }
              },
            );
          }
          this.trustedSet.snapshot = newSnapshot;
          this.checkFinalSnapsnot();
          return newSnapshot;
        }
        updateDelegatedTargets(bytesBuffer, roleName, delegatorName) {
          if (!this.snapshot) {
            throw new error_1.RuntimeError(
              "Cannot update delegated targets before snapshot",
            );
          }
          this.checkFinalSnapsnot();
          const delegator = this.trustedSet[delegatorName];
          if (!delegator) {
            throw new error_1.RuntimeError(
              `No trusted ${delegatorName} metadata`,
            );
          }
          const meta = this.snapshot.signed.meta?.[`${roleName}.json`];
          if (!meta) {
            throw new error_1.RepositoryError(
              `Missing ${roleName}.json in snapshot`,
            );
          }
          meta.verify(bytesBuffer);
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const newDelegate = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Targets,
            data,
          );
          if (newDelegate.signed.type != models_1.MetadataKind.Targets) {
            throw new error_1.RepositoryError(
              `Expected 'targets', got ${newDelegate.signed.type}`,
            );
          }
          delegator.verifyDelegate(roleName, newDelegate);
          const version = newDelegate.signed.version;
          if (version != meta.version) {
            throw new error_1.BadVersionError(
              `Version ${version} of ${roleName} does not match snapshot version ${meta.version}`,
            );
          }
          if (newDelegate.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(
              `${roleName}.json is expired`,
            );
          }
          this.trustedSet[roleName] = newDelegate;
        }
        loadTrustedRoot(bytesBuffer) {
          const data = JSON.parse(bytesBuffer.toString("utf8"));
          const root = models_1.Metadata.fromJSON(
            models_1.MetadataKind.Root,
            data,
          );
          if (root.signed.type != models_1.MetadataKind.Root) {
            throw new error_1.RepositoryError(
              `Expected 'root', got ${root.signed.type}`,
            );
          }
          root.verifyDelegate(models_1.MetadataKind.Root, root);
          this.trustedSet["root"] = root;
        }
        checkFinalTimestamp() {
          if (!this.timestamp) {
            throw new ReferenceError("No trusted timestamp metadata");
          }
          if (this.timestamp.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError(
              "Final timestamp.json is expired",
            );
          }
        }
        checkFinalSnapsnot() {
          if (!this.snapshot) {
            throw new ReferenceError("No trusted snapshot metadata");
          }
          if (!this.timestamp) {
            throw new ReferenceError("No trusted timestamp metadata");
          }
          if (this.snapshot.signed.isExpired(this.referenceTime)) {
            throw new error_1.ExpiredMetadataError("snapshot.json is expired");
          }
          const snapshotMeta = this.timestamp.signed.snapshotMeta;
          if (this.snapshot.signed.version !== snapshotMeta.version) {
            throw new error_1.BadVersionError(
              "Snapshot version doesn't match timestamp",
            );
          }
        }
      }
      exports.TrustedMetadataStore = TrustedMetadataStore;
    },
    7977: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __createBinding =
        (this && this.__createBinding) ||
        (Object.create
          ? function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              var desc = Object.getOwnPropertyDescriptor(m, k);
              if (
                !desc ||
                ("get" in desc
                  ? !m.__esModule
                  : desc.writable || desc.configurable)
              ) {
                desc = {
                  enumerable: true,
                  get: function () {
                    return m[k];
                  },
                };
              }
              Object.defineProperty(o, k2, desc);
            }
          : function (o, m, k, k2) {
              if (k2 === undefined) k2 = k;
              o[k2] = m[k];
            });
      var __setModuleDefault =
        (this && this.__setModuleDefault) ||
        (Object.create
          ? function (o, v) {
              Object.defineProperty(o, "default", {
                enumerable: true,
                value: v,
              });
            }
          : function (o, v) {
              o["default"] = v;
            });
      var __importStar =
        (this && this.__importStar) ||
        function (mod) {
          if (mod && mod.__esModule) return mod;
          var result = {};
          if (mod != null)
            for (var k in mod)
              if (
                k !== "default" &&
                Object.prototype.hasOwnProperty.call(mod, k)
              )
                __createBinding(result, mod, k);
          __setModuleDefault(result, mod);
          return result;
        };
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Updater = void 0;
      const models_1 = __nccwpck_require__(5833);
      const debug_1 = __importDefault(__nccwpck_require__(8237));
      const fs = __importStar(__nccwpck_require__(7147));
      const path = __importStar(__nccwpck_require__(1017));
      const config_1 = __nccwpck_require__(9530);
      const error_1 = __nccwpck_require__(7040);
      const fetcher_1 = __nccwpck_require__(5991);
      const store_1 = __nccwpck_require__(7001);
      const url = __importStar(__nccwpck_require__(5961));
      const log = (0, debug_1.default)("tuf:cache");
      class Updater {
        constructor(options) {
          const {
            metadataDir,
            metadataBaseUrl,
            targetDir,
            targetBaseUrl,
            fetcher,
            config,
          } = options;
          this.dir = metadataDir;
          this.metadataBaseUrl = metadataBaseUrl;
          this.targetDir = targetDir;
          this.targetBaseUrl = targetBaseUrl;
          this.forceCache = options.forceCache ?? false;
          const data = this.loadLocalMetadata(models_1.MetadataKind.Root);
          this.trustedSet = new store_1.TrustedMetadataStore(data);
          this.config = { ...config_1.defaultConfig, ...config };
          this.fetcher =
            fetcher ||
            new fetcher_1.DefaultFetcher({
              timeout: this.config.fetchTimeout,
              retry: this.config.fetchRetries ?? this.config.fetchRetry,
            });
        }
        async refresh() {
          if (this.forceCache) {
            try {
              await this.loadTimestamp({ checkRemote: false });
            } catch (error) {
              await this.loadRoot();
              await this.loadTimestamp();
            }
          } else {
            await this.loadRoot();
            await this.loadTimestamp();
          }
          await this.loadSnapshot();
          await this.loadTargets(
            models_1.MetadataKind.Targets,
            models_1.MetadataKind.Root,
          );
        }
        async getTargetInfo(targetPath) {
          if (!this.trustedSet.targets) {
            await this.refresh();
          }
          return this.preorderDepthFirstWalk(targetPath);
        }
        async downloadTarget(targetInfo, filePath, targetBaseUrl) {
          const targetPath = filePath || this.generateTargetPath(targetInfo);
          if (!targetBaseUrl) {
            if (!this.targetBaseUrl) {
              throw new error_1.ValueError("Target base URL not set");
            }
            targetBaseUrl = this.targetBaseUrl;
          }
          let targetFilePath = targetInfo.path;
          const consistentSnapshot =
            this.trustedSet.root.signed.consistentSnapshot;
          if (consistentSnapshot && this.config.prefixTargetsWithHash) {
            const hashes = Object.values(targetInfo.hashes);
            const { dir, base } = path.parse(targetFilePath);
            const filename = `${hashes[0]}.${base}`;
            targetFilePath = dir ? `${dir}/${filename}` : filename;
          }
          const targetUrl = url.join(targetBaseUrl, targetFilePath);
          await this.fetcher.downloadFile(
            targetUrl,
            targetInfo.length,
            async (fileName) => {
              await targetInfo.verify(fs.createReadStream(fileName));
              log("WRITE %s", targetPath);
              fs.copyFileSync(fileName, targetPath);
            },
          );
          return targetPath;
        }
        async findCachedTarget(targetInfo, filePath) {
          if (!filePath) {
            filePath = this.generateTargetPath(targetInfo);
          }
          try {
            if (fs.existsSync(filePath)) {
              await targetInfo.verify(fs.createReadStream(filePath));
              return filePath;
            }
          } catch (error) {
            return;
          }
          return;
        }
        loadLocalMetadata(fileName) {
          const filePath = path.join(this.dir, `${fileName}.json`);
          log("READ %s", filePath);
          return fs.readFileSync(filePath);
        }
        async loadRoot() {
          const rootVersion = this.trustedSet.root.signed.version;
          const lowerBound = rootVersion + 1;
          const upperBound = lowerBound + this.config.maxRootRotations;
          for (let version = lowerBound; version <= upperBound; version++) {
            const rootUrl = url.join(
              this.metadataBaseUrl,
              `${version}.root.json`,
            );
            try {
              const bytesData = await this.fetcher.downloadBytes(
                rootUrl,
                this.config.rootMaxLength,
              );
              this.trustedSet.updateRoot(bytesData);
              this.persistMetadata(models_1.MetadataKind.Root, bytesData);
            } catch (error) {
              break;
            }
          }
        }
        async loadTimestamp({ checkRemote } = { checkRemote: true }) {
          try {
            const data = this.loadLocalMetadata(
              models_1.MetadataKind.Timestamp,
            );
            this.trustedSet.updateTimestamp(data);
            if (!checkRemote) {
              return;
            }
          } catch (error) {}
          const timestampUrl = url.join(this.metadataBaseUrl, "timestamp.json");
          const bytesData = await this.fetcher.downloadBytes(
            timestampUrl,
            this.config.timestampMaxLength,
          );
          try {
            this.trustedSet.updateTimestamp(bytesData);
          } catch (error) {
            if (error instanceof error_1.EqualVersionError) {
              return;
            }
            throw error;
          }
          this.persistMetadata(models_1.MetadataKind.Timestamp, bytesData);
        }
        async loadSnapshot() {
          try {
            const data = this.loadLocalMetadata(models_1.MetadataKind.Snapshot);
            this.trustedSet.updateSnapshot(data, true);
          } catch (error) {
            if (!this.trustedSet.timestamp) {
              throw new ReferenceError("No timestamp metadata");
            }
            const snapshotMeta = this.trustedSet.timestamp.signed.snapshotMeta;
            const maxLength =
              snapshotMeta.length || this.config.snapshotMaxLength;
            const version = this.trustedSet.root.signed.consistentSnapshot
              ? snapshotMeta.version
              : undefined;
            const snapshotUrl = url.join(
              this.metadataBaseUrl,
              version ? `${version}.snapshot.json` : "snapshot.json",
            );
            try {
              const bytesData = await this.fetcher.downloadBytes(
                snapshotUrl,
                maxLength,
              );
              this.trustedSet.updateSnapshot(bytesData);
              this.persistMetadata(models_1.MetadataKind.Snapshot, bytesData);
            } catch (error) {
              throw new error_1.RuntimeError(
                `Unable to load snapshot metadata error ${error}`,
              );
            }
          }
        }
        async loadTargets(role, parentRole) {
          if (this.trustedSet.getRole(role)) {
            return this.trustedSet.getRole(role);
          }
          try {
            const buffer = this.loadLocalMetadata(role);
            this.trustedSet.updateDelegatedTargets(buffer, role, parentRole);
          } catch (error) {
            if (!this.trustedSet.snapshot) {
              throw new ReferenceError("No snapshot metadata");
            }
            const metaInfo =
              this.trustedSet.snapshot.signed.meta[`${role}.json`];
            const maxLength = metaInfo.length || this.config.targetsMaxLength;
            const version = this.trustedSet.root.signed.consistentSnapshot
              ? metaInfo.version
              : undefined;
            const metadataUrl = url.join(
              this.metadataBaseUrl,
              version ? `${version}.${role}.json` : `${role}.json`,
            );
            try {
              const bytesData = await this.fetcher.downloadBytes(
                metadataUrl,
                maxLength,
              );
              this.trustedSet.updateDelegatedTargets(
                bytesData,
                role,
                parentRole,
              );
              this.persistMetadata(role, bytesData);
            } catch (error) {
              throw new error_1.RuntimeError(
                `Unable to load targets error ${error}`,
              );
            }
          }
          return this.trustedSet.getRole(role);
        }
        async preorderDepthFirstWalk(targetPath) {
          const delegationsToVisit = [
            {
              roleName: models_1.MetadataKind.Targets,
              parentRoleName: models_1.MetadataKind.Root,
            },
          ];
          const visitedRoleNames = new Set();
          while (
            visitedRoleNames.size <= this.config.maxDelegations &&
            delegationsToVisit.length > 0
          ) {
            const { roleName, parentRoleName } = delegationsToVisit.pop();
            if (visitedRoleNames.has(roleName)) {
              continue;
            }
            const targets = (await this.loadTargets(roleName, parentRoleName))
              ?.signed;
            if (!targets) {
              continue;
            }
            const target = targets.targets?.[targetPath];
            if (target) {
              return target;
            }
            visitedRoleNames.add(roleName);
            if (targets.delegations) {
              const childRolesToVisit = [];
              const rolesForTarget =
                targets.delegations.rolesForTarget(targetPath);
              for (const { role: childName, terminating } of rolesForTarget) {
                childRolesToVisit.push({
                  roleName: childName,
                  parentRoleName: roleName,
                });
                if (terminating) {
                  delegationsToVisit.splice(0);
                  break;
                }
              }
              childRolesToVisit.reverse();
              delegationsToVisit.push(...childRolesToVisit);
            }
          }
          return;
        }
        generateTargetPath(targetInfo) {
          if (!this.targetDir) {
            throw new error_1.ValueError("Target directory not set");
          }
          const filePath = encodeURIComponent(targetInfo.path);
          return path.join(this.targetDir, filePath);
        }
        persistMetadata(metaDataName, bytesData) {
          try {
            const filePath = path.join(this.dir, `${metaDataName}.json`);
            log("WRITE %s", filePath);
            fs.writeFileSync(filePath, bytesData.toString("utf8"));
          } catch (error) {
            throw new error_1.PersistError(
              `Failed to persist metadata ${metaDataName} error: ${error}`,
            );
          }
        }
      }
      exports.Updater = Updater;
    },
    6400: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.withTempFile = void 0;
      const promises_1 = __importDefault(__nccwpck_require__(3292));
      const os_1 = __importDefault(__nccwpck_require__(2037));
      const path_1 = __importDefault(__nccwpck_require__(1017));
      const withTempFile = async (handler) =>
        withTempDir(async (dir) =>
          handler(path_1.default.join(dir, "tempfile")),
        );
      exports.withTempFile = withTempFile;
      const withTempDir = async (handler) => {
        const tmpDir = await promises_1.default.realpath(os_1.default.tmpdir());
        const dir = await promises_1.default.mkdtemp(
          tmpDir + path_1.default.sep,
        );
        try {
          return await handler(dir);
        } finally {
          await promises_1.default.rm(dir, {
            force: true,
            recursive: true,
            maxRetries: 3,
          });
        }
      };
    },
    5961: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.join = void 0;
      const url_1 = __nccwpck_require__(7310);
      function join(base, path) {
        return new url_1.URL(
          ensureTrailingSlash(base) + removeLeadingSlash(path),
        ).toString();
      }
      exports.join = join;
      function ensureTrailingSlash(path) {
        return path.endsWith("/") ? path : path + "/";
      }
      function removeLeadingSlash(path) {
        return path.startsWith("/") ? path.slice(1) : path;
      }
    },
    2524: (module, __unused_webpack_exports, __nccwpck_require__) => {
      var parse = __nccwpck_require__(1620);
      var correct = __nccwpck_require__(2372);
      var genericWarning =
        "license should be " +
        'a valid SPDX license expression (without "LicenseRef"), ' +
        '"UNLICENSED", or ' +
        '"SEE LICENSE IN <filename>"';
      var fileReferenceRE = /^SEE LICEN[CS]E IN (.+)$/;
      function startsWith(prefix, string) {
        return string.slice(0, prefix.length) === prefix;
      }
      function usesLicenseRef(ast) {
        if (ast.hasOwnProperty("license")) {
          var license = ast.license;
          return (
            startsWith("LicenseRef", license) ||
            startsWith("DocumentRef", license)
          );
        } else {
          return usesLicenseRef(ast.left) || usesLicenseRef(ast.right);
        }
      }
      module.exports = function (argument) {
        var ast;
        try {
          ast = parse(argument);
        } catch (e) {
          var match;
          if (argument === "UNLICENSED" || argument === "UNLICENCED") {
            return {
              validForOldPackages: true,
              validForNewPackages: true,
              unlicensed: true,
            };
          } else if ((match = fileReferenceRE.exec(argument))) {
            return {
              validForOldPackages: true,
              validForNewPackages: true,
              inFile: match[1],
            };
          } else {
            var result = {
              validForOldPackages: false,
              validForNewPackages: false,
              warnings: [genericWarning],
            };
            if (argument.trim().length !== 0) {
              var corrected = correct(argument);
              if (corrected) {
                result.warnings.push(
                  'license is similar to the valid expression "' +
                    corrected +
                    '"',
                );
              }
            }
            return result;
          }
        }
        if (usesLicenseRef(ast)) {
          return {
            validForNewPackages: false,
            validForOldPackages: false,
            spdx: true,
            warnings: [genericWarning],
          };
        } else {
          return {
            validForNewPackages: true,
            validForOldPackages: true,
            spdx: true,
          };
        }
      };
    },
    4006: (module, __unused_webpack_exports, __nccwpck_require__) => {
      "use strict";
      const { builtinModules: builtins } = __nccwpck_require__(8188);
      var scopedPackagePattern = new RegExp("^(?:@([^/]+?)[/])?([^/]+?)$");
      var blacklist = ["node_modules", "favicon.ico"];
      function validate(name) {
        var warnings = [];
        var errors = [];
        if (name === null) {
          errors.push("name cannot be null");
          return done(warnings, errors);
        }
        if (name === undefined) {
          errors.push("name cannot be undefined");
          return done(warnings, errors);
        }
        if (typeof name !== "string") {
          errors.push("name must be a string");
          return done(warnings, errors);
        }
        if (!name.length) {
          errors.push("name length must be greater than zero");
        }
        if (name.match(/^\./)) {
          errors.push("name cannot start with a period");
        }
        if (name.match(/^_/)) {
          errors.push("name cannot start with an underscore");
        }
        if (name.trim() !== name) {
          errors.push("name cannot contain leading or trailing spaces");
        }
        blacklist.forEach(function (blacklistedName) {
          if (name.toLowerCase() === blacklistedName) {
            errors.push(blacklistedName + " is a blacklisted name");
          }
        });
        if (builtins.includes(name.toLowerCase())) {
          warnings.push(name + " is a core module name");
        }
        if (name.length > 214) {
          warnings.push("name can no longer contain more than 214 characters");
        }
        if (name.toLowerCase() !== name) {
          warnings.push("name can no longer contain capital letters");
        }
        if (/[~'!()*]/.test(name.split("/").slice(-1)[0])) {
          warnings.push(
            'name can no longer contain special characters ("~\'!()*")',
          );
        }
        if (encodeURIComponent(name) !== name) {
          var nameMatch = name.match(scopedPackagePattern);
          if (nameMatch) {
            var user = nameMatch[1];
            var pkg = nameMatch[2];
            if (
              encodeURIComponent(user) === user &&
              encodeURIComponent(pkg) === pkg
            ) {
              return done(warnings, errors);
            }
          }
          errors.push("name can only contain URL-friendly characters");
        }
        return done(warnings, errors);
      }
      var done = function (warnings, errors) {
        var result = {
          validForNewPackages: errors.length === 0 && warnings.length === 0,
          validForOldPackages: errors.length === 0,
          warnings,
          errors,
        };
        if (!result.warnings.length) {
          delete result.warnings;
        }
        if (!result.errors.length) {
          delete result.errors;
        }
        return result;
      };
      module.exports = validate;
    },
    132: (module) => {
      module.exports = eval("require")("supports-color");
    },
    7129: (module) => {
      "use strict";
      module.exports = require("../cacache/index.js");
    },
    4541: (module) => {
      "use strict";
      module.exports = require("../semver/index.js");
    },
    3684: (module) => {
      "use strict";
      module.exports = require("./package.json");
    },
    9491: (module) => {
      "use strict";
      module.exports = require("assert");
    },
    4300: (module) => {
      "use strict";
      module.exports = require("buffer");
    },
    6113: (module) => {
      "use strict";
      module.exports = require("crypto");
    },
    7578: (module) => {
      "use strict";
      module.exports = require("dns");
    },
    2361: (module) => {
      "use strict";
      module.exports = require("events");
    },
    7147: (module) => {
      "use strict";
      module.exports = require("fs");
    },
    3292: (module) => {
      "use strict";
      module.exports = require("fs/promises");
    },
    3685: (module) => {
      "use strict";
      module.exports = require("http");
    },
    5158: (module) => {
      "use strict";
      module.exports = require("http2");
    },
    5687: (module) => {
      "use strict";
      module.exports = require("https");
    },
    8188: (module) => {
      "use strict";
      module.exports = require("module");
    },
    1808: (module) => {
      "use strict";
      module.exports = require("net");
    },
    5673: (module) => {
      "use strict";
      module.exports = require("node:events");
    },
    3977: (module) => {
      "use strict";
      module.exports = require("node:fs/promises");
    },
    2033: (module) => {
      "use strict";
      module.exports = require("node:module");
    },
    4492: (module) => {
      "use strict";
      module.exports = require("node:stream");
    },
    6915: (module) => {
      "use strict";
      module.exports = require("node:string_decoder");
    },
    1041: (module) => {
      "use strict";
      module.exports = require("node:url");
    },
    2037: (module) => {
      "use strict";
      module.exports = require("os");
    },
    1017: (module) => {
      "use strict";
      module.exports = require("path");
    },
    3477: (module) => {
      "use strict";
      module.exports = require("querystring");
    },
    2781: (module) => {
      "use strict";
      module.exports = require("stream");
    },
    1576: (module) => {
      "use strict";
      module.exports = require("string_decoder");
    },
    8670: (module) => {
      "use strict";
      module.exports = require("timers/promises");
    },
    4404: (module) => {
      "use strict";
      module.exports = require("tls");
    },
    6224: (module) => {
      "use strict";
      module.exports = require("tty");
    },
    7310: (module) => {
      "use strict";
      module.exports = require("url");
    },
    3837: (module) => {
      "use strict";
      module.exports = require("util");
    },
    9796: (module) => {
      "use strict";
      module.exports = require("zlib");
    },
    3866: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.LRUCache = void 0;
      const perf =
        typeof performance === "object" &&
        performance &&
        typeof performance.now === "function"
          ? performance
          : Date;
      const warned = new Set();
      const PROCESS = typeof process === "object" && !!process ? process : {};
      const emitWarning = (msg, type, code, fn) => {
        typeof PROCESS.emitWarning === "function"
          ? PROCESS.emitWarning(msg, type, code, fn)
          : console.error(`[${code}] ${type}: ${msg}`);
      };
      let AC = globalThis.AbortController;
      let AS = globalThis.AbortSignal;
      if (typeof AC === "undefined") {
        AS = class AbortSignal {
          onabort;
          _onabort = [];
          reason;
          aborted = false;
          addEventListener(_, fn) {
            this._onabort.push(fn);
          }
        };
        AC = class AbortController {
          constructor() {
            warnACPolyfill();
          }
          signal = new AS();
          abort(reason) {
            if (this.signal.aborted) return;
            this.signal.reason = reason;
            this.signal.aborted = true;
            for (const fn of this.signal._onabort) {
              fn(reason);
            }
            this.signal.onabort?.(reason);
          }
        };
        let printACPolyfillWarning =
          PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING !== "1";
        const warnACPolyfill = () => {
          if (!printACPolyfillWarning) return;
          printACPolyfillWarning = false;
          emitWarning(
            "AbortController is not defined. If using lru-cache in " +
              "node 14, load an AbortController polyfill from the " +
              "`node-abort-controller` package. A minimal polyfill is " +
              "provided for use by LRUCache.fetch(), but it should not be " +
              "relied upon in other contexts (eg, passing it to other APIs that " +
              "use AbortController/AbortSignal might have undesirable effects). " +
              "You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.",
            "NO_ABORT_CONTROLLER",
            "ENOTSUP",
            warnACPolyfill,
          );
        };
      }
      const shouldWarn = (code) => !warned.has(code);
      const TYPE = Symbol("type");
      const isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
      const getUintArray = (max) =>
        !isPosInt(max)
          ? null
          : max <= Math.pow(2, 8)
            ? Uint8Array
            : max <= Math.pow(2, 16)
              ? Uint16Array
              : max <= Math.pow(2, 32)
                ? Uint32Array
                : max <= Number.MAX_SAFE_INTEGER
                  ? ZeroArray
                  : null;
      class ZeroArray extends Array {
        constructor(size) {
          super(size);
          this.fill(0);
        }
      }
      class Stack {
        heap;
        length;
        static #constructing = false;
        static create(max) {
          const HeapCls = getUintArray(max);
          if (!HeapCls) return [];
          Stack.#constructing = true;
          const s = new Stack(max, HeapCls);
          Stack.#constructing = false;
          return s;
        }
        constructor(max, HeapCls) {
          if (!Stack.#constructing) {
            throw new TypeError("instantiate Stack using Stack.create(n)");
          }
          this.heap = new HeapCls(max);
          this.length = 0;
        }
        push(n) {
          this.heap[this.length++] = n;
        }
        pop() {
          return this.heap[--this.length];
        }
      }
      class LRUCache {
        #max;
        #maxSize;
        #dispose;
        #disposeAfter;
        #fetchMethod;
        #memoMethod;
        ttl;
        ttlResolution;
        ttlAutopurge;
        updateAgeOnGet;
        updateAgeOnHas;
        allowStale;
        noDisposeOnSet;
        noUpdateTTL;
        maxEntrySize;
        sizeCalculation;
        noDeleteOnFetchRejection;
        noDeleteOnStaleGet;
        allowStaleOnFetchAbort;
        allowStaleOnFetchRejection;
        ignoreFetchAbort;
        #size;
        #calculatedSize;
        #keyMap;
        #keyList;
        #valList;
        #next;
        #prev;
        #head;
        #tail;
        #free;
        #disposed;
        #sizes;
        #starts;
        #ttls;
        #hasDispose;
        #hasFetchMethod;
        #hasDisposeAfter;
        static unsafeExposeInternals(c) {
          return {
            starts: c.#starts,
            ttls: c.#ttls,
            sizes: c.#sizes,
            keyMap: c.#keyMap,
            keyList: c.#keyList,
            valList: c.#valList,
            next: c.#next,
            prev: c.#prev,
            get head() {
              return c.#head;
            },
            get tail() {
              return c.#tail;
            },
            free: c.#free,
            isBackgroundFetch: (p) => c.#isBackgroundFetch(p),
            backgroundFetch: (k, index, options, context) =>
              c.#backgroundFetch(k, index, options, context),
            moveToTail: (index) => c.#moveToTail(index),
            indexes: (options) => c.#indexes(options),
            rindexes: (options) => c.#rindexes(options),
            isStale: (index) => c.#isStale(index),
          };
        }
        get max() {
          return this.#max;
        }
        get maxSize() {
          return this.#maxSize;
        }
        get calculatedSize() {
          return this.#calculatedSize;
        }
        get size() {
          return this.#size;
        }
        get fetchMethod() {
          return this.#fetchMethod;
        }
        get memoMethod() {
          return this.#memoMethod;
        }
        get dispose() {
          return this.#dispose;
        }
        get disposeAfter() {
          return this.#disposeAfter;
        }
        constructor(options) {
          const {
            max = 0,
            ttl,
            ttlResolution = 1,
            ttlAutopurge,
            updateAgeOnGet,
            updateAgeOnHas,
            allowStale,
            dispose,
            disposeAfter,
            noDisposeOnSet,
            noUpdateTTL,
            maxSize = 0,
            maxEntrySize = 0,
            sizeCalculation,
            fetchMethod,
            memoMethod,
            noDeleteOnFetchRejection,
            noDeleteOnStaleGet,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
          } = options;
          if (max !== 0 && !isPosInt(max)) {
            throw new TypeError("max option must be a nonnegative integer");
          }
          const UintArray = max ? getUintArray(max) : Array;
          if (!UintArray) {
            throw new Error("invalid max value: " + max);
          }
          this.#max = max;
          this.#maxSize = maxSize;
          this.maxEntrySize = maxEntrySize || this.#maxSize;
          this.sizeCalculation = sizeCalculation;
          if (this.sizeCalculation) {
            if (!this.#maxSize && !this.maxEntrySize) {
              throw new TypeError(
                "cannot set sizeCalculation without setting maxSize or maxEntrySize",
              );
            }
            if (typeof this.sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation set to non-function");
            }
          }
          if (memoMethod !== undefined && typeof memoMethod !== "function") {
            throw new TypeError("memoMethod must be a function if defined");
          }
          this.#memoMethod = memoMethod;
          if (fetchMethod !== undefined && typeof fetchMethod !== "function") {
            throw new TypeError("fetchMethod must be a function if specified");
          }
          this.#fetchMethod = fetchMethod;
          this.#hasFetchMethod = !!fetchMethod;
          this.#keyMap = new Map();
          this.#keyList = new Array(max).fill(undefined);
          this.#valList = new Array(max).fill(undefined);
          this.#next = new UintArray(max);
          this.#prev = new UintArray(max);
          this.#head = 0;
          this.#tail = 0;
          this.#free = Stack.create(max);
          this.#size = 0;
          this.#calculatedSize = 0;
          if (typeof dispose === "function") {
            this.#dispose = dispose;
          }
          if (typeof disposeAfter === "function") {
            this.#disposeAfter = disposeAfter;
            this.#disposed = [];
          } else {
            this.#disposeAfter = undefined;
            this.#disposed = undefined;
          }
          this.#hasDispose = !!this.#dispose;
          this.#hasDisposeAfter = !!this.#disposeAfter;
          this.noDisposeOnSet = !!noDisposeOnSet;
          this.noUpdateTTL = !!noUpdateTTL;
          this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
          this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
          this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
          this.ignoreFetchAbort = !!ignoreFetchAbort;
          if (this.maxEntrySize !== 0) {
            if (this.#maxSize !== 0) {
              if (!isPosInt(this.#maxSize)) {
                throw new TypeError(
                  "maxSize must be a positive integer if specified",
                );
              }
            }
            if (!isPosInt(this.maxEntrySize)) {
              throw new TypeError(
                "maxEntrySize must be a positive integer if specified",
              );
            }
            this.#initializeSizeTracking();
          }
          this.allowStale = !!allowStale;
          this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
          this.updateAgeOnGet = !!updateAgeOnGet;
          this.updateAgeOnHas = !!updateAgeOnHas;
          this.ttlResolution =
            isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
          this.ttlAutopurge = !!ttlAutopurge;
          this.ttl = ttl || 0;
          if (this.ttl) {
            if (!isPosInt(this.ttl)) {
              throw new TypeError(
                "ttl must be a positive integer if specified",
              );
            }
            this.#initializeTTLTracking();
          }
          if (this.#max === 0 && this.ttl === 0 && this.#maxSize === 0) {
            throw new TypeError(
              "At least one of max, maxSize, or ttl is required",
            );
          }
          if (!this.ttlAutopurge && !this.#max && !this.#maxSize) {
            const code = "LRU_CACHE_UNBOUNDED";
            if (shouldWarn(code)) {
              warned.add(code);
              const msg =
                "TTL caching without ttlAutopurge, max, or maxSize can " +
                "result in unbounded memory consumption.";
              emitWarning(msg, "UnboundedCacheWarning", code, LRUCache);
            }
          }
        }
        getRemainingTTL(key) {
          return this.#keyMap.has(key) ? Infinity : 0;
        }
        #initializeTTLTracking() {
          const ttls = new ZeroArray(this.#max);
          const starts = new ZeroArray(this.#max);
          this.#ttls = ttls;
          this.#starts = starts;
          this.#setItemTTL = (index, ttl, start = perf.now()) => {
            starts[index] = ttl !== 0 ? start : 0;
            ttls[index] = ttl;
            if (ttl !== 0 && this.ttlAutopurge) {
              const t = setTimeout(() => {
                if (this.#isStale(index)) {
                  this.#delete(this.#keyList[index], "expire");
                }
              }, ttl + 1);
              if (t.unref) {
                t.unref();
              }
            }
          };
          this.#updateItemAge = (index) => {
            starts[index] = ttls[index] !== 0 ? perf.now() : 0;
          };
          this.#statusTTL = (status, index) => {
            if (ttls[index]) {
              const ttl = ttls[index];
              const start = starts[index];
              if (!ttl || !start) return;
              status.ttl = ttl;
              status.start = start;
              status.now = cachedNow || getNow();
              const age = status.now - start;
              status.remainingTTL = ttl - age;
            }
          };
          let cachedNow = 0;
          const getNow = () => {
            const n = perf.now();
            if (this.ttlResolution > 0) {
              cachedNow = n;
              const t = setTimeout(() => (cachedNow = 0), this.ttlResolution);
              if (t.unref) {
                t.unref();
              }
            }
            return n;
          };
          this.getRemainingTTL = (key) => {
            const index = this.#keyMap.get(key);
            if (index === undefined) {
              return 0;
            }
            const ttl = ttls[index];
            const start = starts[index];
            if (!ttl || !start) {
              return Infinity;
            }
            const age = (cachedNow || getNow()) - start;
            return ttl - age;
          };
          this.#isStale = (index) => {
            const s = starts[index];
            const t = ttls[index];
            return !!t && !!s && (cachedNow || getNow()) - s > t;
          };
        }
        #updateItemAge = () => {};
        #statusTTL = () => {};
        #setItemTTL = () => {};
        #isStale = () => false;
        #initializeSizeTracking() {
          const sizes = new ZeroArray(this.#max);
          this.#calculatedSize = 0;
          this.#sizes = sizes;
          this.#removeItemSize = (index) => {
            this.#calculatedSize -= sizes[index];
            sizes[index] = 0;
          };
          this.#requireSize = (k, v, size, sizeCalculation) => {
            if (this.#isBackgroundFetch(v)) {
              return 0;
            }
            if (!isPosInt(size)) {
              if (sizeCalculation) {
                if (typeof sizeCalculation !== "function") {
                  throw new TypeError("sizeCalculation must be a function");
                }
                size = sizeCalculation(v, k);
                if (!isPosInt(size)) {
                  throw new TypeError(
                    "sizeCalculation return invalid (expect positive integer)",
                  );
                }
              } else {
                throw new TypeError(
                  "invalid size value (must be positive integer). " +
                    "When maxSize or maxEntrySize is used, sizeCalculation " +
                    "or size must be set.",
                );
              }
            }
            return size;
          };
          this.#addItemSize = (index, size, status) => {
            sizes[index] = size;
            if (this.#maxSize) {
              const maxSize = this.#maxSize - sizes[index];
              while (this.#calculatedSize > maxSize) {
                this.#evict(true);
              }
            }
            this.#calculatedSize += sizes[index];
            if (status) {
              status.entrySize = size;
              status.totalCalculatedSize = this.#calculatedSize;
            }
          };
        }
        #removeItemSize = (_i) => {};
        #addItemSize = (_i, _s, _st) => {};
        #requireSize = (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError(
              "cannot set size without setting maxSize or maxEntrySize on cache",
            );
          }
          return 0;
        };
        *#indexes({ allowStale = this.allowStale } = {}) {
          if (this.#size) {
            for (let i = this.#tail; true; ) {
              if (!this.#isValidIndex(i)) {
                break;
              }
              if (allowStale || !this.#isStale(i)) {
                yield i;
              }
              if (i === this.#head) {
                break;
              } else {
                i = this.#prev[i];
              }
            }
          }
        }
        *#rindexes({ allowStale = this.allowStale } = {}) {
          if (this.#size) {
            for (let i = this.#head; true; ) {
              if (!this.#isValidIndex(i)) {
                break;
              }
              if (allowStale || !this.#isStale(i)) {
                yield i;
              }
              if (i === this.#tail) {
                break;
              } else {
                i = this.#next[i];
              }
            }
          }
        }
        #isValidIndex(index) {
          return (
            index !== undefined &&
            this.#keyMap.get(this.#keyList[index]) === index
          );
        }
        *entries() {
          for (const i of this.#indexes()) {
            if (
              this.#valList[i] !== undefined &&
              this.#keyList[i] !== undefined &&
              !this.#isBackgroundFetch(this.#valList[i])
            ) {
              yield [this.#keyList[i], this.#valList[i]];
            }
          }
        }
        *rentries() {
          for (const i of this.#rindexes()) {
            if (
              this.#valList[i] !== undefined &&
              this.#keyList[i] !== undefined &&
              !this.#isBackgroundFetch(this.#valList[i])
            ) {
              yield [this.#keyList[i], this.#valList[i]];
            }
          }
        }
        *keys() {
          for (const i of this.#indexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield k;
            }
          }
        }
        *rkeys() {
          for (const i of this.#rindexes()) {
            const k = this.#keyList[i];
            if (k !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield k;
            }
          }
        }
        *values() {
          for (const i of this.#indexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield this.#valList[i];
            }
          }
        }
        *rvalues() {
          for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            if (v !== undefined && !this.#isBackgroundFetch(this.#valList[i])) {
              yield this.#valList[i];
            }
          }
        }
        [Symbol.iterator]() {
          return this.entries();
        }
        [Symbol.toStringTag] = "LRUCache";
        find(fn, getOptions = {}) {
          for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined) continue;
            if (fn(value, this.#keyList[i], this)) {
              return this.get(this.#keyList[i], getOptions);
            }
          }
        }
        forEach(fn, thisp = this) {
          for (const i of this.#indexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
          }
        }
        rforEach(fn, thisp = this) {
          for (const i of this.#rindexes()) {
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined) continue;
            fn.call(thisp, value, this.#keyList[i], this);
          }
        }
        purgeStale() {
          let deleted = false;
          for (const i of this.#rindexes({ allowStale: true })) {
            if (this.#isStale(i)) {
              this.#delete(this.#keyList[i], "expire");
              deleted = true;
            }
          }
          return deleted;
        }
        info(key) {
          const i = this.#keyMap.get(key);
          if (i === undefined) return undefined;
          const v = this.#valList[i];
          const value = this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
          if (value === undefined) return undefined;
          const entry = { value };
          if (this.#ttls && this.#starts) {
            const ttl = this.#ttls[i];
            const start = this.#starts[i];
            if (ttl && start) {
              const remain = ttl - (perf.now() - start);
              entry.ttl = remain;
              entry.start = Date.now();
            }
          }
          if (this.#sizes) {
            entry.size = this.#sizes[i];
          }
          return entry;
        }
        dump() {
          const arr = [];
          for (const i of this.#indexes({ allowStale: true })) {
            const key = this.#keyList[i];
            const v = this.#valList[i];
            const value = this.#isBackgroundFetch(v)
              ? v.__staleWhileFetching
              : v;
            if (value === undefined || key === undefined) continue;
            const entry = { value };
            if (this.#ttls && this.#starts) {
              entry.ttl = this.#ttls[i];
              const age = perf.now() - this.#starts[i];
              entry.start = Math.floor(Date.now() - age);
            }
            if (this.#sizes) {
              entry.size = this.#sizes[i];
            }
            arr.unshift([key, entry]);
          }
          return arr;
        }
        load(arr) {
          this.clear();
          for (const [key, entry] of arr) {
            if (entry.start) {
              const age = Date.now() - entry.start;
              entry.start = perf.now() - age;
            }
            this.set(key, entry.value, entry);
          }
        }
        set(k, v, setOptions = {}) {
          if (v === undefined) {
            this.delete(k);
            return this;
          }
          const {
            ttl = this.ttl,
            start,
            noDisposeOnSet = this.noDisposeOnSet,
            sizeCalculation = this.sizeCalculation,
            status,
          } = setOptions;
          let { noUpdateTTL = this.noUpdateTTL } = setOptions;
          const size = this.#requireSize(
            k,
            v,
            setOptions.size || 0,
            sizeCalculation,
          );
          if (this.maxEntrySize && size > this.maxEntrySize) {
            if (status) {
              status.set = "miss";
              status.maxEntrySizeExceeded = true;
            }
            this.#delete(k, "set");
            return this;
          }
          let index = this.#size === 0 ? undefined : this.#keyMap.get(k);
          if (index === undefined) {
            index =
              this.#size === 0
                ? this.#tail
                : this.#free.length !== 0
                  ? this.#free.pop()
                  : this.#size === this.#max
                    ? this.#evict(false)
                    : this.#size;
            this.#keyList[index] = k;
            this.#valList[index] = v;
            this.#keyMap.set(k, index);
            this.#next[this.#tail] = index;
            this.#prev[index] = this.#tail;
            this.#tail = index;
            this.#size++;
            this.#addItemSize(index, size, status);
            if (status) status.set = "add";
            noUpdateTTL = false;
          } else {
            this.#moveToTail(index);
            const oldVal = this.#valList[index];
            if (v !== oldVal) {
              if (this.#hasFetchMethod && this.#isBackgroundFetch(oldVal)) {
                oldVal.__abortController.abort(new Error("replaced"));
                const { __staleWhileFetching: s } = oldVal;
                if (s !== undefined && !noDisposeOnSet) {
                  if (this.#hasDispose) {
                    this.#dispose?.(s, k, "set");
                  }
                  if (this.#hasDisposeAfter) {
                    this.#disposed?.push([s, k, "set"]);
                  }
                }
              } else if (!noDisposeOnSet) {
                if (this.#hasDispose) {
                  this.#dispose?.(oldVal, k, "set");
                }
                if (this.#hasDisposeAfter) {
                  this.#disposed?.push([oldVal, k, "set"]);
                }
              }
              this.#removeItemSize(index);
              this.#addItemSize(index, size, status);
              this.#valList[index] = v;
              if (status) {
                status.set = "replace";
                const oldValue =
                  oldVal && this.#isBackgroundFetch(oldVal)
                    ? oldVal.__staleWhileFetching
                    : oldVal;
                if (oldValue !== undefined) status.oldValue = oldValue;
              }
            } else if (status) {
              status.set = "update";
            }
          }
          if (ttl !== 0 && !this.#ttls) {
            this.#initializeTTLTracking();
          }
          if (this.#ttls) {
            if (!noUpdateTTL) {
              this.#setItemTTL(index, ttl, start);
            }
            if (status) this.#statusTTL(status, index);
          }
          if (!noDisposeOnSet && this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
              this.#disposeAfter?.(...task);
            }
          }
          return this;
        }
        pop() {
          try {
            while (this.#size) {
              const val = this.#valList[this.#head];
              this.#evict(true);
              if (this.#isBackgroundFetch(val)) {
                if (val.__staleWhileFetching) {
                  return val.__staleWhileFetching;
                }
              } else if (val !== undefined) {
                return val;
              }
            }
          } finally {
            if (this.#hasDisposeAfter && this.#disposed) {
              const dt = this.#disposed;
              let task;
              while ((task = dt?.shift())) {
                this.#disposeAfter?.(...task);
              }
            }
          }
        }
        #evict(free) {
          const head = this.#head;
          const k = this.#keyList[head];
          const v = this.#valList[head];
          if (this.#hasFetchMethod && this.#isBackgroundFetch(v)) {
            v.__abortController.abort(new Error("evicted"));
          } else if (this.#hasDispose || this.#hasDisposeAfter) {
            if (this.#hasDispose) {
              this.#dispose?.(v, k, "evict");
            }
            if (this.#hasDisposeAfter) {
              this.#disposed?.push([v, k, "evict"]);
            }
          }
          this.#removeItemSize(head);
          if (free) {
            this.#keyList[head] = undefined;
            this.#valList[head] = undefined;
            this.#free.push(head);
          }
          if (this.#size === 1) {
            this.#head = this.#tail = 0;
            this.#free.length = 0;
          } else {
            this.#head = this.#next[head];
          }
          this.#keyMap.delete(k);
          this.#size--;
          return head;
        }
        has(k, hasOptions = {}) {
          const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
          const index = this.#keyMap.get(k);
          if (index !== undefined) {
            const v = this.#valList[index];
            if (
              this.#isBackgroundFetch(v) &&
              v.__staleWhileFetching === undefined
            ) {
              return false;
            }
            if (!this.#isStale(index)) {
              if (updateAgeOnHas) {
                this.#updateItemAge(index);
              }
              if (status) {
                status.has = "hit";
                this.#statusTTL(status, index);
              }
              return true;
            } else if (status) {
              status.has = "stale";
              this.#statusTTL(status, index);
            }
          } else if (status) {
            status.has = "miss";
          }
          return false;
        }
        peek(k, peekOptions = {}) {
          const { allowStale = this.allowStale } = peekOptions;
          const index = this.#keyMap.get(k);
          if (index === undefined || (!allowStale && this.#isStale(index))) {
            return;
          }
          const v = this.#valList[index];
          return this.#isBackgroundFetch(v) ? v.__staleWhileFetching : v;
        }
        #backgroundFetch(k, index, options, context) {
          const v = index === undefined ? undefined : this.#valList[index];
          if (this.#isBackgroundFetch(v)) {
            return v;
          }
          const ac = new AC();
          const { signal } = options;
          signal?.addEventListener("abort", () => ac.abort(signal.reason), {
            signal: ac.signal,
          });
          const fetchOpts = { signal: ac.signal, options, context };
          const cb = (v, updateCache = false) => {
            const { aborted } = ac.signal;
            const ignoreAbort = options.ignoreFetchAbort && v !== undefined;
            if (options.status) {
              if (aborted && !updateCache) {
                options.status.fetchAborted = true;
                options.status.fetchError = ac.signal.reason;
                if (ignoreAbort) options.status.fetchAbortIgnored = true;
              } else {
                options.status.fetchResolved = true;
              }
            }
            if (aborted && !ignoreAbort && !updateCache) {
              return fetchFail(ac.signal.reason);
            }
            const bf = p;
            if (this.#valList[index] === p) {
              if (v === undefined) {
                if (bf.__staleWhileFetching) {
                  this.#valList[index] = bf.__staleWhileFetching;
                } else {
                  this.#delete(k, "fetch");
                }
              } else {
                if (options.status) options.status.fetchUpdated = true;
                this.set(k, v, fetchOpts.options);
              }
            }
            return v;
          };
          const eb = (er) => {
            if (options.status) {
              options.status.fetchRejected = true;
              options.status.fetchError = er;
            }
            return fetchFail(er);
          };
          const fetchFail = (er) => {
            const { aborted } = ac.signal;
            const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
            const allowStale =
              allowStaleAborted || options.allowStaleOnFetchRejection;
            const noDelete = allowStale || options.noDeleteOnFetchRejection;
            const bf = p;
            if (this.#valList[index] === p) {
              const del = !noDelete || bf.__staleWhileFetching === undefined;
              if (del) {
                this.#delete(k, "fetch");
              } else if (!allowStaleAborted) {
                this.#valList[index] = bf.__staleWhileFetching;
              }
            }
            if (allowStale) {
              if (options.status && bf.__staleWhileFetching !== undefined) {
                options.status.returnedStale = true;
              }
              return bf.__staleWhileFetching;
            } else if (bf.__returned === bf) {
              throw er;
            }
          };
          const pcall = (res, rej) => {
            const fmp = this.#fetchMethod?.(k, v, fetchOpts);
            if (fmp && fmp instanceof Promise) {
              fmp.then((v) => res(v === undefined ? undefined : v), rej);
            }
            ac.signal.addEventListener("abort", () => {
              if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
                res(undefined);
                if (options.allowStaleOnFetchAbort) {
                  res = (v) => cb(v, true);
                }
              }
            });
          };
          if (options.status) options.status.fetchDispatched = true;
          const p = new Promise(pcall).then(cb, eb);
          const bf = Object.assign(p, {
            __abortController: ac,
            __staleWhileFetching: v,
            __returned: undefined,
          });
          if (index === undefined) {
            this.set(k, bf, { ...fetchOpts.options, status: undefined });
            index = this.#keyMap.get(k);
          } else {
            this.#valList[index] = bf;
          }
          return bf;
        }
        #isBackgroundFetch(p) {
          if (!this.#hasFetchMethod) return false;
          const b = p;
          return (
            !!b &&
            b instanceof Promise &&
            b.hasOwnProperty("__staleWhileFetching") &&
            b.__abortController instanceof AC
          );
        }
        async fetch(k, fetchOptions = {}) {
          const {
            allowStale = this.allowStale,
            updateAgeOnGet = this.updateAgeOnGet,
            noDeleteOnStaleGet = this.noDeleteOnStaleGet,
            ttl = this.ttl,
            noDisposeOnSet = this.noDisposeOnSet,
            size = 0,
            sizeCalculation = this.sizeCalculation,
            noUpdateTTL = this.noUpdateTTL,
            noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
            allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
            ignoreFetchAbort = this.ignoreFetchAbort,
            allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
            context,
            forceRefresh = false,
            status,
            signal,
          } = fetchOptions;
          if (!this.#hasFetchMethod) {
            if (status) status.fetch = "get";
            return this.get(k, {
              allowStale,
              updateAgeOnGet,
              noDeleteOnStaleGet,
              status,
            });
          }
          const options = {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            ttl,
            noDisposeOnSet,
            size,
            sizeCalculation,
            noUpdateTTL,
            noDeleteOnFetchRejection,
            allowStaleOnFetchRejection,
            allowStaleOnFetchAbort,
            ignoreFetchAbort,
            status,
            signal,
          };
          let index = this.#keyMap.get(k);
          if (index === undefined) {
            if (status) status.fetch = "miss";
            const p = this.#backgroundFetch(k, index, options, context);
            return (p.__returned = p);
          } else {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              const stale = allowStale && v.__staleWhileFetching !== undefined;
              if (status) {
                status.fetch = "inflight";
                if (stale) status.returnedStale = true;
              }
              return stale ? v.__staleWhileFetching : (v.__returned = v);
            }
            const isStale = this.#isStale(index);
            if (!forceRefresh && !isStale) {
              if (status) status.fetch = "hit";
              this.#moveToTail(index);
              if (updateAgeOnGet) {
                this.#updateItemAge(index);
              }
              if (status) this.#statusTTL(status, index);
              return v;
            }
            const p = this.#backgroundFetch(k, index, options, context);
            const hasStale = p.__staleWhileFetching !== undefined;
            const staleVal = hasStale && allowStale;
            if (status) {
              status.fetch = isStale ? "stale" : "refresh";
              if (staleVal && isStale) status.returnedStale = true;
            }
            return staleVal ? p.__staleWhileFetching : (p.__returned = p);
          }
        }
        async forceFetch(k, fetchOptions = {}) {
          const v = await this.fetch(k, fetchOptions);
          if (v === undefined) throw new Error("fetch() returned undefined");
          return v;
        }
        memo(k, memoOptions = {}) {
          const memoMethod = this.#memoMethod;
          if (!memoMethod) {
            throw new Error("no memoMethod provided to constructor");
          }
          const { context, forceRefresh, ...options } = memoOptions;
          const v = this.get(k, options);
          if (!forceRefresh && v !== undefined) return v;
          const vv = memoMethod(k, v, { options, context });
          this.set(k, vv, options);
          return vv;
        }
        get(k, getOptions = {}) {
          const {
            allowStale = this.allowStale,
            updateAgeOnGet = this.updateAgeOnGet,
            noDeleteOnStaleGet = this.noDeleteOnStaleGet,
            status,
          } = getOptions;
          const index = this.#keyMap.get(k);
          if (index !== undefined) {
            const value = this.#valList[index];
            const fetching = this.#isBackgroundFetch(value);
            if (status) this.#statusTTL(status, index);
            if (this.#isStale(index)) {
              if (status) status.get = "stale";
              if (!fetching) {
                if (!noDeleteOnStaleGet) {
                  this.#delete(k, "expire");
                }
                if (status && allowStale) status.returnedStale = true;
                return allowStale ? value : undefined;
              } else {
                if (
                  status &&
                  allowStale &&
                  value.__staleWhileFetching !== undefined
                ) {
                  status.returnedStale = true;
                }
                return allowStale ? value.__staleWhileFetching : undefined;
              }
            } else {
              if (status) status.get = "hit";
              if (fetching) {
                return value.__staleWhileFetching;
              }
              this.#moveToTail(index);
              if (updateAgeOnGet) {
                this.#updateItemAge(index);
              }
              return value;
            }
          } else if (status) {
            status.get = "miss";
          }
        }
        #connect(p, n) {
          this.#prev[n] = p;
          this.#next[p] = n;
        }
        #moveToTail(index) {
          if (index !== this.#tail) {
            if (index === this.#head) {
              this.#head = this.#next[index];
            } else {
              this.#connect(this.#prev[index], this.#next[index]);
            }
            this.#connect(this.#tail, index);
            this.#tail = index;
          }
        }
        delete(k) {
          return this.#delete(k, "delete");
        }
        #delete(k, reason) {
          let deleted = false;
          if (this.#size !== 0) {
            const index = this.#keyMap.get(k);
            if (index !== undefined) {
              deleted = true;
              if (this.#size === 1) {
                this.#clear(reason);
              } else {
                this.#removeItemSize(index);
                const v = this.#valList[index];
                if (this.#isBackgroundFetch(v)) {
                  v.__abortController.abort(new Error("deleted"));
                } else if (this.#hasDispose || this.#hasDisposeAfter) {
                  if (this.#hasDispose) {
                    this.#dispose?.(v, k, reason);
                  }
                  if (this.#hasDisposeAfter) {
                    this.#disposed?.push([v, k, reason]);
                  }
                }
                this.#keyMap.delete(k);
                this.#keyList[index] = undefined;
                this.#valList[index] = undefined;
                if (index === this.#tail) {
                  this.#tail = this.#prev[index];
                } else if (index === this.#head) {
                  this.#head = this.#next[index];
                } else {
                  const pi = this.#prev[index];
                  this.#next[pi] = this.#next[index];
                  const ni = this.#next[index];
                  this.#prev[ni] = this.#prev[index];
                }
                this.#size--;
                this.#free.push(index);
              }
            }
          }
          if (this.#hasDisposeAfter && this.#disposed?.length) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
              this.#disposeAfter?.(...task);
            }
          }
          return deleted;
        }
        clear() {
          return this.#clear("delete");
        }
        #clear(reason) {
          for (const index of this.#rindexes({ allowStale: true })) {
            const v = this.#valList[index];
            if (this.#isBackgroundFetch(v)) {
              v.__abortController.abort(new Error("deleted"));
            } else {
              const k = this.#keyList[index];
              if (this.#hasDispose) {
                this.#dispose?.(v, k, reason);
              }
              if (this.#hasDisposeAfter) {
                this.#disposed?.push([v, k, reason]);
              }
            }
          }
          this.#keyMap.clear();
          this.#valList.fill(undefined);
          this.#keyList.fill(undefined);
          if (this.#ttls && this.#starts) {
            this.#ttls.fill(0);
            this.#starts.fill(0);
          }
          if (this.#sizes) {
            this.#sizes.fill(0);
          }
          this.#head = 0;
          this.#tail = 0;
          this.#free.length = 0;
          this.#calculatedSize = 0;
          this.#size = 0;
          if (this.#hasDisposeAfter && this.#disposed) {
            const dt = this.#disposed;
            let task;
            while ((task = dt?.shift())) {
              this.#disposeAfter?.(...task);
            }
          }
        }
      }
      exports.LRUCache = LRUCache;
    },
    4149: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.assertValidPattern = void 0;
      const MAX_PATTERN_LENGTH = 1024 * 64;
      const assertValidPattern = (pattern) => {
        if (typeof pattern !== "string") {
          throw new TypeError("invalid pattern");
        }
        if (pattern.length > MAX_PATTERN_LENGTH) {
          throw new TypeError("pattern is too long");
        }
      };
      exports.assertValidPattern = assertValidPattern;
    },
    5136: (__unused_webpack_module, exports, __nccwpck_require__) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.AST = void 0;
      const brace_expressions_js_1 = __nccwpck_require__(1812);
      const unescape_js_1 = __nccwpck_require__(5698);
      const types = new Set(["!", "?", "+", "*", "@"]);
      const isExtglobType = (c) => types.has(c);
      const startNoTraversal = "(?!(?:^|/)\\.\\.?(?:$|/))";
      const startNoDot = "(?!\\.)";
      const addPatternStart = new Set(["[", "."]);
      const justDots = new Set(["..", "."]);
      const reSpecials = new Set("().*{}+?[]^$\\!");
      const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      const qmark = "[^/]";
      const star = qmark + "*?";
      const starNoEmpty = qmark + "+?";
      class AST {
        type;
        #root;
        #hasMagic;
        #uflag = false;
        #parts = [];
        #parent;
        #parentIndex;
        #negs;
        #filledNegs = false;
        #options;
        #toString;
        #emptyExt = false;
        constructor(type, parent, options = {}) {
          this.type = type;
          if (type) this.#hasMagic = true;
          this.#parent = parent;
          this.#root = this.#parent ? this.#parent.#root : this;
          this.#options = this.#root === this ? options : this.#root.#options;
          this.#negs = this.#root === this ? [] : this.#root.#negs;
          if (type === "!" && !this.#root.#filledNegs) this.#negs.push(this);
          this.#parentIndex = this.#parent ? this.#parent.#parts.length : 0;
        }
        get hasMagic() {
          if (this.#hasMagic !== undefined) return this.#hasMagic;
          for (const p of this.#parts) {
            if (typeof p === "string") continue;
            if (p.type || p.hasMagic) return (this.#hasMagic = true);
          }
          return this.#hasMagic;
        }
        toString() {
          if (this.#toString !== undefined) return this.#toString;
          if (!this.type) {
            return (this.#toString = this.#parts
              .map((p) => String(p))
              .join(""));
          } else {
            return (this.#toString =
              this.type +
              "(" +
              this.#parts.map((p) => String(p)).join("|") +
              ")");
          }
        }
        #fillNegs() {
          if (this !== this.#root) throw new Error("should only call on root");
          if (this.#filledNegs) return this;
          this.toString();
          this.#filledNegs = true;
          let n;
          while ((n = this.#negs.pop())) {
            if (n.type !== "!") continue;
            let p = n;
            let pp = p.#parent;
            while (pp) {
              for (
                let i = p.#parentIndex + 1;
                !pp.type && i < pp.#parts.length;
                i++
              ) {
                for (const part of n.#parts) {
                  if (typeof part === "string") {
                    throw new Error("string part in extglob AST??");
                  }
                  part.copyIn(pp.#parts[i]);
                }
              }
              p = pp;
              pp = p.#parent;
            }
          }
          return this;
        }
        push(...parts) {
          for (const p of parts) {
            if (p === "") continue;
            if (
              typeof p !== "string" &&
              !(p instanceof AST && p.#parent === this)
            ) {
              throw new Error("invalid part: " + p);
            }
            this.#parts.push(p);
          }
        }
        toJSON() {
          const ret =
            this.type === null
              ? this.#parts
                  .slice()
                  .map((p) => (typeof p === "string" ? p : p.toJSON()))
              : [this.type, ...this.#parts.map((p) => p.toJSON())];
          if (this.isStart() && !this.type) ret.unshift([]);
          if (
            this.isEnd() &&
            (this === this.#root ||
              (this.#root.#filledNegs && this.#parent?.type === "!"))
          ) {
            ret.push({});
          }
          return ret;
        }
        isStart() {
          if (this.#root === this) return true;
          if (!this.#parent?.isStart()) return false;
          if (this.#parentIndex === 0) return true;
          const p = this.#parent;
          for (let i = 0; i < this.#parentIndex; i++) {
            const pp = p.#parts[i];
            if (!(pp instanceof AST && pp.type === "!")) {
              return false;
            }
          }
          return true;
        }
        isEnd() {
          if (this.#root === this) return true;
          if (this.#parent?.type === "!") return true;
          if (!this.#parent?.isEnd()) return false;
          if (!this.type) return this.#parent?.isEnd();
          const pl = this.#parent ? this.#parent.#parts.length : 0;
          return this.#parentIndex === pl - 1;
        }
        copyIn(part) {
          if (typeof part === "string") this.push(part);
          else this.push(part.clone(this));
        }
        clone(parent) {
          const c = new AST(this.type, parent);
          for (const p of this.#parts) {
            c.copyIn(p);
          }
          return c;
        }
        static #parseAST(str, ast, pos, opt) {
          let escaping = false;
          let inBrace = false;
          let braceStart = -1;
          let braceNeg = false;
          if (ast.type === null) {
            let i = pos;
            let acc = "";
            while (i < str.length) {
              const c = str.charAt(i++);
              if (escaping || c === "\\") {
                escaping = !escaping;
                acc += c;
                continue;
              }
              if (inBrace) {
                if (i === braceStart + 1) {
                  if (c === "^" || c === "!") {
                    braceNeg = true;
                  }
                } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
                  inBrace = false;
                }
                acc += c;
                continue;
              } else if (c === "[") {
                inBrace = true;
                braceStart = i;
                braceNeg = false;
                acc += c;
                continue;
              }
              if (!opt.noext && isExtglobType(c) && str.charAt(i) === "(") {
                ast.push(acc);
                acc = "";
                const ext = new AST(c, ast);
                i = AST.#parseAST(str, ext, i, opt);
                ast.push(ext);
                continue;
              }
              acc += c;
            }
            ast.push(acc);
            return i;
          }
          let i = pos + 1;
          let part = new AST(null, ast);
          const parts = [];
          let acc = "";
          while (i < str.length) {
            const c = str.charAt(i++);
            if (escaping || c === "\\") {
              escaping = !escaping;
              acc += c;
              continue;
            }
            if (inBrace) {
              if (i === braceStart + 1) {
                if (c === "^" || c === "!") {
                  braceNeg = true;
                }
              } else if (c === "]" && !(i === braceStart + 2 && braceNeg)) {
                inBrace = false;
              }
              acc += c;
              continue;
            } else if (c === "[") {
              inBrace = true;
              braceStart = i;
              braceNeg = false;
              acc += c;
              continue;
            }
            if (isExtglobType(c) && str.charAt(i) === "(") {
              part.push(acc);
              acc = "";
              const ext = new AST(c, part);
              part.push(ext);
              i = AST.#parseAST(str, ext, i, opt);
              continue;
            }
            if (c === "|") {
              part.push(acc);
              acc = "";
              parts.push(part);
              part = new AST(null, ast);
              continue;
            }
            if (c === ")") {
              if (acc === "" && ast.#parts.length === 0) {
                ast.#emptyExt = true;
              }
              part.push(acc);
              acc = "";
              ast.push(...parts, part);
              return i;
            }
            acc += c;
          }
          ast.type = null;
          ast.#hasMagic = undefined;
          ast.#parts = [str.substring(pos - 1)];
          return i;
        }
        static fromGlob(pattern, options = {}) {
          const ast = new AST(null, undefined, options);
          AST.#parseAST(pattern, ast, 0, options);
          return ast;
        }
        toMMPattern() {
          if (this !== this.#root) return this.#root.toMMPattern();
          const glob = this.toString();
          const [re, body, hasMagic, uflag] = this.toRegExpSource();
          const anyMagic =
            hasMagic ||
            this.#hasMagic ||
            (this.#options.nocase &&
              !this.#options.nocaseMagicOnly &&
              glob.toUpperCase() !== glob.toLowerCase());
          if (!anyMagic) {
            return body;
          }
          const flags = (this.#options.nocase ? "i" : "") + (uflag ? "u" : "");
          return Object.assign(new RegExp(`^${re}$`, flags), {
            _src: re,
            _glob: glob,
          });
        }
        get options() {
          return this.#options;
        }
        toRegExpSource(allowDot) {
          const dot = allowDot ?? !!this.#options.dot;
          if (this.#root === this) this.#fillNegs();
          if (!this.type) {
            const noEmpty = this.isStart() && this.isEnd();
            const src = this.#parts
              .map((p) => {
                const [re, _, hasMagic, uflag] =
                  typeof p === "string"
                    ? AST.#parseGlob(p, this.#hasMagic, noEmpty)
                    : p.toRegExpSource(allowDot);
                this.#hasMagic = this.#hasMagic || hasMagic;
                this.#uflag = this.#uflag || uflag;
                return re;
              })
              .join("");
            let start = "";
            if (this.isStart()) {
              if (typeof this.#parts[0] === "string") {
                const dotTravAllowed =
                  this.#parts.length === 1 && justDots.has(this.#parts[0]);
                if (!dotTravAllowed) {
                  const aps = addPatternStart;
                  const needNoTrav =
                    (dot && aps.has(src.charAt(0))) ||
                    (src.startsWith("\\.") && aps.has(src.charAt(2))) ||
                    (src.startsWith("\\.\\.") && aps.has(src.charAt(4)));
                  const needNoDot = !dot && !allowDot && aps.has(src.charAt(0));
                  start = needNoTrav
                    ? startNoTraversal
                    : needNoDot
                      ? startNoDot
                      : "";
                }
              }
            }
            let end = "";
            if (
              this.isEnd() &&
              this.#root.#filledNegs &&
              this.#parent?.type === "!"
            ) {
              end = "(?:$|\\/)";
            }
            const final = start + src + end;
            return [
              final,
              (0, unescape_js_1.unescape)(src),
              (this.#hasMagic = !!this.#hasMagic),
              this.#uflag,
            ];
          }
          const repeated = this.type === "*" || this.type === "+";
          const start = this.type === "!" ? "(?:(?!(?:" : "(?:";
          let body = this.#partsToRegExp(dot);
          if (this.isStart() && this.isEnd() && !body && this.type !== "!") {
            const s = this.toString();
            this.#parts = [s];
            this.type = null;
            this.#hasMagic = undefined;
            return [
              s,
              (0, unescape_js_1.unescape)(this.toString()),
              false,
              false,
            ];
          }
          let bodyDotAllowed =
            !repeated || allowDot || dot || !startNoDot
              ? ""
              : this.#partsToRegExp(true);
          if (bodyDotAllowed === body) {
            bodyDotAllowed = "";
          }
          if (bodyDotAllowed) {
            body = `(?:${body})(?:${bodyDotAllowed})*?`;
          }
          let final = "";
          if (this.type === "!" && this.#emptyExt) {
            final = (this.isStart() && !dot ? startNoDot : "") + starNoEmpty;
          } else {
            const close =
              this.type === "!"
                ? "))" +
                  (this.isStart() && !dot && !allowDot ? startNoDot : "") +
                  star +
                  ")"
                : this.type === "@"
                  ? ")"
                  : this.type === "?"
                    ? ")?"
                    : this.type === "+" && bodyDotAllowed
                      ? ")"
                      : this.type === "*" && bodyDotAllowed
                        ? `)?`
                        : `)${this.type}`;
            final = start + body + close;
          }
          return [
            final,
            (0, unescape_js_1.unescape)(body),
            (this.#hasMagic = !!this.#hasMagic),
            this.#uflag,
          ];
        }
        #partsToRegExp(dot) {
          return this.#parts
            .map((p) => {
              if (typeof p === "string") {
                throw new Error("string type in extglob ast??");
              }
              const [re, _, _hasMagic, uflag] = p.toRegExpSource(dot);
              this.#uflag = this.#uflag || uflag;
              return re;
            })
            .filter((p) => !(this.isStart() && this.isEnd()) || !!p)
            .join("|");
        }
        static #parseGlob(glob, hasMagic, noEmpty = false) {
          let escaping = false;
          let re = "";
          let uflag = false;
          for (let i = 0; i < glob.length; i++) {
            const c = glob.charAt(i);
            if (escaping) {
              escaping = false;
              re += (reSpecials.has(c) ? "\\" : "") + c;
              continue;
            }
            if (c === "\\") {
              if (i === glob.length - 1) {
                re += "\\\\";
              } else {
                escaping = true;
              }
              continue;
            }
            if (c === "[") {
              const [src, needUflag, consumed, magic] = (0,
              brace_expressions_js_1.parseClass)(glob, i);
              if (consumed) {
                re += src;
                uflag = uflag || needUflag;
                i += consumed - 1;
                hasMagic = hasMagic || magic;
                continue;
              }
            }
            if (c === "*") {
              if (noEmpty && glob === "*") re += starNoEmpty;
              else re += star;
              hasMagic = true;
              continue;
            }
            if (c === "?") {
              re += qmark;
              hasMagic = true;
              continue;
            }
            re += regExpEscape(c);
          }
          return [re, (0, unescape_js_1.unescape)(glob), !!hasMagic, uflag];
        }
      }
      exports.AST = AST;
    },
    1812: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.parseClass = void 0;
      const posixClasses = {
        "[:alnum:]": ["\\p{L}\\p{Nl}\\p{Nd}", true],
        "[:alpha:]": ["\\p{L}\\p{Nl}", true],
        "[:ascii:]": ["\\x" + "00-\\x" + "7f", false],
        "[:blank:]": ["\\p{Zs}\\t", true],
        "[:cntrl:]": ["\\p{Cc}", true],
        "[:digit:]": ["\\p{Nd}", true],
        "[:graph:]": ["\\p{Z}\\p{C}", true, true],
        "[:lower:]": ["\\p{Ll}", true],
        "[:print:]": ["\\p{C}", true],
        "[:punct:]": ["\\p{P}", true],
        "[:space:]": ["\\p{Z}\\t\\r\\n\\v\\f", true],
        "[:upper:]": ["\\p{Lu}", true],
        "[:word:]": ["\\p{L}\\p{Nl}\\p{Nd}\\p{Pc}", true],
        "[:xdigit:]": ["A-Fa-f0-9", false],
      };
      const braceEscape = (s) => s.replace(/[[\]\\-]/g, "\\$&");
      const regexpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      const rangesToString = (ranges) => ranges.join("");
      const parseClass = (glob, position) => {
        const pos = position;
        if (glob.charAt(pos) !== "[") {
          throw new Error("not in a brace expression");
        }
        const ranges = [];
        const negs = [];
        let i = pos + 1;
        let sawStart = false;
        let uflag = false;
        let escaping = false;
        let negate = false;
        let endPos = pos;
        let rangeStart = "";
        WHILE: while (i < glob.length) {
          const c = glob.charAt(i);
          if ((c === "!" || c === "^") && i === pos + 1) {
            negate = true;
            i++;
            continue;
          }
          if (c === "]" && sawStart && !escaping) {
            endPos = i + 1;
            break;
          }
          sawStart = true;
          if (c === "\\") {
            if (!escaping) {
              escaping = true;
              i++;
              continue;
            }
          }
          if (c === "[" && !escaping) {
            for (const [cls, [unip, u, neg]] of Object.entries(posixClasses)) {
              if (glob.startsWith(cls, i)) {
                if (rangeStart) {
                  return ["$.", false, glob.length - pos, true];
                }
                i += cls.length;
                if (neg) negs.push(unip);
                else ranges.push(unip);
                uflag = uflag || u;
                continue WHILE;
              }
            }
          }
          escaping = false;
          if (rangeStart) {
            if (c > rangeStart) {
              ranges.push(braceEscape(rangeStart) + "-" + braceEscape(c));
            } else if (c === rangeStart) {
              ranges.push(braceEscape(c));
            }
            rangeStart = "";
            i++;
            continue;
          }
          if (glob.startsWith("-]", i + 1)) {
            ranges.push(braceEscape(c + "-"));
            i += 2;
            continue;
          }
          if (glob.startsWith("-", i + 1)) {
            rangeStart = c;
            i += 2;
            continue;
          }
          ranges.push(braceEscape(c));
          i++;
        }
        if (endPos < i) {
          return ["", false, 0, false];
        }
        if (!ranges.length && !negs.length) {
          return ["$.", false, glob.length - pos, true];
        }
        if (
          negs.length === 0 &&
          ranges.length === 1 &&
          /^\\?.$/.test(ranges[0]) &&
          !negate
        ) {
          const r = ranges[0].length === 2 ? ranges[0].slice(-1) : ranges[0];
          return [regexpEscape(r), false, endPos - pos, false];
        }
        const sranges =
          "[" + (negate ? "^" : "") + rangesToString(ranges) + "]";
        const snegs = "[" + (negate ? "" : "^") + rangesToString(negs) + "]";
        const comb =
          ranges.length && negs.length
            ? "(" + sranges + "|" + snegs + ")"
            : ranges.length
              ? sranges
              : snegs;
        return [comb, uflag, endPos - pos, true];
      };
      exports.parseClass = parseClass;
    },
    2804: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.escape = void 0;
      const escape = (s, { windowsPathsNoEscape = false } = {}) =>
        windowsPathsNoEscape
          ? s.replace(/[?*()[\]]/g, "[$&]")
          : s.replace(/[?*()[\]\\]/g, "\\$&");
      exports.escape = escape;
    },
    4501: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unescape =
        exports.escape =
        exports.AST =
        exports.Minimatch =
        exports.match =
        exports.makeRe =
        exports.braceExpand =
        exports.defaults =
        exports.filter =
        exports.GLOBSTAR =
        exports.sep =
        exports.minimatch =
          void 0;
      const brace_expansion_1 = __importDefault(__nccwpck_require__(8184));
      const assert_valid_pattern_js_1 = __nccwpck_require__(4149);
      const ast_js_1 = __nccwpck_require__(5136);
      const escape_js_1 = __nccwpck_require__(2804);
      const unescape_js_1 = __nccwpck_require__(5698);
      const minimatch = (p, pattern, options = {}) => {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        if (!options.nocomment && pattern.charAt(0) === "#") {
          return false;
        }
        return new Minimatch(pattern, options).match(p);
      };
      exports.minimatch = minimatch;
      const starDotExtRE = /^\*+([^+@!?\*\[\(]*)$/;
      const starDotExtTest = (ext) => (f) =>
        !f.startsWith(".") && f.endsWith(ext);
      const starDotExtTestDot = (ext) => (f) => f.endsWith(ext);
      const starDotExtTestNocase = (ext) => {
        ext = ext.toLowerCase();
        return (f) => !f.startsWith(".") && f.toLowerCase().endsWith(ext);
      };
      const starDotExtTestNocaseDot = (ext) => {
        ext = ext.toLowerCase();
        return (f) => f.toLowerCase().endsWith(ext);
      };
      const starDotStarRE = /^\*+\.\*+$/;
      const starDotStarTest = (f) => !f.startsWith(".") && f.includes(".");
      const starDotStarTestDot = (f) =>
        f !== "." && f !== ".." && f.includes(".");
      const dotStarRE = /^\.\*+$/;
      const dotStarTest = (f) => f !== "." && f !== ".." && f.startsWith(".");
      const starRE = /^\*+$/;
      const starTest = (f) => f.length !== 0 && !f.startsWith(".");
      const starTestDot = (f) => f.length !== 0 && f !== "." && f !== "..";
      const qmarksRE = /^\?+([^+@!?\*\[\(]*)?$/;
      const qmarksTestNocase = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExt([$0]);
        if (!ext) return noext;
        ext = ext.toLowerCase();
        return (f) => noext(f) && f.toLowerCase().endsWith(ext);
      };
      const qmarksTestNocaseDot = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExtDot([$0]);
        if (!ext) return noext;
        ext = ext.toLowerCase();
        return (f) => noext(f) && f.toLowerCase().endsWith(ext);
      };
      const qmarksTestDot = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExtDot([$0]);
        return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
      };
      const qmarksTest = ([$0, ext = ""]) => {
        const noext = qmarksTestNoExt([$0]);
        return !ext ? noext : (f) => noext(f) && f.endsWith(ext);
      };
      const qmarksTestNoExt = ([$0]) => {
        const len = $0.length;
        return (f) => f.length === len && !f.startsWith(".");
      };
      const qmarksTestNoExtDot = ([$0]) => {
        const len = $0.length;
        return (f) => f.length === len && f !== "." && f !== "..";
      };
      const defaultPlatform =
        typeof process === "object" && process
          ? (typeof process.env === "object" &&
              process.env &&
              process.env.__MINIMATCH_TESTING_PLATFORM__) ||
            process.platform
          : "posix";
      const path = { win32: { sep: "\\" }, posix: { sep: "/" } };
      exports.sep =
        defaultPlatform === "win32" ? path.win32.sep : path.posix.sep;
      exports.minimatch.sep = exports.sep;
      exports.GLOBSTAR = Symbol("globstar **");
      exports.minimatch.GLOBSTAR = exports.GLOBSTAR;
      const qmark = "[^/]";
      const star = qmark + "*?";
      const twoStarDot = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?";
      const twoStarNoDot = "(?:(?!(?:\\/|^)\\.).)*?";
      const filter =
        (pattern, options = {}) =>
        (p) =>
          (0, exports.minimatch)(p, pattern, options);
      exports.filter = filter;
      exports.minimatch.filter = exports.filter;
      const ext = (a, b = {}) => Object.assign({}, a, b);
      const defaults = (def) => {
        if (!def || typeof def !== "object" || !Object.keys(def).length) {
          return exports.minimatch;
        }
        const orig = exports.minimatch;
        const m = (p, pattern, options = {}) =>
          orig(p, pattern, ext(def, options));
        return Object.assign(m, {
          Minimatch: class Minimatch extends orig.Minimatch {
            constructor(pattern, options = {}) {
              super(pattern, ext(def, options));
            }
            static defaults(options) {
              return orig.defaults(ext(def, options)).Minimatch;
            }
          },
          AST: class AST extends orig.AST {
            constructor(type, parent, options = {}) {
              super(type, parent, ext(def, options));
            }
            static fromGlob(pattern, options = {}) {
              return orig.AST.fromGlob(pattern, ext(def, options));
            }
          },
          unescape: (s, options = {}) => orig.unescape(s, ext(def, options)),
          escape: (s, options = {}) => orig.escape(s, ext(def, options)),
          filter: (pattern, options = {}) =>
            orig.filter(pattern, ext(def, options)),
          defaults: (options) => orig.defaults(ext(def, options)),
          makeRe: (pattern, options = {}) =>
            orig.makeRe(pattern, ext(def, options)),
          braceExpand: (pattern, options = {}) =>
            orig.braceExpand(pattern, ext(def, options)),
          match: (list, pattern, options = {}) =>
            orig.match(list, pattern, ext(def, options)),
          sep: orig.sep,
          GLOBSTAR: exports.GLOBSTAR,
        });
      };
      exports.defaults = defaults;
      exports.minimatch.defaults = exports.defaults;
      const braceExpand = (pattern, options = {}) => {
        (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
        if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
          return [pattern];
        }
        return (0, brace_expansion_1.default)(pattern);
      };
      exports.braceExpand = braceExpand;
      exports.minimatch.braceExpand = exports.braceExpand;
      const makeRe = (pattern, options = {}) =>
        new Minimatch(pattern, options).makeRe();
      exports.makeRe = makeRe;
      exports.minimatch.makeRe = exports.makeRe;
      const match = (list, pattern, options = {}) => {
        const mm = new Minimatch(pattern, options);
        list = list.filter((f) => mm.match(f));
        if (mm.options.nonull && !list.length) {
          list.push(pattern);
        }
        return list;
      };
      exports.match = match;
      exports.minimatch.match = exports.match;
      const globMagic = /[?*]|[+@!]\(.*?\)|\[|\]/;
      const regExpEscape = (s) => s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
      class Minimatch {
        options;
        set;
        pattern;
        windowsPathsNoEscape;
        nonegate;
        negate;
        comment;
        empty;
        preserveMultipleSlashes;
        partial;
        globSet;
        globParts;
        nocase;
        isWindows;
        platform;
        windowsNoMagicRoot;
        regexp;
        constructor(pattern, options = {}) {
          (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
          options = options || {};
          this.options = options;
          this.pattern = pattern;
          this.platform = options.platform || defaultPlatform;
          this.isWindows = this.platform === "win32";
          this.windowsPathsNoEscape =
            !!options.windowsPathsNoEscape ||
            options.allowWindowsEscape === false;
          if (this.windowsPathsNoEscape) {
            this.pattern = this.pattern.replace(/\\/g, "/");
          }
          this.preserveMultipleSlashes = !!options.preserveMultipleSlashes;
          this.regexp = null;
          this.negate = false;
          this.nonegate = !!options.nonegate;
          this.comment = false;
          this.empty = false;
          this.partial = !!options.partial;
          this.nocase = !!this.options.nocase;
          this.windowsNoMagicRoot =
            options.windowsNoMagicRoot !== undefined
              ? options.windowsNoMagicRoot
              : !!(this.isWindows && this.nocase);
          this.globSet = [];
          this.globParts = [];
          this.set = [];
          this.make();
        }
        hasMagic() {
          if (this.options.magicalBraces && this.set.length > 1) {
            return true;
          }
          for (const pattern of this.set) {
            for (const part of pattern) {
              if (typeof part !== "string") return true;
            }
          }
          return false;
        }
        debug(..._) {}
        make() {
          const pattern = this.pattern;
          const options = this.options;
          if (!options.nocomment && pattern.charAt(0) === "#") {
            this.comment = true;
            return;
          }
          if (!pattern) {
            this.empty = true;
            return;
          }
          this.parseNegate();
          this.globSet = [...new Set(this.braceExpand())];
          if (options.debug) {
            this.debug = (...args) => console.error(...args);
          }
          this.debug(this.pattern, this.globSet);
          const rawGlobParts = this.globSet.map((s) => this.slashSplit(s));
          this.globParts = this.preprocess(rawGlobParts);
          this.debug(this.pattern, this.globParts);
          let set = this.globParts.map((s, _, __) => {
            if (this.isWindows && this.windowsNoMagicRoot) {
              const isUNC =
                s[0] === "" &&
                s[1] === "" &&
                (s[2] === "?" || !globMagic.test(s[2])) &&
                !globMagic.test(s[3]);
              const isDrive = /^[a-z]:/i.test(s[0]);
              if (isUNC) {
                return [
                  ...s.slice(0, 4),
                  ...s.slice(4).map((ss) => this.parse(ss)),
                ];
              } else if (isDrive) {
                return [s[0], ...s.slice(1).map((ss) => this.parse(ss))];
              }
            }
            return s.map((ss) => this.parse(ss));
          });
          this.debug(this.pattern, set);
          this.set = set.filter((s) => s.indexOf(false) === -1);
          if (this.isWindows) {
            for (let i = 0; i < this.set.length; i++) {
              const p = this.set[i];
              if (
                p[0] === "" &&
                p[1] === "" &&
                this.globParts[i][2] === "?" &&
                typeof p[3] === "string" &&
                /^[a-z]:$/i.test(p[3])
              ) {
                p[2] = "?";
              }
            }
          }
          this.debug(this.pattern, this.set);
        }
        preprocess(globParts) {
          if (this.options.noglobstar) {
            for (let i = 0; i < globParts.length; i++) {
              for (let j = 0; j < globParts[i].length; j++) {
                if (globParts[i][j] === "**") {
                  globParts[i][j] = "*";
                }
              }
            }
          }
          const { optimizationLevel = 1 } = this.options;
          if (optimizationLevel >= 2) {
            globParts = this.firstPhasePreProcess(globParts);
            globParts = this.secondPhasePreProcess(globParts);
          } else if (optimizationLevel >= 1) {
            globParts = this.levelOneOptimize(globParts);
          } else {
            globParts = this.adjascentGlobstarOptimize(globParts);
          }
          return globParts;
        }
        adjascentGlobstarOptimize(globParts) {
          return globParts.map((parts) => {
            let gs = -1;
            while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
              let i = gs;
              while (parts[i + 1] === "**") {
                i++;
              }
              if (i !== gs) {
                parts.splice(gs, i - gs);
              }
            }
            return parts;
          });
        }
        levelOneOptimize(globParts) {
          return globParts.map((parts) => {
            parts = parts.reduce((set, part) => {
              const prev = set[set.length - 1];
              if (part === "**" && prev === "**") {
                return set;
              }
              if (part === "..") {
                if (prev && prev !== ".." && prev !== "." && prev !== "**") {
                  set.pop();
                  return set;
                }
              }
              set.push(part);
              return set;
            }, []);
            return parts.length === 0 ? [""] : parts;
          });
        }
        levelTwoFileOptimize(parts) {
          if (!Array.isArray(parts)) {
            parts = this.slashSplit(parts);
          }
          let didSomething = false;
          do {
            didSomething = false;
            if (!this.preserveMultipleSlashes) {
              for (let i = 1; i < parts.length - 1; i++) {
                const p = parts[i];
                if (i === 1 && p === "" && parts[0] === "") continue;
                if (p === "." || p === "") {
                  didSomething = true;
                  parts.splice(i, 1);
                  i--;
                }
              }
              if (
                parts[0] === "." &&
                parts.length === 2 &&
                (parts[1] === "." || parts[1] === "")
              ) {
                didSomething = true;
                parts.pop();
              }
            }
            let dd = 0;
            while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
              const p = parts[dd - 1];
              if (p && p !== "." && p !== ".." && p !== "**") {
                didSomething = true;
                parts.splice(dd - 1, 2);
                dd -= 2;
              }
            }
          } while (didSomething);
          return parts.length === 0 ? [""] : parts;
        }
        firstPhasePreProcess(globParts) {
          let didSomething = false;
          do {
            didSomething = false;
            for (let parts of globParts) {
              let gs = -1;
              while (-1 !== (gs = parts.indexOf("**", gs + 1))) {
                let gss = gs;
                while (parts[gss + 1] === "**") {
                  gss++;
                }
                if (gss > gs) {
                  parts.splice(gs + 1, gss - gs);
                }
                let next = parts[gs + 1];
                const p = parts[gs + 2];
                const p2 = parts[gs + 3];
                if (next !== "..") continue;
                if (
                  !p ||
                  p === "." ||
                  p === ".." ||
                  !p2 ||
                  p2 === "." ||
                  p2 === ".."
                ) {
                  continue;
                }
                didSomething = true;
                parts.splice(gs, 1);
                const other = parts.slice(0);
                other[gs] = "**";
                globParts.push(other);
                gs--;
              }
              if (!this.preserveMultipleSlashes) {
                for (let i = 1; i < parts.length - 1; i++) {
                  const p = parts[i];
                  if (i === 1 && p === "" && parts[0] === "") continue;
                  if (p === "." || p === "") {
                    didSomething = true;
                    parts.splice(i, 1);
                    i--;
                  }
                }
                if (
                  parts[0] === "." &&
                  parts.length === 2 &&
                  (parts[1] === "." || parts[1] === "")
                ) {
                  didSomething = true;
                  parts.pop();
                }
              }
              let dd = 0;
              while (-1 !== (dd = parts.indexOf("..", dd + 1))) {
                const p = parts[dd - 1];
                if (p && p !== "." && p !== ".." && p !== "**") {
                  didSomething = true;
                  const needDot = dd === 1 && parts[dd + 1] === "**";
                  const splin = needDot ? ["."] : [];
                  parts.splice(dd - 1, 2, ...splin);
                  if (parts.length === 0) parts.push("");
                  dd -= 2;
                }
              }
            }
          } while (didSomething);
          return globParts;
        }
        secondPhasePreProcess(globParts) {
          for (let i = 0; i < globParts.length - 1; i++) {
            for (let j = i + 1; j < globParts.length; j++) {
              const matched = this.partsMatch(
                globParts[i],
                globParts[j],
                !this.preserveMultipleSlashes,
              );
              if (matched) {
                globParts[i] = [];
                globParts[j] = matched;
                break;
              }
            }
          }
          return globParts.filter((gs) => gs.length);
        }
        partsMatch(a, b, emptyGSMatch = false) {
          let ai = 0;
          let bi = 0;
          let result = [];
          let which = "";
          while (ai < a.length && bi < b.length) {
            if (a[ai] === b[bi]) {
              result.push(which === "b" ? b[bi] : a[ai]);
              ai++;
              bi++;
            } else if (emptyGSMatch && a[ai] === "**" && b[bi] === a[ai + 1]) {
              result.push(a[ai]);
              ai++;
            } else if (emptyGSMatch && b[bi] === "**" && a[ai] === b[bi + 1]) {
              result.push(b[bi]);
              bi++;
            } else if (
              a[ai] === "*" &&
              b[bi] &&
              (this.options.dot || !b[bi].startsWith(".")) &&
              b[bi] !== "**"
            ) {
              if (which === "b") return false;
              which = "a";
              result.push(a[ai]);
              ai++;
              bi++;
            } else if (
              b[bi] === "*" &&
              a[ai] &&
              (this.options.dot || !a[ai].startsWith(".")) &&
              a[ai] !== "**"
            ) {
              if (which === "a") return false;
              which = "b";
              result.push(b[bi]);
              ai++;
              bi++;
            } else {
              return false;
            }
          }
          return a.length === b.length && result;
        }
        parseNegate() {
          if (this.nonegate) return;
          const pattern = this.pattern;
          let negate = false;
          let negateOffset = 0;
          for (
            let i = 0;
            i < pattern.length && pattern.charAt(i) === "!";
            i++
          ) {
            negate = !negate;
            negateOffset++;
          }
          if (negateOffset) this.pattern = pattern.slice(negateOffset);
          this.negate = negate;
        }
        matchOne(file, pattern, partial = false) {
          const options = this.options;
          if (this.isWindows) {
            const fileDrive =
              typeof file[0] === "string" && /^[a-z]:$/i.test(file[0]);
            const fileUNC =
              !fileDrive &&
              file[0] === "" &&
              file[1] === "" &&
              file[2] === "?" &&
              /^[a-z]:$/i.test(file[3]);
            const patternDrive =
              typeof pattern[0] === "string" && /^[a-z]:$/i.test(pattern[0]);
            const patternUNC =
              !patternDrive &&
              pattern[0] === "" &&
              pattern[1] === "" &&
              pattern[2] === "?" &&
              typeof pattern[3] === "string" &&
              /^[a-z]:$/i.test(pattern[3]);
            const fdi = fileUNC ? 3 : fileDrive ? 0 : undefined;
            const pdi = patternUNC ? 3 : patternDrive ? 0 : undefined;
            if (typeof fdi === "number" && typeof pdi === "number") {
              const [fd, pd] = [file[fdi], pattern[pdi]];
              if (fd.toLowerCase() === pd.toLowerCase()) {
                pattern[pdi] = fd;
                if (pdi > fdi) {
                  pattern = pattern.slice(pdi);
                } else if (fdi > pdi) {
                  file = file.slice(fdi);
                }
              }
            }
          }
          const { optimizationLevel = 1 } = this.options;
          if (optimizationLevel >= 2) {
            file = this.levelTwoFileOptimize(file);
          }
          this.debug("matchOne", this, { file, pattern });
          this.debug("matchOne", file.length, pattern.length);
          for (
            var fi = 0, pi = 0, fl = file.length, pl = pattern.length;
            fi < fl && pi < pl;
            fi++, pi++
          ) {
            this.debug("matchOne loop");
            var p = pattern[pi];
            var f = file[fi];
            this.debug(pattern, p, f);
            if (p === false) {
              return false;
            }
            if (p === exports.GLOBSTAR) {
              this.debug("GLOBSTAR", [pattern, p, f]);
              var fr = fi;
              var pr = pi + 1;
              if (pr === pl) {
                this.debug("** at the end");
                for (; fi < fl; fi++) {
                  if (
                    file[fi] === "." ||
                    file[fi] === ".." ||
                    (!options.dot && file[fi].charAt(0) === ".")
                  )
                    return false;
                }
                return true;
              }
              while (fr < fl) {
                var swallowee = file[fr];
                this.debug(
                  "\nglobstar while",
                  file,
                  fr,
                  pattern,
                  pr,
                  swallowee,
                );
                if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
                  this.debug("globstar found match!", fr, fl, swallowee);
                  return true;
                } else {
                  if (
                    swallowee === "." ||
                    swallowee === ".." ||
                    (!options.dot && swallowee.charAt(0) === ".")
                  ) {
                    this.debug("dot detected!", file, fr, pattern, pr);
                    break;
                  }
                  this.debug("globstar swallow a segment, and continue");
                  fr++;
                }
              }
              if (partial) {
                this.debug("\n>>> no match, partial?", file, fr, pattern, pr);
                if (fr === fl) {
                  return true;
                }
              }
              return false;
            }
            let hit;
            if (typeof p === "string") {
              hit = f === p;
              this.debug("string match", p, f, hit);
            } else {
              hit = p.test(f);
              this.debug("pattern match", p, f, hit);
            }
            if (!hit) return false;
          }
          if (fi === fl && pi === pl) {
            return true;
          } else if (fi === fl) {
            return partial;
          } else if (pi === pl) {
            return fi === fl - 1 && file[fi] === "";
          } else {
            throw new Error("wtf?");
          }
        }
        braceExpand() {
          return (0, exports.braceExpand)(this.pattern, this.options);
        }
        parse(pattern) {
          (0, assert_valid_pattern_js_1.assertValidPattern)(pattern);
          const options = this.options;
          if (pattern === "**") return exports.GLOBSTAR;
          if (pattern === "") return "";
          let m;
          let fastTest = null;
          if ((m = pattern.match(starRE))) {
            fastTest = options.dot ? starTestDot : starTest;
          } else if ((m = pattern.match(starDotExtRE))) {
            fastTest = (
              options.nocase
                ? options.dot
                  ? starDotExtTestNocaseDot
                  : starDotExtTestNocase
                : options.dot
                  ? starDotExtTestDot
                  : starDotExtTest
            )(m[1]);
          } else if ((m = pattern.match(qmarksRE))) {
            fastTest = (
              options.nocase
                ? options.dot
                  ? qmarksTestNocaseDot
                  : qmarksTestNocase
                : options.dot
                  ? qmarksTestDot
                  : qmarksTest
            )(m);
          } else if ((m = pattern.match(starDotStarRE))) {
            fastTest = options.dot ? starDotStarTestDot : starDotStarTest;
          } else if ((m = pattern.match(dotStarRE))) {
            fastTest = dotStarTest;
          }
          const re = ast_js_1.AST.fromGlob(pattern, this.options).toMMPattern();
          if (fastTest && typeof re === "object") {
            Reflect.defineProperty(re, "test", { value: fastTest });
          }
          return re;
        }
        makeRe() {
          if (this.regexp || this.regexp === false) return this.regexp;
          const set = this.set;
          if (!set.length) {
            this.regexp = false;
            return this.regexp;
          }
          const options = this.options;
          const twoStar = options.noglobstar
            ? star
            : options.dot
              ? twoStarDot
              : twoStarNoDot;
          const flags = new Set(options.nocase ? ["i"] : []);
          let re = set
            .map((pattern) => {
              const pp = pattern.map((p) => {
                if (p instanceof RegExp) {
                  for (const f of p.flags.split("")) flags.add(f);
                }
                return typeof p === "string"
                  ? regExpEscape(p)
                  : p === exports.GLOBSTAR
                    ? exports.GLOBSTAR
                    : p._src;
              });
              pp.forEach((p, i) => {
                const next = pp[i + 1];
                const prev = pp[i - 1];
                if (p !== exports.GLOBSTAR || prev === exports.GLOBSTAR) {
                  return;
                }
                if (prev === undefined) {
                  if (next !== undefined && next !== exports.GLOBSTAR) {
                    pp[i + 1] = "(?:\\/|" + twoStar + "\\/)?" + next;
                  } else {
                    pp[i] = twoStar;
                  }
                } else if (next === undefined) {
                  pp[i - 1] = prev + "(?:\\/|" + twoStar + ")?";
                } else if (next !== exports.GLOBSTAR) {
                  pp[i - 1] = prev + "(?:\\/|\\/" + twoStar + "\\/)" + next;
                  pp[i + 1] = exports.GLOBSTAR;
                }
              });
              return pp.filter((p) => p !== exports.GLOBSTAR).join("/");
            })
            .join("|");
          const [open, close] = set.length > 1 ? ["(?:", ")"] : ["", ""];
          re = "^" + open + re + close + "$";
          if (this.negate) re = "^(?!" + re + ").+$";
          try {
            this.regexp = new RegExp(re, [...flags].join(""));
          } catch (ex) {
            this.regexp = false;
          }
          return this.regexp;
        }
        slashSplit(p) {
          if (this.preserveMultipleSlashes) {
            return p.split("/");
          } else if (this.isWindows && /^\/\/[^\/]+/.test(p)) {
            return ["", ...p.split(/\/+/)];
          } else {
            return p.split(/\/+/);
          }
        }
        match(f, partial = this.partial) {
          this.debug("match", f, this.pattern);
          if (this.comment) {
            return false;
          }
          if (this.empty) {
            return f === "";
          }
          if (f === "/" && partial) {
            return true;
          }
          const options = this.options;
          if (this.isWindows) {
            f = f.split("\\").join("/");
          }
          const ff = this.slashSplit(f);
          this.debug(this.pattern, "split", ff);
          const set = this.set;
          this.debug(this.pattern, "set", set);
          let filename = ff[ff.length - 1];
          if (!filename) {
            for (let i = ff.length - 2; !filename && i >= 0; i--) {
              filename = ff[i];
            }
          }
          for (let i = 0; i < set.length; i++) {
            const pattern = set[i];
            let file = ff;
            if (options.matchBase && pattern.length === 1) {
              file = [filename];
            }
            const hit = this.matchOne(file, pattern, partial);
            if (hit) {
              if (options.flipNegate) {
                return true;
              }
              return !this.negate;
            }
          }
          if (options.flipNegate) {
            return false;
          }
          return this.negate;
        }
        static defaults(def) {
          return exports.minimatch.defaults(def).Minimatch;
        }
      }
      exports.Minimatch = Minimatch;
      var ast_js_2 = __nccwpck_require__(5136);
      Object.defineProperty(exports, "AST", {
        enumerable: true,
        get: function () {
          return ast_js_2.AST;
        },
      });
      var escape_js_2 = __nccwpck_require__(2804);
      Object.defineProperty(exports, "escape", {
        enumerable: true,
        get: function () {
          return escape_js_2.escape;
        },
      });
      var unescape_js_2 = __nccwpck_require__(5698);
      Object.defineProperty(exports, "unescape", {
        enumerable: true,
        get: function () {
          return unescape_js_2.unescape;
        },
      });
      exports.minimatch.AST = ast_js_1.AST;
      exports.minimatch.Minimatch = Minimatch;
      exports.minimatch.escape = escape_js_1.escape;
      exports.minimatch.unescape = unescape_js_1.unescape;
    },
    5698: (__unused_webpack_module, exports) => {
      "use strict";
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.unescape = void 0;
      const unescape = (s, { windowsPathsNoEscape = false } = {}) =>
        windowsPathsNoEscape
          ? s.replace(/\[([^\/\\])\]/g, "$1")
          : s
              .replace(/((?!\\).|^)\[([^\/\\])\]/g, "$1$2")
              .replace(/\\([^\/])/g, "$1");
      exports.unescape = unescape;
    },
    4968: function (__unused_webpack_module, exports, __nccwpck_require__) {
      "use strict";
      var __importDefault =
        (this && this.__importDefault) ||
        function (mod) {
          return mod && mod.__esModule ? mod : { default: mod };
        };
      Object.defineProperty(exports, "__esModule", { value: true });
      exports.Minipass =
        exports.isWritable =
        exports.isReadable =
        exports.isStream =
          void 0;
      const proc =
        typeof process === "object" && process
          ? process
          : { stdout: null, stderr: null };
      const node_events_1 = __nccwpck_require__(5673);
      const node_stream_1 = __importDefault(__nccwpck_require__(4492));
      const node_string_decoder_1 = __nccwpck_require__(6915);
      const isStream = (s) =>
        !!s &&
        typeof s === "object" &&
        (s instanceof Minipass ||
          s instanceof node_stream_1.default ||
          (0, exports.isReadable)(s) ||
          (0, exports.isWritable)(s));
      exports.isStream = isStream;
      const isReadable = (s) =>
        !!s &&
        typeof s === "object" &&
        s instanceof node_events_1.EventEmitter &&
        typeof s.pipe === "function" &&
        s.pipe !== node_stream_1.default.Writable.prototype.pipe;
      exports.isReadable = isReadable;
      const isWritable = (s) =>
        !!s &&
        typeof s === "object" &&
        s instanceof node_events_1.EventEmitter &&
        typeof s.write === "function" &&
        typeof s.end === "function";
      exports.isWritable = isWritable;
      const EOF = Symbol("EOF");
      const MAYBE_EMIT_END = Symbol("maybeEmitEnd");
      const EMITTED_END = Symbol("emittedEnd");
      const EMITTING_END = Symbol("emittingEnd");
      const EMITTED_ERROR = Symbol("emittedError");
      const CLOSED = Symbol("closed");
      const READ = Symbol("read");
      const FLUSH = Symbol("flush");
      const FLUSHCHUNK = Symbol("flushChunk");
      const ENCODING = Symbol("encoding");
      const DECODER = Symbol("decoder");
      const FLOWING = Symbol("flowing");
      const PAUSED = Symbol("paused");
      const RESUME = Symbol("resume");
      const BUFFER = Symbol("buffer");
      const PIPES = Symbol("pipes");
      const BUFFERLENGTH = Symbol("bufferLength");
      const BUFFERPUSH = Symbol("bufferPush");
      const BUFFERSHIFT = Symbol("bufferShift");
      const OBJECTMODE = Symbol("objectMode");
      const DESTROYED = Symbol("destroyed");
      const ERROR = Symbol("error");
      const EMITDATA = Symbol("emitData");
      const EMITEND = Symbol("emitEnd");
      const EMITEND2 = Symbol("emitEnd2");
      const ASYNC = Symbol("async");
      const ABORT = Symbol("abort");
      const ABORTED = Symbol("aborted");
      const SIGNAL = Symbol("signal");
      const DATALISTENERS = Symbol("dataListeners");
      const DISCARDED = Symbol("discarded");
      const defer = (fn) => Promise.resolve().then(fn);
      const nodefer = (fn) => fn();
      const isEndish = (ev) =>
        ev === "end" || ev === "finish" || ev === "prefinish";
      const isArrayBufferLike = (b) =>
        b instanceof ArrayBuffer ||
        (!!b &&
          typeof b === "object" &&
          b.constructor &&
          b.constructor.name === "ArrayBuffer" &&
          b.byteLength >= 0);
      const isArrayBufferView = (b) =>
        !Buffer.isBuffer(b) && ArrayBuffer.isView(b);
      class Pipe {
        src;
        dest;
        opts;
        ondrain;
        constructor(src, dest, opts) {
          this.src = src;
          this.dest = dest;
          this.opts = opts;
          this.ondrain = () => src[RESUME]();
          this.dest.on("drain", this.ondrain);
        }
        unpipe() {
          this.dest.removeListener("drain", this.ondrain);
        }
        proxyErrors(_er) {}
        end() {
          this.unpipe();
          if (this.opts.end) this.dest.end();
        }
      }
      class PipeProxyErrors extends Pipe {
        unpipe() {
          this.src.removeListener("error", this.proxyErrors);
          super.unpipe();
        }
        constructor(src, dest, opts) {
          super(src, dest, opts);
          this.proxyErrors = (er) => dest.emit("error", er);
          src.on("error", this.proxyErrors);
        }
      }
      const isObjectModeOptions = (o) => !!o.objectMode;
      const isEncodingOptions = (o) =>
        !o.objectMode && !!o.encoding && o.encoding !== "buffer";
      class Minipass extends node_events_1.EventEmitter {
        [FLOWING] = false;
        [PAUSED] = false;
        [PIPES] = [];
        [BUFFER] = [];
        [OBJECTMODE];
        [ENCODING];
        [ASYNC];
        [DECODER];
        [EOF] = false;
        [EMITTED_END] = false;
        [EMITTING_END] = false;
        [CLOSED] = false;
        [EMITTED_ERROR] = null;
        [BUFFERLENGTH] = 0;
        [DESTROYED] = false;
        [SIGNAL];
        [ABORTED] = false;
        [DATALISTENERS] = 0;
        [DISCARDED] = false;
        writable = true;
        readable = true;
        constructor(...args) {
          const options = args[0] || {};
          super();
          if (options.objectMode && typeof options.encoding === "string") {
            throw new TypeError(
              "Encoding and objectMode may not be used together",
            );
          }
          if (isObjectModeOptions(options)) {
            this[OBJECTMODE] = true;
            this[ENCODING] = null;
          } else if (isEncodingOptions(options)) {
            this[ENCODING] = options.encoding;
            this[OBJECTMODE] = false;
          } else {
            this[OBJECTMODE] = false;
            this[ENCODING] = null;
          }
          this[ASYNC] = !!options.async;
          this[DECODER] = this[ENCODING]
            ? new node_string_decoder_1.StringDecoder(this[ENCODING])
            : null;
          if (options && options.debugExposeBuffer === true) {
            Object.defineProperty(this, "buffer", { get: () => this[BUFFER] });
          }
          if (options && options.debugExposePipes === true) {
            Object.defineProperty(this, "pipes", { get: () => this[PIPES] });
          }
          const { signal } = options;
          if (signal) {
            this[SIGNAL] = signal;
            if (signal.aborted) {
              this[ABORT]();
            } else {
              signal.addEventListener("abort", () => this[ABORT]());
            }
          }
        }
        get bufferLength() {
          return this[BUFFERLENGTH];
        }
        get encoding() {
          return this[ENCODING];
        }
        set encoding(_enc) {
          throw new Error("Encoding must be set at instantiation time");
        }
        setEncoding(_enc) {
          throw new Error("Encoding must be set at instantiation time");
        }
        get objectMode() {
          return this[OBJECTMODE];
        }
        set objectMode(_om) {
          throw new Error("objectMode must be set at instantiation time");
        }
        get ["async"]() {
          return this[ASYNC];
        }
        set ["async"](a) {
          this[ASYNC] = this[ASYNC] || !!a;
        }
        [ABORT]() {
          this[ABORTED] = true;
          this.emit("abort", this[SIGNAL]?.reason);
          this.destroy(this[SIGNAL]?.reason);
        }
        get aborted() {
          return this[ABORTED];
        }
        set aborted(_) {}
        write(chunk, encoding, cb) {
          if (this[ABORTED]) return false;
          if (this[EOF]) throw new Error("write after end");
          if (this[DESTROYED]) {
            this.emit(
              "error",
              Object.assign(
                new Error("Cannot call write after a stream was destroyed"),
                { code: "ERR_STREAM_DESTROYED" },
              ),
            );
            return true;
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = "utf8";
          }
          if (!encoding) encoding = "utf8";
          const fn = this[ASYNC] ? defer : nodefer;
          if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {
            if (isArrayBufferView(chunk)) {
              chunk = Buffer.from(
                chunk.buffer,
                chunk.byteOffset,
                chunk.byteLength,
              );
            } else if (isArrayBufferLike(chunk)) {
              chunk = Buffer.from(chunk);
            } else if (typeof chunk !== "string") {
              throw new Error(
                "Non-contiguous data written to non-objectMode stream",
              );
            }
          }
          if (this[OBJECTMODE]) {
            if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
            if (this[FLOWING]) this.emit("data", chunk);
            else this[BUFFERPUSH](chunk);
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this[FLOWING];
          }
          if (!chunk.length) {
            if (this[BUFFERLENGTH] !== 0) this.emit("readable");
            if (cb) fn(cb);
            return this[FLOWING];
          }
          if (
            typeof chunk === "string" &&
            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)
          ) {
            chunk = Buffer.from(chunk, encoding);
          }
          if (Buffer.isBuffer(chunk) && this[ENCODING]) {
            chunk = this[DECODER].write(chunk);
          }
          if (this[FLOWING] && this[BUFFERLENGTH] !== 0) this[FLUSH](true);
          if (this[FLOWING]) this.emit("data", chunk);
          else this[BUFFERPUSH](chunk);
          if (this[BUFFERLENGTH] !== 0) this.emit("readable");
          if (cb) fn(cb);
          return this[FLOWING];
        }
        read(n) {
          if (this[DESTROYED]) return null;
          this[DISCARDED] = false;
          if (
            this[BUFFERLENGTH] === 0 ||
            n === 0 ||
            (n && n > this[BUFFERLENGTH])
          ) {
            this[MAYBE_EMIT_END]();
            return null;
          }
          if (this[OBJECTMODE]) n = null;
          if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {
            this[BUFFER] = [
              this[ENCODING]
                ? this[BUFFER].join("")
                : Buffer.concat(this[BUFFER], this[BUFFERLENGTH]),
            ];
          }
          const ret = this[READ](n || null, this[BUFFER][0]);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [READ](n, chunk) {
          if (this[OBJECTMODE]) this[BUFFERSHIFT]();
          else {
            const c = chunk;
            if (n === c.length || n === null) this[BUFFERSHIFT]();
            else if (typeof c === "string") {
              this[BUFFER][0] = c.slice(n);
              chunk = c.slice(0, n);
              this[BUFFERLENGTH] -= n;
            } else {
              this[BUFFER][0] = c.subarray(n);
              chunk = c.subarray(0, n);
              this[BUFFERLENGTH] -= n;
            }
          }
          this.emit("data", chunk);
          if (!this[BUFFER].length && !this[EOF]) this.emit("drain");
          return chunk;
        }
        end(chunk, encoding, cb) {
          if (typeof chunk === "function") {
            cb = chunk;
            chunk = undefined;
          }
          if (typeof encoding === "function") {
            cb = encoding;
            encoding = "utf8";
          }
          if (chunk !== undefined) this.write(chunk, encoding);
          if (cb) this.once("end", cb);
          this[EOF] = true;
          this.writable = false;
          if (this[FLOWING] || !this[PAUSED]) this[MAYBE_EMIT_END]();
          return this;
        }
        [RESUME]() {
          if (this[DESTROYED]) return;
          if (!this[DATALISTENERS] && !this[PIPES].length) {
            this[DISCARDED] = true;
          }
          this[PAUSED] = false;
          this[FLOWING] = true;
          this.emit("resume");
          if (this[BUFFER].length) this[FLUSH]();
          else if (this[EOF]) this[MAYBE_EMIT_END]();
          else this.emit("drain");
        }
        resume() {
          return this[RESUME]();
        }
        pause() {
          this[FLOWING] = false;
          this[PAUSED] = true;
          this[DISCARDED] = false;
        }
        get destroyed() {
          return this[DESTROYED];
        }
        get flowing() {
          return this[FLOWING];
        }
        get paused() {
          return this[PAUSED];
        }
        [BUFFERPUSH](chunk) {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] += 1;
          else this[BUFFERLENGTH] += chunk.length;
          this[BUFFER].push(chunk);
        }
        [BUFFERSHIFT]() {
          if (this[OBJECTMODE]) this[BUFFERLENGTH] -= 1;
          else this[BUFFERLENGTH] -= this[BUFFER][0].length;
          return this[BUFFER].shift();
        }
        [FLUSH](noDrain = false) {
          do {} while (
            this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&
            this[BUFFER].length
          );
          if (!noDrain && !this[BUFFER].length && !this[EOF])
            this.emit("drain");
        }
        [FLUSHCHUNK](chunk) {
          this.emit("data", chunk);
          return this[FLOWING];
        }
        pipe(dest, opts) {
          if (this[DESTROYED]) return dest;
          this[DISCARDED] = false;
          const ended = this[EMITTED_END];
          opts = opts || {};
          if (dest === proc.stdout || dest === proc.stderr) opts.end = false;
          else opts.end = opts.end !== false;
          opts.proxyErrors = !!opts.proxyErrors;
          if (ended) {
            if (opts.end) dest.end();
          } else {
            this[PIPES].push(
              !opts.proxyErrors
                ? new Pipe(this, dest, opts)
                : new PipeProxyErrors(this, dest, opts),
            );
            if (this[ASYNC]) defer(() => this[RESUME]());
            else this[RESUME]();
          }
          return dest;
        }
        unpipe(dest) {
          const p = this[PIPES].find((p) => p.dest === dest);
          if (p) {
            if (this[PIPES].length === 1) {
              if (this[FLOWING] && this[DATALISTENERS] === 0) {
                this[FLOWING] = false;
              }
              this[PIPES] = [];
            } else this[PIPES].splice(this[PIPES].indexOf(p), 1);
            p.unpipe();
          }
        }
        addListener(ev, handler) {
          return this.on(ev, handler);
        }
        on(ev, handler) {
          const ret = super.on(ev, handler);
          if (ev === "data") {
            this[DISCARDED] = false;
            this[DATALISTENERS]++;
            if (!this[PIPES].length && !this[FLOWING]) {
              this[RESUME]();
            }
          } else if (ev === "readable" && this[BUFFERLENGTH] !== 0) {
            super.emit("readable");
          } else if (isEndish(ev) && this[EMITTED_END]) {
            super.emit(ev);
            this.removeAllListeners(ev);
          } else if (ev === "error" && this[EMITTED_ERROR]) {
            const h = handler;
            if (this[ASYNC]) defer(() => h.call(this, this[EMITTED_ERROR]));
            else h.call(this, this[EMITTED_ERROR]);
          }
          return ret;
        }
        removeListener(ev, handler) {
          return this.off(ev, handler);
        }
        off(ev, handler) {
          const ret = super.off(ev, handler);
          if (ev === "data") {
            this[DATALISTENERS] = this.listeners("data").length;
            if (
              this[DATALISTENERS] === 0 &&
              !this[DISCARDED] &&
              !this[PIPES].length
            ) {
              this[FLOWING] = false;
            }
          }
          return ret;
        }
        removeAllListeners(ev) {
          const ret = super.removeAllListeners(ev);
          if (ev === "data" || ev === undefined) {
            this[DATALISTENERS] = 0;
            if (!this[DISCARDED] && !this[PIPES].length) {
              this[FLOWING] = false;
            }
          }
          return ret;
        }
        get emittedEnd() {
          return this[EMITTED_END];
        }
        [MAYBE_EMIT_END]() {
          if (
            !this[EMITTING_END] &&
            !this[EMITTED_END] &&
            !this[DESTROYED] &&
            this[BUFFER].length === 0 &&
            this[EOF]
          ) {
            this[EMITTING_END] = true;
            this.emit("end");
            this.emit("prefinish");
            this.emit("finish");
            if (this[CLOSED]) this.emit("close");
            this[EMITTING_END] = false;
          }
        }
        emit(ev, ...args) {
          const data = args[0];
          if (
            ev !== "error" &&
            ev !== "close" &&
            ev !== DESTROYED &&
            this[DESTROYED]
          ) {
            return false;
          } else if (ev === "data") {
            return !this[OBJECTMODE] && !data
              ? false
              : this[ASYNC]
                ? (defer(() => this[EMITDATA](data)), true)
                : this[EMITDATA](data);
          } else if (ev === "end") {
            return this[EMITEND]();
          } else if (ev === "close") {
            this[CLOSED] = true;
            if (!this[EMITTED_END] && !this[DESTROYED]) return false;
            const ret = super.emit("close");
            this.removeAllListeners("close");
            return ret;
          } else if (ev === "error") {
            this[EMITTED_ERROR] = data;
            super.emit(ERROR, data);
            const ret =
              !this[SIGNAL] || this.listeners("error").length
                ? super.emit("error", data)
                : false;
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "resume") {
            const ret = super.emit("resume");
            this[MAYBE_EMIT_END]();
            return ret;
          } else if (ev === "finish" || ev === "prefinish") {
            const ret = super.emit(ev);
            this.removeAllListeners(ev);
            return ret;
          }
          const ret = super.emit(ev, ...args);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITDATA](data) {
          for (const p of this[PIPES]) {
            if (p.dest.write(data) === false) this.pause();
          }
          const ret = this[DISCARDED] ? false : super.emit("data", data);
          this[MAYBE_EMIT_END]();
          return ret;
        }
        [EMITEND]() {
          if (this[EMITTED_END]) return false;
          this[EMITTED_END] = true;
          this.readable = false;
          return this[ASYNC]
            ? (defer(() => this[EMITEND2]()), true)
            : this[EMITEND2]();
        }
        [EMITEND2]() {
          if (this[DECODER]) {
            const data = this[DECODER].end();
            if (data) {
              for (const p of this[PIPES]) {
                p.dest.write(data);
              }
              if (!this[DISCARDED]) super.emit("data", data);
            }
          }
          for (const p of this[PIPES]) {
            p.end();
          }
          const ret = super.emit("end");
          this.removeAllListeners("end");
          return ret;
        }
        async collect() {
          const buf = Object.assign([], { dataLength: 0 });
          if (!this[OBJECTMODE]) buf.dataLength = 0;
          const p = this.promise();
          this.on("data", (c) => {
            buf.push(c);
            if (!this[OBJECTMODE]) buf.dataLength += c.length;
          });
          await p;
          return buf;
        }
        async concat() {
          if (this[OBJECTMODE]) {
            throw new Error("cannot concat in objectMode");
          }
          const buf = await this.collect();
          return this[ENCODING]
            ? buf.join("")
            : Buffer.concat(buf, buf.dataLength);
        }
        async promise() {
          return new Promise((resolve, reject) => {
            this.on(DESTROYED, () => reject(new Error("stream destroyed")));
            this.on("error", (er) => reject(er));
            this.on("end", () => resolve());
          });
        }
        [Symbol.asyncIterator]() {
          this[DISCARDED] = false;
          let stopped = false;
          const stop = async () => {
            this.pause();
            stopped = true;
            return { value: undefined, done: true };
          };
          const next = () => {
            if (stopped) return stop();
            const res = this.read();
            if (res !== null)
              return Promise.resolve({ done: false, value: res });
            if (this[EOF]) return stop();
            let resolve;
            let reject;
            const onerr = (er) => {
              this.off("data", ondata);
              this.off("end", onend);
              this.off(DESTROYED, ondestroy);
              stop();
              reject(er);
            };
            const ondata = (value) => {
              this.off("error", onerr);
              this.off("end", onend);
              this.off(DESTROYED, ondestroy);
              this.pause();
              resolve({ value, done: !!this[EOF] });
            };
            const onend = () => {
              this.off("error", onerr);
              this.off("data", ondata);
              this.off(DESTROYED, ondestroy);
              stop();
              resolve({ done: true, value: undefined });
            };
            const ondestroy = () => onerr(new Error("stream destroyed"));
            return new Promise((res, rej) => {
              reject = rej;
              resolve = res;
              this.once(DESTROYED, ondestroy);
              this.once("error", onerr);
              this.once("end", onend);
              this.once("data", ondata);
            });
          };
          return {
            next,
            throw: stop,
            return: stop,
            [Symbol.asyncIterator]() {
              return this;
            },
          };
        }
        [Symbol.iterator]() {
          this[DISCARDED] = false;
          let stopped = false;
          const stop = () => {
            this.pause();
            this.off(ERROR, stop);
            this.off(DESTROYED, stop);
            this.off("end", stop);
            stopped = true;
            return { done: true, value: undefined };
          };
          const next = () => {
            if (stopped) return stop();
            const value = this.read();
            return value === null ? stop() : { done: false, value };
          };
          this.once("end", stop);
          this.once(ERROR, stop);
          this.once(DESTROYED, stop);
          return {
            next,
            throw: stop,
            return: stop,
            [Symbol.iterator]() {
              return this;
            },
          };
        }
        destroy(er) {
          if (this[DESTROYED]) {
            if (er) this.emit("error", er);
            else this.emit(DESTROYED);
            return this;
          }
          this[DESTROYED] = true;
          this[DISCARDED] = true;
          this[BUFFER].length = 0;
          this[BUFFERLENGTH] = 0;
          const wc = this;
          if (typeof wc.close === "function" && !this[CLOSED]) wc.close();
          if (er) this.emit("error", er);
          else this.emit(DESTROYED);
          return this;
        }
        static get isStream() {
          return exports.isStream;
        }
      }
      exports.Minipass = Minipass;
    },
    4998: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"https://tuf-repo-cdn.sigstore.dev":{"root.json":"ewoJInNpZ25lZCI6IHsKCQkiX3R5cGUiOiAicm9vdCIsCgkJInNwZWNfdmVyc2lvbiI6ICIxLjAiLAoJCSJ2ZXJzaW9uIjogOSwKCQkiZXhwaXJlcyI6ICIyMDI0LTA5LTEyVDA2OjUzOjEwWiIsCgkJImtleXMiOiB7CgkJCSIxZTFkNjVjZTk4YjEwYWRkYWQ0NzY0ZmViZjdkZGEyZDA0MzZiM2QzYTM4OTM1NzljMGRkZGFlYTIwZTU0ODQ5IjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXpCelZPbUhDUG9qTVZMU0kzNjRXaWlWOE5QckRcbjZJZ1J4Vmxpc2t6L3YreTNKRVI1bWNWR2NPTmxpRGNXTUM1SjJsZkhtalBOUGhiNEg3eG04THpmU0E9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSIyMzBlMjEyNjE2Mjc0YTQxOTVjZGMyOGU5ZmNlNzgyYzIwZTZjNzIwZjFhODExYjQwZjk4MjI4Mzc2YmRkM2FjIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRUxyV3ZOdDk0djRSMDg1RUxlZUNNeEhwN1BsZEZcbjAvVDFHeHVrVWgyT0R1Z2dMR0pFMHBjMWU4Q1NCZjZDUzkxRndvOUZVT3VSc2pCVWxkK1ZxU3lDZFE9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSIzYzM0NGFhMDY4ZmQ0Y2M0ZTg3ZGM1MGI2MTJjMDI0MzFmYmM3NzFlOTUwMDM5OTM2ODNhMmIwYmYyNjBjZjBlIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRXk4WEtzbWhCWURJOEpjMEd3ekJ4ZUtheDBjbTVcblNUS0VVNjVIUEZ1blVuNDFzVDhwaTBGak00SWtIei9ZVW13bUxVTzBXdDdseGhqNkJrTElLNHFZQXc9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSI5MjNiYjM5ZTYwZGQ2ZmEyYzMxZTZlYTU1NDczYWE5M2I2NGRkNGU1M2UxNmZiZTQyZjZhMjA3ZDNmOTdkZTJkIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRVdSaUdyNStqKzNKNVNzSCtadHI1bkUySDJ3TzdcbkJWK25PM3M5M2dMY2ExOHFUT3pIWTFvV3lBR0R5a01Tc0dUVUJTdDlEK0FuMEtmS3NEMm1mU000MlE9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSJlMmY1OWFjYjk0ODg1MTk0MDdlMThjYmZjOTMyOTUxMGJlMDNjMDRhY2E5OTI5ZDJmMDMwMTM0M2ZlYzg1NTIzIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRWluaWtTc0FRbVlrTmVINWVZcS9Dbkl6TGFhY09cbnhsU2Fhd1FET3dxS3kvdENxeHE1eHhQU0pjMjFLNFdJaHM5R3lPa0tmenVlWTNHSUx6Y01KWjRjV3c9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSJlYzgxNjY5NzM0ZTAxNzk5NmM1Yjg1ZjNkMDJjM2RlMWRkNDYzN2ExNTIwMTlmZTFhZjEyNWQyZjkzNjhiOTVlIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRUVYc3ozU1pYRmI4ak1WNDJqNnBKbHlqYmpSOEtcbk4zQndvY2V4cTZMTUliNXFzV0tPUXZMTjE2TlVlZkxjNEhzd09vdW1Sc1ZWYWFqU3BRUzZmb2JrUnc9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0sCgkJCSJmZGZhODNhMDdiNWE4MzU4OWI4N2RlZDQxZjc3ZjM5ZDIzMmFkOTFmN2NjZTUyODY4ZGFjZDA2YmEwODk4NDlmIjogewoJCQkJImtleXR5cGUiOiAiZWNkc2EiLAoJCQkJInNjaGVtZSI6ICJlY2RzYS1zaGEyLW5pc3RwMjU2IiwKCQkJCSJrZXlpZF9oYXNoX2FsZ29yaXRobXMiOiBbCgkJCQkJInNoYTI1NiIsCgkJCQkJInNoYTUxMiIKCQkJCV0sCgkJCQkia2V5dmFsIjogewoJCQkJCSJwdWJsaWMiOiAiLS0tLS1CRUdJTiBQVUJMSUMgS0VZLS0tLS1cbk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTBnaHJoOTJMdzFZcjNpZEdWNVdxQ3RNREI4Q3hcbitEOGhkQzR3MlpMTklwbFZSb1ZHTHNrWWEzZ2hlTXlPamlKOGtQaTE1YVEyLy83UCtvajdVdkpQR3c9PVxuLS0tLS1FTkQgUFVCTElDIEtFWS0tLS0tXG4iCgkJCQl9CgkJCX0KCQl9LAoJCSJyb2xlcyI6IHsKCQkJInJvb3QiOiB7CgkJCQkia2V5aWRzIjogWwoJCQkJCSIzYzM0NGFhMDY4ZmQ0Y2M0ZTg3ZGM1MGI2MTJjMDI0MzFmYmM3NzFlOTUwMDM5OTM2ODNhMmIwYmYyNjBjZjBlIiwKCQkJCQkiZWM4MTY2OTczNGUwMTc5OTZjNWI4NWYzZDAyYzNkZTFkZDQ2MzdhMTUyMDE5ZmUxYWYxMjVkMmY5MzY4Yjk1ZSIsCgkJCQkJIjFlMWQ2NWNlOThiMTBhZGRhZDQ3NjRmZWJmN2RkYTJkMDQzNmIzZDNhMzg5MzU3OWMwZGRkYWVhMjBlNTQ4NDkiLAoJCQkJCSJlMmY1OWFjYjk0ODg1MTk0MDdlMThjYmZjOTMyOTUxMGJlMDNjMDRhY2E5OTI5ZDJmMDMwMTM0M2ZlYzg1NTIzIiwKCQkJCQkiZmRmYTgzYTA3YjVhODM1ODliODdkZWQ0MWY3N2YzOWQyMzJhZDkxZjdjY2U1Mjg2OGRhY2QwNmJhMDg5ODQ5ZiIKCQkJCV0sCgkJCQkidGhyZXNob2xkIjogMwoJCQl9LAoJCQkic25hcHNob3QiOiB7CgkJCQkia2V5aWRzIjogWwoJCQkJCSIyMzBlMjEyNjE2Mjc0YTQxOTVjZGMyOGU5ZmNlNzgyYzIwZTZjNzIwZjFhODExYjQwZjk4MjI4Mzc2YmRkM2FjIgoJCQkJXSwKCQkJCSJ0aHJlc2hvbGQiOiAxCgkJCX0sCgkJCSJ0YXJnZXRzIjogewoJCQkJImtleWlkcyI6IFsKCQkJCQkiM2MzNDRhYTA2OGZkNGNjNGU4N2RjNTBiNjEyYzAyNDMxZmJjNzcxZTk1MDAzOTkzNjgzYTJiMGJmMjYwY2YwZSIsCgkJCQkJImVjODE2Njk3MzRlMDE3OTk2YzViODVmM2QwMmMzZGUxZGQ0NjM3YTE1MjAxOWZlMWFmMTI1ZDJmOTM2OGI5NWUiLAoJCQkJCSIxZTFkNjVjZTk4YjEwYWRkYWQ0NzY0ZmViZjdkZGEyZDA0MzZiM2QzYTM4OTM1NzljMGRkZGFlYTIwZTU0ODQ5IiwKCQkJCQkiZTJmNTlhY2I5NDg4NTE5NDA3ZTE4Y2JmYzkzMjk1MTBiZTAzYzA0YWNhOTkyOWQyZjAzMDEzNDNmZWM4NTUyMyIsCgkJCQkJImZkZmE4M2EwN2I1YTgzNTg5Yjg3ZGVkNDFmNzdmMzlkMjMyYWQ5MWY3Y2NlNTI4NjhkYWNkMDZiYTA4OTg0OWYiCgkJCQldLAoJCQkJInRocmVzaG9sZCI6IDMKCQkJfSwKCQkJInRpbWVzdGFtcCI6IHsKCQkJCSJrZXlpZHMiOiBbCgkJCQkJIjkyM2JiMzllNjBkZDZmYTJjMzFlNmVhNTU0NzNhYTkzYjY0ZGQ0ZTUzZTE2ZmJlNDJmNmEyMDdkM2Y5N2RlMmQiCgkJCQldLAoJCQkJInRocmVzaG9sZCI6IDEKCQkJfQoJCX0sCgkJImNvbnNpc3RlbnRfc25hcHNob3QiOiB0cnVlCgl9LAoJInNpZ25hdHVyZXMiOiBbCgkJewoJCQkia2V5aWQiOiAiZmY1MWUxN2ZjZjI1MzExOWI3MDMzZjZmNTc1MTI2MzFkYTRhMDk2OTQ0MmFmY2Y5ZmM4YjE0MWM3ZjJiZTk5YyIsCgkJCSJzaWciOiAiMzA0NTAyMjEwMDhiNzhmODk0YzNjZmVkM2JkNDg2Mzc5YzRlMGUwZGZiM2U3ZGQ4Y2JjNGQ1NTk4ZDI4MThlZWExYmEzYzc1NTAwMjIwMjlkM2QwNmU4OWQwNGQzNzg0OTk4NWRjNDZjMGUxMGRjNWIxZmM2OGRjNzBhZjFlYzk5MTAzMDNhMWYzZWUyZiIKCQl9LAoJCXsKCQkJImtleWlkIjogIjI1YTBlYjQ1MGZkM2VlMmJkNzkyMThjOTYzZGNlM2YxY2M2MTE4YmFkZjI1MWJmMTQ5ZjBiZDA3ZDVjYWJlOTkiLAoJCQkic2lnIjogIjMwNDUwMjIxMDA5ZTZiOTBiOTM1ZTA5YjgzN2E5MGQ0NDAyZWFhMjdkNWVhMjZlYjc4OTE5NDhiYTBlZDcwOTA4NDEyNDhmNDM2MDIyMDAzZGMyMjUxYzRkNGE3OTk5YjkxZTlhZDA4Njg3NjVhZTA5YWM3MjY5Mjc5ZjJhNzg5OWJhZmVmN2EyZDkyNjAiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICJmNTMxMmY1NDJjMjEyNzNkOTQ4NWE0OTM5NDM4NmM0NTc1ODA0NzcwNjY3ZjJkZGI1OWIzYmYwNjY5ZmRkZDJmIiwKCQkJInNpZyI6ICIzMDQ0MDIyMDA5OWU5MDdkY2Y5MGI3YjZlMTA5ZmQxZDZlNDQyMDA2ZmNjYmI0ODg5NGFhYWZmNDdhYjgyNGIwM2ZiMzVkMGQwMjIwMmFhMGEwNmMyMWE0MjMzZjM3OTAwYTQ4YmM4Nzc3ZDNiNDdmNTllM2EzODYxNmNlNjMxYTA0ZGY1N2Y5NjczNiIKCQl9LAoJCXsKCQkJImtleWlkIjogIjNjMzQ0YWEwNjhmZDRjYzRlODdkYzUwYjYxMmMwMjQzMWZiYzc3MWU5NTAwMzk5MzY4M2EyYjBiZjI2MGNmMGUiLAoJCQkic2lnIjogIjMwNDUwMjIxMDA4Yjc4Zjg5NGMzY2ZlZDNiZDQ4NjM3OWM0ZTBlMGRmYjNlN2RkOGNiYzRkNTU5OGQyODE4ZWVhMWJhM2M3NTUwMDIyMDI5ZDNkMDZlODlkMDRkMzc4NDk5ODVkYzQ2YzBlMTBkYzViMWZjNjhkYzcwYWYxZWM5OTEwMzAzYTFmM2VlMmYiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICJlYzgxNjY5NzM0ZTAxNzk5NmM1Yjg1ZjNkMDJjM2RlMWRkNDYzN2ExNTIwMTlmZTFhZjEyNWQyZjkzNjhiOTVlIiwKCQkJInNpZyI6ICIzMDQ1MDIyMTAwOWU2YjkwYjkzNWUwOWI4MzdhOTBkNDQwMmVhYTI3ZDVlYTI2ZWI3ODkxOTQ4YmEwZWQ3MDkwODQxMjQ4ZjQzNjAyMjAwM2RjMjI1MWM0ZDRhNzk5OWI5MWU5YWQwODY4NzY1YWUwOWFjNzI2OTI3OWYyYTc4OTliYWZlZjdhMmQ5MjYwIgoJCX0sCgkJewoJCQkia2V5aWQiOiAiZTJmNTlhY2I5NDg4NTE5NDA3ZTE4Y2JmYzkzMjk1MTBiZTAzYzA0YWNhOTkyOWQyZjAzMDEzNDNmZWM4NTUyMyIsCgkJCSJzaWciOiAiMzA0NTAyMjAwZTU2MTNiOTAxZTBmM2UwOGVjZWFiZGRjNzNmOThiNTBkZGY4OTJlOTk4ZDBiMzY5YzZlM2Q0NTFhYzQ4ODc1MDIyMTAwOTQwY2Y5MmQxZjQzZWUyZTVjZGJiMjI1NzJiYjUyOTI1ZWQzODYzYTY4OGY3ZmZkZDRiZDJlMmU1NmYwMjhiMyIKCQl9LAoJCXsKCQkJImtleWlkIjogIjJlNjFjZDBjYmY0YThmNDU4MDliZGE5ZjdmNzhjMGQzM2FkMTE4NDJmZjk0YWUzNDA4NzNlMjY2NGRjODQzZGUiLAoJCQkic2lnIjogIjMwNDUwMjIwMmNmZjQ0ZjIyMTVkN2E0N2IyOGI4ZjVmNTgwYzJjZmJiZDFiZmNmY2JiZTc4ZGUzMjMwNDViMmMwYmFkYzVlOTAyMjEwMGM3NDM5NDllYjNmNGVhNWE0YjlhZTI3YWM2ZWRkZWExZjBmZjliZmQwMDRmOGE5YTlkMThjNmU0MTQyYjZlNzUiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICIxZTFkNjVjZTk4YjEwYWRkYWQ0NzY0ZmViZjdkZGEyZDA0MzZiM2QzYTM4OTM1NzljMGRkZGFlYTIwZTU0ODQ5IiwKCQkJInNpZyI6ICIzMDQ0MDIyMDA5OWU5MDdkY2Y5MGI3YjZlMTA5ZmQxZDZlNDQyMDA2ZmNjYmI0ODg5NGFhYWZmNDdhYjgyNGIwM2ZiMzVkMGQwMjIwMmFhMGEwNmMyMWE0MjMzZjM3OTAwYTQ4YmM4Nzc3ZDNiNDdmNTllM2EzODYxNmNlNjMxYTA0ZGY1N2Y5NjczNiIKCQl9LAoJCXsKCQkJImtleWlkIjogImZkZmE4M2EwN2I1YTgzNTg5Yjg3ZGVkNDFmNzdmMzlkMjMyYWQ5MWY3Y2NlNTI4NjhkYWNkMDZiYTA4OTg0OWYiLAoJCQkic2lnIjogIjMwNDUwMjIwMmNmZjQ0ZjIyMTVkN2E0N2IyOGI4ZjVmNTgwYzJjZmJiZDFiZmNmY2JiZTc4ZGUzMjMwNDViMmMwYmFkYzVlOTAyMjEwMGM3NDM5NDllYjNmNGVhNWE0YjlhZTI3YWM2ZWRkZWExZjBmZjliZmQwMDRmOGE5YTlkMThjNmU0MTQyYjZlNzUiCgkJfSwKCQl7CgkJCSJrZXlpZCI6ICI3Zjc1MTNiMjU0MjlhNjQ0NzNlMTBjZTNhZDJmM2RhMzcyYmJkZDE0YjY1ZDA3YmJhZjU0N2U3YzhiYmJlNjJiIiwKCQkJInNpZyI6ICIzMDQ1MDIyMDBlNTYxM2I5MDFlMGYzZTA4ZWNlYWJkZGM3M2Y5OGI1MGRkZjg5MmU5OThkMGIzNjljNmUzZDQ1MWFjNDg4NzUwMjIxMDA5NDBjZjkyZDFmNDNlZTJlNWNkYmIyMjU3MmJiNTI5MjVlZDM4NjNhNjg4ZjdmZmRkNGJkMmUyZTU2ZjAyOGIzIgoJCX0KCV0KfQ==","targets":{"trusted_root.json":"ewogICJtZWRpYVR5cGUiOiAiYXBwbGljYXRpb24vdm5kLmRldi5zaWdzdG9yZS50cnVzdGVkcm9vdCtqc29uO3ZlcnNpb249MC4xIiwKICAidGxvZ3MiOiBbCiAgICB7CiAgICAgICJiYXNlVXJsIjogImh0dHBzOi8vcmVrb3Iuc2lnc3RvcmUuZGV2IiwKICAgICAgImhhc2hBbGdvcml0aG0iOiAiU0hBMl8yNTYiLAogICAgICAicHVibGljS2V5IjogewogICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUUyRzJZKzJ0YWJkVFY1QmNHaUJJeDBhOWZBRndya0JibUxTR3RrczRMM3FYNnlZWTB6dWZCbmhDOFVyL2l5NTVHaFdQLzlBL2JZMkxoQzMwTTkrUll0dz09IiwKICAgICAgICAia2V5RGV0YWlscyI6ICJQS0lYX0VDRFNBX1AyNTZfU0hBXzI1NiIsCiAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgInN0YXJ0IjogIjIwMjEtMDEtMTJUMTE6NTM6MjcuMDAwWiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJsb2dJZCI6IHsKICAgICAgICAia2V5SWQiOiAid05JOWF0UUdseitWV2ZPNkxSeWdINFFVZlkvOFc0UkZ3aVQ1aTVXUmdCMD0iCiAgICAgIH0KICAgIH0KICBdLAogICJjZXJ0aWZpY2F0ZUF1dGhvcml0aWVzIjogWwogICAgewogICAgICAic3ViamVjdCI6IHsKICAgICAgICAib3JnYW5pemF0aW9uIjogInNpZ3N0b3JlLmRldiIsCiAgICAgICAgImNvbW1vbk5hbWUiOiAic2lnc3RvcmUiCiAgICAgIH0sCiAgICAgICJ1cmkiOiAiaHR0cHM6Ly9mdWxjaW8uc2lnc3RvcmUuZGV2IiwKICAgICAgImNlcnRDaGFpbiI6IHsKICAgICAgICAiY2VydGlmaWNhdGVzIjogWwogICAgICAgICAgewogICAgICAgICAgICAicmF3Qnl0ZXMiOiAiTUlJQitEQ0NBWDZnQXdJQkFnSVROVmtEWm9DaW9mUERzeTdkZm02Z2VMYnVoekFLQmdncWhrak9QUVFEQXpBcU1SVXdFd1lEVlFRS0V3eHphV2R6ZEc5eVpTNWtaWFl4RVRBUEJnTlZCQU1UQ0hOcFozTjBiM0psTUI0WERUSXhNRE13TnpBek1qQXlPVm9YRFRNeE1ESXlNekF6TWpBeU9Wb3dLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQjJNQkFHQnlxR1NNNDlBZ0VHQlN1QkJBQWlBMklBQkxTeUE3SWk1aytwTk84WkVXWTB5bGVtV0Rvd09rTmEza0wrR1pFNVo1R1dlaEw5L0E5YlJOQTNSYnJzWjVpMEpjYXN0YVJMN1NwNWZwL2pENWR4cWMvVWRUVm5sdlMxNmFuKzJZZnN3ZS9RdUxvbFJVQ3JjT0UyKzJpQTUrdHpkNk5tTUdRd0RnWURWUjBQQVFIL0JBUURBZ0VHTUJJR0ExVWRFd0VCL3dRSU1BWUJBZjhDQVFFd0hRWURWUjBPQkJZRUZNakZIUUJCbWlRcE1sRWs2dzJ1U3UxS0J0UHNNQjhHQTFVZEl3UVlNQmFBRk1qRkhRQkJtaVFwTWxFazZ3MnVTdTFLQnRQc01Bb0dDQ3FHU000OUJBTURBMmdBTUdVQ01IOGxpV0pmTXVpNnZYWEJoakRnWTRNd3NsbU4vVEp4VmUvODNXckZvbXdtTmYwNTZ5MVg0OEY5YzRtM2Ezb3pYQUl4QUtqUmF5NS9hai9qc0tLR0lrbVFhdGpJOHV1cEhyLytDeEZ2YUpXbXBZcU5rTERHUlUrOW9yemg1aEkyUnJjdWFRPT0iCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAidmFsaWRGb3IiOiB7CiAgICAgICAgInN0YXJ0IjogIjIwMjEtMDMtMDdUMDM6MjA6MjkuMDAwWiIsCiAgICAgICAgImVuZCI6ICIyMDIyLTEyLTMxVDIzOjU5OjU5Ljk5OVoiCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJzdWJqZWN0IjogewogICAgICAgICJvcmdhbml6YXRpb24iOiAic2lnc3RvcmUuZGV2IiwKICAgICAgICAiY29tbW9uTmFtZSI6ICJzaWdzdG9yZSIKICAgICAgfSwKICAgICAgInVyaSI6ICJodHRwczovL2Z1bGNpby5zaWdzdG9yZS5kZXYiLAogICAgICAiY2VydENoYWluIjogewogICAgICAgICJjZXJ0aWZpY2F0ZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNSUlDR2pDQ0FhR2dBd0lCQWdJVUFMblZpVmZuVTBickphc21Sa0hybi9VbmZhUXdDZ1lJS29aSXpqMEVBd013S2pFVk1CTUdBMVVFQ2hNTWMybG5jM1J2Y21VdVpHVjJNUkV3RHdZRFZRUURFd2h6YVdkemRHOXlaVEFlRncweU1qQTBNVE15TURBMk1UVmFGdzB6TVRFd01EVXhNelUyTlRoYU1EY3hGVEFUQmdOVkJBb1RESE5wWjNOMGIzSmxMbVJsZGpFZU1Cd0dBMVVFQXhNVmMybG5jM1J2Y21VdGFXNTBaWEp0WldScFlYUmxNSFl3RUFZSEtvWkl6ajBDQVFZRks0RUVBQ0lEWWdBRThSVlMveXNIK05PdnVEWnlQSVp0aWxnVUY5TmxhcllwQWQ5SFAxdkJCSDFVNUNWNzdMU1M3czBaaUg0bkU3SHY3cHRTNkx2dlIvU1RrNzk4TFZnTXpMbEo0SGVJZkYzdEhTYWV4TGNZcFNBU3Ixa1MwTi9SZ0JKei85aldDaVhubzNzd2VUQU9CZ05WSFE4QkFmOEVCQU1DQVFZd0V3WURWUjBsQkF3d0NnWUlLd1lCQlFVSEF3TXdFZ1lEVlIwVEFRSC9CQWd3QmdFQi93SUJBREFkQmdOVkhRNEVGZ1FVMzlQcHoxWWtFWmI1cU5qcEtGV2l4aTRZWkQ4d0h3WURWUjBqQkJnd0ZvQVVXTUFlWDVGRnBXYXBlc3lRb1pNaTBDckZ4Zm93Q2dZSUtvWkl6ajBFQXdNRFp3QXdaQUl3UENzUUs0RFlpWllEUElhRGk1SEZLbmZ4WHg2QVNTVm1FUmZzeW5ZQmlYMlg2U0pSblpVODQvOURaZG5GdnZ4bUFqQk90NlFwQmxjNEovMER4dmtUQ3FwY2x2emlMNkJDQ1BuamRsSUIzUHUzQnhzUG15Z1VZN0lpMnpiZENkbGlpb3c9IgogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgInJhd0J5dGVzIjogIk1JSUI5ekNDQVh5Z0F3SUJBZ0lVQUxaTkFQRmR4SFB3amVEbG9Ed3lZQ2hBTy80d0NnWUlLb1pJemowRUF3TXdLakVWTUJNR0ExVUVDaE1NYzJsbmMzUnZjbVV1WkdWMk1SRXdEd1lEVlFRREV3aHphV2R6ZEc5eVpUQWVGdzB5TVRFd01EY3hNelUyTlRsYUZ3MHpNVEV3TURVeE16VTJOVGhhTUNveEZUQVRCZ05WQkFvVERITnBaM04wYjNKbExtUmxkakVSTUE4R0ExVUVBeE1JYzJsbmMzUnZjbVV3ZGpBUUJnY3Foa2pPUFFJQkJnVXJnUVFBSWdOaUFBVDdYZUZUNHJiM1BRR3dTNElhanRMazMvT2xucGdhbmdhQmNsWXBzWUJyNWkrNHluQjA3Y2ViM0xQME9JT1pkeGV4WDY5YzVpVnV5SlJRK0h6MDV5aStVRjN1QldBbEhwaVM1c2gwK0gyR0hFN1NYcmsxRUM1bTFUcjE5TDlnZzkyall6QmhNQTRHQTFVZER3RUIvd1FFQXdJQkJqQVBCZ05WSFJNQkFmOEVCVEFEQVFIL01CMEdBMVVkRGdRV0JCUll3QjVma1VXbFpxbDZ6SkNoa3lMUUtzWEYrakFmQmdOVkhTTUVHREFXZ0JSWXdCNWZrVVdsWnFsNnpKQ2hreUxRS3NYRitqQUtCZ2dxaGtqT1BRUURBd05wQURCbUFqRUFqMW5IZVhacCsxM05XQk5hK0VEc0RQOEcxV1dnMXRDTVdQL1dIUHFwYVZvMGpoc3dlTkZaZ1NzMGVFN3dZSTRxQWpFQTJXQjlvdDk4c0lrb0YzdlpZZGQzL1Z0V0I1YjlUTk1lYTdJeC9zdEo1VGZjTExlQUJMRTRCTkpPc1E0dm5CSEoiCiAgICAgICAgICB9CiAgICAgICAgXQogICAgICB9LAogICAgICAidmFsaWRGb3IiOiB7CiAgICAgICAgInN0YXJ0IjogIjIwMjItMDQtMTNUMjA6MDY6MTUuMDAwWiIKICAgICAgfQogICAgfQogIF0sCiAgImN0bG9ncyI6IFsKICAgIHsKICAgICAgImJhc2VVcmwiOiAiaHR0cHM6Ly9jdGZlLnNpZ3N0b3JlLmRldi90ZXN0IiwKICAgICAgImhhc2hBbGdvcml0aG0iOiAiU0hBMl8yNTYiLAogICAgICAicHVibGljS2V5IjogewogICAgICAgICJyYXdCeXRlcyI6ICJNRmt3RXdZSEtvWkl6ajBDQVFZSUtvWkl6ajBEQVFjRFFnQUViZndSK1JKdWRYc2NnUkJScEtYMVhGRHkzUHl1ZER4ei9TZm5SaTFmVDhla3BmQmQyTzF1b3o3anIzWjhuS3p4QTY5RVVRK2VGQ0ZJM3pldWJQV1U3dz09IiwKICAgICAgICAia2V5RGV0YWlscyI6ICJQS0lYX0VDRFNBX1AyNTZfU0hBXzI1NiIsCiAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgInN0YXJ0IjogIjIwMjEtMDMtMTRUMDA6MDA6MDAuMDAwWiIsCiAgICAgICAgICAiZW5kIjogIjIwMjItMTAtMzFUMjM6NTk6NTkuOTk5WiIKICAgICAgICB9CiAgICAgIH0sCiAgICAgICJsb2dJZCI6IHsKICAgICAgICAia2V5SWQiOiAiQ0dDUzhDaFMvMmhGMGRGcko0U2NSV2NZckJZOXd6alNiZWE4SWdZMmIzST0iCiAgICAgIH0KICAgIH0sCiAgICB7CiAgICAgICJiYXNlVXJsIjogImh0dHBzOi8vY3RmZS5zaWdzdG9yZS5kZXYvMjAyMiIsCiAgICAgICJoYXNoQWxnb3JpdGhtIjogIlNIQTJfMjU2IiwKICAgICAgInB1YmxpY0tleSI6IHsKICAgICAgICAicmF3Qnl0ZXMiOiAiTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFaVBTbEZpMENtRlRmRWpDVXFGOUh1Q0VjWVhOS0FhWWFsSUptQlo4eXllelBqVHFoeHJLQnBNbmFvY1Z0TEpCSTFlTTN1WG5RelFHQUpkSjRnczlGeXc9PSIsCiAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICJ2YWxpZEZvciI6IHsKICAgICAgICAgICJzdGFydCI6ICIyMDIyLTEwLTIwVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgfQogICAgICB9LAogICAgICAibG9nSWQiOiB7CiAgICAgICAgImtleUlkIjogIjNUMHdhc2JIRVRKakdSNGNtV2MzQXFKS1hyamVQSzMvaDRweWdDOHA3bzQ9IgogICAgICB9CiAgICB9CiAgXSwKICAidGltZXN0YW1wQXV0aG9yaXRpZXMiOiBbCiAgICB7CiAgICAgICJzdWJqZWN0IjogewogICAgICAgICJvcmdhbml6YXRpb24iOiAiR2l0SHViLCBJbmMuIiwKICAgICAgICAiY29tbW9uTmFtZSI6ICJJbnRlcm5hbCBTZXJ2aWNlcyBSb290IgogICAgICB9LAogICAgICAiY2VydENoYWluIjogewogICAgICAgICJjZXJ0aWZpY2F0ZXMiOiBbCiAgICAgICAgICB7CiAgICAgICAgICAgICJyYXdCeXRlcyI6ICJNSUlCM0RDQ0FXS2dBd0lCQWdJVWNoa05zSDM2WGEwNGIxTHFJYytxcjlEVmVjTXdDZ1lJS29aSXpqMEVBd013TWpFVk1CTUdBMVVFQ2hNTVIybDBTSFZpTENCSmJtTXVNUmt3RndZRFZRUURFeEJVVTBFZ2FXNTBaWEp0WldScFlYUmxNQjRYRFRJek1EUXhOREF3TURBd01Gb1hEVEkwTURReE16QXdNREF3TUZvd01qRVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVJrd0Z3WURWUVFERXhCVVUwRWdWR2x0WlhOMFlXMXdhVzVuTUZrd0V3WUhLb1pJemowQ0FRWUlLb1pJemowREFRY0RRZ0FFVUQ1Wk5iU3FZTWQ2cjhxcE9PRVg5aWJHblpUOUdzdVhPaHIvZjhVOUZKdWdCR0V4S1lwNDBPVUxTMGVyalpXN3hWOXhWNTJObkpmNU9lRHE0ZTVaS3FOV01GUXdEZ1lEVlIwUEFRSC9CQVFEQWdlQU1CTUdBMVVkSlFRTU1Bb0dDQ3NHQVFVRkJ3TUlNQXdHQTFVZEV3RUIvd1FDTUFBd0h3WURWUjBqQkJnd0ZvQVVhVzFSdWRPZ1Z0MGxlcVkwV0tZYnVQcjQ3d0F3Q2dZSUtvWkl6ajBFQXdNRGFBQXdaUUl3YlVIOUh2RDRlakNaSk9XUW5xQWxrcVVSbGx2dTlNOCtWcUxiaVJLK3pTZlpDWndzaWxqUm44TVFRUlNrWEVFNUFqRUFnK1Z4cXRvamZWZnU4RGh6emhDeDlHS0VUYkpIYjE5aVY3Mm1NS1ViREFGbXpaNmJROGI1NFpiOHRpZHk1YVdlIgogICAgICAgICAgfSwKICAgICAgICAgIHsKICAgICAgICAgICAgInJhd0J5dGVzIjogIk1JSUNFRENDQVpXZ0F3SUJBZ0lVWDhaTzVRWFA3dk40ZE1RNWU5c1UzbnViOE9nd0NnWUlLb1pJemowRUF3TXdPREVWTUJNR0ExVUVDaE1NUjJsMFNIVmlMQ0JKYm1NdU1SOHdIUVlEVlFRREV4WkpiblJsY201aGJDQlRaWEoyYVdObGN5QlNiMjkwTUI0WERUSXpNRFF4TkRBd01EQXdNRm9YRFRJNE1EUXhNakF3TURBd01Gb3dNakVWTUJNR0ExVUVDaE1NUjJsMFNIVmlMQ0JKYm1NdU1Sa3dGd1lEVlFRREV4QlVVMEVnYVc1MFpYSnRaV1JwWVhSbE1IWXdFQVlIS29aSXpqMENBUVlGSzRFRUFDSURZZ0FFdk1MWS9kVFZidklKWUFOQXVzekV3Sm5RRTFsbGZ0eW55TUtJTWhoNDhIbXFiVnI1eWd5YnpzTFJMVktiQldPZFoyMWFlSnorZ1ppeXRaZXRxY3lGOVdsRVI1TkVNZjZKVjdaTm9qUXB4SHE0UkhHb0dTY2VRdi9xdlRpWnhFREtvMll3WkRBT0JnTlZIUThCQWY4RUJBTUNBUVl3RWdZRFZSMFRBUUgvQkFnd0JnRUIvd0lCQURBZEJnTlZIUTRFRmdRVWFXMVJ1ZE9nVnQwbGVxWTBXS1lidVByNDd3QXdId1lEVlIwakJCZ3dGb0FVOU5ZWWxvYm5BRzRjMC9xanh5SC9scS93eitRd0NnWUlLb1pJemowRUF3TURhUUF3WmdJeEFLMUIxODV5Z0NySVlGbElzM0dqc3dqbndTTUc2TFk4d29MVmRha0tEWnhWYThmOGNxTXMxRGhjeEowKzA5dzk1UUl4QU8rdEJ6Wms3dmpVSjlpSmdENFI2WldUeFFXS3FObTc0ak85OW8rbzlzdjRGSS9TWlRaVEZ5TW4wSUpFSGRObXlBPT0iCiAgICAgICAgICB9LAogICAgICAgICAgewogICAgICAgICAgICAicmF3Qnl0ZXMiOiAiTUlJQjlEQ0NBWHFnQXdJQkFnSVVhL0pBa2RVaks0SlV3c3F0YWlSSkdXaHFMU293Q2dZSUtvWkl6ajBFQXdNd09ERVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVI4d0hRWURWUVFERXhaSmJuUmxjbTVoYkNCVFpYSjJhV05sY3lCU2IyOTBNQjRYRFRJek1EUXhOREF3TURBd01Gb1hEVE16TURReE1UQXdNREF3TUZvd09ERVZNQk1HQTFVRUNoTU1SMmwwU0hWaUxDQkpibU11TVI4d0hRWURWUVFERXhaSmJuUmxjbTVoYkNCVFpYSjJhV05sY3lCU2IyOTBNSFl3RUFZSEtvWkl6ajBDQVFZRks0RUVBQ0lEWWdBRWY5akZBWHh6NGt4NjhBSFJNT2tGQmhmbERjTVR2emFYejR4L0ZDY1hqSi8xcUVLb24vcVBJR25hVVJza0R0eU5iTkRPcGVKVERERnF0NDhpTVBybnpweDZJWndxZW1mVUpONHhCRVpmemErcFl0L2l5b2QrOXRacjIwUlJXU3YvbzBVd1F6QU9CZ05WSFE4QkFmOEVCQU1DQVFZd0VnWURWUjBUQVFIL0JBZ3dCZ0VCL3dJQkFqQWRCZ05WSFE0RUZnUVU5TllZbG9ibkFHNGMwL3FqeHlIL2xxL3d6K1F3Q2dZSUtvWkl6ajBFQXdNRGFBQXdaUUl4QUxaTFo4QmdSWHpLeExNTU45VklsTytlNGhyQm5OQmdGN3R6N0hucm93djJOZXRaRXJJQUNLRnltQmx2V0R2dE1BSXdaTytraTZzc1ExYnNabzk4TzhtRUFmMk5aN2lpQ2dERFUwVndqZWNvNnp5ZWgwekJUczkvN2dWNkFITlE1M3hEIgogICAgICAgICAgfQogICAgICAgIF0KICAgICAgfSwKICAgICAgInZhbGlkRm9yIjogewogICAgICAgICJzdGFydCI6ICIyMDIzLTA0LTE0VDAwOjAwOjAwLjAwMFoiCiAgICAgIH0KICAgIH0KICBdCn0K","registry.npmjs.org%2Fkeys.json":"ewogICAgImtleXMiOiBbCiAgICAgICAgewogICAgICAgICAgICAia2V5SWQiOiAiU0hBMjU2OmpsM2J3c3d1ODBQampva0NnaDBvMnc1YzJVNExoUUFFNTdnajljejFrekEiLAogICAgICAgICAgICAia2V5VXNhZ2UiOiAibnBtOnNpZ25hdHVyZXMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTFPbGIzek1BRkZ4WEtIaUlrUU81Y0ozWWhsNWk2VVBwK0lodXRlQkpidUhjQTVVb2dLbzBFV3RsV3dXNktTYUtvVE5FWUw3SmxDUWlWbmtoQmt0VWdnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIxOTk5LTAxLTAxVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9LAogICAgICAgIHsKICAgICAgICAgICAgImtleUlkIjogIlNIQTI1NjpqbDNid3N3dTgwUGpqb2tDZ2gwbzJ3NWMyVTRMaFFBRTU3Z2o5Y3oxa3pBIiwKICAgICAgICAgICAgImtleVVzYWdlIjogIm5wbTphdHRlc3RhdGlvbnMiLAogICAgICAgICAgICAicHVibGljS2V5IjogewogICAgICAgICAgICAgICAgInJhd0J5dGVzIjogIk1Ga3dFd1lIS29aSXpqMENBUVlJS29aSXpqMERBUWNEUWdBRTFPbGIzek1BRkZ4WEtIaUlrUU81Y0ozWWhsNWk2VVBwK0lodXRlQkpidUhjQTVVb2dLbzBFV3RsV3dXNktTYUtvVE5FWUw3SmxDUWlWbmtoQmt0VWdnPT0iLAogICAgICAgICAgICAgICAgImtleURldGFpbHMiOiAiUEtJWF9FQ0RTQV9QMjU2X1NIQV8yNTYiLAogICAgICAgICAgICAgICAgInZhbGlkRm9yIjogewogICAgICAgICAgICAgICAgICAgICJzdGFydCI6ICIyMDIyLTEyLTAxVDAwOjAwOjAwLjAwMFoiCiAgICAgICAgICAgICAgICB9CiAgICAgICAgICAgIH0KICAgICAgICB9CiAgICBdCn0K"}}}',
      );
    },
    3236: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[{"name":"Agola CI","constant":"AGOLA","env":"AGOLA_GIT_REF","pr":"AGOLA_PULL_REQUEST_ID"},{"name":"Appcircle","constant":"APPCIRCLE","env":"AC_APPCIRCLE"},{"name":"AppVeyor","constant":"APPVEYOR","env":"APPVEYOR","pr":"APPVEYOR_PULL_REQUEST_NUMBER"},{"name":"AWS CodeBuild","constant":"CODEBUILD","env":"CODEBUILD_BUILD_ARN"},{"name":"Azure Pipelines","constant":"AZURE_PIPELINES","env":"TF_BUILD","pr":{"BUILD_REASON":"PullRequest"}},{"name":"Bamboo","constant":"BAMBOO","env":"bamboo_planKey"},{"name":"Bitbucket Pipelines","constant":"BITBUCKET","env":"BITBUCKET_COMMIT","pr":"BITBUCKET_PR_ID"},{"name":"Bitrise","constant":"BITRISE","env":"BITRISE_IO","pr":"BITRISE_PULL_REQUEST"},{"name":"Buddy","constant":"BUDDY","env":"BUDDY_WORKSPACE_ID","pr":"BUDDY_EXECUTION_PULL_REQUEST_ID"},{"name":"Buildkite","constant":"BUILDKITE","env":"BUILDKITE","pr":{"env":"BUILDKITE_PULL_REQUEST","ne":"false"}},{"name":"CircleCI","constant":"CIRCLE","env":"CIRCLECI","pr":"CIRCLE_PULL_REQUEST"},{"name":"Cirrus CI","constant":"CIRRUS","env":"CIRRUS_CI","pr":"CIRRUS_PR"},{"name":"Codefresh","constant":"CODEFRESH","env":"CF_BUILD_ID","pr":{"any":["CF_PULL_REQUEST_NUMBER","CF_PULL_REQUEST_ID"]}},{"name":"Codemagic","constant":"CODEMAGIC","env":"CM_BUILD_ID","pr":"CM_PULL_REQUEST"},{"name":"Codeship","constant":"CODESHIP","env":{"CI_NAME":"codeship"}},{"name":"Drone","constant":"DRONE","env":"DRONE","pr":{"DRONE_BUILD_EVENT":"pull_request"}},{"name":"dsari","constant":"DSARI","env":"DSARI"},{"name":"Earthly","constant":"EARTHLY","env":"EARTHLY_CI"},{"name":"Expo Application Services","constant":"EAS","env":"EAS_BUILD"},{"name":"Gerrit","constant":"GERRIT","env":"GERRIT_PROJECT"},{"name":"Gitea Actions","constant":"GITEA_ACTIONS","env":"GITEA_ACTIONS"},{"name":"GitHub Actions","constant":"GITHUB_ACTIONS","env":"GITHUB_ACTIONS","pr":{"GITHUB_EVENT_NAME":"pull_request"}},{"name":"GitLab CI","constant":"GITLAB","env":"GITLAB_CI","pr":"CI_MERGE_REQUEST_ID"},{"name":"GoCD","constant":"GOCD","env":"GO_PIPELINE_LABEL"},{"name":"Google Cloud Build","constant":"GOOGLE_CLOUD_BUILD","env":"BUILDER_OUTPUT"},{"name":"Harness CI","constant":"HARNESS","env":"HARNESS_BUILD_ID"},{"name":"Heroku","constant":"HEROKU","env":{"env":"NODE","includes":"/app/.heroku/node/bin/node"}},{"name":"Hudson","constant":"HUDSON","env":"HUDSON_URL"},{"name":"Jenkins","constant":"JENKINS","env":["JENKINS_URL","BUILD_ID"],"pr":{"any":["ghprbPullId","CHANGE_ID"]}},{"name":"LayerCI","constant":"LAYERCI","env":"LAYERCI","pr":"LAYERCI_PULL_REQUEST"},{"name":"Magnum CI","constant":"MAGNUM","env":"MAGNUM"},{"name":"Netlify CI","constant":"NETLIFY","env":"NETLIFY","pr":{"env":"PULL_REQUEST","ne":"false"}},{"name":"Nevercode","constant":"NEVERCODE","env":"NEVERCODE","pr":{"env":"NEVERCODE_PULL_REQUEST","ne":"false"}},{"name":"Prow","constant":"PROW","env":"PROW_JOB_ID"},{"name":"ReleaseHub","constant":"RELEASEHUB","env":"RELEASE_BUILD_ID"},{"name":"Render","constant":"RENDER","env":"RENDER","pr":{"IS_PULL_REQUEST":"true"}},{"name":"Sail CI","constant":"SAIL","env":"SAILCI","pr":"SAIL_PULL_REQUEST_NUMBER"},{"name":"Screwdriver","constant":"SCREWDRIVER","env":"SCREWDRIVER","pr":{"env":"SD_PULL_REQUEST","ne":"false"}},{"name":"Semaphore","constant":"SEMAPHORE","env":"SEMAPHORE","pr":"PULL_REQUEST_NUMBER"},{"name":"Sourcehut","constant":"SOURCEHUT","env":{"CI_NAME":"sourcehut"}},{"name":"Strider CD","constant":"STRIDER","env":"STRIDER"},{"name":"TaskCluster","constant":"TASKCLUSTER","env":["TASK_ID","RUN_ID"]},{"name":"TeamCity","constant":"TEAMCITY","env":"TEAMCITY_VERSION"},{"name":"Travis CI","constant":"TRAVIS","env":"TRAVIS","pr":{"env":"TRAVIS_PULL_REQUEST","ne":"false"}},{"name":"Vela","constant":"VELA","env":"VELA","pr":{"VELA_PULL_REQUEST":"1"}},{"name":"Vercel","constant":"VERCEL","env":{"any":["NOW_BUILDER","VERCEL"]},"pr":"VERCEL_GIT_PULL_REQUEST_ID"},{"name":"Visual Studio App Center","constant":"APPCENTER","env":"APPCENTER_BUILD_ID"},{"name":"Woodpecker","constant":"WOODPECKER","env":{"CI":"woodpecker"},"pr":{"CI_BUILD_EVENT":"pull_request"}},{"name":"Xcode Cloud","constant":"XCODE_CLOUD","env":"CI_XCODE_PROJECT","pr":"CI_PULL_REQUEST_NUMBER"},{"name":"Xcode Server","constant":"XCODE_SERVER","env":"XCS"}]',
      );
    },
    3480: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["8740","䏰䰲䘃䖦䕸𧉧䵷䖳𧲱䳢𧳅㮕䜶䝄䱇䱀𤊿𣘗𧍒𦺋𧃒䱗𪍑䝏䗚䲅𧱬䴇䪤䚡𦬣爥𥩔𡩣𣸆𣽡晍囻"],["8767","綕夝𨮹㷴霴𧯯寛𡵞媤㘥𩺰嫑宷峼杮薓𩥅瑡璝㡵𡵓𣚞𦀡㻬"],["87a1","𥣞㫵竼龗𤅡𨤍𣇪𠪊𣉞䌊蒄龖鐯䤰蘓墖靊鈘秐稲晠権袝瑌篅枂稬剏遆㓦珄𥶹瓆鿇垳䤯呌䄱𣚎堘穲𧭥讏䚮𦺈䆁𥶙箮𢒼鿈𢓁𢓉𢓌鿉蔄𣖻䂴鿊䓡𪷿拁灮鿋"],["8840","㇀",4,"𠄌㇅𠃑𠃍㇆㇇𠃋𡿨㇈𠃊㇉㇊㇋㇌𠄎㇍㇎ĀÁǍÀĒÉĚÈŌÓǑÒ࿿Ê̄Ế࿿Ê̌ỀÊāáǎàɑēéěèīíǐìōóǒòūúǔùǖǘǚ"],["88a1","ǜü࿿ê̄ế࿿ê̌ềêɡ⏚⏛"],["8940","𪎩𡅅"],["8943","攊"],["8946","丽滝鵎釟"],["894c","𧜵撑会伨侨兖兴农凤务动医华发变团声处备夲头学实実岚庆总斉柾栄桥济炼电纤纬纺织经统缆缷艺苏药视设询车轧轮"],["89a1","琑糼緍楆竉刧"],["89ab","醌碸酞肼"],["89b0","贋胶𠧧"],["89b5","肟黇䳍鷉鸌䰾𩷶𧀎鸊𪄳㗁"],["89c1","溚舾甙"],["89c5","䤑马骏龙禇𨑬𡷊𠗐𢫦两亁亀亇亿仫伷㑌侽㹈倃傈㑽㒓㒥円夅凛凼刅争剹劐匧㗇厩㕑厰㕓参吣㕭㕲㚁咓咣咴咹哐哯唘唣唨㖘唿㖥㖿嗗㗅"],["8a40","𧶄唥"],["8a43","𠱂𠴕𥄫喐𢳆㧬𠍁蹆𤶸𩓥䁓𨂾睺𢰸㨴䟕𨅝𦧲𤷪擝𠵼𠾴𠳕𡃴撍蹾𠺖𠰋𠽤𢲩𨉖𤓓"],["8a64","𠵆𩩍𨃩䟴𤺧𢳂骲㩧𩗴㿭㔆𥋇𩟔𧣈𢵄鵮頕"],["8a76","䏙𦂥撴哣𢵌𢯊𡁷㧻𡁯"],["8aa1","𦛚𦜖𧦠擪𥁒𠱃蹨𢆡𨭌𠜱"],["8aac","䠋𠆩㿺塳𢶍"],["8ab2","𤗈𠓼𦂗𠽌𠶖啹䂻䎺"],["8abb","䪴𢩦𡂝膪飵𠶜捹㧾𢝵跀嚡摼㹃"],["8ac9","𪘁𠸉𢫏𢳉"],["8ace","𡃈𣧂㦒㨆𨊛㕸𥹉𢃇噒𠼱𢲲𩜠㒼氽𤸻"],["8adf","𧕴𢺋𢈈𪙛𨳍𠹺𠰴𦠜羓𡃏𢠃𢤹㗻𥇣𠺌𠾍𠺪㾓𠼰𠵇𡅏𠹌"],["8af6","𠺫𠮩𠵈𡃀𡄽㿹𢚖搲𠾭"],["8b40","𣏴𧘹𢯎𠵾𠵿𢱑𢱕㨘𠺘𡃇𠼮𪘲𦭐𨳒𨶙𨳊閪哌苄喹"],["8b55","𩻃鰦骶𧝞𢷮煀腭胬尜𦕲脴㞗卟𨂽醶𠻺𠸏𠹷𠻻㗝𤷫㘉𠳖嚯𢞵𡃉𠸐𠹸𡁸𡅈𨈇𡑕𠹹𤹐𢶤婔𡀝𡀞𡃵𡃶垜𠸑"],["8ba1","𧚔𨋍𠾵𠹻𥅾㜃𠾶𡆀𥋘𪊽𤧚𡠺𤅷𨉼墙剨㘚𥜽箲孨䠀䬬鼧䧧鰟鮍𥭴𣄽嗻㗲嚉丨夂𡯁屮靑𠂆乛亻㔾尣彑忄㣺扌攵歺氵氺灬爫丬犭𤣩罒礻糹罓𦉪㓁"],["8bde","𦍋耂肀𦘒𦥑卝衤见𧢲讠贝钅镸长门𨸏韦页风飞饣𩠐鱼鸟黄歯龜丷𠂇阝户钢"],["8c40","倻淾𩱳龦㷉袏𤅎灷峵䬠𥇍㕙𥴰愢𨨲辧釶熑朙玺𣊁𪄇㲋𡦀䬐磤琂冮𨜏䀉橣𪊺䈣蘏𠩯稪𩥇𨫪靕灍匤𢁾鏴盙𨧣龧矝亣俰傼丯众龨吴綋墒壐𡶶庒庙忂𢜒斋"],["8ca1","𣏹椙橃𣱣泿"],["8ca7","爀𤔅玌㻛𤨓嬕璹讃𥲤𥚕窓篬糃繬苸薗龩袐龪躹龫迏蕟駠鈡龬𨶹𡐿䁱䊢娚"],["8cc9","顨杫䉶圽"],["8cce","藖𤥻芿𧄍䲁𦵴嵻𦬕𦾾龭龮宖龯曧繛湗秊㶈䓃𣉖𢞖䎚䔶"],["8ce6","峕𣬚諹屸㴒𣕑嵸龲煗䕘𤃬𡸣䱷㥸㑊𠆤𦱁諌侴𠈹妿腬顖𩣺弻"],["8d40","𠮟"],["8d42","𢇁𨥭䄂䚻𩁹㼇龳𪆵䃸㟖䛷𦱆䅼𨚲𧏿䕭㣔𥒚䕡䔛䶉䱻䵶䗪㿈𤬏㙡䓞䒽䇭崾嵈嵖㷼㠏嶤嶹㠠㠸幂庽弥徃㤈㤔㤿㥍惗愽峥㦉憷憹懏㦸戬抐拥挘㧸嚱"],["8da1","㨃揢揻搇摚㩋擀崕嘡龟㪗斆㪽旿晓㫲暒㬢朖㭂枤栀㭘桊梄㭲㭱㭻椉楃牜楤榟榅㮼槖㯝橥橴橱檂㯬檙㯲檫檵櫔櫶殁毁毪汵沪㳋洂洆洦涁㳯涤涱渕渘温溆𨧀溻滢滚齿滨滩漤漴㵆𣽁澁澾㵪㵵熷岙㶊瀬㶑灐灔灯灿炉𠌥䏁㗱𠻘"],["8e40","𣻗垾𦻓焾𥟠㙎榢𨯩孴穉𥣡𩓙穥穽𥦬窻窰竂竃燑𦒍䇊竚竝竪䇯咲𥰁笋筕笩𥌎𥳾箢筯莜𥮴𦱿篐萡箒箸𥴠㶭𥱥蒒篺簆簵𥳁籄粃𤢂粦晽𤕸糉糇糦籴糳糵糎"],["8ea1","繧䔝𦹄絝𦻖璍綉綫焵綳緒𤁗𦀩緤㴓緵𡟹緥𨍭縝𦄡𦅚繮纒䌫鑬縧罀罁罇礶𦋐駡羗𦍑羣𡙡𠁨䕜𣝦䔃𨌺翺𦒉者耈耝耨耯𪂇𦳃耻耼聡𢜔䦉𦘦𣷣𦛨朥肧𨩈脇脚墰𢛶汿𦒘𤾸擧𡒊舘𡡞橓𤩥𤪕䑺舩𠬍𦩒𣵾俹𡓽蓢荢𦬊𤦧𣔰𡝳𣷸芪椛芳䇛"],["8f40","蕋苐茚𠸖𡞴㛁𣅽𣕚艻苢茘𣺋𦶣𦬅𦮗𣗎㶿茝嗬莅䔋𦶥莬菁菓㑾𦻔橗蕚㒖𦹂𢻯葘𥯤葱㷓䓤檧葊𣲵祘蒨𦮖𦹷𦹃蓞萏莑䒠蒓蓤𥲑䉀𥳀䕃蔴嫲𦺙䔧蕳䔖枿蘖"],["8fa1","𨘥𨘻藁𧂈蘂𡖂𧃍䕫䕪蘨㙈𡢢号𧎚虾蝱𪃸蟮𢰧螱蟚蠏噡虬桖䘏衅衆𧗠𣶹𧗤衞袜䙛袴袵揁装睷𧜏覇覊覦覩覧覼𨨥觧𧤤𧪽誜瞓釾誐𧩙竩𧬺𣾏䜓𧬸煼謌謟𥐰𥕥謿譌譍誩𤩺讐讛誯𡛟䘕衏貛𧵔𧶏貫㜥𧵓賖𧶘𧶽贒贃𡤐賛灜贑𤳉㻐起"],["9040","趩𨀂𡀔𤦊㭼𨆼𧄌竧躭躶軃鋔輙輭𨍥𨐒辥錃𪊟𠩐辳䤪𨧞𨔽𣶻廸𣉢迹𪀔𨚼𨔁𢌥㦀𦻗逷𨔼𧪾遡𨕬𨘋邨𨜓郄𨛦邮都酧㫰醩釄粬𨤳𡺉鈎沟鉁鉢𥖹銹𨫆𣲛𨬌𥗛"],["90a1","𠴱錬鍫𨫡𨯫炏嫃𨫢𨫥䥥鉄𨯬𨰹𨯿鍳鑛躼閅閦鐦閠濶䊹𢙺𨛘𡉼𣸮䧟氜陻隖䅬隣𦻕懚隶磵𨫠隽双䦡𦲸𠉴𦐐𩂯𩃥𤫑𡤕𣌊霱虂霶䨏䔽䖅𤫩灵孁霛靜𩇕靗孊𩇫靟鐥僐𣂷𣂼鞉鞟鞱鞾韀韒韠𥑬韮琜𩐳響韵𩐝𧥺䫑頴頳顋顦㬎𧅵㵑𠘰𤅜"],["9140","𥜆飊颷飈飇䫿𦴧𡛓喰飡飦飬鍸餹𤨩䭲𩡗𩤅駵騌騻騐驘𥜥㛄𩂱𩯕髠髢𩬅髴䰎鬔鬭𨘀倴鬴𦦨㣃𣁽魐魀𩴾婅𡡣鮎𤉋鰂鯿鰌𩹨鷔𩾷𪆒𪆫𪃡𪄣𪇟鵾鶃𪄴鸎梈"],["91a1","鷄𢅛𪆓𪈠𡤻𪈳鴹𪂹𪊴麐麕麞麢䴴麪麯𤍤黁㭠㧥㴝伲㞾𨰫鼂鼈䮖鐤𦶢鼗鼖鼹嚟嚊齅馸𩂋韲葿齢齩竜龎爖䮾𤥵𤦻煷𤧸𤍈𤩑玞𨯚𡣺禟𨥾𨸶鍩鏳𨩄鋬鎁鏋𨥬𤒹爗㻫睲穃烐𤑳𤏸煾𡟯炣𡢾𣖙㻇𡢅𥐯𡟸㜢𡛻𡠹㛡𡝴𡣑𥽋㜣𡛀坛𤨥𡏾𡊨"],["9240","𡏆𡒶蔃𣚦蔃葕𤦔𧅥𣸱𥕜𣻻𧁒䓴𣛮𩦝𦼦柹㜳㰕㷧塬𡤢栐䁗𣜿𤃡𤂋𤄏𦰡哋嚞𦚱嚒𠿟𠮨𠸍鏆𨬓鎜仸儫㠙𤐶亼𠑥𠍿佋侊𥙑婨𠆫𠏋㦙𠌊𠐔㐵伩𠋀𨺳𠉵諚𠈌亘"],["92a1","働儍侢伃𤨎𣺊佂倮偬傁俌俥偘僼兙兛兝兞湶𣖕𣸹𣺿浲𡢄𣺉冨凃𠗠䓝𠒣𠒒𠒑赺𨪜𠜎剙劤𠡳勡鍮䙺熌𤎌𠰠𤦬𡃤槑𠸝瑹㻞璙琔瑖玘䮎𤪼𤂍叐㖄爏𤃉喴𠍅响𠯆圝鉝雴鍦埝垍坿㘾壋媙𨩆𡛺𡝯𡜐娬妸銏婾嫏娒𥥆𡧳𡡡𤊕㛵洅瑃娡𥺃"],["9340","媁𨯗𠐓鏠璌𡌃焅䥲鐈𨧻鎽㞠尞岞幞幈𡦖𡥼𣫮廍孏𡤃𡤄㜁𡢠㛝𡛾㛓脪𨩇𡶺𣑲𨦨弌弎𡤧𡞫婫𡜻孄蘔𧗽衠恾𢡠𢘫忛㺸𢖯𢖾𩂈𦽳懀𠀾𠁆𢘛憙憘恵𢲛𢴇𤛔𩅍"],["93a1","摱𤙥𢭪㨩𢬢𣑐𩣪𢹸挷𪑛撶挱揑𤧣𢵧护𢲡搻敫楲㯴𣂎𣊭𤦉𣊫唍𣋠𡣙𩐿曎𣊉𣆳㫠䆐𥖄𨬢𥖏𡛼𥕛𥐥磮𣄃𡠪𣈴㑤𣈏𣆂𤋉暎𦴤晫䮓昰𧡰𡷫晣𣋒𣋡昞𥡲㣑𣠺𣞼㮙𣞢𣏾瓐㮖枏𤘪梶栞㯄檾㡣𣟕𤒇樳橒櫉欅𡤒攑梘橌㯗橺歗𣿀𣲚鎠鋲𨯪𨫋"],["9440","銉𨀞𨧜鑧涥漋𤧬浧𣽿㶏渄𤀼娽渊塇洤硂焻𤌚𤉶烱牐犇犔𤞏𤜥兹𤪤𠗫瑺𣻸𣙟𤩊𤤗𥿡㼆㺱𤫟𨰣𣼵悧㻳瓌琼鎇琷䒟𦷪䕑疃㽣𤳙𤴆㽘畕癳𪗆㬙瑨𨫌𤦫𤦎㫻"],["94a1","㷍𤩎㻿𤧅𤣳釺圲鍂𨫣𡡤僟𥈡𥇧睸𣈲眎眏睻𤚗𣞁㩞𤣰琸璛㺿𤪺𤫇䃈𤪖𦆮錇𥖁砞碍碈磒珐祙𧝁𥛣䄎禛蒖禥樭𣻺稺秴䅮𡛦䄲鈵秱𠵌𤦌𠊙𣶺𡝮㖗啫㕰㚪𠇔𠰍竢婙𢛵𥪯𥪜娍𠉛磰娪𥯆竾䇹籝籭䈑𥮳𥺼𥺦糍𤧹𡞰粎籼粮檲緜縇緓罎𦉡"],["9540","𦅜𧭈綗𥺂䉪𦭵𠤖柖𠁎𣗏埄𦐒𦏸𤥢翝笧𠠬𥫩𥵃笌𥸎駦虅驣樜𣐿㧢𤧷𦖭騟𦖠蒀𧄧𦳑䓪脷䐂胆脉腂𦞴飃𦩂艢艥𦩑葓𦶧蘐𧈛媆䅿𡡀嬫𡢡嫤𡣘蚠蜨𣶏蠭𧐢娂"],["95a1","衮佅袇袿裦襥襍𥚃襔𧞅𧞄𨯵𨯙𨮜𨧹㺭蒣䛵䛏㟲訽訜𩑈彍鈫𤊄旔焩烄𡡅鵭貟賩𧷜妚矃姰䍮㛔踪躧𤰉輰轊䋴汘澻𢌡䢛潹溋𡟚鯩㚵𤤯邻邗啱䤆醻鐄𨩋䁢𨫼鐧𨰝𨰻蓥訫閙閧閗閖𨴴瑅㻂𤣿𤩂𤏪㻧𣈥随𨻧𨹦𨹥㻌𤧭𤩸𣿮琒瑫㻼靁𩂰"],["9640","桇䨝𩂓𥟟靝鍨𨦉𨰦𨬯𦎾銺嬑譩䤼珹𤈛鞛靱餸𠼦巁𨯅𤪲頟𩓚鋶𩗗釥䓀𨭐𤩧𨭤飜𨩅㼀鈪䤥萔餻饍𧬆㷽馛䭯馪驜𨭥𥣈檏騡嫾騯𩣱䮐𩥈馼䮽䮗鍽塲𡌂堢𤦸"],["96a1","𡓨硄𢜟𣶸棅㵽鑘㤧慐𢞁𢥫愇鱏鱓鱻鰵鰐魿鯏𩸭鮟𪇵𪃾鴡䲮𤄄鸘䲰鴌𪆴𪃭𪃳𩤯鶥蒽𦸒𦿟𦮂藼䔳𦶤𦺄𦷰萠藮𦸀𣟗𦁤秢𣖜𣙀䤭𤧞㵢鏛銾鍈𠊿碹鉷鑍俤㑀遤𥕝砽硔碶硋𡝗𣇉𤥁㚚佲濚濙瀞瀞吔𤆵垻壳垊鴖埗焴㒯𤆬燫𦱀𤾗嬨𡞵𨩉"],["9740","愌嫎娋䊼𤒈㜬䭻𨧼鎻鎸𡣖𠼝葲𦳀𡐓𤋺𢰦𤏁妔𣶷𦝁綨𦅛𦂤𤦹𤦋𨧺鋥珢㻩璴𨭣𡢟㻡𤪳櫘珳珻㻖𤨾𤪔𡟙𤩦𠎧𡐤𤧥瑈𤤖炥𤥶銄珦鍟𠓾錱𨫎𨨖鎆𨯧𥗕䤵𨪂煫"],["97a1","𤥃𠳿嚤𠘚𠯫𠲸唂秄𡟺緾𡛂𤩐𡡒䔮鐁㜊𨫀𤦭妰𡢿𡢃𧒄媡㛢𣵛㚰鉟婹𨪁𡡢鍴㳍𠪴䪖㦊僴㵩㵌𡎜煵䋻𨈘渏𩃤䓫浗𧹏灧沯㳖𣿭𣸭渂漌㵯𠏵畑㚼㓈䚀㻚䡱姄鉮䤾轁𨰜𦯀堒埈㛖𡑒烾𤍢𤩱𢿣𡊰𢎽梹楧𡎘𣓥𧯴𣛟𨪃𣟖𣏺𤲟樚𣚭𦲷萾䓟䓎"],["9840","𦴦𦵑𦲂𦿞漗𧄉茽𡜺菭𦲀𧁓𡟛妉媂𡞳婡婱𡤅𤇼㜭姯𡜼㛇熎鎐暚𤊥婮娫𤊓樫𣻹𧜶𤑛𤋊焝𤉙𨧡侰𦴨峂𤓎𧹍𤎽樌𤉖𡌄炦焳𤏩㶥泟勇𤩏繥姫崯㷳彜𤩝𡟟綤萦"],["98a1","咅𣫺𣌀𠈔坾𠣕𠘙㿥𡾞𪊶瀃𩅛嵰玏糓𨩙𩐠俈翧狍猐𧫴猸猹𥛶獁獈㺩𧬘遬燵𤣲珡臶㻊県㻑沢国琙琞琟㻢㻰㻴㻺瓓㼎㽓畂畭畲疍㽼痈痜㿀癍㿗癴㿜発𤽜熈嘣覀塩䀝睃䀹条䁅㗛瞘䁪䁯属瞾矋売砘点砜䂨砹硇硑硦葈𥔵礳栃礲䄃"],["9940","䄉禑禙辻稆込䅧窑䆲窼艹䇄竏竛䇏両筢筬筻簒簛䉠䉺类粜䊌粸䊔糭输烀𠳏総緔緐緽羮羴犟䎗耠耥笹耮耱联㷌垴炠肷胩䏭脌猪脎脒畠脔䐁㬹腖腙腚"],["99a1","䐓堺腼膄䐥膓䐭膥埯臁臤艔䒏芦艶苊苘苿䒰荗险榊萅烵葤惣蒈䔄蒾蓡蓸蔐蔸蕒䔻蕯蕰藠䕷虲蚒蚲蛯际螋䘆䘗袮裿褤襇覑𧥧訩訸誔誴豑賔賲贜䞘塟跃䟭仮踺嗘坔蹱嗵躰䠷軎転軤軭軲辷迁迊迌逳駄䢭飠鈓䤞鈨鉘鉫銱銮銿"],["9a40","鋣鋫鋳鋴鋽鍃鎄鎭䥅䥑麿鐗匁鐝鐭鐾䥪鑔鑹锭関䦧间阳䧥枠䨤靀䨵鞲韂噔䫤惨颹䬙飱塄餎餙冴餜餷饂饝饢䭰駅䮝騼鬏窃魩鮁鯝鯱鯴䱭鰠㝯𡯂鵉鰺"],["9aa1","黾噐鶓鶽鷀鷼银辶鹻麬麱麽黆铜黢黱黸竈齄𠂔𠊷𠎠椚铃妬𠓗塀铁㞹𠗕𠘕𠙶𡚺块煳𠫂𠫍𠮿呪吆𠯋咞𠯻𠰻𠱓𠱥𠱼惧𠲍噺𠲵𠳝𠳭𠵯𠶲𠷈楕鰯螥𠸄𠸎𠻗𠾐𠼭𠹳尠𠾼帋𡁜𡁏𡁶朞𡁻𡂈𡂖㙇𡂿𡃓𡄯𡄻卤蒭𡋣𡍵𡌶讁𡕷𡘙𡟃𡟇乸炻𡠭𡥪"],["9b40","𡨭𡩅𡰪𡱰𡲬𡻈拃𡻕𡼕熘桕𢁅槩㛈𢉼𢏗𢏺𢜪𢡱𢥏苽𢥧𢦓𢫕覥𢫨辠𢬎鞸𢬿顇骽𢱌"],["9b62","𢲈𢲷𥯨𢴈𢴒𢶷𢶕𢹂𢽴𢿌𣀳𣁦𣌟𣏞徱晈暿𧩹𣕧𣗳爁𤦺矗𣘚𣜖纇𠍆墵朎"],["9ba1","椘𣪧𧙗𥿢𣸑𣺹𧗾𢂚䣐䪸𤄙𨪚𤋮𤌍𤀻𤌴𤎖𤩅𠗊凒𠘑妟𡺨㮾𣳿𤐄𤓖垈𤙴㦛𤜯𨗨𩧉㝢𢇃譞𨭎駖𤠒𤣻𤨕爉𤫀𠱸奥𤺥𤾆𠝹軚𥀬劏圿煱𥊙𥐙𣽊𤪧喼𥑆𥑮𦭒釔㑳𥔿𧘲𥕞䜘𥕢𥕦𥟇𤤿𥡝偦㓻𣏌惞𥤃䝼𨥈𥪮𥮉𥰆𡶐垡煑澶𦄂𧰒遖𦆲𤾚譢𦐂𦑊"],["9c40","嵛𦯷輶𦒄𡤜諪𤧶𦒈𣿯𦔒䯀𦖿𦚵𢜛鑥𥟡憕娧晉侻嚹𤔡𦛼乪𤤴陖涏𦲽㘘襷𦞙𦡮𦐑𦡞營𦣇筂𩃀𠨑𦤦鄄𦤹穅鷰𦧺騦𦨭㙟𦑩𠀡禃𦨴𦭛崬𣔙菏𦮝䛐𦲤画补𦶮墶"],["9ca1","㜜𢖍𧁋𧇍㱔𧊀𧊅銁𢅺𧊋錰𧋦𤧐氹钟𧑐𠻸蠧裵𢤦𨑳𡞱溸𤨪𡠠㦤㚹尐秣䔿暶𩲭𩢤襃𧟌𧡘囖䃟𡘊㦡𣜯𨃨𡏅熭荦𧧝𩆨婧䲷𧂯𨦫𧧽𧨊𧬋𧵦𤅺筃祾𨀉澵𪋟樃𨌘厢𦸇鎿栶靝𨅯𨀣𦦵𡏭𣈯𨁈嶅𨰰𨂃圕頣𨥉嶫𤦈斾槕叒𤪥𣾁㰑朶𨂐𨃴𨄮𡾡𨅏"],["9d40","𨆉𨆯𨈚𨌆𨌯𨎊㗊𨑨𨚪䣺揦𨥖砈鉕𨦸䏲𨧧䏟𨧨𨭆𨯔姸𨰉輋𨿅𩃬筑𩄐𩄼㷷𩅞𤫊运犏嚋𩓧𩗩𩖰𩖸𩜲𩣑𩥉𩥪𩧃𩨨𩬎𩵚𩶛纟𩻸𩼣䲤镇𪊓熢𪋿䶑递𪗋䶜𠲜达嗁"],["9da1","辺𢒰边𤪓䔉繿潖檱仪㓤𨬬𧢝㜺躀𡟵𨀤𨭬𨮙𧨾𦚯㷫𧙕𣲷𥘵𥥖亚𥺁𦉘嚿𠹭踎孭𣺈𤲞揞拐𡟶𡡻攰嘭𥱊吚𥌑㷆𩶘䱽嘢嘞罉𥻘奵𣵀蝰东𠿪𠵉𣚺脗鵞贘瘻鱅癎瞹鍅吲腈苷嘥脲萘肽嗪祢噃吖𠺝㗎嘅嗱曱𨋢㘭甴嗰喺咗啲𠱁𠲖廐𥅈𠹶𢱢"],["9e40","𠺢麫絚嗞𡁵抝靭咔賍燶酶揼掹揾啩𢭃鱲𢺳冚㓟𠶧冧呍唞唓癦踭𦢊疱肶蠄螆裇膶萜𡃁䓬猄𤜆宐茋𦢓噻𢛴𧴯𤆣𧵳𦻐𧊶酰𡇙鈈𣳼𪚩𠺬𠻹牦𡲢䝎𤿂𧿹𠿫䃺"],["9ea1","鱝攟𢶠䣳𤟠𩵼𠿬𠸊恢𧖣𠿭"],["9ead","𦁈𡆇熣纎鵐业丄㕷嬍沲卧㚬㧜卽㚥𤘘墚𤭮舭呋垪𥪕𠥹"],["9ec5","㩒𢑥獴𩺬䴉鯭𣳾𩼰䱛𤾩𩖞𩿞葜𣶶𧊲𦞳𣜠挮紥𣻷𣸬㨪逈勌㹴㙺䗩𠒎癀嫰𠺶硺𧼮墧䂿噼鮋嵴癔𪐴麅䳡痹㟻愙𣃚𤏲"],["9ef5","噝𡊩垧𤥣𩸆刴𧂮㖭汊鵼"],["9f40","籖鬹埞𡝬屓擓𩓐𦌵𧅤蚭𠴨𦴢𤫢𠵱"],["9f4f","凾𡼏嶎霃𡷑麁遌笟鬂峑箣扨挵髿篏鬪籾鬮籂粆鰕篼鬉鼗鰛𤤾齚啳寃俽麘俲剠㸆勑坧偖妷帒韈鶫轜呩鞴饀鞺匬愰"],["9fa1","椬叚鰊鴂䰻陁榀傦畆𡝭駚剳"],["9fae","酙隁酜"],["9fb2","酑𨺗捿𦴣櫊嘑醎畺抅𠏼獏籰𥰡𣳽"],["9fc1","𤤙盖鮝个𠳔莾衂"],["9fc9","届槀僭坺刟巵从氱𠇲伹咜哚劚趂㗾弌㗳"],["9fdb","歒酼龥鮗頮颴骺麨麄煺笔"],["9fe7","毺蠘罸"],["9feb","嘠𪙊蹷齓"],["9ff0","跔蹏鸜踁抂𨍽踨蹵竓𤩷稾磘泪詧瘇"],["a040","𨩚鼦泎蟖痃𪊲硓咢贌狢獱謭猂瓱賫𤪻蘯徺袠䒷"],["a055","𡠻𦸅"],["a058","詾𢔛"],["a05b","惽癧髗鵄鍮鮏蟵"],["a063","蠏賷猬霡鮰㗖犲䰇籑饊𦅙慙䰄麖慽"],["a073","坟慯抦戹拎㩜懢厪𣏵捤栂㗒"],["a0a1","嵗𨯂迚𨸹"],["a0a6","僙𡵆礆匲阸𠼻䁥"],["a0ae","矾"],["a0b0","糂𥼚糚稭聦聣絍甅瓲覔舚朌聢𧒆聛瓰脃眤覉𦟌畓𦻑螩蟎臈螌詉貭譃眫瓸蓚㘵榲趦"],["a0d4","覩瑨涹蟁𤀑瓧㷛煶悤憜㳑煢恷"],["a0e2","罱𨬭牐惩䭾删㰘𣳇𥻗𧙖𥔱𡥄𡋾𩤃𦷜𧂭峁𦆭𨨏𣙷𠃮𦡆𤼎䕢嬟𦍌齐麦𦉫"],["a3c0","␀",31,"␡"],["c6a1","①",9,"⑴",9,"ⅰ",9,"丶丿亅亠冂冖冫勹匸卩厶夊宀巛⼳广廴彐彡攴无疒癶辵隶¨ˆヽヾゝゞ〃仝々〆〇ー［］✽ぁ",23],["c740","す",58,"ァアィイ"],["c7a1","ゥ",81,"А",5,"ЁЖ",4],["c840","Л",26,"ёж",25,"⇧↸↹㇏𠃌乚𠂊刂䒑"],["c8a1","龰冈龱𧘇"],["c8cd","￢￤＇＂㈱№℡゛゜⺀⺄⺆⺇⺈⺊⺌⺍⺕⺜⺝⺥⺧⺪⺬⺮⺶⺼⺾⻆⻊⻌⻍⻏⻖⻗⻞⻣"],["c8f5","ʃɐɛɔɵœøŋʊɪ"],["f9fe","￭"],["fa40","𠕇鋛𠗟𣿅蕌䊵珯况㙉𤥂𨧤鍄𡧛苮𣳈砼杄拟𤤳𨦪𠊠𦮳𡌅侫𢓭倈𦴩𧪄𣘀𤪱𢔓倩𠍾徤𠎀𠍇滛𠐟偽儁㑺儎顬㝃萖𤦤𠒇兠𣎴兪𠯿𢃼𠋥𢔰𠖎𣈳𡦃宂蝽𠖳𣲙冲冸"],["faa1","鴴凉减凑㳜凓𤪦决凢卂凭菍椾𣜭彻刋刦刼劵剗劔効勅簕蕂勠蘍𦬓包𨫞啉滙𣾀𠥔𣿬匳卄𠯢泋𡜦栛珕恊㺪㣌𡛨燝䒢卭却𨚫卾卿𡖖𡘓矦厓𨪛厠厫厮玧𥝲㽙玜叁叅汉义埾叙㪫𠮏叠𣿫𢶣叶𠱷吓灹唫晗浛呭𦭓𠵴啝咏咤䞦𡜍𠻝㶴𠵍"],["fb40","𨦼𢚘啇䳭启琗喆喩嘅𡣗𤀺䕒𤐵暳𡂴嘷曍𣊊暤暭噍噏磱囱鞇叾圀囯园𨭦㘣𡉏坆𤆥汮炋坂㚱𦱾埦𡐖堃𡑔𤍣堦𤯵塜墪㕡壠壜𡈼壻寿坃𪅐𤉸鏓㖡够梦㛃湙"],["fba1","𡘾娤啓𡚒蔅姉𠵎𦲁𦴪𡟜姙𡟻𡞲𦶦浱𡠨𡛕姹𦹅媫婣㛦𤦩婷㜈媖瑥嫓𦾡𢕔㶅𡤑㜲𡚸広勐孶斈孼𧨎䀄䡝𠈄寕慠𡨴𥧌𠖥寳宝䴐尅𡭄尓珎尔𡲥𦬨屉䣝岅峩峯嶋𡷹𡸷崐崘嵆𡺤岺巗苼㠭𤤁𢁉𢅳芇㠶㯂帮檊幵幺𤒼𠳓厦亷廐厨𡝱帉廴𨒂"],["fc40","廹廻㢠廼栾鐛弍𠇁弢㫞䢮𡌺强𦢈𢏐彘𢑱彣鞽𦹮彲鍀𨨶徧嶶㵟𥉐𡽪𧃸𢙨釖𠊞𨨩怱暅𡡷㥣㷇㘹垐𢞴祱㹀悞悤悳𤦂𤦏𧩓璤僡媠慤萤慂慈𦻒憁凴𠙖憇宪𣾷"],["fca1","𢡟懓𨮝𩥝懐㤲𢦀𢣁怣慜攞掋𠄘担𡝰拕𢸍捬𤧟㨗搸揸𡎎𡟼撐澊𢸶頔𤂌𥜝擡擥鑻㩦携㩗敍漖𤨨𤨣斅敭敟𣁾斵𤥀䬷旑䃘𡠩无旣忟𣐀昘𣇷𣇸晄𣆤𣆥晋𠹵晧𥇦晳晴𡸽𣈱𨗴𣇈𥌓矅𢣷馤朂𤎜𤨡㬫槺𣟂杞杧杢𤇍𩃭柗䓩栢湐鈼栁𣏦𦶠桝"],["fd40","𣑯槡樋𨫟楳棃𣗍椁椀㴲㨁𣘼㮀枬楡𨩊䋼椶榘㮡𠏉荣傐槹𣙙𢄪橅𣜃檝㯳枱櫈𩆜㰍欝𠤣惞欵歴𢟍溵𣫛𠎵𡥘㝀吡𣭚毡𣻼毜氷𢒋𤣱𦭑汚舦汹𣶼䓅𣶽𤆤𤤌𤤀"],["fda1","𣳉㛥㳫𠴲鮃𣇹𢒑羏样𦴥𦶡𦷫涖浜湼漄𤥿𤂅𦹲蔳𦽴凇沜渝萮𨬡港𣸯瑓𣾂秌湏媑𣁋濸㜍澝𣸰滺𡒗𤀽䕕鏰潄潜㵎潴𩅰㴻澟𤅄濓𤂑𤅕𤀹𣿰𣾴𤄿凟𤅖𤅗𤅀𦇝灋灾炧炁烌烕烖烟䄄㷨熴熖𤉷焫煅媈煊煮岜𤍥煏鍢𤋁焬𤑚𤨧𤨢熺𨯨炽爎"],["fe40","鑂爕夑鑃爤鍁𥘅爮牀𤥴梽牕牗㹕𣁄栍漽犂猪猫𤠣𨠫䣭𨠄猨献珏玪𠰺𦨮珉瑉𤇢𡛧𤨤昣㛅𤦷𤦍𤧻珷琕椃𤨦琹𠗃㻗瑜𢢭瑠𨺲瑇珤瑶莹瑬㜰瑴鏱樬璂䥓𤪌"],["fea1","𤅟𤩹𨮏孆𨰃𡢞瓈𡦈甎瓩甞𨻙𡩋寗𨺬鎅畍畊畧畮𤾂㼄𤴓疎瑝疞疴瘂瘬癑癏癯癶𦏵皐臯㟸𦤑𦤎皡皥皷盌𦾟葢𥂝𥅽𡸜眞眦着撯𥈠睘𣊬瞯𨥤𨥨𡛁矴砉𡍶𤨒棊碯磇磓隥礮𥗠磗礴碱𧘌辸袄𨬫𦂃𢘜禆褀椂禀𥡗禝𧬹礼禩渪𧄦㺨秆𩄍秔"]]',
      );
    },
    3336: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127,"€"],["8140","丂丄丅丆丏丒丗丟丠両丣並丩丮丯丱丳丵丷丼乀乁乂乄乆乊乑乕乗乚乛乢乣乤乥乧乨乪",5,"乲乴",9,"乿",6,"亇亊"],["8180","亐亖亗亙亜亝亞亣亪亯亰亱亴亶亷亸亹亼亽亾仈仌仏仐仒仚仛仜仠仢仦仧仩仭仮仯仱仴仸仹仺仼仾伀伂",6,"伋伌伒",4,"伜伝伡伣伨伩伬伭伮伱伳伵伷伹伻伾",4,"佄佅佇",5,"佒佔佖佡佢佦佨佪佫佭佮佱佲併佷佸佹佺佽侀侁侂侅來侇侊侌侎侐侒侓侕侖侘侙侚侜侞侟価侢"],["8240","侤侫侭侰",4,"侶",8,"俀俁係俆俇俈俉俋俌俍俒",4,"俙俛俠俢俤俥俧俫俬俰俲俴俵俶俷俹俻俼俽俿",11],["8280","個倎倐們倓倕倖倗倛倝倞倠倢倣値倧倫倯",10,"倻倽倿偀偁偂偄偅偆偉偊偋偍偐",4,"偖偗偘偙偛偝",7,"偦",5,"偭",8,"偸偹偺偼偽傁傂傃傄傆傇傉傊傋傌傎",20,"傤傦傪傫傭",4,"傳",6,"傼"],["8340","傽",17,"僐",5,"僗僘僙僛",10,"僨僩僪僫僯僰僱僲僴僶",4,"僼",9,"儈"],["8380","儉儊儌",5,"儓",13,"儢",28,"兂兇兊兌兎兏児兒兓兗兘兙兛兝",4,"兣兤兦內兩兪兯兲兺兾兿冃冄円冇冊冋冎冏冐冑冓冔冘冚冝冞冟冡冣冦",4,"冭冮冴冸冹冺冾冿凁凂凃凅凈凊凍凎凐凒",5],["8440","凘凙凚凜凞凟凢凣凥",5,"凬凮凱凲凴凷凾刄刅刉刋刌刏刐刓刔刕刜刞刟刡刢刣別刦刧刪刬刯刱刲刴刵刼刾剄",5,"剋剎剏剒剓剕剗剘"],["8480","剙剚剛剝剟剠剢剣剤剦剨剫剬剭剮剰剱剳",9,"剾劀劃",4,"劉",6,"劑劒劔",6,"劜劤劥劦劧劮劯劰労",9,"勀勁勂勄勅勆勈勊勌勍勎勏勑勓勔動勗務",5,"勠勡勢勣勥",10,"勱",7,"勻勼勽匁匂匃匄匇匉匊匋匌匎"],["8540","匑匒匓匔匘匛匜匞匟匢匤匥匧匨匩匫匬匭匯",9,"匼匽區卂卄卆卋卌卍卐協単卙卛卝卥卨卪卬卭卲卶卹卻卼卽卾厀厁厃厇厈厊厎厏"],["8580","厐",4,"厖厗厙厛厜厞厠厡厤厧厪厫厬厭厯",6,"厷厸厹厺厼厽厾叀參",4,"収叏叐叒叓叕叚叜叝叞叡叢叧叴叺叾叿吀吂吅吇吋吔吘吙吚吜吢吤吥吪吰吳吶吷吺吽吿呁呂呄呅呇呉呌呍呎呏呑呚呝",4,"呣呥呧呩",7,"呴呹呺呾呿咁咃咅咇咈咉咊咍咑咓咗咘咜咞咟咠咡"],["8640","咢咥咮咰咲咵咶咷咹咺咼咾哃哅哊哋哖哘哛哠",4,"哫哬哯哰哱哴",5,"哻哾唀唂唃唄唅唈唊",4,"唒唓唕",5,"唜唝唞唟唡唥唦"],["8680","唨唩唫唭唲唴唵唶唸唹唺唻唽啀啂啅啇啈啋",4,"啑啒啓啔啗",4,"啝啞啟啠啢啣啨啩啫啯",5,"啹啺啽啿喅喆喌喍喎喐喒喓喕喖喗喚喛喞喠",6,"喨",8,"喲喴営喸喺喼喿",4,"嗆嗇嗈嗊嗋嗎嗏嗐嗕嗗",4,"嗞嗠嗢嗧嗩嗭嗮嗰嗱嗴嗶嗸",4,"嗿嘂嘃嘄嘅"],["8740","嘆嘇嘊嘋嘍嘐",7,"嘙嘚嘜嘝嘠嘡嘢嘥嘦嘨嘩嘪嘫嘮嘯嘰嘳嘵嘷嘸嘺嘼嘽嘾噀",11,"噏",4,"噕噖噚噛噝",4],["8780","噣噥噦噧噭噮噯噰噲噳噴噵噷噸噹噺噽",7,"嚇",6,"嚐嚑嚒嚔",14,"嚤",10,"嚰",6,"嚸嚹嚺嚻嚽",12,"囋",8,"囕囖囘囙囜団囥",5,"囬囮囯囲図囶囷囸囻囼圀圁圂圅圇國",6],["8840","園",9,"圝圞圠圡圢圤圥圦圧圫圱圲圴",4,"圼圽圿坁坃坄坅坆坈坉坋坒",4,"坘坙坢坣坥坧坬坮坰坱坲坴坵坸坹坺坽坾坿垀"],["8880","垁垇垈垉垊垍",4,"垔",6,"垜垝垞垟垥垨垪垬垯垰垱垳垵垶垷垹",8,"埄",6,"埌埍埐埑埓埖埗埛埜埞埡埢埣埥",7,"埮埰埱埲埳埵埶執埻埼埾埿堁堃堄堅堈堉堊堌堎堏堐堒堓堔堖堗堘堚堛堜堝堟堢堣堥",4,"堫",4,"報堲堳場堶",7],["8940","堾",5,"塅",6,"塎塏塐塒塓塕塖塗塙",4,"塟",5,"塦",4,"塭",16,"塿墂墄墆墇墈墊墋墌"],["8980","墍",4,"墔",4,"墛墜墝墠",7,"墪",17,"墽墾墿壀壂壃壄壆",10,"壒壓壔壖",13,"壥",5,"壭壯壱売壴壵壷壸壺",7,"夃夅夆夈",4,"夎夐夑夒夓夗夘夛夝夞夠夡夢夣夦夨夬夰夲夳夵夶夻"],["8a40","夽夾夿奀奃奅奆奊奌奍奐奒奓奙奛",4,"奡奣奤奦",12,"奵奷奺奻奼奾奿妀妅妉妋妌妎妏妐妑妔妕妘妚妛妜妝妟妠妡妢妦"],["8a80","妧妬妭妰妱妳",5,"妺妼妽妿",6,"姇姈姉姌姍姎姏姕姖姙姛姞",4,"姤姦姧姩姪姫姭",11,"姺姼姽姾娀娂娊娋娍娎娏娐娒娔娕娖娗娙娚娛娝娞娡娢娤娦娧娨娪",6,"娳娵娷",4,"娽娾娿婁",4,"婇婈婋",9,"婖婗婘婙婛",5],["8b40","婡婣婤婥婦婨婩婫",8,"婸婹婻婼婽婾媀",17,"媓",6,"媜",13,"媫媬"],["8b80","媭",4,"媴媶媷媹",4,"媿嫀嫃",5,"嫊嫋嫍",4,"嫓嫕嫗嫙嫚嫛嫝嫞嫟嫢嫤嫥嫧嫨嫪嫬",4,"嫲",22,"嬊",11,"嬘",25,"嬳嬵嬶嬸",7,"孁",6],["8c40","孈",7,"孒孖孞孠孡孧孨孫孭孮孯孲孴孶孷學孹孻孼孾孿宂宆宊宍宎宐宑宒宔宖実宧宨宩宬宭宮宯宱宲宷宺宻宼寀寁寃寈寉寊寋寍寎寏"],["8c80","寑寔",8,"寠寢寣實寧審",4,"寯寱",6,"寽対尀専尃尅將專尋尌對導尐尒尓尗尙尛尞尟尠尡尣尦尨尩尪尫尭尮尯尰尲尳尵尶尷屃屄屆屇屌屍屒屓屔屖屗屘屚屛屜屝屟屢層屧",6,"屰屲",6,"屻屼屽屾岀岃",4,"岉岊岋岎岏岒岓岕岝",4,"岤",4],["8d40","岪岮岯岰岲岴岶岹岺岻岼岾峀峂峃峅",5,"峌",5,"峓",5,"峚",6,"峢峣峧峩峫峬峮峯峱",9,"峼",4],["8d80","崁崄崅崈",5,"崏",4,"崕崗崘崙崚崜崝崟",4,"崥崨崪崫崬崯",4,"崵",7,"崿",7,"嵈嵉嵍",10,"嵙嵚嵜嵞",10,"嵪嵭嵮嵰嵱嵲嵳嵵",12,"嶃",21,"嶚嶛嶜嶞嶟嶠"],["8e40","嶡",21,"嶸",12,"巆",6,"巎",12,"巜巟巠巣巤巪巬巭"],["8e80","巰巵巶巸",4,"巿帀帄帇帉帊帋帍帎帒帓帗帞",7,"帨",4,"帯帰帲",4,"帹帺帾帿幀幁幃幆",5,"幍",6,"幖",4,"幜幝幟幠幣",14,"幵幷幹幾庁庂広庅庈庉庌庍庎庒庘庛庝庡庢庣庤庨",4,"庮",4,"庴庺庻庼庽庿",6],["8f40","廆廇廈廋",5,"廔廕廗廘廙廚廜",11,"廩廫",8,"廵廸廹廻廼廽弅弆弇弉弌弍弎弐弒弔弖弙弚弜弝弞弡弢弣弤"],["8f80","弨弫弬弮弰弲",6,"弻弽弾弿彁",14,"彑彔彙彚彛彜彞彟彠彣彥彧彨彫彮彯彲彴彵彶彸彺彽彾彿徃徆徍徎徏徑従徔徖徚徛徝從徟徠徢",5,"復徫徬徯",5,"徶徸徹徺徻徾",4,"忇忈忊忋忎忓忔忕忚忛応忞忟忢忣忥忦忨忩忬忯忰忲忳忴忶忷忹忺忼怇"],["9040","怈怉怋怌怐怑怓怗怘怚怞怟怢怣怤怬怭怮怰",4,"怶",4,"怽怾恀恄",6,"恌恎恏恑恓恔恖恗恘恛恜恞恟恠恡恥恦恮恱恲恴恵恷恾悀"],["9080","悁悂悅悆悇悈悊悋悎悏悐悑悓悕悗悘悙悜悞悡悢悤悥悧悩悪悮悰悳悵悶悷悹悺悽",7,"惇惈惉惌",4,"惒惓惔惖惗惙惛惞惡",4,"惪惱惲惵惷惸惻",4,"愂愃愄愅愇愊愋愌愐",4,"愖愗愘愙愛愜愝愞愡愢愥愨愩愪愬",18,"慀",6],["9140","慇慉態慍慏慐慒慓慔慖",6,"慞慟慠慡慣慤慥慦慩",6,"慱慲慳慴慶慸",18,"憌憍憏",4,"憕"],["9180","憖",6,"憞",8,"憪憫憭",9,"憸",5,"憿懀懁懃",4,"應懌",4,"懓懕",16,"懧",13,"懶",8,"戀",5,"戇戉戓戔戙戜戝戞戠戣戦戧戨戩戫戭戯戰戱戲戵戶戸",4,"扂扄扅扆扊"],["9240","扏扐払扖扗扙扚扜",6,"扤扥扨扱扲扴扵扷扸扺扻扽抁抂抃抅抆抇抈抋",5,"抔抙抜抝択抣抦抧抩抪抭抮抯抰抲抳抴抶抷抸抺抾拀拁"],["9280","拃拋拏拑拕拝拞拠拡拤拪拫拰拲拵拸拹拺拻挀挃挄挅挆挊挋挌挍挏挐挒挓挔挕挗挘挙挜挦挧挩挬挭挮挰挱挳",5,"挻挼挾挿捀捁捄捇捈捊捑捒捓捔捖",7,"捠捤捥捦捨捪捫捬捯捰捲捳捴捵捸捹捼捽捾捿掁掃掄掅掆掋掍掑掓掔掕掗掙",6,"採掤掦掫掯掱掲掵掶掹掻掽掿揀"],["9340","揁揂揃揅揇揈揊揋揌揑揓揔揕揗",6,"揟揢揤",4,"揫揬揮揯揰揱揳揵揷揹揺揻揼揾搃搄搆",4,"損搎搑搒搕",5,"搝搟搢搣搤"],["9380","搥搧搨搩搫搮",5,"搵",4,"搻搼搾摀摂摃摉摋",6,"摓摕摖摗摙",4,"摟",7,"摨摪摫摬摮",9,"摻",6,"撃撆撈",8,"撓撔撗撘撚撛撜撝撟",4,"撥撦撧撨撪撫撯撱撲撳撴撶撹撻撽撾撿擁擃擄擆",6,"擏擑擓擔擕擖擙據"],["9440","擛擜擝擟擠擡擣擥擧",24,"攁",7,"攊",7,"攓",4,"攙",8],["9480","攢攣攤攦",4,"攬攭攰攱攲攳攷攺攼攽敀",4,"敆敇敊敋敍敎敐敒敓敔敗敘敚敜敟敠敡敤敥敧敨敩敪敭敮敯敱敳敵敶數",14,"斈斉斊斍斎斏斒斔斕斖斘斚斝斞斠斢斣斦斨斪斬斮斱",7,"斺斻斾斿旀旂旇旈旉旊旍旐旑旓旔旕旘",7,"旡旣旤旪旫"],["9540","旲旳旴旵旸旹旻",4,"昁昄昅昇昈昉昋昍昐昑昒昖昗昘昚昛昜昞昡昢昣昤昦昩昪昫昬昮昰昲昳昷",4,"昽昿晀時晄",6,"晍晎晐晑晘"],["9580","晙晛晜晝晞晠晢晣晥晧晩",4,"晱晲晳晵晸晹晻晼晽晿暀暁暃暅暆暈暉暊暋暍暎暏暐暒暓暔暕暘",4,"暞",8,"暩",4,"暯",4,"暵暶暷暸暺暻暼暽暿",25,"曚曞",7,"曧曨曪",5,"曱曵曶書曺曻曽朁朂會"],["9640","朄朅朆朇朌朎朏朑朒朓朖朘朙朚朜朞朠",5,"朧朩朮朰朲朳朶朷朸朹朻朼朾朿杁杄杅杇杊杋杍杒杔杕杗",4,"杝杢杣杤杦杧杫杬杮東杴杶"],["9680","杸杹杺杻杽枀枂枃枅枆枈枊枌枍枎枏枑枒枓枔枖枙枛枟枠枡枤枦枩枬枮枱枲枴枹",7,"柂柅",9,"柕柖柗柛柟柡柣柤柦柧柨柪柫柭柮柲柵",7,"柾栁栂栃栄栆栍栐栒栔栕栘",4,"栞栟栠栢",6,"栫",6,"栴栵栶栺栻栿桇桋桍桏桒桖",5],["9740","桜桝桞桟桪桬",7,"桵桸",8,"梂梄梇",7,"梐梑梒梔梕梖梘",9,"梣梤梥梩梪梫梬梮梱梲梴梶梷梸"],["9780","梹",6,"棁棃",5,"棊棌棎棏棐棑棓棔棖棗棙棛",4,"棡棢棤",9,"棯棲棳棴棶棷棸棻棽棾棿椀椂椃椄椆",4,"椌椏椑椓",11,"椡椢椣椥",7,"椮椯椱椲椳椵椶椷椸椺椻椼椾楀楁楃",16,"楕楖楘楙楛楜楟"],["9840","楡楢楤楥楧楨楩楪楬業楯楰楲",4,"楺楻楽楾楿榁榃榅榊榋榌榎",5,"榖榗榙榚榝",9,"榩榪榬榮榯榰榲榳榵榶榸榹榺榼榽"],["9880","榾榿槀槂",7,"構槍槏槑槒槓槕",5,"槜槝槞槡",11,"槮槯槰槱槳",9,"槾樀",9,"樋",11,"標",5,"樠樢",5,"権樫樬樭樮樰樲樳樴樶",6,"樿",4,"橅橆橈",7,"橑",6,"橚"],["9940","橜",4,"橢橣橤橦",10,"橲",6,"橺橻橽橾橿檁檂檃檅",8,"檏檒",4,"檘",7,"檡",5],["9980","檧檨檪檭",114,"欥欦欨",6],["9a40","欯欰欱欳欴欵欶欸欻欼欽欿歀歁歂歄歅歈歊歋歍",11,"歚",7,"歨歩歫",13,"歺歽歾歿殀殅殈"],["9a80","殌殎殏殐殑殔殕殗殘殙殜",4,"殢",7,"殫",7,"殶殸",6,"毀毃毄毆",4,"毌毎毐毑毘毚毜",4,"毢",7,"毬毭毮毰毱毲毴毶毷毸毺毻毼毾",6,"氈",4,"氎氒気氜氝氞氠氣氥氫氬氭氱氳氶氷氹氺氻氼氾氿汃汄汅汈汋",4,"汑汒汓汖汘"],["9b40","汙汚汢汣汥汦汧汫",4,"汱汳汵汷汸決汻汼汿沀沄沇沊沋沍沎沑沒沕沖沗沘沚沜沝沞沠沢沨沬沯沰沴沵沶沷沺泀況泂泃泆泇泈泋泍泎泏泑泒泘"],["9b80","泙泚泜泝泟泤泦泧泩泬泭泲泴泹泿洀洂洃洅洆洈洉洊洍洏洐洑洓洔洕洖洘洜洝洟",5,"洦洨洩洬洭洯洰洴洶洷洸洺洿浀浂浄浉浌浐浕浖浗浘浛浝浟浡浢浤浥浧浨浫浬浭浰浱浲浳浵浶浹浺浻浽",4,"涃涄涆涇涊涋涍涏涐涒涖",4,"涜涢涥涬涭涰涱涳涴涶涷涹",5,"淁淂淃淈淉淊"],["9c40","淍淎淏淐淒淓淔淕淗淚淛淜淟淢淣淥淧淨淩淪淭淯淰淲淴淵淶淸淺淽",7,"渆渇済渉渋渏渒渓渕渘渙減渜渞渟渢渦渧渨渪測渮渰渱渳渵"],["9c80","渶渷渹渻",7,"湅",7,"湏湐湑湒湕湗湙湚湜湝湞湠",10,"湬湭湯",14,"満溁溂溄溇溈溊",4,"溑",6,"溙溚溛溝溞溠溡溣溤溦溨溩溫溬溭溮溰溳溵溸溹溼溾溿滀滃滄滅滆滈滉滊滌滍滎滐滒滖滘滙滛滜滝滣滧滪",5],["9d40","滰滱滲滳滵滶滷滸滺",7,"漃漄漅漇漈漊",4,"漐漑漒漖",9,"漡漢漣漥漦漧漨漬漮漰漲漴漵漷",6,"漿潀潁潂"],["9d80","潃潄潅潈潉潊潌潎",9,"潙潚潛潝潟潠潡潣潤潥潧",5,"潯潰潱潳潵潶潷潹潻潽",6,"澅澆澇澊澋澏",12,"澝澞澟澠澢",4,"澨",10,"澴澵澷澸澺",5,"濁濃",5,"濊",6,"濓",10,"濟濢濣濤濥"],["9e40","濦",7,"濰",32,"瀒",7,"瀜",6,"瀤",6],["9e80","瀫",9,"瀶瀷瀸瀺",17,"灍灎灐",13,"灟",11,"灮灱灲灳灴灷灹灺灻災炁炂炃炄炆炇炈炋炌炍炏炐炑炓炗炘炚炛炞",12,"炰炲炴炵炶為炾炿烄烅烆烇烉烋",12,"烚"],["9f40","烜烝烞烠烡烢烣烥烪烮烰",6,"烸烺烻烼烾",10,"焋",4,"焑焒焔焗焛",10,"焧",7,"焲焳焴"],["9f80","焵焷",13,"煆煇煈煉煋煍煏",12,"煝煟",4,"煥煩",4,"煯煰煱煴煵煶煷煹煻煼煾",5,"熅",4,"熋熌熍熎熐熑熒熓熕熖熗熚",4,"熡",6,"熩熪熫熭",5,"熴熶熷熸熺",8,"燄",9,"燏",4],["a040","燖",9,"燡燢燣燤燦燨",5,"燯",9,"燺",11,"爇",19],["a080","爛爜爞",9,"爩爫爭爮爯爲爳爴爺爼爾牀",6,"牉牊牋牎牏牐牑牓牔牕牗牘牚牜牞牠牣牤牥牨牪牫牬牭牰牱牳牴牶牷牸牻牼牽犂犃犅",4,"犌犎犐犑犓",11,"犠",11,"犮犱犲犳犵犺",6,"狅狆狇狉狊狋狌狏狑狓狔狕狖狘狚狛"],["a1a1","　、。·ˉˇ¨〃々—～‖…‘’“”〔〕〈",7,"〖〗【】±×÷∶∧∨∑∏∪∩∈∷√⊥∥∠⌒⊙∫∮≡≌≈∽∝≠≮≯≤≥∞∵∴♂♀°′″℃＄¤￠￡‰§№☆★○●◎◇◆□■△▲※→←↑↓〓"],["a2a1","ⅰ",9],["a2b1","⒈",19,"⑴",19,"①",9],["a2e5","㈠",9],["a2f1","Ⅰ",11],["a3a1","！＂＃￥％",88,"￣"],["a4a1","ぁ",82],["a5a1","ァ",85],["a6a1","Α",16,"Σ",6],["a6c1","α",16,"σ",6],["a6e0","︵︶︹︺︿﹀︽︾﹁﹂﹃﹄"],["a6ee","︻︼︷︸︱"],["a6f4","︳︴"],["a7a1","А",5,"ЁЖ",25],["a7d1","а",5,"ёж",25],["a840","ˊˋ˙–―‥‵℅℉↖↗↘↙∕∟∣≒≦≧⊿═",35,"▁",6],["a880","█",7,"▓▔▕▼▽◢◣◤◥☉⊕〒〝〞"],["a8a1","āáǎàēéěèīíǐìōóǒòūúǔùǖǘǚǜüêɑ"],["a8bd","ńň"],["a8c0","ɡ"],["a8c5","ㄅ",36],["a940","〡",8,"㊣㎎㎏㎜㎝㎞㎡㏄㏎㏑㏒㏕︰￢￤"],["a959","℡㈱"],["a95c","‐"],["a960","ー゛゜ヽヾ〆ゝゞ﹉",9,"﹔﹕﹖﹗﹙",8],["a980","﹢",4,"﹨﹩﹪﹫"],["a996","〇"],["a9a4","─",75],["aa40","狜狝狟狢",5,"狪狫狵狶狹狽狾狿猀猂猄",5,"猋猌猍猏猐猑猒猔猘猙猚猟猠猣猤猦猧猨猭猯猰猲猳猵猶猺猻猼猽獀",8],["aa80","獉獊獋獌獎獏獑獓獔獕獖獘",7,"獡",10,"獮獰獱"],["ab40","獲",11,"獿",4,"玅玆玈玊玌玍玏玐玒玓玔玕玗玘玙玚玜玝玞玠玡玣",5,"玪玬玭玱玴玵玶玸玹玼玽玾玿珁珃",4],["ab80","珋珌珎珒",6,"珚珛珜珝珟珡珢珣珤珦珨珪珫珬珮珯珰珱珳",4],["ac40","珸",10,"琄琇琈琋琌琍琎琑",8,"琜",5,"琣琤琧琩琫琭琯琱琲琷",4,"琽琾琿瑀瑂",11],["ac80","瑎",6,"瑖瑘瑝瑠",12,"瑮瑯瑱",4,"瑸瑹瑺"],["ad40","瑻瑼瑽瑿璂璄璅璆璈璉璊璌璍璏璑",10,"璝璟",7,"璪",15,"璻",12],["ad80","瓈",9,"瓓",8,"瓝瓟瓡瓥瓧",6,"瓰瓱瓲"],["ae40","瓳瓵瓸",6,"甀甁甂甃甅",7,"甎甐甒甔甕甖甗甛甝甞甠",4,"甦甧甪甮甴甶甹甼甽甿畁畂畃畄畆畇畉畊畍畐畑畒畓畕畖畗畘"],["ae80","畝",7,"畧畨畩畫",6,"畳畵當畷畺",4,"疀疁疂疄疅疇"],["af40","疈疉疊疌疍疎疐疓疕疘疛疜疞疢疦",4,"疭疶疷疺疻疿痀痁痆痋痌痎痏痐痑痓痗痙痚痜痝痟痠痡痥痩痬痭痮痯痲痳痵痶痷痸痺痻痽痾瘂瘄瘆瘇"],["af80","瘈瘉瘋瘍瘎瘏瘑瘒瘓瘔瘖瘚瘜瘝瘞瘡瘣瘧瘨瘬瘮瘯瘱瘲瘶瘷瘹瘺瘻瘽癁療癄"],["b040","癅",6,"癎",5,"癕癗",4,"癝癟癠癡癢癤",6,"癬癭癮癰",7,"癹発發癿皀皁皃皅皉皊皌皍皏皐皒皔皕皗皘皚皛"],["b080","皜",7,"皥",8,"皯皰皳皵",9,"盀盁盃啊阿埃挨哎唉哀皑癌蔼矮艾碍爱隘鞍氨安俺按暗岸胺案肮昂盎凹敖熬翱袄傲奥懊澳芭捌扒叭吧笆八疤巴拔跋靶把耙坝霸罢爸白柏百摆佰败拜稗斑班搬扳般颁板版扮拌伴瓣半办绊邦帮梆榜膀绑棒磅蚌镑傍谤苞胞包褒剥"],["b140","盄盇盉盋盌盓盕盙盚盜盝盞盠",4,"盦",7,"盰盳盵盶盷盺盻盽盿眀眂眃眅眆眊県眎",10,"眛眜眝眞眡眣眤眥眧眪眫"],["b180","眬眮眰",4,"眹眻眽眾眿睂睄睅睆睈",7,"睒",7,"睜薄雹保堡饱宝抱报暴豹鲍爆杯碑悲卑北辈背贝钡倍狈备惫焙被奔苯本笨崩绷甭泵蹦迸逼鼻比鄙笔彼碧蓖蔽毕毙毖币庇痹闭敝弊必辟壁臂避陛鞭边编贬扁便变卞辨辩辫遍标彪膘表鳖憋别瘪彬斌濒滨宾摈兵冰柄丙秉饼炳"],["b240","睝睞睟睠睤睧睩睪睭",11,"睺睻睼瞁瞂瞃瞆",5,"瞏瞐瞓",11,"瞡瞣瞤瞦瞨瞫瞭瞮瞯瞱瞲瞴瞶",4],["b280","瞼瞾矀",12,"矎",8,"矘矙矚矝",4,"矤病并玻菠播拨钵波博勃搏铂箔伯帛舶脖膊渤泊驳捕卜哺补埠不布步簿部怖擦猜裁材才财睬踩采彩菜蔡餐参蚕残惭惨灿苍舱仓沧藏操糙槽曹草厕策侧册测层蹭插叉茬茶查碴搽察岔差诧拆柴豺搀掺蝉馋谗缠铲产阐颤昌猖"],["b340","矦矨矪矯矰矱矲矴矵矷矹矺矻矼砃",5,"砊砋砎砏砐砓砕砙砛砞砠砡砢砤砨砪砫砮砯砱砲砳砵砶砽砿硁硂硃硄硆硈硉硊硋硍硏硑硓硔硘硙硚"],["b380","硛硜硞",11,"硯",7,"硸硹硺硻硽",6,"场尝常长偿肠厂敞畅唱倡超抄钞朝嘲潮巢吵炒车扯撤掣彻澈郴臣辰尘晨忱沉陈趁衬撑称城橙成呈乘程惩澄诚承逞骋秤吃痴持匙池迟弛驰耻齿侈尺赤翅斥炽充冲虫崇宠抽酬畴踌稠愁筹仇绸瞅丑臭初出橱厨躇锄雏滁除楚"],["b440","碄碅碆碈碊碋碏碐碒碔碕碖碙碝碞碠碢碤碦碨",7,"碵碶碷碸確碻碼碽碿磀磂磃磄磆磇磈磌磍磎磏磑磒磓磖磗磘磚",9],["b480","磤磥磦磧磩磪磫磭",4,"磳磵磶磸磹磻",5,"礂礃礄礆",6,"础储矗搐触处揣川穿椽传船喘串疮窗幢床闯创吹炊捶锤垂春椿醇唇淳纯蠢戳绰疵茨磁雌辞慈瓷词此刺赐次聪葱囱匆从丛凑粗醋簇促蹿篡窜摧崔催脆瘁粹淬翠村存寸磋撮搓措挫错搭达答瘩打大呆歹傣戴带殆代贷袋待逮"],["b540","礍",5,"礔",9,"礟",4,"礥",14,"礵",4,"礽礿祂祃祄祅祇祊",8,"祔祕祘祙祡祣"],["b580","祤祦祩祪祫祬祮祰",6,"祹祻",4,"禂禃禆禇禈禉禋禌禍禎禐禑禒怠耽担丹单郸掸胆旦氮但惮淡诞弹蛋当挡党荡档刀捣蹈倒岛祷导到稻悼道盗德得的蹬灯登等瞪凳邓堤低滴迪敌笛狄涤翟嫡抵底地蒂第帝弟递缔颠掂滇碘点典靛垫电佃甸店惦奠淀殿碉叼雕凋刁掉吊钓调跌爹碟蝶迭谍叠"],["b640","禓",6,"禛",11,"禨",10,"禴",4,"禼禿秂秄秅秇秈秊秌秎秏秐秓秔秖秗秙",5,"秠秡秢秥秨秪"],["b680","秬秮秱",6,"秹秺秼秾秿稁稄稅稇稈稉稊稌稏",4,"稕稖稘稙稛稜丁盯叮钉顶鼎锭定订丢东冬董懂动栋侗恫冻洞兜抖斗陡豆逗痘都督毒犊独读堵睹赌杜镀肚度渡妒端短锻段断缎堆兑队对墩吨蹲敦顿囤钝盾遁掇哆多夺垛躲朵跺舵剁惰堕蛾峨鹅俄额讹娥恶厄扼遏鄂饿恩而儿耳尔饵洱二"],["b740","稝稟稡稢稤",14,"稴稵稶稸稺稾穀",5,"穇",9,"穒",4,"穘",16],["b780","穩",6,"穱穲穳穵穻穼穽穾窂窅窇窉窊窋窌窎窏窐窓窔窙窚窛窞窡窢贰发罚筏伐乏阀法珐藩帆番翻樊矾钒繁凡烦反返范贩犯饭泛坊芳方肪房防妨仿访纺放菲非啡飞肥匪诽吠肺废沸费芬酚吩氛分纷坟焚汾粉奋份忿愤粪丰封枫蜂峰锋风疯烽逢冯缝讽奉凤佛否夫敷肤孵扶拂辐幅氟符伏俘服"],["b840","窣窤窧窩窪窫窮",4,"窴",10,"竀",10,"竌",9,"竗竘竚竛竜竝竡竢竤竧",5,"竮竰竱竲竳"],["b880","竴",4,"竻竼竾笀笁笂笅笇笉笌笍笎笐笒笓笖笗笘笚笜笝笟笡笢笣笧笩笭浮涪福袱弗甫抚辅俯釜斧脯腑府腐赴副覆赋复傅付阜父腹负富讣附妇缚咐噶嘎该改概钙盖溉干甘杆柑竿肝赶感秆敢赣冈刚钢缸肛纲岗港杠篙皋高膏羔糕搞镐稿告哥歌搁戈鸽胳疙割革葛格蛤阁隔铬个各给根跟耕更庚羹"],["b940","笯笰笲笴笵笶笷笹笻笽笿",5,"筆筈筊筍筎筓筕筗筙筜筞筟筡筣",10,"筯筰筳筴筶筸筺筼筽筿箁箂箃箄箆",6,"箎箏"],["b980","箑箒箓箖箘箙箚箛箞箟箠箣箤箥箮箯箰箲箳箵箶箷箹",7,"篂篃範埂耿梗工攻功恭龚供躬公宫弓巩汞拱贡共钩勾沟苟狗垢构购够辜菇咕箍估沽孤姑鼓古蛊骨谷股故顾固雇刮瓜剐寡挂褂乖拐怪棺关官冠观管馆罐惯灌贯光广逛瑰规圭硅归龟闺轨鬼诡癸桂柜跪贵刽辊滚棍锅郭国果裹过哈"],["ba40","篅篈築篊篋篍篎篏篐篒篔",4,"篛篜篞篟篠篢篣篤篧篨篩篫篬篭篯篰篲",4,"篸篹篺篻篽篿",7,"簈簉簊簍簎簐",5,"簗簘簙"],["ba80","簚",4,"簠",5,"簨簩簫",12,"簹",5,"籂骸孩海氦亥害骇酣憨邯韩含涵寒函喊罕翰撼捍旱憾悍焊汗汉夯杭航壕嚎豪毫郝好耗号浩呵喝荷菏核禾和何合盒貉阂河涸赫褐鹤贺嘿黑痕很狠恨哼亨横衡恒轰哄烘虹鸿洪宏弘红喉侯猴吼厚候后呼乎忽瑚壶葫胡蝴狐糊湖"],["bb40","籃",9,"籎",36,"籵",5,"籾",9],["bb80","粈粊",6,"粓粔粖粙粚粛粠粡粣粦粧粨粩粫粬粭粯粰粴",4,"粺粻弧虎唬护互沪户花哗华猾滑画划化话槐徊怀淮坏欢环桓还缓换患唤痪豢焕涣宦幻荒慌黄磺蝗簧皇凰惶煌晃幌恍谎灰挥辉徽恢蛔回毁悔慧卉惠晦贿秽会烩汇讳诲绘荤昏婚魂浑混豁活伙火获或惑霍货祸击圾基机畸稽积箕"],["bc40","粿糀糂糃糄糆糉糋糎",6,"糘糚糛糝糞糡",6,"糩",5,"糰",7,"糹糺糼",13,"紋",5],["bc80","紑",14,"紡紣紤紥紦紨紩紪紬紭紮細",6,"肌饥迹激讥鸡姬绩缉吉极棘辑籍集及急疾汲即嫉级挤几脊己蓟技冀季伎祭剂悸济寄寂计记既忌际妓继纪嘉枷夹佳家加荚颊贾甲钾假稼价架驾嫁歼监坚尖笺间煎兼肩艰奸缄茧检柬碱硷拣捡简俭剪减荐槛鉴践贱见键箭件"],["bd40","紷",54,"絯",7],["bd80","絸",32,"健舰剑饯渐溅涧建僵姜将浆江疆蒋桨奖讲匠酱降蕉椒礁焦胶交郊浇骄娇嚼搅铰矫侥脚狡角饺缴绞剿教酵轿较叫窖揭接皆秸街阶截劫节桔杰捷睫竭洁结解姐戒藉芥界借介疥诫届巾筋斤金今津襟紧锦仅谨进靳晋禁近烬浸"],["be40","継",12,"綧",6,"綯",42],["be80","線",32,"尽劲荆兢茎睛晶鲸京惊精粳经井警景颈静境敬镜径痉靖竟竞净炯窘揪究纠玖韭久灸九酒厩救旧臼舅咎就疚鞠拘狙疽居驹菊局咀矩举沮聚拒据巨具距踞锯俱句惧炬剧捐鹃娟倦眷卷绢撅攫抉掘倔爵觉决诀绝均菌钧军君峻"],["bf40","緻",62],["bf80","縺縼",4,"繂",4,"繈",21,"俊竣浚郡骏喀咖卡咯开揩楷凯慨刊堪勘坎砍看康慷糠扛抗亢炕考拷烤靠坷苛柯棵磕颗科壳咳可渴克刻客课肯啃垦恳坑吭空恐孔控抠口扣寇枯哭窟苦酷库裤夸垮挎跨胯块筷侩快宽款匡筐狂框矿眶旷况亏盔岿窥葵奎魁傀"],["c040","繞",35,"纃",23,"纜纝纞"],["c080","纮纴纻纼绖绤绬绹缊缐缞缷缹缻",6,"罃罆",9,"罒罓馈愧溃坤昆捆困括扩廓阔垃拉喇蜡腊辣啦莱来赖蓝婪栏拦篮阑兰澜谰揽览懒缆烂滥琅榔狼廊郎朗浪捞劳牢老佬姥酪烙涝勒乐雷镭蕾磊累儡垒擂肋类泪棱楞冷厘梨犁黎篱狸离漓理李里鲤礼莉荔吏栗丽厉励砾历利傈例俐"],["c140","罖罙罛罜罝罞罠罣",4,"罫罬罭罯罰罳罵罶罷罸罺罻罼罽罿羀羂",7,"羋羍羏",4,"羕",4,"羛羜羠羢羣羥羦羨",6,"羱"],["c180","羳",4,"羺羻羾翀翂翃翄翆翇翈翉翋翍翏",4,"翖翗翙",5,"翢翣痢立粒沥隶力璃哩俩联莲连镰廉怜涟帘敛脸链恋炼练粮凉梁粱良两辆量晾亮谅撩聊僚疗燎寥辽潦了撂镣廖料列裂烈劣猎琳林磷霖临邻鳞淋凛赁吝拎玲菱零龄铃伶羚凌灵陵岭领另令溜琉榴硫馏留刘瘤流柳六龙聋咙笼窿"],["c240","翤翧翨翪翫翬翭翯翲翴",6,"翽翾翿耂耇耈耉耊耎耏耑耓耚耛耝耞耟耡耣耤耫",5,"耲耴耹耺耼耾聀聁聄聅聇聈聉聎聏聐聑聓聕聖聗"],["c280","聙聛",13,"聫",5,"聲",11,"隆垄拢陇楼娄搂篓漏陋芦卢颅庐炉掳卤虏鲁麓碌露路赂鹿潞禄录陆戮驴吕铝侣旅履屡缕虑氯律率滤绿峦挛孪滦卵乱掠略抡轮伦仑沦纶论萝螺罗逻锣箩骡裸落洛骆络妈麻玛码蚂马骂嘛吗埋买麦卖迈脉瞒馒蛮满蔓曼慢漫"],["c340","聾肁肂肅肈肊肍",5,"肔肕肗肙肞肣肦肧肨肬肰肳肵肶肸肹肻胅胇",4,"胏",6,"胘胟胠胢胣胦胮胵胷胹胻胾胿脀脁脃脄脅脇脈脋"],["c380","脌脕脗脙脛脜脝脟",12,"脭脮脰脳脴脵脷脹",4,"脿谩芒茫盲氓忙莽猫茅锚毛矛铆卯茂冒帽貌贸么玫枚梅酶霉煤没眉媒镁每美昧寐妹媚门闷们萌蒙檬盟锰猛梦孟眯醚靡糜迷谜弥米秘觅泌蜜密幂棉眠绵冕免勉娩缅面苗描瞄藐秒渺庙妙蔑灭民抿皿敏悯闽明螟鸣铭名命谬摸"],["c440","腀",5,"腇腉腍腎腏腒腖腗腘腛",4,"腡腢腣腤腦腨腪腫腬腯腲腳腵腶腷腸膁膃",4,"膉膋膌膍膎膐膒",5,"膙膚膞",4,"膤膥"],["c480","膧膩膫",7,"膴",5,"膼膽膾膿臄臅臇臈臉臋臍",6,"摹蘑模膜磨摩魔抹末莫墨默沫漠寞陌谋牟某拇牡亩姆母墓暮幕募慕木目睦牧穆拿哪呐钠那娜纳氖乃奶耐奈南男难囊挠脑恼闹淖呢馁内嫩能妮霓倪泥尼拟你匿腻逆溺蔫拈年碾撵捻念娘酿鸟尿捏聂孽啮镊镍涅您柠狞凝宁"],["c540","臔",14,"臤臥臦臨臩臫臮",4,"臵",5,"臽臿舃與",4,"舎舏舑舓舕",5,"舝舠舤舥舦舧舩舮舲舺舼舽舿"],["c580","艀艁艂艃艅艆艈艊艌艍艎艐",7,"艙艛艜艝艞艠",7,"艩拧泞牛扭钮纽脓浓农弄奴努怒女暖虐疟挪懦糯诺哦欧鸥殴藕呕偶沤啪趴爬帕怕琶拍排牌徘湃派攀潘盘磐盼畔判叛乓庞旁耪胖抛咆刨炮袍跑泡呸胚培裴赔陪配佩沛喷盆砰抨烹澎彭蓬棚硼篷膨朋鹏捧碰坯砒霹批披劈琵毗"],["c640","艪艫艬艭艱艵艶艷艸艻艼芀芁芃芅芆芇芉芌芐芓芔芕芖芚芛芞芠芢芣芧芲芵芶芺芻芼芿苀苂苃苅苆苉苐苖苙苚苝苢苧苨苩苪苬苭苮苰苲苳苵苶苸"],["c680","苺苼",4,"茊茋茍茐茒茓茖茘茙茝",9,"茩茪茮茰茲茷茻茽啤脾疲皮匹痞僻屁譬篇偏片骗飘漂瓢票撇瞥拼频贫品聘乒坪苹萍平凭瓶评屏坡泼颇婆破魄迫粕剖扑铺仆莆葡菩蒲埔朴圃普浦谱曝瀑期欺栖戚妻七凄漆柒沏其棋奇歧畦崎脐齐旗祈祁骑起岂乞企启契砌器气迄弃汽泣讫掐"],["c740","茾茿荁荂荄荅荈荊",4,"荓荕",4,"荝荢荰",6,"荹荺荾",6,"莇莈莊莋莌莍莏莐莑莔莕莖莗莙莚莝莟莡",6,"莬莭莮"],["c780","莯莵莻莾莿菂菃菄菆菈菉菋菍菎菐菑菒菓菕菗菙菚菛菞菢菣菤菦菧菨菫菬菭恰洽牵扦钎铅千迁签仟谦乾黔钱钳前潜遣浅谴堑嵌欠歉枪呛腔羌墙蔷强抢橇锹敲悄桥瞧乔侨巧鞘撬翘峭俏窍切茄且怯窃钦侵亲秦琴勤芹擒禽寝沁青轻氢倾卿清擎晴氰情顷请庆琼穷秋丘邱球求囚酋泅趋区蛆曲躯屈驱渠"],["c840","菮華菳",4,"菺菻菼菾菿萀萂萅萇萈萉萊萐萒",5,"萙萚萛萞",5,"萩",7,"萲",5,"萹萺萻萾",7,"葇葈葉"],["c880","葊",6,"葒",4,"葘葝葞葟葠葢葤",4,"葪葮葯葰葲葴葷葹葻葼取娶龋趣去圈颧权醛泉全痊拳犬券劝缺炔瘸却鹊榷确雀裙群然燃冉染瓤壤攘嚷让饶扰绕惹热壬仁人忍韧任认刃妊纫扔仍日戎茸蓉荣融熔溶容绒冗揉柔肉茹蠕儒孺如辱乳汝入褥软阮蕊瑞锐闰润若弱撒洒萨腮鳃塞赛三叁"],["c940","葽",4,"蒃蒄蒅蒆蒊蒍蒏",7,"蒘蒚蒛蒝蒞蒟蒠蒢",12,"蒰蒱蒳蒵蒶蒷蒻蒼蒾蓀蓂蓃蓅蓆蓇蓈蓋蓌蓎蓏蓒蓔蓕蓗"],["c980","蓘",4,"蓞蓡蓢蓤蓧",4,"蓭蓮蓯蓱",10,"蓽蓾蔀蔁蔂伞散桑嗓丧搔骚扫嫂瑟色涩森僧莎砂杀刹沙纱傻啥煞筛晒珊苫杉山删煽衫闪陕擅赡膳善汕扇缮墒伤商赏晌上尚裳梢捎稍烧芍勺韶少哨邵绍奢赊蛇舌舍赦摄射慑涉社设砷申呻伸身深娠绅神沈审婶甚肾慎渗声生甥牲升绳"],["ca40","蔃",8,"蔍蔎蔏蔐蔒蔔蔕蔖蔘蔙蔛蔜蔝蔞蔠蔢",8,"蔭",9,"蔾",4,"蕄蕅蕆蕇蕋",10],["ca80","蕗蕘蕚蕛蕜蕝蕟",4,"蕥蕦蕧蕩",8,"蕳蕵蕶蕷蕸蕼蕽蕿薀薁省盛剩胜圣师失狮施湿诗尸虱十石拾时什食蚀实识史矢使屎驶始式示士世柿事拭誓逝势是嗜噬适仕侍释饰氏市恃室视试收手首守寿授售受瘦兽蔬枢梳殊抒输叔舒淑疏书赎孰熟薯暑曙署蜀黍鼠属术述树束戍竖墅庶数漱"],["cb40","薂薃薆薈",6,"薐",10,"薝",6,"薥薦薧薩薫薬薭薱",5,"薸薺",6,"藂",6,"藊",4,"藑藒"],["cb80","藔藖",5,"藝",6,"藥藦藧藨藪",14,"恕刷耍摔衰甩帅栓拴霜双爽谁水睡税吮瞬顺舜说硕朔烁斯撕嘶思私司丝死肆寺嗣四伺似饲巳松耸怂颂送宋讼诵搜艘擞嗽苏酥俗素速粟僳塑溯宿诉肃酸蒜算虽隋随绥髓碎岁穗遂隧祟孙损笋蓑梭唆缩琐索锁所塌他它她塔"],["cc40","藹藺藼藽藾蘀",4,"蘆",10,"蘒蘓蘔蘕蘗",15,"蘨蘪",13,"蘹蘺蘻蘽蘾蘿虀"],["cc80","虁",11,"虒虓處",4,"虛虜虝號虠虡虣",7,"獭挞蹋踏胎苔抬台泰酞太态汰坍摊贪瘫滩坛檀痰潭谭谈坦毯袒碳探叹炭汤塘搪堂棠膛唐糖倘躺淌趟烫掏涛滔绦萄桃逃淘陶讨套特藤腾疼誊梯剔踢锑提题蹄啼体替嚏惕涕剃屉天添填田甜恬舔腆挑条迢眺跳贴铁帖厅听烃"],["cd40","虭虯虰虲",6,"蚃",6,"蚎",4,"蚔蚖",5,"蚞",4,"蚥蚦蚫蚭蚮蚲蚳蚷蚸蚹蚻",4,"蛁蛂蛃蛅蛈蛌蛍蛒蛓蛕蛖蛗蛚蛜"],["cd80","蛝蛠蛡蛢蛣蛥蛦蛧蛨蛪蛫蛬蛯蛵蛶蛷蛺蛻蛼蛽蛿蜁蜄蜅蜆蜋蜌蜎蜏蜐蜑蜔蜖汀廷停亭庭挺艇通桐酮瞳同铜彤童桶捅筒统痛偷投头透凸秃突图徒途涂屠土吐兔湍团推颓腿蜕褪退吞屯臀拖托脱鸵陀驮驼椭妥拓唾挖哇蛙洼娃瓦袜歪外豌弯湾玩顽丸烷完碗挽晚皖惋宛婉万腕汪王亡枉网往旺望忘妄威"],["ce40","蜙蜛蜝蜟蜠蜤蜦蜧蜨蜪蜫蜬蜭蜯蜰蜲蜳蜵蜶蜸蜹蜺蜼蜽蝀",6,"蝊蝋蝍蝏蝐蝑蝒蝔蝕蝖蝘蝚",5,"蝡蝢蝦",7,"蝯蝱蝲蝳蝵"],["ce80","蝷蝸蝹蝺蝿螀螁螄螆螇螉螊螌螎",4,"螔螕螖螘",6,"螠",4,"巍微危韦违桅围唯惟为潍维苇萎委伟伪尾纬未蔚味畏胃喂魏位渭谓尉慰卫瘟温蚊文闻纹吻稳紊问嗡翁瓮挝蜗涡窝我斡卧握沃巫呜钨乌污诬屋无芜梧吾吴毋武五捂午舞伍侮坞戊雾晤物勿务悟误昔熙析西硒矽晰嘻吸锡牺"],["cf40","螥螦螧螩螪螮螰螱螲螴螶螷螸螹螻螼螾螿蟁",4,"蟇蟈蟉蟌",4,"蟔",6,"蟜蟝蟞蟟蟡蟢蟣蟤蟦蟧蟨蟩蟫蟬蟭蟯",9],["cf80","蟺蟻蟼蟽蟿蠀蠁蠂蠄",5,"蠋",7,"蠔蠗蠘蠙蠚蠜",4,"蠣稀息希悉膝夕惜熄烯溪汐犀檄袭席习媳喜铣洗系隙戏细瞎虾匣霞辖暇峡侠狭下厦夏吓掀锨先仙鲜纤咸贤衔舷闲涎弦嫌显险现献县腺馅羡宪陷限线相厢镶香箱襄湘乡翔祥详想响享项巷橡像向象萧硝霄削哮嚣销消宵淆晓"],["d040","蠤",13,"蠳",5,"蠺蠻蠽蠾蠿衁衂衃衆",5,"衎",5,"衕衖衘衚",6,"衦衧衪衭衯衱衳衴衵衶衸衹衺"],["d080","衻衼袀袃袆袇袉袊袌袎袏袐袑袓袔袕袗",4,"袝",4,"袣袥",5,"小孝校肖啸笑效楔些歇蝎鞋协挟携邪斜胁谐写械卸蟹懈泄泻谢屑薪芯锌欣辛新忻心信衅星腥猩惺兴刑型形邢行醒幸杏性姓兄凶胸匈汹雄熊休修羞朽嗅锈秀袖绣墟戌需虚嘘须徐许蓄酗叙旭序畜恤絮婿绪续轩喧宣悬旋玄"],["d140","袬袮袯袰袲",4,"袸袹袺袻袽袾袿裀裃裄裇裈裊裋裌裍裏裐裑裓裖裗裚",4,"裠裡裦裧裩",6,"裲裵裶裷裺裻製裿褀褁褃",5],["d180","褉褋",4,"褑褔",4,"褜",4,"褢褣褤褦褧褨褩褬褭褮褯褱褲褳褵褷选癣眩绚靴薛学穴雪血勋熏循旬询寻驯巡殉汛训讯逊迅压押鸦鸭呀丫芽牙蚜崖衙涯雅哑亚讶焉咽阉烟淹盐严研蜒岩延言颜阎炎沿奄掩眼衍演艳堰燕厌砚雁唁彦焰宴谚验殃央鸯秧杨扬佯疡羊洋阳氧仰痒养样漾邀腰妖瑶"],["d240","褸",8,"襂襃襅",24,"襠",5,"襧",19,"襼"],["d280","襽襾覀覂覄覅覇",26,"摇尧遥窑谣姚咬舀药要耀椰噎耶爷野冶也页掖业叶曳腋夜液一壹医揖铱依伊衣颐夷遗移仪胰疑沂宜姨彝椅蚁倚已乙矣以艺抑易邑屹亿役臆逸肄疫亦裔意毅忆义益溢诣议谊译异翼翌绎茵荫因殷音阴姻吟银淫寅饮尹引隐"],["d340","覢",30,"觃觍觓觔觕觗觘觙觛觝觟觠觡觢觤觧觨觩觪觬觭觮觰觱觲觴",6],["d380","觻",4,"訁",5,"計",21,"印英樱婴鹰应缨莹萤营荧蝇迎赢盈影颖硬映哟拥佣臃痈庸雍踊蛹咏泳涌永恿勇用幽优悠忧尤由邮铀犹油游酉有友右佑釉诱又幼迂淤于盂榆虞愚舆余俞逾鱼愉渝渔隅予娱雨与屿禹宇语羽玉域芋郁吁遇喻峪御愈欲狱育誉"],["d440","訞",31,"訿",8,"詉",21],["d480","詟",25,"詺",6,"浴寓裕预豫驭鸳渊冤元垣袁原援辕园员圆猿源缘远苑愿怨院曰约越跃钥岳粤月悦阅耘云郧匀陨允运蕴酝晕韵孕匝砸杂栽哉灾宰载再在咱攒暂赞赃脏葬遭糟凿藻枣早澡蚤躁噪造皂灶燥责择则泽贼怎增憎曾赠扎喳渣札轧"],["d540","誁",7,"誋",7,"誔",46],["d580","諃",32,"铡闸眨栅榨咋乍炸诈摘斋宅窄债寨瞻毡詹粘沾盏斩辗崭展蘸栈占战站湛绽樟章彰漳张掌涨杖丈帐账仗胀瘴障招昭找沼赵照罩兆肇召遮折哲蛰辙者锗蔗这浙珍斟真甄砧臻贞针侦枕疹诊震振镇阵蒸挣睁征狰争怔整拯正政"],["d640","諤",34,"謈",27],["d680","謤謥謧",30,"帧症郑证芝枝支吱蜘知肢脂汁之织职直植殖执值侄址指止趾只旨纸志挚掷至致置帜峙制智秩稚质炙痔滞治窒中盅忠钟衷终种肿重仲众舟周州洲诌粥轴肘帚咒皱宙昼骤珠株蛛朱猪诸诛逐竹烛煮拄瞩嘱主著柱助蛀贮铸筑"],["d740","譆",31,"譧",4,"譭",25],["d780","讇",24,"讬讱讻诇诐诪谉谞住注祝驻抓爪拽专砖转撰赚篆桩庄装妆撞壮状椎锥追赘坠缀谆准捉拙卓桌琢茁酌啄着灼浊兹咨资姿滋淄孜紫仔籽滓子自渍字鬃棕踪宗综总纵邹走奏揍租足卒族祖诅阻组钻纂嘴醉最罪尊遵昨左佐柞做作坐座"],["d840","谸",8,"豂豃豄豅豈豊豋豍",7,"豖豗豘豙豛",5,"豣",6,"豬",6,"豴豵豶豷豻",6,"貃貄貆貇"],["d880","貈貋貍",6,"貕貖貗貙",20,"亍丌兀丐廿卅丕亘丞鬲孬噩丨禺丿匕乇夭爻卮氐囟胤馗毓睾鼗丶亟鼐乜乩亓芈孛啬嘏仄厍厝厣厥厮靥赝匚叵匦匮匾赜卦卣刂刈刎刭刳刿剀剌剞剡剜蒯剽劂劁劐劓冂罔亻仃仉仂仨仡仫仞伛仳伢佤仵伥伧伉伫佞佧攸佚佝"],["d940","貮",62],["d980","賭",32,"佟佗伲伽佶佴侑侉侃侏佾佻侪佼侬侔俦俨俪俅俚俣俜俑俟俸倩偌俳倬倏倮倭俾倜倌倥倨偾偃偕偈偎偬偻傥傧傩傺僖儆僭僬僦僮儇儋仝氽佘佥俎龠汆籴兮巽黉馘冁夔勹匍訇匐凫夙兕亠兖亳衮袤亵脔裒禀嬴蠃羸冫冱冽冼"],["da40","贎",14,"贠赑赒赗赟赥赨赩赪赬赮赯赱赲赸",8,"趂趃趆趇趈趉趌",4,"趒趓趕",9,"趠趡"],["da80","趢趤",12,"趲趶趷趹趻趽跀跁跂跅跇跈跉跊跍跐跒跓跔凇冖冢冥讠讦讧讪讴讵讷诂诃诋诏诎诒诓诔诖诘诙诜诟诠诤诨诩诮诰诳诶诹诼诿谀谂谄谇谌谏谑谒谔谕谖谙谛谘谝谟谠谡谥谧谪谫谮谯谲谳谵谶卩卺阝阢阡阱阪阽阼陂陉陔陟陧陬陲陴隈隍隗隰邗邛邝邙邬邡邴邳邶邺"],["db40","跕跘跙跜跠跡跢跥跦跧跩跭跮跰跱跲跴跶跼跾",6,"踆踇踈踋踍踎踐踑踒踓踕",7,"踠踡踤",4,"踫踭踰踲踳踴踶踷踸踻踼踾"],["db80","踿蹃蹅蹆蹌",4,"蹓",5,"蹚",11,"蹧蹨蹪蹫蹮蹱邸邰郏郅邾郐郄郇郓郦郢郜郗郛郫郯郾鄄鄢鄞鄣鄱鄯鄹酃酆刍奂劢劬劭劾哿勐勖勰叟燮矍廴凵凼鬯厶弁畚巯坌垩垡塾墼壅壑圩圬圪圳圹圮圯坜圻坂坩垅坫垆坼坻坨坭坶坳垭垤垌垲埏垧垴垓垠埕埘埚埙埒垸埴埯埸埤埝"],["dc40","蹳蹵蹷",4,"蹽蹾躀躂躃躄躆躈",6,"躑躒躓躕",6,"躝躟",11,"躭躮躰躱躳",6,"躻",7],["dc80","軃",10,"軏",21,"堋堍埽埭堀堞堙塄堠塥塬墁墉墚墀馨鼙懿艹艽艿芏芊芨芄芎芑芗芙芫芸芾芰苈苊苣芘芷芮苋苌苁芩芴芡芪芟苄苎芤苡茉苷苤茏茇苜苴苒苘茌苻苓茑茚茆茔茕苠苕茜荑荛荜茈莒茼茴茱莛荞茯荏荇荃荟荀茗荠茭茺茳荦荥"],["dd40","軥",62],["dd80","輤",32,"荨茛荩荬荪荭荮莰荸莳莴莠莪莓莜莅荼莶莩荽莸荻莘莞莨莺莼菁萁菥菘堇萘萋菝菽菖萜萸萑萆菔菟萏萃菸菹菪菅菀萦菰菡葜葑葚葙葳蒇蒈葺蒉葸萼葆葩葶蒌蒎萱葭蓁蓍蓐蓦蒽蓓蓊蒿蒺蓠蒡蒹蒴蒗蓥蓣蔌甍蔸蓰蔹蔟蔺"],["de40","轅",32,"轪辀辌辒辝辠辡辢辤辥辦辧辪辬辭辮辯農辳辴辵辷辸辺辻込辿迀迃迆"],["de80","迉",4,"迏迒迖迗迚迠迡迣迧迬迯迱迲迴迵迶迺迻迼迾迿逇逈逌逎逓逕逘蕖蔻蓿蓼蕙蕈蕨蕤蕞蕺瞢蕃蕲蕻薤薨薇薏蕹薮薜薅薹薷薰藓藁藜藿蘧蘅蘩蘖蘼廾弈夼奁耷奕奚奘匏尢尥尬尴扌扪抟抻拊拚拗拮挢拶挹捋捃掭揶捱捺掎掴捭掬掊捩掮掼揲揸揠揿揄揞揎摒揆掾摅摁搋搛搠搌搦搡摞撄摭撖"],["df40","這逜連逤逥逧",5,"逰",4,"逷逹逺逽逿遀遃遅遆遈",4,"過達違遖遙遚遜",5,"遤遦遧適遪遫遬遯",4,"遶",6,"遾邁"],["df80","還邅邆邇邉邊邌",4,"邒邔邖邘邚邜邞邟邠邤邥邧邨邩邫邭邲邷邼邽邿郀摺撷撸撙撺擀擐擗擤擢攉攥攮弋忒甙弑卟叱叽叩叨叻吒吖吆呋呒呓呔呖呃吡呗呙吣吲咂咔呷呱呤咚咛咄呶呦咝哐咭哂咴哒咧咦哓哔呲咣哕咻咿哌哙哚哜咩咪咤哝哏哞唛哧唠哽唔哳唢唣唏唑唧唪啧喏喵啉啭啁啕唿啐唼"],["e040","郂郃郆郈郉郋郌郍郒郔郕郖郘郙郚郞郟郠郣郤郥郩郪郬郮郰郱郲郳郵郶郷郹郺郻郼郿鄀鄁鄃鄅",19,"鄚鄛鄜"],["e080","鄝鄟鄠鄡鄤",10,"鄰鄲",6,"鄺",8,"酄唷啖啵啶啷唳唰啜喋嗒喃喱喹喈喁喟啾嗖喑啻嗟喽喾喔喙嗪嗷嗉嘟嗑嗫嗬嗔嗦嗝嗄嗯嗥嗲嗳嗌嗍嗨嗵嗤辔嘞嘈嘌嘁嘤嘣嗾嘀嘧嘭噘嘹噗嘬噍噢噙噜噌噔嚆噤噱噫噻噼嚅嚓嚯囔囗囝囡囵囫囹囿圄圊圉圜帏帙帔帑帱帻帼"],["e140","酅酇酈酑酓酔酕酖酘酙酛酜酟酠酦酧酨酫酭酳酺酻酼醀",4,"醆醈醊醎醏醓",6,"醜",5,"醤",5,"醫醬醰醱醲醳醶醷醸醹醻"],["e180","醼",10,"釈釋釐釒",9,"針",8,"帷幄幔幛幞幡岌屺岍岐岖岈岘岙岑岚岜岵岢岽岬岫岱岣峁岷峄峒峤峋峥崂崃崧崦崮崤崞崆崛嵘崾崴崽嵬嵛嵯嵝嵫嵋嵊嵩嵴嶂嶙嶝豳嶷巅彳彷徂徇徉後徕徙徜徨徭徵徼衢彡犭犰犴犷犸狃狁狎狍狒狨狯狩狲狴狷猁狳猃狺"],["e240","釦",62],["e280","鈥",32,"狻猗猓猡猊猞猝猕猢猹猥猬猸猱獐獍獗獠獬獯獾舛夥飧夤夂饣饧",5,"饴饷饽馀馄馇馊馍馐馑馓馔馕庀庑庋庖庥庠庹庵庾庳赓廒廑廛廨廪膺忄忉忖忏怃忮怄忡忤忾怅怆忪忭忸怙怵怦怛怏怍怩怫怊怿怡恸恹恻恺恂"],["e340","鉆",45,"鉵",16],["e380","銆",7,"銏",24,"恪恽悖悚悭悝悃悒悌悛惬悻悱惝惘惆惚悴愠愦愕愣惴愀愎愫慊慵憬憔憧憷懔懵忝隳闩闫闱闳闵闶闼闾阃阄阆阈阊阋阌阍阏阒阕阖阗阙阚丬爿戕氵汔汜汊沣沅沐沔沌汨汩汴汶沆沩泐泔沭泷泸泱泗沲泠泖泺泫泮沱泓泯泾"],["e440","銨",5,"銯",24,"鋉",31],["e480","鋩",32,"洹洧洌浃浈洇洄洙洎洫浍洮洵洚浏浒浔洳涑浯涞涠浞涓涔浜浠浼浣渚淇淅淞渎涿淠渑淦淝淙渖涫渌涮渫湮湎湫溲湟溆湓湔渲渥湄滟溱溘滠漭滢溥溧溽溻溷滗溴滏溏滂溟潢潆潇漤漕滹漯漶潋潴漪漉漩澉澍澌潸潲潼潺濑"],["e540","錊",51,"錿",10],["e580","鍊",31,"鍫濉澧澹澶濂濡濮濞濠濯瀚瀣瀛瀹瀵灏灞宀宄宕宓宥宸甯骞搴寤寮褰寰蹇謇辶迓迕迥迮迤迩迦迳迨逅逄逋逦逑逍逖逡逵逶逭逯遄遑遒遐遨遘遢遛暹遴遽邂邈邃邋彐彗彖彘尻咫屐屙孱屣屦羼弪弩弭艴弼鬻屮妁妃妍妩妪妣"],["e640","鍬",34,"鎐",27],["e680","鎬",29,"鏋鏌鏍妗姊妫妞妤姒妲妯姗妾娅娆姝娈姣姘姹娌娉娲娴娑娣娓婀婧婊婕娼婢婵胬媪媛婷婺媾嫫媲嫒嫔媸嫠嫣嫱嫖嫦嫘嫜嬉嬗嬖嬲嬷孀尕尜孚孥孳孑孓孢驵驷驸驺驿驽骀骁骅骈骊骐骒骓骖骘骛骜骝骟骠骢骣骥骧纟纡纣纥纨纩"],["e740","鏎",7,"鏗",54],["e780","鐎",32,"纭纰纾绀绁绂绉绋绌绐绔绗绛绠绡绨绫绮绯绱绲缍绶绺绻绾缁缂缃缇缈缋缌缏缑缒缗缙缜缛缟缡",6,"缪缫缬缭缯",4,"缵幺畿巛甾邕玎玑玮玢玟珏珂珑玷玳珀珉珈珥珙顼琊珩珧珞玺珲琏琪瑛琦琥琨琰琮琬"],["e840","鐯",14,"鐿",43,"鑬鑭鑮鑯"],["e880","鑰",20,"钑钖钘铇铏铓铔铚铦铻锜锠琛琚瑁瑜瑗瑕瑙瑷瑭瑾璜璎璀璁璇璋璞璨璩璐璧瓒璺韪韫韬杌杓杞杈杩枥枇杪杳枘枧杵枨枞枭枋杷杼柰栉柘栊柩枰栌柙枵柚枳柝栀柃枸柢栎柁柽栲栳桠桡桎桢桄桤梃栝桕桦桁桧桀栾桊桉栩梵梏桴桷梓桫棂楮棼椟椠棹"],["e940","锧锳锽镃镈镋镕镚镠镮镴镵長",7,"門",42],["e980","閫",32,"椤棰椋椁楗棣椐楱椹楠楂楝榄楫榀榘楸椴槌榇榈槎榉楦楣楹榛榧榻榫榭槔榱槁槊槟榕槠榍槿樯槭樗樘橥槲橄樾檠橐橛樵檎橹樽樨橘橼檑檐檩檗檫猷獒殁殂殇殄殒殓殍殚殛殡殪轫轭轱轲轳轵轶轸轷轹轺轼轾辁辂辄辇辋"],["ea40","闌",27,"闬闿阇阓阘阛阞阠阣",6,"阫阬阭阯阰阷阸阹阺阾陁陃陊陎陏陑陒陓陖陗"],["ea80","陘陙陚陜陝陞陠陣陥陦陫陭",4,"陳陸",12,"隇隉隊辍辎辏辘辚軎戋戗戛戟戢戡戥戤戬臧瓯瓴瓿甏甑甓攴旮旯旰昊昙杲昃昕昀炅曷昝昴昱昶昵耆晟晔晁晏晖晡晗晷暄暌暧暝暾曛曜曦曩贲贳贶贻贽赀赅赆赈赉赇赍赕赙觇觊觋觌觎觏觐觑牮犟牝牦牯牾牿犄犋犍犏犒挈挲掰"],["eb40","隌階隑隒隓隕隖隚際隝",9,"隨",7,"隱隲隴隵隷隸隺隻隿雂雃雈雊雋雐雑雓雔雖",9,"雡",6,"雫"],["eb80","雬雭雮雰雱雲雴雵雸雺電雼雽雿霂霃霅霊霋霌霐霑霒霔霕霗",4,"霝霟霠搿擘耄毪毳毽毵毹氅氇氆氍氕氘氙氚氡氩氤氪氲攵敕敫牍牒牖爰虢刖肟肜肓肼朊肽肱肫肭肴肷胧胨胩胪胛胂胄胙胍胗朐胝胫胱胴胭脍脎胲胼朕脒豚脶脞脬脘脲腈腌腓腴腙腚腱腠腩腼腽腭腧塍媵膈膂膑滕膣膪臌朦臊膻"],["ec40","霡",8,"霫霬霮霯霱霳",4,"霺霻霼霽霿",18,"靔靕靗靘靚靜靝靟靣靤靦靧靨靪",7],["ec80","靲靵靷",4,"靽",7,"鞆",4,"鞌鞎鞏鞐鞓鞕鞖鞗鞙",4,"臁膦欤欷欹歃歆歙飑飒飓飕飙飚殳彀毂觳斐齑斓於旆旄旃旌旎旒旖炀炜炖炝炻烀炷炫炱烨烊焐焓焖焯焱煳煜煨煅煲煊煸煺熘熳熵熨熠燠燔燧燹爝爨灬焘煦熹戾戽扃扈扉礻祀祆祉祛祜祓祚祢祗祠祯祧祺禅禊禚禧禳忑忐"],["ed40","鞞鞟鞡鞢鞤",6,"鞬鞮鞰鞱鞳鞵",46],["ed80","韤韥韨韮",4,"韴韷",23,"怼恝恚恧恁恙恣悫愆愍慝憩憝懋懑戆肀聿沓泶淼矶矸砀砉砗砘砑斫砭砜砝砹砺砻砟砼砥砬砣砩硎硭硖硗砦硐硇硌硪碛碓碚碇碜碡碣碲碹碥磔磙磉磬磲礅磴礓礤礞礴龛黹黻黼盱眄眍盹眇眈眚眢眙眭眦眵眸睐睑睇睃睚睨"],["ee40","頏",62],["ee80","顎",32,"睢睥睿瞍睽瞀瞌瞑瞟瞠瞰瞵瞽町畀畎畋畈畛畲畹疃罘罡罟詈罨罴罱罹羁罾盍盥蠲钅钆钇钋钊钌钍钏钐钔钗钕钚钛钜钣钤钫钪钭钬钯钰钲钴钶",4,"钼钽钿铄铈",6,"铐铑铒铕铖铗铙铘铛铞铟铠铢铤铥铧铨铪"],["ef40","顯",5,"颋颎颒颕颙颣風",37,"飏飐飔飖飗飛飜飝飠",4],["ef80","飥飦飩",30,"铩铫铮铯铳铴铵铷铹铼铽铿锃锂锆锇锉锊锍锎锏锒",4,"锘锛锝锞锟锢锪锫锩锬锱锲锴锶锷锸锼锾锿镂锵镄镅镆镉镌镎镏镒镓镔镖镗镘镙镛镞镟镝镡镢镤",8,"镯镱镲镳锺矧矬雉秕秭秣秫稆嵇稃稂稞稔"],["f040","餈",4,"餎餏餑",28,"餯",26],["f080","饊",9,"饖",12,"饤饦饳饸饹饻饾馂馃馉稹稷穑黏馥穰皈皎皓皙皤瓞瓠甬鸠鸢鸨",4,"鸲鸱鸶鸸鸷鸹鸺鸾鹁鹂鹄鹆鹇鹈鹉鹋鹌鹎鹑鹕鹗鹚鹛鹜鹞鹣鹦",6,"鹱鹭鹳疒疔疖疠疝疬疣疳疴疸痄疱疰痃痂痖痍痣痨痦痤痫痧瘃痱痼痿瘐瘀瘅瘌瘗瘊瘥瘘瘕瘙"],["f140","馌馎馚",10,"馦馧馩",47],["f180","駙",32,"瘛瘼瘢瘠癀瘭瘰瘿瘵癃瘾瘳癍癞癔癜癖癫癯翊竦穸穹窀窆窈窕窦窠窬窨窭窳衤衩衲衽衿袂袢裆袷袼裉裢裎裣裥裱褚裼裨裾裰褡褙褓褛褊褴褫褶襁襦襻疋胥皲皴矜耒耔耖耜耠耢耥耦耧耩耨耱耋耵聃聆聍聒聩聱覃顸颀颃"],["f240","駺",62],["f280","騹",32,"颉颌颍颏颔颚颛颞颟颡颢颥颦虍虔虬虮虿虺虼虻蚨蚍蚋蚬蚝蚧蚣蚪蚓蚩蚶蛄蚵蛎蚰蚺蚱蚯蛉蛏蚴蛩蛱蛲蛭蛳蛐蜓蛞蛴蛟蛘蛑蜃蜇蛸蜈蜊蜍蜉蜣蜻蜞蜥蜮蜚蜾蝈蜴蜱蜩蜷蜿螂蜢蝽蝾蝻蝠蝰蝌蝮螋蝓蝣蝼蝤蝙蝥螓螯螨蟒"],["f340","驚",17,"驲骃骉骍骎骔骕骙骦骩",6,"骲骳骴骵骹骻骽骾骿髃髄髆",4,"髍髎髏髐髒體髕髖髗髙髚髛髜"],["f380","髝髞髠髢髣髤髥髧髨髩髪髬髮髰",8,"髺髼",6,"鬄鬅鬆蟆螈螅螭螗螃螫蟥螬螵螳蟋蟓螽蟑蟀蟊蟛蟪蟠蟮蠖蠓蟾蠊蠛蠡蠹蠼缶罂罄罅舐竺竽笈笃笄笕笊笫笏筇笸笪笙笮笱笠笥笤笳笾笞筘筚筅筵筌筝筠筮筻筢筲筱箐箦箧箸箬箝箨箅箪箜箢箫箴篑篁篌篝篚篥篦篪簌篾篼簏簖簋"],["f440","鬇鬉",5,"鬐鬑鬒鬔",10,"鬠鬡鬢鬤",10,"鬰鬱鬳",7,"鬽鬾鬿魀魆魊魋魌魎魐魒魓魕",5],["f480","魛",32,"簟簪簦簸籁籀臾舁舂舄臬衄舡舢舣舭舯舨舫舸舻舳舴舾艄艉艋艏艚艟艨衾袅袈裘裟襞羝羟羧羯羰羲籼敉粑粝粜粞粢粲粼粽糁糇糌糍糈糅糗糨艮暨羿翎翕翥翡翦翩翮翳糸絷綦綮繇纛麸麴赳趄趔趑趱赧赭豇豉酊酐酎酏酤"],["f540","魼",62],["f580","鮻",32,"酢酡酰酩酯酽酾酲酴酹醌醅醐醍醑醢醣醪醭醮醯醵醴醺豕鹾趸跫踅蹙蹩趵趿趼趺跄跖跗跚跞跎跏跛跆跬跷跸跣跹跻跤踉跽踔踝踟踬踮踣踯踺蹀踹踵踽踱蹉蹁蹂蹑蹒蹊蹰蹶蹼蹯蹴躅躏躔躐躜躞豸貂貊貅貘貔斛觖觞觚觜"],["f640","鯜",62],["f680","鰛",32,"觥觫觯訾謦靓雩雳雯霆霁霈霏霎霪霭霰霾龀龃龅",5,"龌黾鼋鼍隹隼隽雎雒瞿雠銎銮鋈錾鍪鏊鎏鐾鑫鱿鲂鲅鲆鲇鲈稣鲋鲎鲐鲑鲒鲔鲕鲚鲛鲞",5,"鲥",4,"鲫鲭鲮鲰",7,"鲺鲻鲼鲽鳄鳅鳆鳇鳊鳋"],["f740","鰼",62],["f780","鱻鱽鱾鲀鲃鲄鲉鲊鲌鲏鲓鲖鲗鲘鲙鲝鲪鲬鲯鲹鲾",4,"鳈鳉鳑鳒鳚鳛鳠鳡鳌",4,"鳓鳔鳕鳗鳘鳙鳜鳝鳟鳢靼鞅鞑鞒鞔鞯鞫鞣鞲鞴骱骰骷鹘骶骺骼髁髀髅髂髋髌髑魅魃魇魉魈魍魑飨餍餮饕饔髟髡髦髯髫髻髭髹鬈鬏鬓鬟鬣麽麾縻麂麇麈麋麒鏖麝麟黛黜黝黠黟黢黩黧黥黪黯鼢鼬鼯鼹鼷鼽鼾齄"],["f840","鳣",62],["f880","鴢",32],["f940","鵃",62],["f980","鶂",32],["fa40","鶣",62],["fa80","鷢",32],["fb40","鸃",27,"鸤鸧鸮鸰鸴鸻鸼鹀鹍鹐鹒鹓鹔鹖鹙鹝鹟鹠鹡鹢鹥鹮鹯鹲鹴",9,"麀"],["fb80","麁麃麄麅麆麉麊麌",5,"麔",8,"麞麠",5,"麧麨麩麪"],["fc40","麫",8,"麵麶麷麹麺麼麿",4,"黅黆黇黈黊黋黌黐黒黓黕黖黗黙黚點黡黣黤黦黨黫黬黭黮黰",8,"黺黽黿",6],["fc80","鼆",4,"鼌鼏鼑鼒鼔鼕鼖鼘鼚",5,"鼡鼣",8,"鼭鼮鼰鼱"],["fd40","鼲",4,"鼸鼺鼼鼿",4,"齅",10,"齒",38],["fd80","齹",5,"龁龂龍",11,"龜龝龞龡",4,"郎凉秊裏隣"],["fe40","兀嗀﨎﨏﨑﨓﨔礼﨟蘒﨡﨣﨤﨧﨨﨩"]]',
      );
    },
    7348: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["8141","갂갃갅갆갋",4,"갘갞갟갡갢갣갥",6,"갮갲갳갴"],["8161","갵갶갷갺갻갽갾갿걁",9,"걌걎",5,"걕"],["8181","걖걗걙걚걛걝",18,"걲걳걵걶걹걻",4,"겂겇겈겍겎겏겑겒겓겕",6,"겞겢",5,"겫겭겮겱",6,"겺겾겿곀곂곃곅곆곇곉곊곋곍",7,"곖곘",7,"곢곣곥곦곩곫곭곮곲곴곷",4,"곾곿괁괂괃괅괇",4,"괎괐괒괓"],["8241","괔괕괖괗괙괚괛괝괞괟괡",7,"괪괫괮",5],["8261","괶괷괹괺괻괽",6,"굆굈굊",5,"굑굒굓굕굖굗"],["8281","굙",7,"굢굤",7,"굮굯굱굲굷굸굹굺굾궀궃",4,"궊궋궍궎궏궑",10,"궞",5,"궥",17,"궸",7,"귂귃귅귆귇귉",6,"귒귔",7,"귝귞귟귡귢귣귥",18],["8341","귺귻귽귾긂",5,"긊긌긎",5,"긕",7],["8361","긝",18,"긲긳긵긶긹긻긼"],["8381","긽긾긿깂깄깇깈깉깋깏깑깒깓깕깗",4,"깞깢깣깤깦깧깪깫깭깮깯깱",6,"깺깾",5,"꺆",5,"꺍",46,"꺿껁껂껃껅",6,"껎껒",5,"껚껛껝",8],["8441","껦껧껩껪껬껮",5,"껵껶껷껹껺껻껽",8],["8461","꼆꼉꼊꼋꼌꼎꼏꼑",18],["8481","꼤",7,"꼮꼯꼱꼳꼵",6,"꼾꽀꽄꽅꽆꽇꽊",5,"꽑",10,"꽞",5,"꽦",18,"꽺",5,"꾁꾂꾃꾅꾆꾇꾉",6,"꾒꾓꾔꾖",5,"꾝",26,"꾺꾻꾽꾾"],["8541","꾿꿁",5,"꿊꿌꿏",4,"꿕",6,"꿝",4],["8561","꿢",5,"꿪",5,"꿲꿳꿵꿶꿷꿹",6,"뀂뀃"],["8581","뀅",6,"뀍뀎뀏뀑뀒뀓뀕",6,"뀞",9,"뀩",26,"끆끇끉끋끍끏끐끑끒끖끘끚끛끜끞",29,"끾끿낁낂낃낅",6,"낎낐낒",5,"낛낝낞낣낤"],["8641","낥낦낧낪낰낲낶낷낹낺낻낽",6,"냆냊",5,"냒"],["8661","냓냕냖냗냙",6,"냡냢냣냤냦",10],["8681","냱",22,"넊넍넎넏넑넔넕넖넗넚넞",4,"넦넧넩넪넫넭",6,"넶넺",5,"녂녃녅녆녇녉",6,"녒녓녖녗녙녚녛녝녞녟녡",22,"녺녻녽녾녿놁놃",4,"놊놌놎놏놐놑놕놖놗놙놚놛놝"],["8741","놞",9,"놩",15],["8761","놹",18,"뇍뇎뇏뇑뇒뇓뇕"],["8781","뇖",5,"뇞뇠",7,"뇪뇫뇭뇮뇯뇱",7,"뇺뇼뇾",5,"눆눇눉눊눍",6,"눖눘눚",5,"눡",18,"눵",6,"눽",26,"뉙뉚뉛뉝뉞뉟뉡",6,"뉪",4],["8841","뉯",4,"뉶",5,"뉽",6,"늆늇늈늊",4],["8861","늏늒늓늕늖늗늛",4,"늢늤늧늨늩늫늭늮늯늱늲늳늵늶늷"],["8881","늸",15,"닊닋닍닎닏닑닓",4,"닚닜닞닟닠닡닣닧닩닪닰닱닲닶닼닽닾댂댃댅댆댇댉",6,"댒댖",5,"댝",54,"덗덙덚덝덠덡덢덣"],["8941","덦덨덪덬덭덯덲덳덵덶덷덹",6,"뎂뎆",5,"뎍"],["8961","뎎뎏뎑뎒뎓뎕",10,"뎢",5,"뎩뎪뎫뎭"],["8981","뎮",21,"돆돇돉돊돍돏돑돒돓돖돘돚돜돞돟돡돢돣돥돦돧돩",18,"돽",18,"됑",6,"됙됚됛됝됞됟됡",6,"됪됬",7,"됵",15],["8a41","둅",10,"둒둓둕둖둗둙",6,"둢둤둦"],["8a61","둧",4,"둭",18,"뒁뒂"],["8a81","뒃",4,"뒉",19,"뒞",5,"뒥뒦뒧뒩뒪뒫뒭",7,"뒶뒸뒺",5,"듁듂듃듅듆듇듉",6,"듑듒듓듔듖",5,"듞듟듡듢듥듧",4,"듮듰듲",5,"듹",26,"딖딗딙딚딝"],["8b41","딞",5,"딦딫",4,"딲딳딵딶딷딹",6,"땂땆"],["8b61","땇땈땉땊땎땏땑땒땓땕",6,"땞땢",8],["8b81","땫",52,"떢떣떥떦떧떩떬떭떮떯떲떶",4,"떾떿뗁뗂뗃뗅",6,"뗎뗒",5,"뗙",18,"뗭",18],["8c41","똀",15,"똒똓똕똖똗똙",4],["8c61","똞",6,"똦",5,"똭",6,"똵",5],["8c81","똻",12,"뙉",26,"뙥뙦뙧뙩",50,"뚞뚟뚡뚢뚣뚥",5,"뚭뚮뚯뚰뚲",16],["8d41","뛃",16,"뛕",8],["8d61","뛞",17,"뛱뛲뛳뛵뛶뛷뛹뛺"],["8d81","뛻",4,"뜂뜃뜄뜆",33,"뜪뜫뜭뜮뜱",6,"뜺뜼",7,"띅띆띇띉띊띋띍",6,"띖",9,"띡띢띣띥띦띧띩",6,"띲띴띶",5,"띾띿랁랂랃랅",6,"랎랓랔랕랚랛랝랞"],["8e41","랟랡",6,"랪랮",5,"랶랷랹",8],["8e61","럂",4,"럈럊",19],["8e81","럞",13,"럮럯럱럲럳럵",6,"럾렂",4,"렊렋렍렎렏렑",6,"렚렜렞",5,"렦렧렩렪렫렭",6,"렶렺",5,"롁롂롃롅",11,"롒롔",7,"롞롟롡롢롣롥",6,"롮롰롲",5,"롹롺롻롽",7],["8f41","뢅",7,"뢎",17],["8f61","뢠",7,"뢩",6,"뢱뢲뢳뢵뢶뢷뢹",4],["8f81","뢾뢿룂룄룆",5,"룍룎룏룑룒룓룕",7,"룞룠룢",5,"룪룫룭룮룯룱",6,"룺룼룾",5,"뤅",18,"뤙",6,"뤡",26,"뤾뤿륁륂륃륅",6,"륍륎륐륒",5],["9041","륚륛륝륞륟륡",6,"륪륬륮",5,"륶륷륹륺륻륽"],["9061","륾",5,"릆릈릋릌릏",15],["9081","릟",12,"릮릯릱릲릳릵",6,"릾맀맂",5,"맊맋맍맓",4,"맚맜맟맠맢맦맧맩맪맫맭",6,"맶맻",4,"먂",5,"먉",11,"먖",33,"먺먻먽먾먿멁멃멄멅멆"],["9141","멇멊멌멏멐멑멒멖멗멙멚멛멝",6,"멦멪",5],["9161","멲멳멵멶멷멹",9,"몆몈몉몊몋몍",5],["9181","몓",20,"몪몭몮몯몱몳",4,"몺몼몾",5,"뫅뫆뫇뫉",14,"뫚",33,"뫽뫾뫿묁묂묃묅",7,"묎묐묒",5,"묙묚묛묝묞묟묡",6],["9241","묨묪묬",7,"묷묹묺묿",4,"뭆뭈뭊뭋뭌뭎뭑뭒"],["9261","뭓뭕뭖뭗뭙",7,"뭢뭤",7,"뭭",4],["9281","뭲",21,"뮉뮊뮋뮍뮎뮏뮑",18,"뮥뮦뮧뮩뮪뮫뮭",6,"뮵뮶뮸",7,"믁믂믃믅믆믇믉",6,"믑믒믔",35,"믺믻믽믾밁"],["9341","밃",4,"밊밎밐밒밓밙밚밠밡밢밣밦밨밪밫밬밮밯밲밳밵"],["9361","밶밷밹",6,"뱂뱆뱇뱈뱊뱋뱎뱏뱑",8],["9381","뱚뱛뱜뱞",37,"벆벇벉벊벍벏",4,"벖벘벛",4,"벢벣벥벦벩",6,"벲벶",5,"벾벿볁볂볃볅",7,"볎볒볓볔볖볗볙볚볛볝",22,"볷볹볺볻볽"],["9441","볾",5,"봆봈봊",5,"봑봒봓봕",8],["9461","봞",5,"봥",6,"봭",12],["9481","봺",5,"뵁",6,"뵊뵋뵍뵎뵏뵑",6,"뵚",9,"뵥뵦뵧뵩",22,"붂붃붅붆붋",4,"붒붔붖붗붘붛붝",6,"붥",10,"붱",6,"붹",24],["9541","뷒뷓뷖뷗뷙뷚뷛뷝",11,"뷪",5,"뷱"],["9561","뷲뷳뷵뷶뷷뷹",6,"븁븂븄븆",5,"븎븏븑븒븓"],["9581","븕",6,"븞븠",35,"빆빇빉빊빋빍빏",4,"빖빘빜빝빞빟빢빣빥빦빧빩빫",4,"빲빶",4,"빾빿뺁뺂뺃뺅",6,"뺎뺒",5,"뺚",13,"뺩",14],["9641","뺸",23,"뻒뻓"],["9661","뻕뻖뻙",6,"뻡뻢뻦",5,"뻭",8],["9681","뻶",10,"뼂",5,"뼊",13,"뼚뼞",33,"뽂뽃뽅뽆뽇뽉",6,"뽒뽓뽔뽖",44],["9741","뾃",16,"뾕",8],["9761","뾞",17,"뾱",7],["9781","뾹",11,"뿆",5,"뿎뿏뿑뿒뿓뿕",6,"뿝뿞뿠뿢",89,"쀽쀾쀿"],["9841","쁀",16,"쁒",5,"쁙쁚쁛"],["9861","쁝쁞쁟쁡",6,"쁪",15],["9881","쁺",21,"삒삓삕삖삗삙",6,"삢삤삦",5,"삮삱삲삷",4,"삾샂샃샄샆샇샊샋샍샎샏샑",6,"샚샞",5,"샦샧샩샪샫샭",6,"샶샸샺",5,"섁섂섃섅섆섇섉",6,"섑섒섓섔섖",5,"섡섢섥섨섩섪섫섮"],["9941","섲섳섴섵섷섺섻섽섾섿셁",6,"셊셎",5,"셖셗"],["9961","셙셚셛셝",6,"셦셪",5,"셱셲셳셵셶셷셹셺셻"],["9981","셼",8,"솆",5,"솏솑솒솓솕솗",4,"솞솠솢솣솤솦솧솪솫솭솮솯솱",11,"솾",5,"쇅쇆쇇쇉쇊쇋쇍",6,"쇕쇖쇙",6,"쇡쇢쇣쇥쇦쇧쇩",6,"쇲쇴",7,"쇾쇿숁숂숃숅",6,"숎숐숒",5,"숚숛숝숞숡숢숣"],["9a41","숤숥숦숧숪숬숮숰숳숵",16],["9a61","쉆쉇쉉",6,"쉒쉓쉕쉖쉗쉙",6,"쉡쉢쉣쉤쉦"],["9a81","쉧",4,"쉮쉯쉱쉲쉳쉵",6,"쉾슀슂",5,"슊",5,"슑",6,"슙슚슜슞",5,"슦슧슩슪슫슮",5,"슶슸슺",33,"싞싟싡싢싥",5,"싮싰싲싳싴싵싷싺싽싾싿쌁",6,"쌊쌋쌎쌏"],["9b41","쌐쌑쌒쌖쌗쌙쌚쌛쌝",6,"쌦쌧쌪",8],["9b61","쌳",17,"썆",7],["9b81","썎",25,"썪썫썭썮썯썱썳",4,"썺썻썾",5,"쎅쎆쎇쎉쎊쎋쎍",50,"쏁",22,"쏚"],["9c41","쏛쏝쏞쏡쏣",4,"쏪쏫쏬쏮",5,"쏶쏷쏹",5],["9c61","쏿",8,"쐉",6,"쐑",9],["9c81","쐛",8,"쐥",6,"쐭쐮쐯쐱쐲쐳쐵",6,"쐾",9,"쑉",26,"쑦쑧쑩쑪쑫쑭",6,"쑶쑷쑸쑺",5,"쒁",18,"쒕",6,"쒝",12],["9d41","쒪",13,"쒹쒺쒻쒽",8],["9d61","쓆",25],["9d81","쓠",8,"쓪",5,"쓲쓳쓵쓶쓷쓹쓻쓼쓽쓾씂",9,"씍씎씏씑씒씓씕",6,"씝",10,"씪씫씭씮씯씱",6,"씺씼씾",5,"앆앇앋앏앐앑앒앖앚앛앜앟앢앣앥앦앧앩",6,"앲앶",5,"앾앿얁얂얃얅얆얈얉얊얋얎얐얒얓얔"],["9e41","얖얙얚얛얝얞얟얡",7,"얪",9,"얶"],["9e61","얷얺얿",4,"엋엍엏엒엓엕엖엗엙",6,"엢엤엦엧"],["9e81","엨엩엪엫엯엱엲엳엵엸엹엺엻옂옃옄옉옊옋옍옎옏옑",6,"옚옝",6,"옦옧옩옪옫옯옱옲옶옸옺옼옽옾옿왂왃왅왆왇왉",6,"왒왖",5,"왞왟왡",10,"왭왮왰왲",5,"왺왻왽왾왿욁",6,"욊욌욎",5,"욖욗욙욚욛욝",6,"욦"],["9f41","욨욪",5,"욲욳욵욶욷욻",4,"웂웄웆",5,"웎"],["9f61","웏웑웒웓웕",6,"웞웟웢",5,"웪웫웭웮웯웱웲"],["9f81","웳",4,"웺웻웼웾",5,"윆윇윉윊윋윍",6,"윖윘윚",5,"윢윣윥윦윧윩",6,"윲윴윶윸윹윺윻윾윿읁읂읃읅",4,"읋읎읐읙읚읛읝읞읟읡",6,"읩읪읬",7,"읶읷읹읺읻읿잀잁잂잆잋잌잍잏잒잓잕잙잛",4,"잢잧",4,"잮잯잱잲잳잵잶잷"],["a041","잸잹잺잻잾쟂",5,"쟊쟋쟍쟏쟑",6,"쟙쟚쟛쟜"],["a061","쟞",5,"쟥쟦쟧쟩쟪쟫쟭",13],["a081","쟻",4,"젂젃젅젆젇젉젋",4,"젒젔젗",4,"젞젟젡젢젣젥",6,"젮젰젲",5,"젹젺젻젽젾젿졁",6,"졊졋졎",5,"졕",26,"졲졳졵졶졷졹졻",4,"좂좄좈좉좊좎",5,"좕",7,"좞좠좢좣좤"],["a141","좥좦좧좩",18,"좾좿죀죁"],["a161","죂죃죅죆죇죉죊죋죍",6,"죖죘죚",5,"죢죣죥"],["a181","죦",14,"죶",5,"죾죿줁줂줃줇",4,"줎　、。·‥…¨〃­―∥＼∼‘’“”〔〕〈",9,"±×÷≠≤≥∞∴°′″℃Å￠￡￥♂♀∠⊥⌒∂∇≡≒§※☆★○●◎◇◆□■△▲▽▼→←↑↓↔〓≪≫√∽∝∵∫∬∈∋⊆⊇⊂⊃∪∩∧∨￢"],["a241","줐줒",5,"줙",18],["a261","줭",6,"줵",18],["a281","쥈",7,"쥒쥓쥕쥖쥗쥙",6,"쥢쥤",7,"쥭쥮쥯⇒⇔∀∃´～ˇ˘˝˚˙¸˛¡¿ː∮∑∏¤℉‰◁◀▷▶♤♠♡♥♧♣⊙◈▣◐◑▒▤▥▨▧▦▩♨☏☎☜☞¶†‡↕↗↙↖↘♭♩♪♬㉿㈜№㏇™㏂㏘℡€®"],["a341","쥱쥲쥳쥵",6,"쥽",10,"즊즋즍즎즏"],["a361","즑",6,"즚즜즞",16],["a381","즯",16,"짂짃짅짆짉짋",4,"짒짔짗짘짛！",58,"￦］",32,"￣"],["a441","짞짟짡짣짥짦짨짩짪짫짮짲",5,"짺짻짽짾짿쨁쨂쨃쨄"],["a461","쨅쨆쨇쨊쨎",5,"쨕쨖쨗쨙",12],["a481","쨦쨧쨨쨪",28,"ㄱ",93],["a541","쩇",4,"쩎쩏쩑쩒쩓쩕",6,"쩞쩢",5,"쩩쩪"],["a561","쩫",17,"쩾",5,"쪅쪆"],["a581","쪇",16,"쪙",14,"ⅰ",9],["a5b0","Ⅰ",9],["a5c1","Α",16,"Σ",6],["a5e1","α",16,"σ",6],["a641","쪨",19,"쪾쪿쫁쫂쫃쫅"],["a661","쫆",5,"쫎쫐쫒쫔쫕쫖쫗쫚",5,"쫡",6],["a681","쫨쫩쫪쫫쫭",6,"쫵",18,"쬉쬊─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂┒┑┚┙┖┕┎┍┞┟┡┢┦┧┩┪┭┮┱┲┵┶┹┺┽┾╀╁╃",7],["a741","쬋",4,"쬑쬒쬓쬕쬖쬗쬙",6,"쬢",7],["a761","쬪",22,"쭂쭃쭄"],["a781","쭅쭆쭇쭊쭋쭍쭎쭏쭑",6,"쭚쭛쭜쭞",5,"쭥",7,"㎕㎖㎗ℓ㎘㏄㎣㎤㎥㎦㎙",9,"㏊㎍㎎㎏㏏㎈㎉㏈㎧㎨㎰",9,"㎀",4,"㎺",5,"㎐",4,"Ω㏀㏁㎊㎋㎌㏖㏅㎭㎮㎯㏛㎩㎪㎫㎬㏝㏐㏓㏃㏉㏜㏆"],["a841","쭭",10,"쭺",14],["a861","쮉",18,"쮝",6],["a881","쮤",19,"쮹",11,"ÆÐªĦ"],["a8a6","Ĳ"],["a8a8","ĿŁØŒºÞŦŊ"],["a8b1","㉠",27,"ⓐ",25,"①",14,"½⅓⅔¼¾⅛⅜⅝⅞"],["a941","쯅",14,"쯕",10],["a961","쯠쯡쯢쯣쯥쯦쯨쯪",18],["a981","쯽",14,"찎찏찑찒찓찕",6,"찞찟찠찣찤æđðħıĳĸŀłøœßþŧŋŉ㈀",27,"⒜",25,"⑴",14,"¹²³⁴ⁿ₁₂₃₄"],["aa41","찥찦찪찫찭찯찱",6,"찺찿",4,"챆챇챉챊챋챍챎"],["aa61","챏",4,"챖챚",5,"챡챢챣챥챧챩",6,"챱챲"],["aa81","챳챴챶",29,"ぁ",82],["ab41","첔첕첖첗첚첛첝첞첟첡",6,"첪첮",5,"첶첷첹"],["ab61","첺첻첽",6,"쳆쳈쳊",5,"쳑쳒쳓쳕",5],["ab81","쳛",8,"쳥",6,"쳭쳮쳯쳱",12,"ァ",85],["ac41","쳾쳿촀촂",5,"촊촋촍촎촏촑",6,"촚촜촞촟촠"],["ac61","촡촢촣촥촦촧촩촪촫촭",11,"촺",4],["ac81","촿",28,"쵝쵞쵟А",5,"ЁЖ",25],["acd1","а",5,"ёж",25],["ad41","쵡쵢쵣쵥",6,"쵮쵰쵲",5,"쵹",7],["ad61","춁",6,"춉",10,"춖춗춙춚춛춝춞춟"],["ad81","춠춡춢춣춦춨춪",5,"춱",18,"췅"],["ae41","췆",5,"췍췎췏췑",16],["ae61","췢",5,"췩췪췫췭췮췯췱",6,"췺췼췾",4],["ae81","츃츅츆츇츉츊츋츍",6,"츕츖츗츘츚",5,"츢츣츥츦츧츩츪츫"],["af41","츬츭츮츯츲츴츶",19],["af61","칊",13,"칚칛칝칞칢",5,"칪칬"],["af81","칮",5,"칶칷칹칺칻칽",6,"캆캈캊",5,"캒캓캕캖캗캙"],["b041","캚",5,"캢캦",5,"캮",12],["b061","캻",5,"컂",19],["b081","컖",13,"컦컧컩컪컭",6,"컶컺",5,"가각간갇갈갉갊감",7,"같",4,"갠갤갬갭갯갰갱갸갹갼걀걋걍걔걘걜거걱건걷걸걺검겁것겄겅겆겉겊겋게겐겔겜겝겟겠겡겨격겪견겯결겸겹겻겼경곁계곈곌곕곗고곡곤곧골곪곬곯곰곱곳공곶과곽관괄괆"],["b141","켂켃켅켆켇켉",6,"켒켔켖",5,"켝켞켟켡켢켣"],["b161","켥",6,"켮켲",5,"켹",11],["b181","콅",14,"콖콗콙콚콛콝",6,"콦콨콪콫콬괌괍괏광괘괜괠괩괬괭괴괵괸괼굄굅굇굉교굔굘굡굣구국군굳굴굵굶굻굼굽굿궁궂궈궉권궐궜궝궤궷귀귁귄귈귐귑귓규균귤그극근귿글긁금급긋긍긔기긱긴긷길긺김깁깃깅깆깊까깍깎깐깔깖깜깝깟깠깡깥깨깩깬깰깸"],["b241","콭콮콯콲콳콵콶콷콹",6,"쾁쾂쾃쾄쾆",5,"쾍"],["b261","쾎",18,"쾢",5,"쾩"],["b281","쾪",5,"쾱",18,"쿅",6,"깹깻깼깽꺄꺅꺌꺼꺽꺾껀껄껌껍껏껐껑께껙껜껨껫껭껴껸껼꼇꼈꼍꼐꼬꼭꼰꼲꼴꼼꼽꼿꽁꽂꽃꽈꽉꽐꽜꽝꽤꽥꽹꾀꾄꾈꾐꾑꾕꾜꾸꾹꾼꿀꿇꿈꿉꿋꿍꿎꿔꿜꿨꿩꿰꿱꿴꿸뀀뀁뀄뀌뀐뀔뀜뀝뀨끄끅끈끊끌끎끓끔끕끗끙"],["b341","쿌",19,"쿢쿣쿥쿦쿧쿩"],["b361","쿪",5,"쿲쿴쿶",5,"쿽쿾쿿퀁퀂퀃퀅",5],["b381","퀋",5,"퀒",5,"퀙",19,"끝끼끽낀낄낌낍낏낑나낙낚난낟날낡낢남납낫",4,"낱낳내낵낸낼냄냅냇냈냉냐냑냔냘냠냥너넉넋넌널넒넓넘넙넛넜넝넣네넥넨넬넴넵넷넸넹녀녁년녈념녑녔녕녘녜녠노녹논놀놂놈놉놋농높놓놔놘놜놨뇌뇐뇔뇜뇝"],["b441","퀮",5,"퀶퀷퀹퀺퀻퀽",6,"큆큈큊",5],["b461","큑큒큓큕큖큗큙",6,"큡",10,"큮큯"],["b481","큱큲큳큵",6,"큾큿킀킂",18,"뇟뇨뇩뇬뇰뇹뇻뇽누눅눈눋눌눔눕눗눙눠눴눼뉘뉜뉠뉨뉩뉴뉵뉼늄늅늉느늑는늘늙늚늠늡늣능늦늪늬늰늴니닉닌닐닒님닙닛닝닢다닥닦단닫",4,"닳담답닷",4,"닿대댁댄댈댐댑댓댔댕댜더덕덖던덛덜덞덟덤덥"],["b541","킕",14,"킦킧킩킪킫킭",5],["b561","킳킶킸킺",5,"탂탃탅탆탇탊",5,"탒탖",4],["b581","탛탞탟탡탢탣탥",6,"탮탲",5,"탹",11,"덧덩덫덮데덱덴델뎀뎁뎃뎄뎅뎌뎐뎔뎠뎡뎨뎬도독돈돋돌돎돐돔돕돗동돛돝돠돤돨돼됐되된될됨됩됫됴두둑둔둘둠둡둣둥둬뒀뒈뒝뒤뒨뒬뒵뒷뒹듀듄듈듐듕드득든듣들듦듬듭듯등듸디딕딘딛딜딤딥딧딨딩딪따딱딴딸"],["b641","턅",7,"턎",17],["b661","턠",15,"턲턳턵턶턷턹턻턼턽턾"],["b681","턿텂텆",5,"텎텏텑텒텓텕",6,"텞텠텢",5,"텩텪텫텭땀땁땃땄땅땋때땍땐땔땜땝땟땠땡떠떡떤떨떪떫떰떱떳떴떵떻떼떽뗀뗄뗌뗍뗏뗐뗑뗘뗬또똑똔똘똥똬똴뙈뙤뙨뚜뚝뚠뚤뚫뚬뚱뛔뛰뛴뛸뜀뜁뜅뜨뜩뜬뜯뜰뜸뜹뜻띄띈띌띔띕띠띤띨띰띱띳띵라락란랄람랍랏랐랑랒랖랗"],["b741","텮",13,"텽",6,"톅톆톇톉톊"],["b761","톋",20,"톢톣톥톦톧"],["b781","톩",6,"톲톴톶톷톸톹톻톽톾톿퇁",14,"래랙랜랠램랩랫랬랭랴략랸럇량러럭런럴럼럽럿렀렁렇레렉렌렐렘렙렛렝려력련렬렴렵렷렸령례롄롑롓로록론롤롬롭롯롱롸롼뢍뢨뢰뢴뢸룀룁룃룅료룐룔룝룟룡루룩룬룰룸룹룻룽뤄뤘뤠뤼뤽륀륄륌륏륑류륙륜률륨륩"],["b841","퇐",7,"퇙",17],["b861","퇫",8,"퇵퇶퇷퇹",13],["b881","툈툊",5,"툑",24,"륫륭르륵른를름릅릇릉릊릍릎리릭린릴림립릿링마막만많",4,"맘맙맛망맞맡맣매맥맨맬맴맵맷맸맹맺먀먁먈먕머먹먼멀멂멈멉멋멍멎멓메멕멘멜멤멥멧멨멩며멱면멸몃몄명몇몌모목몫몬몰몲몸몹못몽뫄뫈뫘뫙뫼"],["b941","툪툫툮툯툱툲툳툵",6,"툾퉀퉂",5,"퉉퉊퉋퉌"],["b961","퉍",14,"퉝",6,"퉥퉦퉧퉨"],["b981","퉩",22,"튂튃튅튆튇튉튊튋튌묀묄묍묏묑묘묜묠묩묫무묵묶문묻물묽묾뭄뭅뭇뭉뭍뭏뭐뭔뭘뭡뭣뭬뮈뮌뮐뮤뮨뮬뮴뮷므믄믈믐믓미믹민믿밀밂밈밉밋밌밍및밑바",4,"받",4,"밤밥밧방밭배백밴밸뱀뱁뱃뱄뱅뱉뱌뱍뱐뱝버벅번벋벌벎범법벗"],["ba41","튍튎튏튒튓튔튖",5,"튝튞튟튡튢튣튥",6,"튭"],["ba61","튮튯튰튲",5,"튺튻튽튾틁틃",4,"틊틌",5],["ba81","틒틓틕틖틗틙틚틛틝",6,"틦",9,"틲틳틵틶틷틹틺벙벚베벡벤벧벨벰벱벳벴벵벼벽변별볍볏볐병볕볘볜보복볶본볼봄봅봇봉봐봔봤봬뵀뵈뵉뵌뵐뵘뵙뵤뵨부북분붇불붉붊붐붑붓붕붙붚붜붤붰붸뷔뷕뷘뷜뷩뷰뷴뷸븀븃븅브븍븐블븜븝븟비빅빈빌빎빔빕빗빙빚빛빠빡빤"],["bb41","틻",4,"팂팄팆",5,"팏팑팒팓팕팗",4,"팞팢팣"],["bb61","팤팦팧팪팫팭팮팯팱",6,"팺팾",5,"퍆퍇퍈퍉"],["bb81","퍊",31,"빨빪빰빱빳빴빵빻빼빽뺀뺄뺌뺍뺏뺐뺑뺘뺙뺨뻐뻑뻔뻗뻘뻠뻣뻤뻥뻬뼁뼈뼉뼘뼙뼛뼜뼝뽀뽁뽄뽈뽐뽑뽕뾔뾰뿅뿌뿍뿐뿔뿜뿟뿡쀼쁑쁘쁜쁠쁨쁩삐삑삔삘삠삡삣삥사삭삯산삳살삵삶삼삽삿샀상샅새색샌샐샘샙샛샜생샤"],["bc41","퍪",17,"퍾퍿펁펂펃펅펆펇"],["bc61","펈펉펊펋펎펒",5,"펚펛펝펞펟펡",6,"펪펬펮"],["bc81","펯",4,"펵펶펷펹펺펻펽",6,"폆폇폊",5,"폑",5,"샥샨샬샴샵샷샹섀섄섈섐섕서",4,"섣설섦섧섬섭섯섰성섶세섹센셀셈셉셋셌셍셔셕션셜셤셥셧셨셩셰셴셸솅소속솎손솔솖솜솝솟송솥솨솩솬솰솽쇄쇈쇌쇔쇗쇘쇠쇤쇨쇰쇱쇳쇼쇽숀숄숌숍숏숑수숙순숟술숨숩숫숭"],["bd41","폗폙",7,"폢폤",7,"폮폯폱폲폳폵폶폷"],["bd61","폸폹폺폻폾퐀퐂",5,"퐉",13],["bd81","퐗",5,"퐞",25,"숯숱숲숴쉈쉐쉑쉔쉘쉠쉥쉬쉭쉰쉴쉼쉽쉿슁슈슉슐슘슛슝스슥슨슬슭슴습슷승시식신싣실싫심십싯싱싶싸싹싻싼쌀쌈쌉쌌쌍쌓쌔쌕쌘쌜쌤쌥쌨쌩썅써썩썬썰썲썸썹썼썽쎄쎈쎌쏀쏘쏙쏜쏟쏠쏢쏨쏩쏭쏴쏵쏸쐈쐐쐤쐬쐰"],["be41","퐸",7,"푁푂푃푅",14],["be61","푔",7,"푝푞푟푡푢푣푥",7,"푮푰푱푲"],["be81","푳",4,"푺푻푽푾풁풃",4,"풊풌풎",5,"풕",8,"쐴쐼쐽쑈쑤쑥쑨쑬쑴쑵쑹쒀쒔쒜쒸쒼쓩쓰쓱쓴쓸쓺쓿씀씁씌씐씔씜씨씩씬씰씸씹씻씽아악안앉않알앍앎앓암압앗았앙앝앞애액앤앨앰앱앳앴앵야약얀얄얇얌얍얏양얕얗얘얜얠얩어억언얹얻얼얽얾엄",6,"엌엎"],["bf41","풞",10,"풪",14],["bf61","풹",18,"퓍퓎퓏퓑퓒퓓퓕"],["bf81","퓖",5,"퓝퓞퓠",7,"퓩퓪퓫퓭퓮퓯퓱",6,"퓹퓺퓼에엑엔엘엠엡엣엥여역엮연열엶엷염",5,"옅옆옇예옌옐옘옙옛옜오옥온올옭옮옰옳옴옵옷옹옻와왁완왈왐왑왓왔왕왜왝왠왬왯왱외왹왼욀욈욉욋욍요욕욘욜욤욥욧용우욱운울욹욺움웁웃웅워웍원월웜웝웠웡웨"],["c041","퓾",5,"픅픆픇픉픊픋픍",6,"픖픘",5],["c061","픞",25],["c081","픸픹픺픻픾픿핁핂핃핅",6,"핎핐핒",5,"핚핛핝핞핟핡핢핣웩웬웰웸웹웽위윅윈윌윔윕윗윙유육윤율윰윱윳융윷으윽은을읊음읍읏응",7,"읜읠읨읫이익인일읽읾잃임입잇있잉잊잎자작잔잖잗잘잚잠잡잣잤장잦재잭잰잴잼잽잿쟀쟁쟈쟉쟌쟎쟐쟘쟝쟤쟨쟬저적전절젊"],["c141","핤핦핧핪핬핮",5,"핶핷핹핺핻핽",6,"햆햊햋"],["c161","햌햍햎햏햑",19,"햦햧"],["c181","햨",31,"점접젓정젖제젝젠젤젬젭젯젱져젼졀졈졉졌졍졔조족존졸졺좀좁좃종좆좇좋좌좍좔좝좟좡좨좼좽죄죈죌죔죕죗죙죠죡죤죵주죽준줄줅줆줌줍줏중줘줬줴쥐쥑쥔쥘쥠쥡쥣쥬쥰쥴쥼즈즉즌즐즘즙즛증지직진짇질짊짐집짓"],["c241","헊헋헍헎헏헑헓",4,"헚헜헞",5,"헦헧헩헪헫헭헮"],["c261","헯",4,"헶헸헺",5,"혂혃혅혆혇혉",6,"혒"],["c281","혖",5,"혝혞혟혡혢혣혥",7,"혮",9,"혺혻징짖짙짚짜짝짠짢짤짧짬짭짯짰짱째짹짼쨀쨈쨉쨋쨌쨍쨔쨘쨩쩌쩍쩐쩔쩜쩝쩟쩠쩡쩨쩽쪄쪘쪼쪽쫀쫄쫌쫍쫏쫑쫓쫘쫙쫠쫬쫴쬈쬐쬔쬘쬠쬡쭁쭈쭉쭌쭐쭘쭙쭝쭤쭸쭹쮜쮸쯔쯤쯧쯩찌찍찐찔찜찝찡찢찧차착찬찮찰참찹찻"],["c341","혽혾혿홁홂홃홄홆홇홊홌홎홏홐홒홓홖홗홙홚홛홝",4],["c361","홢",4,"홨홪",5,"홲홳홵",11],["c381","횁횂횄횆",5,"횎횏횑횒횓횕",7,"횞횠횢",5,"횩횪찼창찾채책챈챌챔챕챗챘챙챠챤챦챨챰챵처척천철첨첩첫첬청체첵첸첼쳄쳅쳇쳉쳐쳔쳤쳬쳰촁초촉촌촐촘촙촛총촤촨촬촹최쵠쵤쵬쵭쵯쵱쵸춈추축춘출춤춥춧충춰췄췌췐취췬췰췸췹췻췽츄츈츌츔츙츠측츤츨츰츱츳층"],["c441","횫횭횮횯횱",7,"횺횼",7,"훆훇훉훊훋"],["c461","훍훎훏훐훒훓훕훖훘훚",5,"훡훢훣훥훦훧훩",4],["c481","훮훯훱훲훳훴훶",5,"훾훿휁휂휃휅",11,"휒휓휔치칙친칟칠칡침칩칫칭카칵칸칼캄캅캇캉캐캑캔캘캠캡캣캤캥캬캭컁커컥컨컫컬컴컵컷컸컹케켁켄켈켐켑켓켕켜켠켤켬켭켯켰켱켸코콕콘콜콤콥콧콩콰콱콴콸쾀쾅쾌쾡쾨쾰쿄쿠쿡쿤쿨쿰쿱쿳쿵쿼퀀퀄퀑퀘퀭퀴퀵퀸퀼"],["c541","휕휖휗휚휛휝휞휟휡",6,"휪휬휮",5,"휶휷휹"],["c561","휺휻휽",6,"흅흆흈흊",5,"흒흓흕흚",4],["c581","흟흢흤흦흧흨흪흫흭흮흯흱흲흳흵",6,"흾흿힀힂",5,"힊힋큄큅큇큉큐큔큘큠크큭큰클큼큽킁키킥킨킬킴킵킷킹타탁탄탈탉탐탑탓탔탕태택탠탤탬탭탯탰탱탸턍터턱턴털턺텀텁텃텄텅테텍텐텔템텝텟텡텨텬텼톄톈토톡톤톨톰톱톳통톺톼퇀퇘퇴퇸툇툉툐투툭툰툴툼툽툿퉁퉈퉜"],["c641","힍힎힏힑",6,"힚힜힞",5],["c6a1","퉤튀튁튄튈튐튑튕튜튠튤튬튱트특튼튿틀틂틈틉틋틔틘틜틤틥티틱틴틸팀팁팃팅파팍팎판팔팖팜팝팟팠팡팥패팩팬팰팸팹팻팼팽퍄퍅퍼퍽펀펄펌펍펏펐펑페펙펜펠펨펩펫펭펴편펼폄폅폈평폐폘폡폣포폭폰폴폼폽폿퐁"],["c7a1","퐈퐝푀푄표푠푤푭푯푸푹푼푿풀풂품풉풋풍풔풩퓌퓐퓔퓜퓟퓨퓬퓰퓸퓻퓽프픈플픔픕픗피픽핀필핌핍핏핑하학한할핥함합핫항해핵핸핼햄햅햇했행햐향허헉헌헐헒험헙헛헝헤헥헨헬헴헵헷헹혀혁현혈혐협혓혔형혜혠"],["c8a1","혤혭호혹혼홀홅홈홉홋홍홑화확환활홧황홰홱홴횃횅회획횐횔횝횟횡효횬횰횹횻후훅훈훌훑훔훗훙훠훤훨훰훵훼훽휀휄휑휘휙휜휠휨휩휫휭휴휵휸휼흄흇흉흐흑흔흖흗흘흙흠흡흣흥흩희흰흴흼흽힁히힉힌힐힘힙힛힝"],["caa1","伽佳假價加可呵哥嘉嫁家暇架枷柯歌珂痂稼苛茄街袈訶賈跏軻迦駕刻却各恪慤殼珏脚覺角閣侃刊墾奸姦干幹懇揀杆柬桿澗癎看磵稈竿簡肝艮艱諫間乫喝曷渴碣竭葛褐蝎鞨勘坎堪嵌感憾戡敢柑橄減甘疳監瞰紺邯鑑鑒龕"],["cba1","匣岬甲胛鉀閘剛堈姜岡崗康强彊慷江畺疆糠絳綱羌腔舡薑襁講鋼降鱇介价個凱塏愷愾慨改槪漑疥皆盖箇芥蓋豈鎧開喀客坑更粳羹醵倨去居巨拒据據擧渠炬祛距踞車遽鉅鋸乾件健巾建愆楗腱虔蹇鍵騫乞傑杰桀儉劍劒檢"],["cca1","瞼鈐黔劫怯迲偈憩揭擊格檄激膈覡隔堅牽犬甄絹繭肩見譴遣鵑抉決潔結缺訣兼慊箝謙鉗鎌京俓倞傾儆勁勍卿坰境庚徑慶憬擎敬景暻更梗涇炅烱璟璥瓊痙硬磬竟競絅經耕耿脛莖警輕逕鏡頃頸驚鯨係啓堺契季屆悸戒桂械"],["cda1","棨溪界癸磎稽系繫繼計誡谿階鷄古叩告呱固姑孤尻庫拷攷故敲暠枯槁沽痼皐睾稿羔考股膏苦苽菰藁蠱袴誥賈辜錮雇顧高鼓哭斛曲梏穀谷鵠困坤崑昆梱棍滾琨袞鯤汨滑骨供公共功孔工恐恭拱控攻珙空蚣貢鞏串寡戈果瓜"],["cea1","科菓誇課跨過鍋顆廓槨藿郭串冠官寬慣棺款灌琯瓘管罐菅觀貫關館刮恝括适侊光匡壙廣曠洸炚狂珖筐胱鑛卦掛罫乖傀塊壞怪愧拐槐魁宏紘肱轟交僑咬喬嬌嶠巧攪敎校橋狡皎矯絞翹膠蕎蛟較轎郊餃驕鮫丘久九仇俱具勾"],["cfa1","區口句咎嘔坵垢寇嶇廐懼拘救枸柩構歐毆毬求溝灸狗玖球瞿矩究絿耉臼舅舊苟衢謳購軀逑邱鉤銶駒驅鳩鷗龜國局菊鞠鞫麴君窘群裙軍郡堀屈掘窟宮弓穹窮芎躬倦券勸卷圈拳捲權淃眷厥獗蕨蹶闕机櫃潰詭軌饋句晷歸貴"],["d0a1","鬼龜叫圭奎揆槻珪硅窺竅糾葵規赳逵閨勻均畇筠菌鈞龜橘克剋劇戟棘極隙僅劤勤懃斤根槿瑾筋芹菫覲謹近饉契今妗擒昑檎琴禁禽芩衾衿襟金錦伋及急扱汲級給亘兢矜肯企伎其冀嗜器圻基埼夔奇妓寄岐崎己幾忌技旗旣"],["d1a1","朞期杞棋棄機欺氣汽沂淇玘琦琪璂璣畸畿碁磯祁祇祈祺箕紀綺羈耆耭肌記譏豈起錡錤飢饑騎騏驥麒緊佶吉拮桔金喫儺喇奈娜懦懶拏拿癩",5,"那樂",4,"諾酪駱亂卵暖欄煖爛蘭難鸞捏捺南嵐枏楠湳濫男藍襤拉"],["d2a1","納臘蠟衲囊娘廊",4,"乃來內奈柰耐冷女年撚秊念恬拈捻寧寗努勞奴弩怒擄櫓爐瑙盧",5,"駑魯",10,"濃籠聾膿農惱牢磊腦賂雷尿壘",7,"嫩訥杻紐勒",5,"能菱陵尼泥匿溺多茶"],["d3a1","丹亶但單團壇彖斷旦檀段湍短端簞緞蛋袒鄲鍛撻澾獺疸達啖坍憺擔曇淡湛潭澹痰聃膽蕁覃談譚錟沓畓答踏遝唐堂塘幢戇撞棠當糖螳黨代垈坮大對岱帶待戴擡玳臺袋貸隊黛宅德悳倒刀到圖堵塗導屠島嶋度徒悼挑掉搗桃"],["d4a1","棹櫂淘渡滔濤燾盜睹禱稻萄覩賭跳蹈逃途道都鍍陶韜毒瀆牘犢獨督禿篤纛讀墩惇敦旽暾沌焞燉豚頓乭突仝冬凍動同憧東桐棟洞潼疼瞳童胴董銅兜斗杜枓痘竇荳讀豆逗頭屯臀芚遁遯鈍得嶝橙燈登等藤謄鄧騰喇懶拏癩羅"],["d5a1","蘿螺裸邏樂洛烙珞絡落諾酪駱丹亂卵欄欒瀾爛蘭鸞剌辣嵐擥攬欖濫籃纜藍襤覽拉臘蠟廊朗浪狼琅瑯螂郞來崍徠萊冷掠略亮倆兩凉梁樑粮粱糧良諒輛量侶儷勵呂廬慮戾旅櫚濾礪藜蠣閭驢驪麗黎力曆歷瀝礫轢靂憐戀攣漣"],["d6a1","煉璉練聯蓮輦連鍊冽列劣洌烈裂廉斂殮濂簾獵令伶囹寧岺嶺怜玲笭羚翎聆逞鈴零靈領齡例澧禮醴隷勞怒撈擄櫓潞瀘爐盧老蘆虜路輅露魯鷺鹵碌祿綠菉錄鹿麓論壟弄朧瀧瓏籠聾儡瀨牢磊賂賚賴雷了僚寮廖料燎療瞭聊蓼"],["d7a1","遼鬧龍壘婁屢樓淚漏瘻累縷蔞褸鏤陋劉旒柳榴流溜瀏琉瑠留瘤硫謬類六戮陸侖倫崙淪綸輪律慄栗率隆勒肋凜凌楞稜綾菱陵俚利厘吏唎履悧李梨浬犁狸理璃異痢籬罹羸莉裏裡里釐離鯉吝潾燐璘藺躪隣鱗麟林淋琳臨霖砬"],["d8a1","立笠粒摩瑪痲碼磨馬魔麻寞幕漠膜莫邈万卍娩巒彎慢挽晩曼滿漫灣瞞萬蔓蠻輓饅鰻唜抹末沫茉襪靺亡妄忘忙望網罔芒茫莽輞邙埋妹媒寐昧枚梅每煤罵買賣邁魅脈貊陌驀麥孟氓猛盲盟萌冪覓免冕勉棉沔眄眠綿緬面麵滅"],["d9a1","蔑冥名命明暝椧溟皿瞑茗蓂螟酩銘鳴袂侮冒募姆帽慕摸摹暮某模母毛牟牡瑁眸矛耗芼茅謀謨貌木沐牧目睦穆鶩歿沒夢朦蒙卯墓妙廟描昴杳渺猫竗苗錨務巫憮懋戊拇撫无楙武毋無珷畝繆舞茂蕪誣貿霧鵡墨默們刎吻問文"],["daa1","汶紊紋聞蚊門雯勿沕物味媚尾嵋彌微未梶楣渼湄眉米美薇謎迷靡黴岷悶愍憫敏旻旼民泯玟珉緡閔密蜜謐剝博拍搏撲朴樸泊珀璞箔粕縛膊舶薄迫雹駁伴半反叛拌搬攀斑槃泮潘班畔瘢盤盼磐磻礬絆般蟠返頒飯勃拔撥渤潑"],["dba1","發跋醱鉢髮魃倣傍坊妨尨幇彷房放方旁昉枋榜滂磅紡肪膀舫芳蒡蚌訪謗邦防龐倍俳北培徘拜排杯湃焙盃背胚裴裵褙賠輩配陪伯佰帛柏栢白百魄幡樊煩燔番磻繁蕃藩飜伐筏罰閥凡帆梵氾汎泛犯範范法琺僻劈壁擘檗璧癖"],["dca1","碧蘗闢霹便卞弁變辨辯邊別瞥鱉鼈丙倂兵屛幷昞昺柄棅炳甁病秉竝輧餠騈保堡報寶普步洑湺潽珤甫菩補褓譜輔伏僕匐卜宓復服福腹茯蔔複覆輹輻馥鰒本乶俸奉封峯峰捧棒烽熢琫縫蓬蜂逢鋒鳳不付俯傅剖副否咐埠夫婦"],["dda1","孚孵富府復扶敷斧浮溥父符簿缶腐腑膚艀芙莩訃負賦賻赴趺部釜阜附駙鳧北分吩噴墳奔奮忿憤扮昐汾焚盆粉糞紛芬賁雰不佛弗彿拂崩朋棚硼繃鵬丕備匕匪卑妃婢庇悲憊扉批斐枇榧比毖毗毘沸泌琵痺砒碑秕秘粃緋翡肥"],["dea1","脾臂菲蜚裨誹譬費鄙非飛鼻嚬嬪彬斌檳殯浜濱瀕牝玭貧賓頻憑氷聘騁乍事些仕伺似使俟僿史司唆嗣四士奢娑寫寺射巳師徙思捨斜斯柶査梭死沙泗渣瀉獅砂社祀祠私篩紗絲肆舍莎蓑蛇裟詐詞謝賜赦辭邪飼駟麝削數朔索"],["dfa1","傘刪山散汕珊産疝算蒜酸霰乷撒殺煞薩三參杉森渗芟蔘衫揷澁鈒颯上傷像償商喪嘗孀尙峠常床庠廂想桑橡湘爽牀狀相祥箱翔裳觴詳象賞霜塞璽賽嗇塞穡索色牲生甥省笙墅壻嶼序庶徐恕抒捿敍暑曙書栖棲犀瑞筮絮緖署"],["e0a1","胥舒薯西誓逝鋤黍鼠夕奭席惜昔晳析汐淅潟石碩蓆釋錫仙僊先善嬋宣扇敾旋渲煽琁瑄璇璿癬禪線繕羨腺膳船蘚蟬詵跣選銑鐥饍鮮卨屑楔泄洩渫舌薛褻設說雪齧剡暹殲纖蟾贍閃陝攝涉燮葉城姓宬性惺成星晟猩珹盛省筬"],["e1a1","聖聲腥誠醒世勢歲洗稅笹細說貰召嘯塑宵小少巢所掃搔昭梳沼消溯瀟炤燒甦疏疎瘙笑篠簫素紹蔬蕭蘇訴逍遡邵銷韶騷俗屬束涑粟續謖贖速孫巽損蓀遜飡率宋悚松淞訟誦送頌刷殺灑碎鎖衰釗修受嗽囚垂壽嫂守岫峀帥愁"],["e2a1","戍手授搜收數樹殊水洙漱燧狩獸琇璲瘦睡秀穗竪粹綏綬繡羞脩茱蒐蓚藪袖誰讐輸遂邃酬銖銹隋隧隨雖需須首髓鬚叔塾夙孰宿淑潚熟琡璹肅菽巡徇循恂旬栒楯橓殉洵淳珣盾瞬筍純脣舜荀蓴蕣詢諄醇錞順馴戌術述鉥崇崧"],["e3a1","嵩瑟膝蝨濕拾習褶襲丞乘僧勝升承昇繩蠅陞侍匙嘶始媤尸屎屍市弑恃施是時枾柴猜矢示翅蒔蓍視試詩諡豕豺埴寔式息拭植殖湜熄篒蝕識軾食飾伸侁信呻娠宸愼新晨燼申神紳腎臣莘薪藎蜃訊身辛辰迅失室實悉審尋心沁"],["e4a1","沈深瀋甚芯諶什十拾雙氏亞俄兒啞娥峨我牙芽莪蛾衙訝阿雅餓鴉鵝堊岳嶽幄惡愕握樂渥鄂鍔顎鰐齷安岸按晏案眼雁鞍顔鮟斡謁軋閼唵岩巖庵暗癌菴闇壓押狎鴨仰央怏昻殃秧鴦厓哀埃崖愛曖涯碍艾隘靄厄扼掖液縊腋額"],["e5a1","櫻罌鶯鸚也倻冶夜惹揶椰爺耶若野弱掠略約若葯蒻藥躍亮佯兩凉壤孃恙揚攘敭暘梁楊樣洋瀁煬痒瘍禳穰糧羊良襄諒讓釀陽量養圄御於漁瘀禦語馭魚齬億憶抑檍臆偃堰彦焉言諺孼蘖俺儼嚴奄掩淹嶪業円予余勵呂女如廬"],["e6a1","旅歟汝濾璵礖礪與艅茹輿轝閭餘驪麗黎亦力域役易曆歷疫繹譯轢逆驛嚥堧姸娟宴年延憐戀捐挻撚椽沇沿涎涓淵演漣烟然煙煉燃燕璉硏硯秊筵緣練縯聯衍軟輦蓮連鉛鍊鳶列劣咽悅涅烈熱裂說閱厭廉念捻染殮炎焰琰艶苒"],["e7a1","簾閻髥鹽曄獵燁葉令囹塋寧嶺嶸影怜映暎楹榮永泳渶潁濚瀛瀯煐營獰玲瑛瑩瓔盈穎纓羚聆英詠迎鈴鍈零霙靈領乂倪例刈叡曳汭濊猊睿穢芮藝蘂禮裔詣譽豫醴銳隸霓預五伍俉傲午吾吳嗚塢墺奧娛寤悟惡懊敖旿晤梧汚澳"],["e8a1","烏熬獒筽蜈誤鰲鼇屋沃獄玉鈺溫瑥瘟穩縕蘊兀壅擁瓮甕癰翁邕雍饔渦瓦窩窪臥蛙蝸訛婉完宛梡椀浣玩琓琬碗緩翫脘腕莞豌阮頑曰往旺枉汪王倭娃歪矮外嵬巍猥畏了僚僥凹堯夭妖姚寥寮尿嶢拗搖撓擾料曜樂橈燎燿瑤療"],["e9a1","窈窯繇繞耀腰蓼蟯要謠遙遼邀饒慾欲浴縟褥辱俑傭冗勇埇墉容庸慂榕涌湧溶熔瑢用甬聳茸蓉踊鎔鏞龍于佑偶優又友右宇寓尤愚憂旴牛玗瑀盂祐禑禹紆羽芋藕虞迂遇郵釪隅雨雩勖彧旭昱栯煜稶郁頊云暈橒殞澐熉耘芸蕓"],["eaa1","運隕雲韻蔚鬱亐熊雄元原員圓園垣媛嫄寃怨愿援沅洹湲源爰猿瑗苑袁轅遠阮院願鴛月越鉞位偉僞危圍委威尉慰暐渭爲瑋緯胃萎葦蔿蝟衛褘謂違韋魏乳侑儒兪劉唯喩孺宥幼幽庾悠惟愈愉揄攸有杻柔柚柳楡楢油洧流游溜"],["eba1","濡猶猷琉瑜由留癒硫紐維臾萸裕誘諛諭踰蹂遊逾遺酉釉鍮類六堉戮毓肉育陸倫允奫尹崙淪潤玧胤贇輪鈗閏律慄栗率聿戎瀜絨融隆垠恩慇殷誾銀隱乙吟淫蔭陰音飮揖泣邑凝應膺鷹依倚儀宜意懿擬椅毅疑矣義艤薏蟻衣誼"],["eca1","議醫二以伊利吏夷姨履已弛彛怡易李梨泥爾珥理異痍痢移罹而耳肄苡荑裏裡貽貳邇里離飴餌匿溺瀷益翊翌翼謚人仁刃印吝咽因姻寅引忍湮燐璘絪茵藺蚓認隣靭靷鱗麟一佚佾壹日溢逸鎰馹任壬妊姙恁林淋稔臨荏賃入卄"],["eda1","立笠粒仍剩孕芿仔刺咨姉姿子字孜恣慈滋炙煮玆瓷疵磁紫者自茨蔗藉諮資雌作勺嚼斫昨灼炸爵綽芍酌雀鵲孱棧殘潺盞岑暫潛箴簪蠶雜丈仗匠場墻壯奬將帳庄張掌暲杖樟檣欌漿牆狀獐璋章粧腸臟臧莊葬蔣薔藏裝贓醬長"],["eea1","障再哉在宰才材栽梓渽滓災縡裁財載齋齎爭箏諍錚佇低儲咀姐底抵杵楮樗沮渚狙猪疽箸紵苧菹著藷詛貯躇這邸雎齟勣吊嫡寂摘敵滴狄炙的積笛籍績翟荻謫賊赤跡蹟迪迹適鏑佃佺傳全典前剪塡塼奠專展廛悛戰栓殿氈澱"],["efa1","煎琠田甸畑癲筌箋箭篆纏詮輾轉鈿銓錢鐫電顚顫餞切截折浙癤竊節絶占岾店漸点粘霑鮎點接摺蝶丁井亭停偵呈姃定幀庭廷征情挺政整旌晶晸柾楨檉正汀淀淨渟湞瀞炡玎珽町睛碇禎程穽精綎艇訂諪貞鄭酊釘鉦鋌錠霆靖"],["f0a1","靜頂鼎制劑啼堤帝弟悌提梯濟祭第臍薺製諸蹄醍除際霽題齊俎兆凋助嘲弔彫措操早晁曺曹朝條棗槽漕潮照燥爪璪眺祖祚租稠窕粗糟組繰肇藻蚤詔調趙躁造遭釣阻雕鳥族簇足鏃存尊卒拙猝倧宗從悰慫棕淙琮種終綜縱腫"],["f1a1","踪踵鍾鐘佐坐左座挫罪主住侏做姝胄呪周嗾奏宙州廚晝朱柱株注洲湊澍炷珠疇籌紂紬綢舟蛛註誅走躊輳週酎酒鑄駐竹粥俊儁准埈寯峻晙樽浚準濬焌畯竣蠢逡遵雋駿茁中仲衆重卽櫛楫汁葺增憎曾拯烝甑症繒蒸證贈之只"],["f2a1","咫地址志持指摯支旨智枝枳止池沚漬知砥祉祗紙肢脂至芝芷蜘誌識贄趾遲直稙稷織職唇嗔塵振搢晉晋桭榛殄津溱珍瑨璡畛疹盡眞瞋秦縉縝臻蔯袗診賑軫辰進鎭陣陳震侄叱姪嫉帙桎瓆疾秩窒膣蛭質跌迭斟朕什執潗緝輯"],["f3a1","鏶集徵懲澄且侘借叉嗟嵯差次此磋箚茶蹉車遮捉搾着窄錯鑿齪撰澯燦璨瓚竄簒纂粲纘讚贊鑽餐饌刹察擦札紮僭參塹慘慙懺斬站讒讖倉倡創唱娼廠彰愴敞昌昶暢槍滄漲猖瘡窓脹艙菖蒼債埰寀寨彩採砦綵菜蔡采釵冊柵策"],["f4a1","責凄妻悽處倜刺剔尺慽戚拓擲斥滌瘠脊蹠陟隻仟千喘天川擅泉淺玔穿舛薦賤踐遷釧闡阡韆凸哲喆徹撤澈綴輟轍鐵僉尖沾添甛瞻簽籤詹諂堞妾帖捷牒疊睫諜貼輒廳晴淸聽菁請靑鯖切剃替涕滯締諦逮遞體初剿哨憔抄招梢"],["f5a1","椒楚樵炒焦硝礁礎秒稍肖艸苕草蕉貂超酢醋醮促囑燭矗蜀觸寸忖村邨叢塚寵悤憁摠總聰蔥銃撮催崔最墜抽推椎楸樞湫皺秋芻萩諏趨追鄒酋醜錐錘鎚雛騶鰍丑畜祝竺筑築縮蓄蹙蹴軸逐春椿瑃出朮黜充忠沖蟲衝衷悴膵萃"],["f6a1","贅取吹嘴娶就炊翠聚脆臭趣醉驟鷲側仄厠惻測層侈値嗤峙幟恥梔治淄熾痔痴癡稚穉緇緻置致蚩輜雉馳齒則勅飭親七柒漆侵寢枕沈浸琛砧針鍼蟄秤稱快他咤唾墮妥惰打拖朶楕舵陀馱駝倬卓啄坼度托拓擢晫柝濁濯琢琸託"],["f7a1","鐸呑嘆坦彈憚歎灘炭綻誕奪脫探眈耽貪塔搭榻宕帑湯糖蕩兌台太怠態殆汰泰笞胎苔跆邰颱宅擇澤撑攄兎吐土討慟桶洞痛筒統通堆槌腿褪退頹偸套妬投透鬪慝特闖坡婆巴把播擺杷波派爬琶破罷芭跛頗判坂板版瓣販辦鈑"],["f8a1","阪八叭捌佩唄悖敗沛浿牌狽稗覇貝彭澎烹膨愎便偏扁片篇編翩遍鞭騙貶坪平枰萍評吠嬖幣廢弊斃肺蔽閉陛佈包匍匏咆哺圃布怖抛抱捕暴泡浦疱砲胞脯苞葡蒲袍褒逋鋪飽鮑幅暴曝瀑爆輻俵剽彪慓杓標漂瓢票表豹飇飄驃"],["f9a1","品稟楓諷豊風馮彼披疲皮被避陂匹弼必泌珌畢疋筆苾馝乏逼下何厦夏廈昰河瑕荷蝦賀遐霞鰕壑學虐謔鶴寒恨悍旱汗漢澣瀚罕翰閑閒限韓割轄函含咸啣喊檻涵緘艦銜陷鹹合哈盒蛤閤闔陜亢伉姮嫦巷恒抗杭桁沆港缸肛航"],["faa1","行降項亥偕咳垓奚孩害懈楷海瀣蟹解該諧邂駭骸劾核倖幸杏荇行享向嚮珦鄕響餉饗香噓墟虛許憲櫶獻軒歇險驗奕爀赫革俔峴弦懸晛泫炫玄玹現眩睍絃絢縣舷衒見賢鉉顯孑穴血頁嫌俠協夾峽挾浹狹脅脇莢鋏頰亨兄刑型"],["fba1","形泂滎瀅灐炯熒珩瑩荊螢衡逈邢鎣馨兮彗惠慧暳蕙蹊醯鞋乎互呼壕壺好岵弧戶扈昊晧毫浩淏湖滸澔濠濩灝狐琥瑚瓠皓祜糊縞胡芦葫蒿虎號蝴護豪鎬頀顥惑或酷婚昏混渾琿魂忽惚笏哄弘汞泓洪烘紅虹訌鴻化和嬅樺火畵"],["fca1","禍禾花華話譁貨靴廓擴攫確碻穫丸喚奐宦幻患換歡晥桓渙煥環紈還驩鰥活滑猾豁闊凰幌徨恍惶愰慌晃晄榥況湟滉潢煌璜皇篁簧荒蝗遑隍黃匯回廻徊恢悔懷晦會檜淮澮灰獪繪膾茴蛔誨賄劃獲宖橫鐄哮嚆孝效斅曉梟涍淆"],["fda1","爻肴酵驍侯候厚后吼喉嗅帿後朽煦珝逅勛勳塤壎焄熏燻薰訓暈薨喧暄煊萱卉喙毁彙徽揮暉煇諱輝麾休携烋畦虧恤譎鷸兇凶匈洶胸黑昕欣炘痕吃屹紇訖欠欽歆吸恰洽翕興僖凞喜噫囍姬嬉希憙憘戱晞曦熙熹熺犧禧稀羲詰"]]',
      );
    },
    4284: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["a140","　，、。．‧；：？！︰…‥﹐﹑﹒·﹔﹕﹖﹗｜–︱—︳╴︴﹏（）︵︶｛｝︷︸〔〕︹︺【】︻︼《》︽︾〈〉︿﹀「」﹁﹂『』﹃﹄﹙﹚"],["a1a1","﹛﹜﹝﹞‘’“”〝〞‵′＃＆＊※§〃○●△▲◎☆★◇◆□■▽▼㊣℅¯￣＿ˍ﹉﹊﹍﹎﹋﹌﹟﹠﹡＋－×÷±√＜＞＝≦≧≠∞≒≡﹢",4,"～∩∪⊥∠∟⊿㏒㏑∫∮∵∴♀♂⊕⊙↑↓←→↖↗↙↘∥∣／"],["a240","＼∕﹨＄￥〒￠￡％＠℃℉﹩﹪﹫㏕㎜㎝㎞㏎㎡㎎㎏㏄°兙兛兞兝兡兣嗧瓩糎▁",7,"▏▎▍▌▋▊▉┼┴┬┤├▔─│▕┌┐└┘╭"],["a2a1","╮╰╯═╞╪╡◢◣◥◤╱╲╳０",9,"Ⅰ",9,"〡",8,"十卄卅Ａ",25,"ａ",21],["a340","ｗｘｙｚΑ",16,"Σ",6,"α",16,"σ",6,"ㄅ",10],["a3a1","ㄐ",25,"˙ˉˊˇˋ"],["a3e1","€"],["a440","一乙丁七乃九了二人儿入八几刀刁力匕十卜又三下丈上丫丸凡久么也乞于亡兀刃勺千叉口土士夕大女子孑孓寸小尢尸山川工己已巳巾干廾弋弓才"],["a4a1","丑丐不中丰丹之尹予云井互五亢仁什仃仆仇仍今介仄元允內六兮公冗凶分切刈勻勾勿化匹午升卅卞厄友及反壬天夫太夭孔少尤尺屯巴幻廿弔引心戈戶手扎支文斗斤方日曰月木欠止歹毋比毛氏水火爪父爻片牙牛犬王丙"],["a540","世丕且丘主乍乏乎以付仔仕他仗代令仙仞充兄冉冊冬凹出凸刊加功包匆北匝仟半卉卡占卯卮去可古右召叮叩叨叼司叵叫另只史叱台句叭叻四囚外"],["a5a1","央失奴奶孕它尼巨巧左市布平幼弁弘弗必戊打扔扒扑斥旦朮本未末札正母民氐永汁汀氾犯玄玉瓜瓦甘生用甩田由甲申疋白皮皿目矛矢石示禾穴立丞丟乒乓乩亙交亦亥仿伉伙伊伕伍伐休伏仲件任仰仳份企伋光兇兆先全"],["a640","共再冰列刑划刎刖劣匈匡匠印危吉吏同吊吐吁吋各向名合吃后吆吒因回囝圳地在圭圬圯圩夙多夷夸妄奸妃好她如妁字存宇守宅安寺尖屹州帆并年"],["a6a1","式弛忙忖戎戌戍成扣扛托收早旨旬旭曲曳有朽朴朱朵次此死氖汝汗汙江池汐汕污汛汍汎灰牟牝百竹米糸缶羊羽老考而耒耳聿肉肋肌臣自至臼舌舛舟艮色艾虫血行衣西阡串亨位住佇佗佞伴佛何估佐佑伽伺伸佃佔似但佣"],["a740","作你伯低伶余佝佈佚兌克免兵冶冷別判利刪刨劫助努劬匣即卵吝吭吞吾否呎吧呆呃吳呈呂君吩告吹吻吸吮吵吶吠吼呀吱含吟听囪困囤囫坊坑址坍"],["a7a1","均坎圾坐坏圻壯夾妝妒妨妞妣妙妖妍妤妓妊妥孝孜孚孛完宋宏尬局屁尿尾岐岑岔岌巫希序庇床廷弄弟彤形彷役忘忌志忍忱快忸忪戒我抄抗抖技扶抉扭把扼找批扳抒扯折扮投抓抑抆改攻攸旱更束李杏材村杜杖杞杉杆杠"],["a840","杓杗步每求汞沙沁沈沉沅沛汪決沐汰沌汨沖沒汽沃汲汾汴沆汶沍沔沘沂灶灼災灸牢牡牠狄狂玖甬甫男甸皂盯矣私秀禿究系罕肖肓肝肘肛肚育良芒"],["a8a1","芋芍見角言谷豆豕貝赤走足身車辛辰迂迆迅迄巡邑邢邪邦那酉釆里防阮阱阪阬並乖乳事些亞享京佯依侍佳使佬供例來侃佰併侈佩佻侖佾侏侑佺兔兒兕兩具其典冽函刻券刷刺到刮制剁劾劻卒協卓卑卦卷卸卹取叔受味呵"],["a940","咖呸咕咀呻呷咄咒咆呼咐呱呶和咚呢周咋命咎固垃坷坪坩坡坦坤坼夜奉奇奈奄奔妾妻委妹妮姑姆姐姍始姓姊妯妳姒姅孟孤季宗定官宜宙宛尚屈居"],["a9a1","屆岷岡岸岩岫岱岳帘帚帖帕帛帑幸庚店府底庖延弦弧弩往征彿彼忝忠忽念忿怏怔怯怵怖怪怕怡性怩怫怛或戕房戾所承拉拌拄抿拂抹拒招披拓拔拋拈抨抽押拐拙拇拍抵拚抱拘拖拗拆抬拎放斧於旺昔易昌昆昂明昀昏昕昊"],["aa40","昇服朋杭枋枕東果杳杷枇枝林杯杰板枉松析杵枚枓杼杪杲欣武歧歿氓氛泣注泳沱泌泥河沽沾沼波沫法泓沸泄油況沮泗泅泱沿治泡泛泊沬泯泜泖泠"],["aaa1","炕炎炒炊炙爬爭爸版牧物狀狎狙狗狐玩玨玟玫玥甽疝疙疚的盂盲直知矽社祀祁秉秈空穹竺糾罔羌羋者肺肥肢肱股肫肩肴肪肯臥臾舍芳芝芙芭芽芟芹花芬芥芯芸芣芰芾芷虎虱初表軋迎返近邵邸邱邶采金長門阜陀阿阻附"],["ab40","陂隹雨青非亟亭亮信侵侯便俠俑俏保促侶俘俟俊俗侮俐俄係俚俎俞侷兗冒冑冠剎剃削前剌剋則勇勉勃勁匍南卻厚叛咬哀咨哎哉咸咦咳哇哂咽咪品"],["aba1","哄哈咯咫咱咻咩咧咿囿垂型垠垣垢城垮垓奕契奏奎奐姜姘姿姣姨娃姥姪姚姦威姻孩宣宦室客宥封屎屏屍屋峙峒巷帝帥帟幽庠度建弈弭彥很待徊律徇後徉怒思怠急怎怨恍恰恨恢恆恃恬恫恪恤扁拜挖按拼拭持拮拽指拱拷"],["ac40","拯括拾拴挑挂政故斫施既春昭映昧是星昨昱昤曷柿染柱柔某柬架枯柵柩柯柄柑枴柚查枸柏柞柳枰柙柢柝柒歪殃殆段毒毗氟泉洋洲洪流津洌洱洞洗"],["aca1","活洽派洶洛泵洹洧洸洩洮洵洎洫炫為炳炬炯炭炸炮炤爰牲牯牴狩狠狡玷珊玻玲珍珀玳甚甭畏界畎畋疫疤疥疢疣癸皆皇皈盈盆盃盅省盹相眉看盾盼眇矜砂研砌砍祆祉祈祇禹禺科秒秋穿突竿竽籽紂紅紀紉紇約紆缸美羿耄"],["ad40","耐耍耑耶胖胥胚胃胄背胡胛胎胞胤胝致舢苧范茅苣苛苦茄若茂茉苒苗英茁苜苔苑苞苓苟苯茆虐虹虻虺衍衫要觔計訂訃貞負赴赳趴軍軌述迦迢迪迥"],["ada1","迭迫迤迨郊郎郁郃酋酊重閂限陋陌降面革韋韭音頁風飛食首香乘亳倌倍倣俯倦倥俸倩倖倆值借倚倒們俺倀倔倨俱倡個候倘俳修倭倪俾倫倉兼冤冥冢凍凌准凋剖剜剔剛剝匪卿原厝叟哨唐唁唷哼哥哲唆哺唔哩哭員唉哮哪"],["ae40","哦唧唇哽唏圃圄埂埔埋埃堉夏套奘奚娑娘娜娟娛娓姬娠娣娩娥娌娉孫屘宰害家宴宮宵容宸射屑展屐峭峽峻峪峨峰島崁峴差席師庫庭座弱徒徑徐恙"],["aea1","恣恥恐恕恭恩息悄悟悚悍悔悌悅悖扇拳挈拿捎挾振捕捂捆捏捉挺捐挽挪挫挨捍捌效敉料旁旅時晉晏晃晒晌晅晁書朔朕朗校核案框桓根桂桔栩梳栗桌桑栽柴桐桀格桃株桅栓栘桁殊殉殷氣氧氨氦氤泰浪涕消涇浦浸海浙涓"],["af40","浬涉浮浚浴浩涌涊浹涅浥涔烊烘烤烙烈烏爹特狼狹狽狸狷玆班琉珮珠珪珞畔畝畜畚留疾病症疲疳疽疼疹痂疸皋皰益盍盎眩真眠眨矩砰砧砸砝破砷"],["afa1","砥砭砠砟砲祕祐祠祟祖神祝祗祚秤秣秧租秦秩秘窄窈站笆笑粉紡紗紋紊素索純紐紕級紜納紙紛缺罟羔翅翁耆耘耕耙耗耽耿胱脂胰脅胭胴脆胸胳脈能脊胼胯臭臬舀舐航舫舨般芻茫荒荔荊茸荐草茵茴荏茲茹茶茗荀茱茨荃"],["b040","虔蚊蚪蚓蚤蚩蚌蚣蚜衰衷袁袂衽衹記訐討訌訕訊託訓訖訏訑豈豺豹財貢起躬軒軔軏辱送逆迷退迺迴逃追逅迸邕郡郝郢酒配酌釘針釗釜釙閃院陣陡"],["b0a1","陛陝除陘陞隻飢馬骨高鬥鬲鬼乾偺偽停假偃偌做偉健偶偎偕偵側偷偏倏偯偭兜冕凰剪副勒務勘動匐匏匙匿區匾參曼商啪啦啄啞啡啃啊唱啖問啕唯啤唸售啜唬啣唳啁啗圈國圉域堅堊堆埠埤基堂堵執培夠奢娶婁婉婦婪婀"],["b140","娼婢婚婆婊孰寇寅寄寂宿密尉專將屠屜屝崇崆崎崛崖崢崑崩崔崙崤崧崗巢常帶帳帷康庸庶庵庾張強彗彬彩彫得徙從徘御徠徜恿患悉悠您惋悴惦悽"],["b1a1","情悻悵惜悼惘惕惆惟悸惚惇戚戛扈掠控捲掖探接捷捧掘措捱掩掉掃掛捫推掄授掙採掬排掏掀捻捩捨捺敝敖救教敗啟敏敘敕敔斜斛斬族旋旌旎晝晚晤晨晦晞曹勗望梁梯梢梓梵桿桶梱梧梗械梃棄梭梆梅梔條梨梟梡梂欲殺"],["b240","毫毬氫涎涼淳淙液淡淌淤添淺清淇淋涯淑涮淞淹涸混淵淅淒渚涵淚淫淘淪深淮淨淆淄涪淬涿淦烹焉焊烽烯爽牽犁猜猛猖猓猙率琅琊球理現琍瓠瓶"],["b2a1","瓷甜產略畦畢異疏痔痕疵痊痍皎盔盒盛眷眾眼眶眸眺硫硃硎祥票祭移窒窕笠笨笛第符笙笞笮粒粗粕絆絃統紮紹紼絀細紳組累終紲紱缽羞羚翌翎習耜聊聆脯脖脣脫脩脰脤舂舵舷舶船莎莞莘荸莢莖莽莫莒莊莓莉莠荷荻荼"],["b340","莆莧處彪蛇蛀蚶蛄蚵蛆蛋蚱蚯蛉術袞袈被袒袖袍袋覓規訪訝訣訥許設訟訛訢豉豚販責貫貨貪貧赧赦趾趺軛軟這逍通逗連速逝逐逕逞造透逢逖逛途"],["b3a1","部郭都酗野釵釦釣釧釭釩閉陪陵陳陸陰陴陶陷陬雀雪雩章竟頂頃魚鳥鹵鹿麥麻傢傍傅備傑傀傖傘傚最凱割剴創剩勞勝勛博厥啻喀喧啼喊喝喘喂喜喪喔喇喋喃喳單喟唾喲喚喻喬喱啾喉喫喙圍堯堪場堤堰報堡堝堠壹壺奠"],["b440","婷媚婿媒媛媧孳孱寒富寓寐尊尋就嵌嵐崴嵇巽幅帽幀幃幾廊廁廂廄弼彭復循徨惑惡悲悶惠愜愣惺愕惰惻惴慨惱愎惶愉愀愒戟扉掣掌描揀揩揉揆揍"],["b4a1","插揣提握揖揭揮捶援揪換摒揚揹敞敦敢散斑斐斯普晰晴晶景暑智晾晷曾替期朝棺棕棠棘棗椅棟棵森棧棹棒棲棣棋棍植椒椎棉棚楮棻款欺欽殘殖殼毯氮氯氬港游湔渡渲湧湊渠渥渣減湛湘渤湖湮渭渦湯渴湍渺測湃渝渾滋"],["b540","溉渙湎湣湄湲湩湟焙焚焦焰無然煮焜牌犄犀猶猥猴猩琺琪琳琢琥琵琶琴琯琛琦琨甥甦畫番痢痛痣痙痘痞痠登發皖皓皴盜睏短硝硬硯稍稈程稅稀窘"],["b5a1","窗窖童竣等策筆筐筒答筍筋筏筑粟粥絞結絨絕紫絮絲絡給絢絰絳善翔翕耋聒肅腕腔腋腑腎脹腆脾腌腓腴舒舜菩萃菸萍菠菅萋菁華菱菴著萊菰萌菌菽菲菊萸萎萄菜萇菔菟虛蛟蛙蛭蛔蛛蛤蛐蛞街裁裂袱覃視註詠評詞証詁"],["b640","詔詛詐詆訴診訶詖象貂貯貼貳貽賁費賀貴買貶貿貸越超趁跎距跋跚跑跌跛跆軻軸軼辜逮逵週逸進逶鄂郵鄉郾酣酥量鈔鈕鈣鈉鈞鈍鈐鈇鈑閔閏開閑"],["b6a1","間閒閎隊階隋陽隅隆隍陲隄雁雅雄集雇雯雲韌項順須飧飪飯飩飲飭馮馭黃黍黑亂傭債傲傳僅傾催傷傻傯僇剿剷剽募勦勤勢勣匯嗟嗨嗓嗦嗎嗜嗇嗑嗣嗤嗯嗚嗡嗅嗆嗥嗉園圓塞塑塘塗塚塔填塌塭塊塢塒塋奧嫁嫉嫌媾媽媼"],["b740","媳嫂媲嵩嵯幌幹廉廈弒彙徬微愚意慈感想愛惹愁愈慎慌慄慍愾愴愧愍愆愷戡戢搓搾搞搪搭搽搬搏搜搔損搶搖搗搆敬斟新暗暉暇暈暖暄暘暍會榔業"],["b7a1","楚楷楠楔極椰概楊楨楫楞楓楹榆楝楣楛歇歲毀殿毓毽溢溯滓溶滂源溝滇滅溥溘溼溺溫滑準溜滄滔溪溧溴煎煙煩煤煉照煜煬煦煌煥煞煆煨煖爺牒猷獅猿猾瑯瑚瑕瑟瑞瑁琿瑙瑛瑜當畸瘀痰瘁痲痱痺痿痴痳盞盟睛睫睦睞督"],["b840","睹睪睬睜睥睨睢矮碎碰碗碘碌碉硼碑碓硿祺祿禁萬禽稜稚稠稔稟稞窟窠筷節筠筮筧粱粳粵經絹綑綁綏絛置罩罪署義羨群聖聘肆肄腱腰腸腥腮腳腫"],["b8a1","腹腺腦舅艇蒂葷落萱葵葦葫葉葬葛萼萵葡董葩葭葆虞虜號蛹蜓蜈蜇蜀蛾蛻蜂蜃蜆蜊衙裟裔裙補裘裝裡裊裕裒覜解詫該詳試詩詰誇詼詣誠話誅詭詢詮詬詹詻訾詨豢貊貉賊資賈賄貲賃賂賅跡跟跨路跳跺跪跤跦躲較載軾輊"],["b940","辟農運遊道遂達逼違遐遇遏過遍遑逾遁鄒鄗酬酪酩釉鈷鉗鈸鈽鉀鈾鉛鉋鉤鉑鈴鉉鉍鉅鈹鈿鉚閘隘隔隕雍雋雉雊雷電雹零靖靴靶預頑頓頊頒頌飼飴"],["b9a1","飽飾馳馱馴髡鳩麂鼎鼓鼠僧僮僥僖僭僚僕像僑僱僎僩兢凳劃劂匱厭嗾嘀嘛嘗嗽嘔嘆嘉嘍嘎嗷嘖嘟嘈嘐嗶團圖塵塾境墓墊塹墅塽壽夥夢夤奪奩嫡嫦嫩嫗嫖嫘嫣孵寞寧寡寥實寨寢寤察對屢嶄嶇幛幣幕幗幔廓廖弊彆彰徹慇"],["ba40","愿態慷慢慣慟慚慘慵截撇摘摔撤摸摟摺摑摧搴摭摻敲斡旗旖暢暨暝榜榨榕槁榮槓構榛榷榻榫榴槐槍榭槌榦槃榣歉歌氳漳演滾漓滴漩漾漠漬漏漂漢"],["baa1","滿滯漆漱漸漲漣漕漫漯澈漪滬漁滲滌滷熔熙煽熊熄熒爾犒犖獄獐瑤瑣瑪瑰瑭甄疑瘧瘍瘋瘉瘓盡監瞄睽睿睡磁碟碧碳碩碣禎福禍種稱窪窩竭端管箕箋筵算箝箔箏箸箇箄粹粽精綻綰綜綽綾綠緊綴網綱綺綢綿綵綸維緒緇綬"],["bb40","罰翠翡翟聞聚肇腐膀膏膈膊腿膂臧臺與舔舞艋蓉蒿蓆蓄蒙蒞蒲蒜蓋蒸蓀蓓蒐蒼蓑蓊蜿蜜蜻蜢蜥蜴蜘蝕蜷蜩裳褂裴裹裸製裨褚裯誦誌語誣認誡誓誤"],["bba1","說誥誨誘誑誚誧豪貍貌賓賑賒赫趙趕跼輔輒輕輓辣遠遘遜遣遙遞遢遝遛鄙鄘鄞酵酸酷酴鉸銀銅銘銖鉻銓銜銨鉼銑閡閨閩閣閥閤隙障際雌雒需靼鞅韶頗領颯颱餃餅餌餉駁骯骰髦魁魂鳴鳶鳳麼鼻齊億儀僻僵價儂儈儉儅凜"],["bc40","劇劈劉劍劊勰厲嘮嘻嘹嘲嘿嘴嘩噓噎噗噴嘶嘯嘰墀墟增墳墜墮墩墦奭嬉嫻嬋嫵嬌嬈寮寬審寫層履嶝嶔幢幟幡廢廚廟廝廣廠彈影德徵慶慧慮慝慕憂"],["bca1","慼慰慫慾憧憐憫憎憬憚憤憔憮戮摩摯摹撞撲撈撐撰撥撓撕撩撒撮播撫撚撬撙撢撳敵敷數暮暫暴暱樣樟槨樁樞標槽模樓樊槳樂樅槭樑歐歎殤毅毆漿潼澄潑潦潔澆潭潛潸潮澎潺潰潤澗潘滕潯潠潟熟熬熱熨牖犛獎獗瑩璋璃"],["bd40","瑾璀畿瘠瘩瘟瘤瘦瘡瘢皚皺盤瞎瞇瞌瞑瞋磋磅確磊碾磕碼磐稿稼穀稽稷稻窯窮箭箱範箴篆篇篁箠篌糊締練緯緻緘緬緝編緣線緞緩綞緙緲緹罵罷羯"],["bda1","翩耦膛膜膝膠膚膘蔗蔽蔚蓮蔬蔭蔓蔑蔣蔡蔔蓬蔥蓿蔆螂蝴蝶蝠蝦蝸蝨蝙蝗蝌蝓衛衝褐複褒褓褕褊誼諒談諄誕請諸課諉諂調誰論諍誶誹諛豌豎豬賠賞賦賤賬賭賢賣賜質賡赭趟趣踫踐踝踢踏踩踟踡踞躺輝輛輟輩輦輪輜輞"],["be40","輥適遮遨遭遷鄰鄭鄧鄱醇醉醋醃鋅銻銷鋪銬鋤鋁銳銼鋒鋇鋰銲閭閱霄霆震霉靠鞍鞋鞏頡頫頜颳養餓餒餘駝駐駟駛駑駕駒駙骷髮髯鬧魅魄魷魯鴆鴉"],["bea1","鴃麩麾黎墨齒儒儘儔儐儕冀冪凝劑劓勳噙噫噹噩噤噸噪器噥噱噯噬噢噶壁墾壇壅奮嬝嬴學寰導彊憲憑憩憊懍憶憾懊懈戰擅擁擋撻撼據擄擇擂操撿擒擔撾整曆曉暹曄曇暸樽樸樺橙橫橘樹橄橢橡橋橇樵機橈歙歷氅濂澱澡"],["bf40","濃澤濁澧澳激澹澶澦澠澴熾燉燐燒燈燕熹燎燙燜燃燄獨璜璣璘璟璞瓢甌甍瘴瘸瘺盧盥瞠瞞瞟瞥磨磚磬磧禦積穎穆穌穋窺篙簑築篤篛篡篩篦糕糖縊"],["bfa1","縑縈縛縣縞縝縉縐罹羲翰翱翮耨膳膩膨臻興艘艙蕊蕙蕈蕨蕩蕃蕉蕭蕪蕞螃螟螞螢融衡褪褲褥褫褡親覦諦諺諫諱謀諜諧諮諾謁謂諷諭諳諶諼豫豭貓賴蹄踱踴蹂踹踵輻輯輸輳辨辦遵遴選遲遼遺鄴醒錠錶鋸錳錯錢鋼錫錄錚"],["c040","錐錦錡錕錮錙閻隧隨險雕霎霑霖霍霓霏靛靜靦鞘頰頸頻頷頭頹頤餐館餞餛餡餚駭駢駱骸骼髻髭鬨鮑鴕鴣鴦鴨鴒鴛默黔龍龜優償儡儲勵嚎嚀嚐嚅嚇"],["c0a1","嚏壕壓壑壎嬰嬪嬤孺尷屨嶼嶺嶽嶸幫彌徽應懂懇懦懋戲戴擎擊擘擠擰擦擬擱擢擭斂斃曙曖檀檔檄檢檜櫛檣橾檗檐檠歜殮毚氈濘濱濟濠濛濤濫濯澀濬濡濩濕濮濰燧營燮燦燥燭燬燴燠爵牆獰獲璩環璦璨癆療癌盪瞳瞪瞰瞬"],["c140","瞧瞭矯磷磺磴磯礁禧禪穗窿簇簍篾篷簌篠糠糜糞糢糟糙糝縮績繆縷縲繃縫總縱繅繁縴縹繈縵縿縯罄翳翼聱聲聰聯聳臆臃膺臂臀膿膽臉膾臨舉艱薪"],["c1a1","薄蕾薜薑薔薯薛薇薨薊虧蟀蟑螳蟒蟆螫螻螺蟈蟋褻褶襄褸褽覬謎謗謙講謊謠謝謄謐豁谿豳賺賽購賸賻趨蹉蹋蹈蹊轄輾轂轅輿避遽還邁邂邀鄹醣醞醜鍍鎂錨鍵鍊鍥鍋錘鍾鍬鍛鍰鍚鍔闊闋闌闈闆隱隸雖霜霞鞠韓顆颶餵騁"],["c240","駿鮮鮫鮪鮭鴻鴿麋黏點黜黝黛鼾齋叢嚕嚮壙壘嬸彝懣戳擴擲擾攆擺擻擷斷曜朦檳檬櫃檻檸櫂檮檯歟歸殯瀉瀋濾瀆濺瀑瀏燻燼燾燸獷獵璧璿甕癖癘"],["c2a1","癒瞽瞿瞻瞼礎禮穡穢穠竄竅簫簧簪簞簣簡糧織繕繞繚繡繒繙罈翹翻職聶臍臏舊藏薩藍藐藉薰薺薹薦蟯蟬蟲蟠覆覲觴謨謹謬謫豐贅蹙蹣蹦蹤蹟蹕軀轉轍邇邃邈醫醬釐鎔鎊鎖鎢鎳鎮鎬鎰鎘鎚鎗闔闖闐闕離雜雙雛雞霤鞣鞦"],["c340","鞭韹額顏題顎顓颺餾餿餽餮馥騎髁鬃鬆魏魎魍鯊鯉鯽鯈鯀鵑鵝鵠黠鼕鼬儳嚥壞壟壢寵龐廬懲懷懶懵攀攏曠曝櫥櫝櫚櫓瀛瀟瀨瀚瀝瀕瀘爆爍牘犢獸"],["c3a1","獺璽瓊瓣疇疆癟癡矇礙禱穫穩簾簿簸簽簷籀繫繭繹繩繪羅繳羶羹羸臘藩藝藪藕藤藥藷蟻蠅蠍蟹蟾襠襟襖襞譁譜識證譚譎譏譆譙贈贊蹼蹲躇蹶蹬蹺蹴轔轎辭邊邋醱醮鏡鏑鏟鏃鏈鏜鏝鏖鏢鏍鏘鏤鏗鏨關隴難霪霧靡韜韻類"],["c440","願顛颼饅饉騖騙鬍鯨鯧鯖鯛鶉鵡鵲鵪鵬麒麗麓麴勸嚨嚷嚶嚴嚼壤孀孃孽寶巉懸懺攘攔攙曦朧櫬瀾瀰瀲爐獻瓏癢癥礦礪礬礫竇競籌籃籍糯糰辮繽繼"],["c4a1","纂罌耀臚艦藻藹蘑藺蘆蘋蘇蘊蠔蠕襤覺觸議譬警譯譟譫贏贍躉躁躅躂醴釋鐘鐃鏽闡霰飄饒饑馨騫騰騷騵鰓鰍鹹麵黨鼯齟齣齡儷儸囁囀囂夔屬巍懼懾攝攜斕曩櫻欄櫺殲灌爛犧瓖瓔癩矓籐纏續羼蘗蘭蘚蠣蠢蠡蠟襪襬覽譴"],["c540","護譽贓躊躍躋轟辯醺鐮鐳鐵鐺鐸鐲鐫闢霸霹露響顧顥饗驅驃驀騾髏魔魑鰭鰥鶯鶴鷂鶸麝黯鼙齜齦齧儼儻囈囊囉孿巔巒彎懿攤權歡灑灘玀瓤疊癮癬"],["c5a1","禳籠籟聾聽臟襲襯觼讀贖贗躑躓轡酈鑄鑑鑒霽霾韃韁顫饕驕驍髒鬚鱉鰱鰾鰻鷓鷗鼴齬齪龔囌巖戀攣攫攪曬欐瓚竊籤籣籥纓纖纔臢蘸蘿蠱變邐邏鑣鑠鑤靨顯饜驚驛驗髓體髑鱔鱗鱖鷥麟黴囑壩攬灞癱癲矗罐羈蠶蠹衢讓讒"],["c640","讖艷贛釀鑪靂靈靄韆顰驟鬢魘鱟鷹鷺鹼鹽鼇齷齲廳欖灣籬籮蠻觀躡釁鑲鑰顱饞髖鬣黌灤矚讚鑷韉驢驥纜讜躪釅鑽鑾鑼鱷鱸黷豔鑿鸚爨驪鬱鸛鸞籲"],["c940","乂乜凵匚厂万丌乇亍囗兀屮彳丏冇与丮亓仂仉仈冘勼卬厹圠夃夬尐巿旡殳毌气爿丱丼仨仜仩仡仝仚刌匜卌圢圣夗夯宁宄尒尻屴屳帄庀庂忉戉扐氕"],["c9a1","氶汃氿氻犮犰玊禸肊阞伎优伬仵伔仱伀价伈伝伂伅伢伓伄仴伒冱刓刉刐劦匢匟卍厊吇囡囟圮圪圴夼妀奼妅奻奾奷奿孖尕尥屼屺屻屾巟幵庄异弚彴忕忔忏扜扞扤扡扦扢扙扠扚扥旯旮朾朹朸朻机朿朼朳氘汆汒汜汏汊汔汋"],["ca40","汌灱牞犴犵玎甪癿穵网艸艼芀艽艿虍襾邙邗邘邛邔阢阤阠阣佖伻佢佉体佤伾佧佒佟佁佘伭伳伿佡冏冹刜刞刡劭劮匉卣卲厎厏吰吷吪呔呅吙吜吥吘"],["caa1","吽呏呁吨吤呇囮囧囥坁坅坌坉坋坒夆奀妦妘妠妗妎妢妐妏妧妡宎宒尨尪岍岏岈岋岉岒岊岆岓岕巠帊帎庋庉庌庈庍弅弝彸彶忒忑忐忭忨忮忳忡忤忣忺忯忷忻怀忴戺抃抌抎抏抔抇扱扻扺扰抁抈扷扽扲扴攷旰旴旳旲旵杅杇"],["cb40","杙杕杌杈杝杍杚杋毐氙氚汸汧汫沄沋沏汱汯汩沚汭沇沕沜汦汳汥汻沎灴灺牣犿犽狃狆狁犺狅玕玗玓玔玒町甹疔疕皁礽耴肕肙肐肒肜芐芏芅芎芑芓"],["cba1","芊芃芄豸迉辿邟邡邥邞邧邠阰阨阯阭丳侘佼侅佽侀侇佶佴侉侄佷佌侗佪侚佹侁佸侐侜侔侞侒侂侕佫佮冞冼冾刵刲刳剆刱劼匊匋匼厒厔咇呿咁咑咂咈呫呺呾呥呬呴呦咍呯呡呠咘呣呧呤囷囹坯坲坭坫坱坰坶垀坵坻坳坴坢"],["cc40","坨坽夌奅妵妺姏姎妲姌姁妶妼姃姖妱妽姀姈妴姇孢孥宓宕屄屇岮岤岠岵岯岨岬岟岣岭岢岪岧岝岥岶岰岦帗帔帙弨弢弣弤彔徂彾彽忞忥怭怦怙怲怋"],["cca1","怴怊怗怳怚怞怬怢怍怐怮怓怑怌怉怜戔戽抭抴拑抾抪抶拊抮抳抯抻抩抰抸攽斨斻昉旼昄昒昈旻昃昋昍昅旽昑昐曶朊枅杬枎枒杶杻枘枆构杴枍枌杺枟枑枙枃杽极杸杹枔欥殀歾毞氝沓泬泫泮泙沶泔沭泧沷泐泂沺泃泆泭泲"],["cd40","泒泝沴沊沝沀泞泀洰泍泇沰泹泏泩泑炔炘炅炓炆炄炑炖炂炚炃牪狖狋狘狉狜狒狔狚狌狑玤玡玭玦玢玠玬玝瓝瓨甿畀甾疌疘皯盳盱盰盵矸矼矹矻矺"],["cda1","矷祂礿秅穸穻竻籵糽耵肏肮肣肸肵肭舠芠苀芫芚芘芛芵芧芮芼芞芺芴芨芡芩苂芤苃芶芢虰虯虭虮豖迒迋迓迍迖迕迗邲邴邯邳邰阹阽阼阺陃俍俅俓侲俉俋俁俔俜俙侻侳俛俇俖侺俀侹俬剄剉勀勂匽卼厗厖厙厘咺咡咭咥哏"],["ce40","哃茍咷咮哖咶哅哆咠呰咼咢咾呲哞咰垵垞垟垤垌垗垝垛垔垘垏垙垥垚垕壴复奓姡姞姮娀姱姝姺姽姼姶姤姲姷姛姩姳姵姠姾姴姭宨屌峐峘峌峗峋峛"],["cea1","峞峚峉峇峊峖峓峔峏峈峆峎峟峸巹帡帢帣帠帤庰庤庢庛庣庥弇弮彖徆怷怹恔恲恞恅恓恇恉恛恌恀恂恟怤恄恘恦恮扂扃拏挍挋拵挎挃拫拹挏挌拸拶挀挓挔拺挕拻拰敁敃斪斿昶昡昲昵昜昦昢昳昫昺昝昴昹昮朏朐柁柲柈枺"],["cf40","柜枻柸柘柀枷柅柫柤柟枵柍枳柷柶柮柣柂枹柎柧柰枲柼柆柭柌枮柦柛柺柉柊柃柪柋欨殂殄殶毖毘毠氠氡洨洴洭洟洼洿洒洊泚洳洄洙洺洚洑洀洝浂"],["cfa1","洁洘洷洃洏浀洇洠洬洈洢洉洐炷炟炾炱炰炡炴炵炩牁牉牊牬牰牳牮狊狤狨狫狟狪狦狣玅珌珂珈珅玹玶玵玴珫玿珇玾珃珆玸珋瓬瓮甮畇畈疧疪癹盄眈眃眄眅眊盷盻盺矧矨砆砑砒砅砐砏砎砉砃砓祊祌祋祅祄秕种秏秖秎窀"],["d040","穾竑笀笁籺籸籹籿粀粁紃紈紁罘羑羍羾耇耎耏耔耷胘胇胠胑胈胂胐胅胣胙胜胊胕胉胏胗胦胍臿舡芔苙苾苹茇苨茀苕茺苫苖苴苬苡苲苵茌苻苶苰苪"],["d0a1","苤苠苺苳苭虷虴虼虳衁衎衧衪衩觓訄訇赲迣迡迮迠郱邽邿郕郅邾郇郋郈釔釓陔陏陑陓陊陎倞倅倇倓倢倰倛俵俴倳倷倬俶俷倗倜倠倧倵倯倱倎党冔冓凊凄凅凈凎剡剚剒剞剟剕剢勍匎厞唦哢唗唒哧哳哤唚哿唄唈哫唑唅哱"],["d140","唊哻哷哸哠唎唃唋圁圂埌堲埕埒垺埆垽垼垸垶垿埇埐垹埁夎奊娙娖娭娮娕娏娗娊娞娳孬宧宭宬尃屖屔峬峿峮峱峷崀峹帩帨庨庮庪庬弳弰彧恝恚恧"],["d1a1","恁悢悈悀悒悁悝悃悕悛悗悇悜悎戙扆拲挐捖挬捄捅挶捃揤挹捋捊挼挩捁挴捘捔捙挭捇挳捚捑挸捗捀捈敊敆旆旃旄旂晊晟晇晑朒朓栟栚桉栲栳栻桋桏栖栱栜栵栫栭栯桎桄栴栝栒栔栦栨栮桍栺栥栠欬欯欭欱欴歭肂殈毦毤"],["d240","毨毣毢毧氥浺浣浤浶洍浡涒浘浢浭浯涑涍淯浿涆浞浧浠涗浰浼浟涂涘洯浨涋浾涀涄洖涃浻浽浵涐烜烓烑烝烋缹烢烗烒烞烠烔烍烅烆烇烚烎烡牂牸"],["d2a1","牷牶猀狺狴狾狶狳狻猁珓珙珥珖玼珧珣珩珜珒珛珔珝珚珗珘珨瓞瓟瓴瓵甡畛畟疰痁疻痄痀疿疶疺皊盉眝眛眐眓眒眣眑眕眙眚眢眧砣砬砢砵砯砨砮砫砡砩砳砪砱祔祛祏祜祓祒祑秫秬秠秮秭秪秜秞秝窆窉窅窋窌窊窇竘笐"],["d340","笄笓笅笏笈笊笎笉笒粄粑粊粌粈粍粅紞紝紑紎紘紖紓紟紒紏紌罜罡罞罠罝罛羖羒翃翂翀耖耾耹胺胲胹胵脁胻脀舁舯舥茳茭荄茙荑茥荖茿荁茦茜茢"],["d3a1","荂荎茛茪茈茼荍茖茤茠茷茯茩荇荅荌荓茞茬荋茧荈虓虒蚢蚨蚖蚍蚑蚞蚇蚗蚆蚋蚚蚅蚥蚙蚡蚧蚕蚘蚎蚝蚐蚔衃衄衭衵衶衲袀衱衿衯袃衾衴衼訒豇豗豻貤貣赶赸趵趷趶軑軓迾迵适迿迻逄迼迶郖郠郙郚郣郟郥郘郛郗郜郤酐"],["d440","酎酏釕釢釚陜陟隼飣髟鬯乿偰偪偡偞偠偓偋偝偲偈偍偁偛偊偢倕偅偟偩偫偣偤偆偀偮偳偗偑凐剫剭剬剮勖勓匭厜啵啶唼啍啐唴唪啑啢唶唵唰啒啅"],["d4a1","唌唲啥啎唹啈唭唻啀啋圊圇埻堔埢埶埜埴堀埭埽堈埸堋埳埏堇埮埣埲埥埬埡堎埼堐埧堁堌埱埩埰堍堄奜婠婘婕婧婞娸娵婭婐婟婥婬婓婤婗婃婝婒婄婛婈媎娾婍娹婌婰婩婇婑婖婂婜孲孮寁寀屙崞崋崝崚崠崌崨崍崦崥崏"],["d540","崰崒崣崟崮帾帴庱庴庹庲庳弶弸徛徖徟悊悐悆悾悰悺惓惔惏惤惙惝惈悱惛悷惊悿惃惍惀挲捥掊掂捽掽掞掭掝掗掫掎捯掇掐据掯捵掜捭掮捼掤挻掟"],["d5a1","捸掅掁掑掍捰敓旍晥晡晛晙晜晢朘桹梇梐梜桭桮梮梫楖桯梣梬梩桵桴梲梏桷梒桼桫桲梪梀桱桾梛梖梋梠梉梤桸桻梑梌梊桽欶欳欷欸殑殏殍殎殌氪淀涫涴涳湴涬淩淢涷淶淔渀淈淠淟淖涾淥淜淝淛淴淊涽淭淰涺淕淂淏淉"],["d640","淐淲淓淽淗淍淣涻烺焍烷焗烴焌烰焄烳焐烼烿焆焓焀烸烶焋焂焎牾牻牼牿猝猗猇猑猘猊猈狿猏猞玈珶珸珵琄琁珽琇琀珺珼珿琌琋珴琈畤畣痎痒痏"],["d6a1","痋痌痑痐皏皉盓眹眯眭眱眲眴眳眽眥眻眵硈硒硉硍硊硌砦硅硐祤祧祩祪祣祫祡离秺秸秶秷窏窔窐笵筇笴笥笰笢笤笳笘笪笝笱笫笭笯笲笸笚笣粔粘粖粣紵紽紸紶紺絅紬紩絁絇紾紿絊紻紨罣羕羜羝羛翊翋翍翐翑翇翏翉耟"],["d740","耞耛聇聃聈脘脥脙脛脭脟脬脞脡脕脧脝脢舑舸舳舺舴舲艴莐莣莨莍荺荳莤荴莏莁莕莙荵莔莩荽莃莌莝莛莪莋荾莥莯莈莗莰荿莦莇莮荶莚虙虖蚿蚷"],["d7a1","蛂蛁蛅蚺蚰蛈蚹蚳蚸蛌蚴蚻蚼蛃蚽蚾衒袉袕袨袢袪袚袑袡袟袘袧袙袛袗袤袬袌袓袎覂觖觙觕訰訧訬訞谹谻豜豝豽貥赽赻赹趼跂趹趿跁軘軞軝軜軗軠軡逤逋逑逜逌逡郯郪郰郴郲郳郔郫郬郩酖酘酚酓酕釬釴釱釳釸釤釹釪"],["d840","釫釷釨釮镺閆閈陼陭陫陱陯隿靪頄飥馗傛傕傔傞傋傣傃傌傎傝偨傜傒傂傇兟凔匒匑厤厧喑喨喥喭啷噅喢喓喈喏喵喁喣喒喤啽喌喦啿喕喡喎圌堩堷"],["d8a1","堙堞堧堣堨埵塈堥堜堛堳堿堶堮堹堸堭堬堻奡媯媔媟婺媢媞婸媦婼媥媬媕媮娷媄媊媗媃媋媩婻婽媌媜媏媓媝寪寍寋寔寑寊寎尌尰崷嵃嵫嵁嵋崿崵嵑嵎嵕崳崺嵒崽崱嵙嵂崹嵉崸崼崲崶嵀嵅幄幁彘徦徥徫惉悹惌惢惎惄愔"],["d940","惲愊愖愅惵愓惸惼惾惁愃愘愝愐惿愄愋扊掔掱掰揎揥揨揯揃撝揳揊揠揶揕揲揵摡揟掾揝揜揄揘揓揂揇揌揋揈揰揗揙攲敧敪敤敜敨敥斌斝斞斮旐旒"],["d9a1","晼晬晻暀晱晹晪晲朁椌棓椄棜椪棬棪棱椏棖棷棫棤棶椓椐棳棡椇棌椈楰梴椑棯棆椔棸棐棽棼棨椋椊椗棎棈棝棞棦棴棑椆棔棩椕椥棇欹欻欿欼殔殗殙殕殽毰毲毳氰淼湆湇渟湉溈渼渽湅湢渫渿湁湝湳渜渳湋湀湑渻渃渮湞"],["da40","湨湜湡渱渨湠湱湫渹渢渰湓湥渧湸湤湷湕湹湒湦渵渶湚焠焞焯烻焮焱焣焥焢焲焟焨焺焛牋牚犈犉犆犅犋猒猋猰猢猱猳猧猲猭猦猣猵猌琮琬琰琫琖"],["daa1","琚琡琭琱琤琣琝琩琠琲瓻甯畯畬痧痚痡痦痝痟痤痗皕皒盚睆睇睄睍睅睊睎睋睌矞矬硠硤硥硜硭硱硪确硰硩硨硞硢祴祳祲祰稂稊稃稌稄窙竦竤筊笻筄筈筌筎筀筘筅粢粞粨粡絘絯絣絓絖絧絪絏絭絜絫絒絔絩絑絟絎缾缿罥"],["db40","罦羢羠羡翗聑聏聐胾胔腃腊腒腏腇脽腍脺臦臮臷臸臹舄舼舽舿艵茻菏菹萣菀菨萒菧菤菼菶萐菆菈菫菣莿萁菝菥菘菿菡菋菎菖菵菉萉萏菞萑萆菂菳"],["dba1","菕菺菇菑菪萓菃菬菮菄菻菗菢萛菛菾蛘蛢蛦蛓蛣蛚蛪蛝蛫蛜蛬蛩蛗蛨蛑衈衖衕袺裗袹袸裀袾袶袼袷袽袲褁裉覕覘覗觝觚觛詎詍訹詙詀詗詘詄詅詒詈詑詊詌詏豟貁貀貺貾貰貹貵趄趀趉跘跓跍跇跖跜跏跕跙跈跗跅軯軷軺"],["dc40","軹軦軮軥軵軧軨軶軫軱軬軴軩逭逴逯鄆鄬鄄郿郼鄈郹郻鄁鄀鄇鄅鄃酡酤酟酢酠鈁鈊鈥鈃鈚鈦鈏鈌鈀鈒釿釽鈆鈄鈧鈂鈜鈤鈙鈗鈅鈖镻閍閌閐隇陾隈"],["dca1","隉隃隀雂雈雃雱雰靬靰靮頇颩飫鳦黹亃亄亶傽傿僆傮僄僊傴僈僂傰僁傺傱僋僉傶傸凗剺剸剻剼嗃嗛嗌嗐嗋嗊嗝嗀嗔嗄嗩喿嗒喍嗏嗕嗢嗖嗈嗲嗍嗙嗂圔塓塨塤塏塍塉塯塕塎塝塙塥塛堽塣塱壼嫇嫄嫋媺媸媱媵媰媿嫈媻嫆"],["dd40","媷嫀嫊媴媶嫍媹媐寖寘寙尟尳嵱嵣嵊嵥嵲嵬嵞嵨嵧嵢巰幏幎幊幍幋廅廌廆廋廇彀徯徭惷慉慊愫慅愶愲愮慆愯慏愩慀戠酨戣戥戤揅揱揫搐搒搉搠搤"],["dda1","搳摃搟搕搘搹搷搢搣搌搦搰搨摁搵搯搊搚摀搥搧搋揧搛搮搡搎敯斒旓暆暌暕暐暋暊暙暔晸朠楦楟椸楎楢楱椿楅楪椹楂楗楙楺楈楉椵楬椳椽楥棰楸椴楩楀楯楄楶楘楁楴楌椻楋椷楜楏楑椲楒椯楻椼歆歅歃歂歈歁殛嗀毻毼"],["de40","毹毷毸溛滖滈溏滀溟溓溔溠溱溹滆滒溽滁溞滉溷溰滍溦滏溲溾滃滜滘溙溒溎溍溤溡溿溳滐滊溗溮溣煇煔煒煣煠煁煝煢煲煸煪煡煂煘煃煋煰煟煐煓"],["dea1","煄煍煚牏犍犌犑犐犎猼獂猻猺獀獊獉瑄瑊瑋瑒瑑瑗瑀瑏瑐瑎瑂瑆瑍瑔瓡瓿瓾瓽甝畹畷榃痯瘏瘃痷痾痼痹痸瘐痻痶痭痵痽皙皵盝睕睟睠睒睖睚睩睧睔睙睭矠碇碚碔碏碄碕碅碆碡碃硹碙碀碖硻祼禂祽祹稑稘稙稒稗稕稢稓"],["df40","稛稐窣窢窞竫筦筤筭筴筩筲筥筳筱筰筡筸筶筣粲粴粯綈綆綀綍絿綅絺綎絻綃絼綌綔綄絽綒罭罫罧罨罬羦羥羧翛翜耡腤腠腷腜腩腛腢腲朡腞腶腧腯"],["dfa1","腄腡舝艉艄艀艂艅蓱萿葖葶葹蒏蒍葥葑葀蒆葧萰葍葽葚葙葴葳葝蔇葞萷萺萴葺葃葸萲葅萩菙葋萯葂萭葟葰萹葎葌葒葯蓅蒎萻葇萶萳葨葾葄萫葠葔葮葐蜋蜄蛷蜌蛺蛖蛵蝍蛸蜎蜉蜁蛶蜍蜅裖裋裍裎裞裛裚裌裐覅覛觟觥觤"],["e040","觡觠觢觜触詶誆詿詡訿詷誂誄詵誃誁詴詺谼豋豊豥豤豦貆貄貅賌赨赩趑趌趎趏趍趓趔趐趒跰跠跬跱跮跐跩跣跢跧跲跫跴輆軿輁輀輅輇輈輂輋遒逿"],["e0a1","遄遉逽鄐鄍鄏鄑鄖鄔鄋鄎酮酯鉈鉒鈰鈺鉦鈳鉥鉞銃鈮鉊鉆鉭鉬鉏鉠鉧鉯鈶鉡鉰鈱鉔鉣鉐鉲鉎鉓鉌鉖鈲閟閜閞閛隒隓隑隗雎雺雽雸雵靳靷靸靲頏頍頎颬飶飹馯馲馰馵骭骫魛鳪鳭鳧麀黽僦僔僗僨僳僛僪僝僤僓僬僰僯僣僠"],["e140","凘劀劁勩勫匰厬嘧嘕嘌嘒嗼嘏嘜嘁嘓嘂嗺嘝嘄嗿嗹墉塼墐墘墆墁塿塴墋塺墇墑墎塶墂墈塻墔墏壾奫嫜嫮嫥嫕嫪嫚嫭嫫嫳嫢嫠嫛嫬嫞嫝嫙嫨嫟孷寠"],["e1a1","寣屣嶂嶀嵽嶆嵺嶁嵷嶊嶉嶈嵾嵼嶍嵹嵿幘幙幓廘廑廗廎廜廕廙廒廔彄彃彯徶愬愨慁慞慱慳慒慓慲慬憀慴慔慺慛慥愻慪慡慖戩戧戫搫摍摛摝摴摶摲摳摽摵摦撦摎撂摞摜摋摓摠摐摿搿摬摫摙摥摷敳斠暡暠暟朅朄朢榱榶槉"],["e240","榠槎榖榰榬榼榑榙榎榧榍榩榾榯榿槄榽榤槔榹槊榚槏榳榓榪榡榞槙榗榐槂榵榥槆歊歍歋殞殟殠毃毄毾滎滵滱漃漥滸漷滻漮漉潎漙漚漧漘漻漒滭漊"],["e2a1","漶潳滹滮漭潀漰漼漵滫漇漎潃漅滽滶漹漜滼漺漟漍漞漈漡熇熐熉熀熅熂熏煻熆熁熗牄牓犗犕犓獃獍獑獌瑢瑳瑱瑵瑲瑧瑮甀甂甃畽疐瘖瘈瘌瘕瘑瘊瘔皸瞁睼瞅瞂睮瞀睯睾瞃碲碪碴碭碨硾碫碞碥碠碬碢碤禘禊禋禖禕禔禓"],["e340","禗禈禒禐稫穊稰稯稨稦窨窫窬竮箈箜箊箑箐箖箍箌箛箎箅箘劄箙箤箂粻粿粼粺綧綷緂綣綪緁緀緅綝緎緄緆緋緌綯綹綖綼綟綦綮綩綡緉罳翢翣翥翞"],["e3a1","耤聝聜膉膆膃膇膍膌膋舕蒗蒤蒡蒟蒺蓎蓂蒬蒮蒫蒹蒴蓁蓍蒪蒚蒱蓐蒝蒧蒻蒢蒔蓇蓌蒛蒩蒯蒨蓖蒘蒶蓏蒠蓗蓔蓒蓛蒰蒑虡蜳蜣蜨蝫蝀蜮蜞蜡蜙蜛蝃蜬蝁蜾蝆蜠蜲蜪蜭蜼蜒蜺蜱蜵蝂蜦蜧蜸蜤蜚蜰蜑裷裧裱裲裺裾裮裼裶裻"],["e440","裰裬裫覝覡覟覞觩觫觨誫誙誋誒誏誖谽豨豩賕賏賗趖踉踂跿踍跽踊踃踇踆踅跾踀踄輐輑輎輍鄣鄜鄠鄢鄟鄝鄚鄤鄡鄛酺酲酹酳銥銤鉶銛鉺銠銔銪銍"],["e4a1","銦銚銫鉹銗鉿銣鋮銎銂銕銢鉽銈銡銊銆銌銙銧鉾銇銩銝銋鈭隞隡雿靘靽靺靾鞃鞀鞂靻鞄鞁靿韎韍頖颭颮餂餀餇馝馜駃馹馻馺駂馽駇骱髣髧鬾鬿魠魡魟鳱鳲鳵麧僿儃儰僸儆儇僶僾儋儌僽儊劋劌勱勯噈噂噌嘵噁噊噉噆噘"],["e540","噚噀嘳嘽嘬嘾嘸嘪嘺圚墫墝墱墠墣墯墬墥墡壿嫿嫴嫽嫷嫶嬃嫸嬂嫹嬁嬇嬅嬏屧嶙嶗嶟嶒嶢嶓嶕嶠嶜嶡嶚嶞幩幝幠幜緳廛廞廡彉徲憋憃慹憱憰憢憉"],["e5a1","憛憓憯憭憟憒憪憡憍慦憳戭摮摰撖撠撅撗撜撏撋撊撌撣撟摨撱撘敶敺敹敻斲斳暵暰暩暲暷暪暯樀樆樗槥槸樕槱槤樠槿槬槢樛樝槾樧槲槮樔槷槧橀樈槦槻樍槼槫樉樄樘樥樏槶樦樇槴樖歑殥殣殢殦氁氀毿氂潁漦潾澇濆澒"],["e640","澍澉澌潢潏澅潚澖潶潬澂潕潲潒潐潗澔澓潝漀潡潫潽潧澐潓澋潩潿澕潣潷潪潻熲熯熛熰熠熚熩熵熝熥熞熤熡熪熜熧熳犘犚獘獒獞獟獠獝獛獡獚獙"],["e6a1","獢璇璉璊璆璁瑽璅璈瑼瑹甈甇畾瘥瘞瘙瘝瘜瘣瘚瘨瘛皜皝皞皛瞍瞏瞉瞈磍碻磏磌磑磎磔磈磃磄磉禚禡禠禜禢禛歶稹窲窴窳箷篋箾箬篎箯箹篊箵糅糈糌糋緷緛緪緧緗緡縃緺緦緶緱緰緮緟罶羬羰羭翭翫翪翬翦翨聤聧膣膟"],["e740","膞膕膢膙膗舖艏艓艒艐艎艑蔤蔻蔏蔀蔩蔎蔉蔍蔟蔊蔧蔜蓻蔫蓺蔈蔌蓴蔪蓲蔕蓷蓫蓳蓼蔒蓪蓩蔖蓾蔨蔝蔮蔂蓽蔞蓶蔱蔦蓧蓨蓰蓯蓹蔘蔠蔰蔋蔙蔯虢"],["e7a1","蝖蝣蝤蝷蟡蝳蝘蝔蝛蝒蝡蝚蝑蝞蝭蝪蝐蝎蝟蝝蝯蝬蝺蝮蝜蝥蝏蝻蝵蝢蝧蝩衚褅褌褔褋褗褘褙褆褖褑褎褉覢覤覣觭觰觬諏諆誸諓諑諔諕誻諗誾諀諅諘諃誺誽諙谾豍貏賥賟賙賨賚賝賧趠趜趡趛踠踣踥踤踮踕踛踖踑踙踦踧"],["e840","踔踒踘踓踜踗踚輬輤輘輚輠輣輖輗遳遰遯遧遫鄯鄫鄩鄪鄲鄦鄮醅醆醊醁醂醄醀鋐鋃鋄鋀鋙銶鋏鋱鋟鋘鋩鋗鋝鋌鋯鋂鋨鋊鋈鋎鋦鋍鋕鋉鋠鋞鋧鋑鋓"],["e8a1","銵鋡鋆銴镼閬閫閮閰隤隢雓霅霈霂靚鞊鞎鞈韐韏頞頝頦頩頨頠頛頧颲餈飺餑餔餖餗餕駜駍駏駓駔駎駉駖駘駋駗駌骳髬髫髳髲髱魆魃魧魴魱魦魶魵魰魨魤魬鳼鳺鳽鳿鳷鴇鴀鳹鳻鴈鴅鴄麃黓鼏鼐儜儓儗儚儑凞匴叡噰噠噮"],["e940","噳噦噣噭噲噞噷圜圛壈墽壉墿墺壂墼壆嬗嬙嬛嬡嬔嬓嬐嬖嬨嬚嬠嬞寯嶬嶱嶩嶧嶵嶰嶮嶪嶨嶲嶭嶯嶴幧幨幦幯廩廧廦廨廥彋徼憝憨憖懅憴懆懁懌憺"],["e9a1","憿憸憌擗擖擐擏擉撽撉擃擛擳擙攳敿敼斢曈暾曀曊曋曏暽暻暺曌朣樴橦橉橧樲橨樾橝橭橶橛橑樨橚樻樿橁橪橤橐橏橔橯橩橠樼橞橖橕橍橎橆歕歔歖殧殪殫毈毇氄氃氆澭濋澣濇澼濎濈潞濄澽澞濊澨瀄澥澮澺澬澪濏澿澸"],["ea40","澢濉澫濍澯澲澰燅燂熿熸燖燀燁燋燔燊燇燏熽燘熼燆燚燛犝犞獩獦獧獬獥獫獪瑿璚璠璔璒璕璡甋疀瘯瘭瘱瘽瘳瘼瘵瘲瘰皻盦瞚瞝瞡瞜瞛瞢瞣瞕瞙"],["eaa1","瞗磝磩磥磪磞磣磛磡磢磭磟磠禤穄穈穇窶窸窵窱窷篞篣篧篝篕篥篚篨篹篔篪篢篜篫篘篟糒糔糗糐糑縒縡縗縌縟縠縓縎縜縕縚縢縋縏縖縍縔縥縤罃罻罼罺羱翯耪耩聬膱膦膮膹膵膫膰膬膴膲膷膧臲艕艖艗蕖蕅蕫蕍蕓蕡蕘"],["eb40","蕀蕆蕤蕁蕢蕄蕑蕇蕣蔾蕛蕱蕎蕮蕵蕕蕧蕠薌蕦蕝蕔蕥蕬虣虥虤螛螏螗螓螒螈螁螖螘蝹螇螣螅螐螑螝螄螔螜螚螉褞褦褰褭褮褧褱褢褩褣褯褬褟觱諠"],["eba1","諢諲諴諵諝謔諤諟諰諈諞諡諨諿諯諻貑貒貐賵賮賱賰賳赬赮趥趧踳踾踸蹀蹅踶踼踽蹁踰踿躽輶輮輵輲輹輷輴遶遹遻邆郺鄳鄵鄶醓醐醑醍醏錧錞錈錟錆錏鍺錸錼錛錣錒錁鍆錭錎錍鋋錝鋺錥錓鋹鋷錴錂錤鋿錩錹錵錪錔錌"],["ec40","錋鋾錉錀鋻錖閼闍閾閹閺閶閿閵閽隩雔霋霒霐鞙鞗鞔韰韸頵頯頲餤餟餧餩馞駮駬駥駤駰駣駪駩駧骹骿骴骻髶髺髹髷鬳鮀鮅鮇魼魾魻鮂鮓鮒鮐魺鮕"],["eca1","魽鮈鴥鴗鴠鴞鴔鴩鴝鴘鴢鴐鴙鴟麈麆麇麮麭黕黖黺鼒鼽儦儥儢儤儠儩勴嚓嚌嚍嚆嚄嚃噾嚂噿嚁壖壔壏壒嬭嬥嬲嬣嬬嬧嬦嬯嬮孻寱寲嶷幬幪徾徻懃憵憼懧懠懥懤懨懞擯擩擣擫擤擨斁斀斶旚曒檍檖檁檥檉檟檛檡檞檇檓檎"],["ed40","檕檃檨檤檑橿檦檚檅檌檒歛殭氉濌澩濴濔濣濜濭濧濦濞濲濝濢濨燡燱燨燲燤燰燢獳獮獯璗璲璫璐璪璭璱璥璯甐甑甒甏疄癃癈癉癇皤盩瞵瞫瞲瞷瞶"],["eda1","瞴瞱瞨矰磳磽礂磻磼磲礅磹磾礄禫禨穜穛穖穘穔穚窾竀竁簅簏篲簀篿篻簎篴簋篳簂簉簃簁篸篽簆篰篱簐簊糨縭縼繂縳顈縸縪繉繀繇縩繌縰縻縶繄縺罅罿罾罽翴翲耬膻臄臌臊臅臇膼臩艛艚艜薃薀薏薧薕薠薋薣蕻薤薚薞"],["ee40","蕷蕼薉薡蕺蕸蕗薎薖薆薍薙薝薁薢薂薈薅蕹蕶薘薐薟虨螾螪螭蟅螰螬螹螵螼螮蟉蟃蟂蟌螷螯蟄蟊螴螶螿螸螽蟞螲褵褳褼褾襁襒褷襂覭覯覮觲觳謞"],["eea1","謘謖謑謅謋謢謏謒謕謇謍謈謆謜謓謚豏豰豲豱豯貕貔賹赯蹎蹍蹓蹐蹌蹇轃轀邅遾鄸醚醢醛醙醟醡醝醠鎡鎃鎯鍤鍖鍇鍼鍘鍜鍶鍉鍐鍑鍠鍭鎏鍌鍪鍹鍗鍕鍒鍏鍱鍷鍻鍡鍞鍣鍧鎀鍎鍙闇闀闉闃闅閷隮隰隬霠霟霘霝霙鞚鞡鞜"],["ef40","鞞鞝韕韔韱顁顄顊顉顅顃餥餫餬餪餳餲餯餭餱餰馘馣馡騂駺駴駷駹駸駶駻駽駾駼騃骾髾髽鬁髼魈鮚鮨鮞鮛鮦鮡鮥鮤鮆鮢鮠鮯鴳鵁鵧鴶鴮鴯鴱鴸鴰"],["efa1","鵅鵂鵃鴾鴷鵀鴽翵鴭麊麉麍麰黈黚黻黿鼤鼣鼢齔龠儱儭儮嚘嚜嚗嚚嚝嚙奰嬼屩屪巀幭幮懘懟懭懮懱懪懰懫懖懩擿攄擽擸攁攃擼斔旛曚曛曘櫅檹檽櫡櫆檺檶檷櫇檴檭歞毉氋瀇瀌瀍瀁瀅瀔瀎濿瀀濻瀦濼濷瀊爁燿燹爃燽獶"],["f040","璸瓀璵瓁璾璶璻瓂甔甓癜癤癙癐癓癗癚皦皽盬矂瞺磿礌礓礔礉礐礒礑禭禬穟簜簩簙簠簟簭簝簦簨簢簥簰繜繐繖繣繘繢繟繑繠繗繓羵羳翷翸聵臑臒"],["f0a1","臐艟艞薴藆藀藃藂薳薵薽藇藄薿藋藎藈藅薱薶藒蘤薸薷薾虩蟧蟦蟢蟛蟫蟪蟥蟟蟳蟤蟔蟜蟓蟭蟘蟣螤蟗蟙蠁蟴蟨蟝襓襋襏襌襆襐襑襉謪謧謣謳謰謵譇謯謼謾謱謥謷謦謶謮謤謻謽謺豂豵貙貘貗賾贄贂贀蹜蹢蹠蹗蹖蹞蹥蹧"],["f140","蹛蹚蹡蹝蹩蹔轆轇轈轋鄨鄺鄻鄾醨醥醧醯醪鎵鎌鎒鎷鎛鎝鎉鎧鎎鎪鎞鎦鎕鎈鎙鎟鎍鎱鎑鎲鎤鎨鎴鎣鎥闒闓闑隳雗雚巂雟雘雝霣霢霥鞬鞮鞨鞫鞤鞪"],["f1a1","鞢鞥韗韙韖韘韺顐顑顒颸饁餼餺騏騋騉騍騄騑騊騅騇騆髀髜鬈鬄鬅鬩鬵魊魌魋鯇鯆鯃鮿鯁鮵鮸鯓鮶鯄鮹鮽鵜鵓鵏鵊鵛鵋鵙鵖鵌鵗鵒鵔鵟鵘鵚麎麌黟鼁鼀鼖鼥鼫鼪鼩鼨齌齕儴儵劖勷厴嚫嚭嚦嚧嚪嚬壚壝壛夒嬽嬾嬿巃幰"],["f240","徿懻攇攐攍攉攌攎斄旞旝曞櫧櫠櫌櫑櫙櫋櫟櫜櫐櫫櫏櫍櫞歠殰氌瀙瀧瀠瀖瀫瀡瀢瀣瀩瀗瀤瀜瀪爌爊爇爂爅犥犦犤犣犡瓋瓅璷瓃甖癠矉矊矄矱礝礛"],["f2a1","礡礜礗礞禰穧穨簳簼簹簬簻糬糪繶繵繸繰繷繯繺繲繴繨罋罊羃羆羷翽翾聸臗臕艤艡艣藫藱藭藙藡藨藚藗藬藲藸藘藟藣藜藑藰藦藯藞藢蠀蟺蠃蟶蟷蠉蠌蠋蠆蟼蠈蟿蠊蠂襢襚襛襗襡襜襘襝襙覈覷覶觶譐譈譊譀譓譖譔譋譕"],["f340","譑譂譒譗豃豷豶貚贆贇贉趬趪趭趫蹭蹸蹳蹪蹯蹻軂轒轑轏轐轓辴酀鄿醰醭鏞鏇鏏鏂鏚鏐鏹鏬鏌鏙鎩鏦鏊鏔鏮鏣鏕鏄鏎鏀鏒鏧镽闚闛雡霩霫霬霨霦"],["f3a1","鞳鞷鞶韝韞韟顜顙顝顗颿颽颻颾饈饇饃馦馧騚騕騥騝騤騛騢騠騧騣騞騜騔髂鬋鬊鬎鬌鬷鯪鯫鯠鯞鯤鯦鯢鯰鯔鯗鯬鯜鯙鯥鯕鯡鯚鵷鶁鶊鶄鶈鵱鶀鵸鶆鶋鶌鵽鵫鵴鵵鵰鵩鶅鵳鵻鶂鵯鵹鵿鶇鵨麔麑黀黼鼭齀齁齍齖齗齘匷嚲"],["f440","嚵嚳壣孅巆巇廮廯忀忁懹攗攖攕攓旟曨曣曤櫳櫰櫪櫨櫹櫱櫮櫯瀼瀵瀯瀷瀴瀱灂瀸瀿瀺瀹灀瀻瀳灁爓爔犨獽獼璺皫皪皾盭矌矎矏矍矲礥礣礧礨礤礩"],["f4a1","禲穮穬穭竷籉籈籊籇籅糮繻繾纁纀羺翿聹臛臙舋艨艩蘢藿蘁藾蘛蘀藶蘄蘉蘅蘌藽蠙蠐蠑蠗蠓蠖襣襦覹觷譠譪譝譨譣譥譧譭趮躆躈躄轙轖轗轕轘轚邍酃酁醷醵醲醳鐋鐓鏻鐠鐏鐔鏾鐕鐐鐨鐙鐍鏵鐀鏷鐇鐎鐖鐒鏺鐉鏸鐊鏿"],["f540","鏼鐌鏶鐑鐆闞闠闟霮霯鞹鞻韽韾顠顢顣顟飁飂饐饎饙饌饋饓騲騴騱騬騪騶騩騮騸騭髇髊髆鬐鬒鬑鰋鰈鯷鰅鰒鯸鱀鰇鰎鰆鰗鰔鰉鶟鶙鶤鶝鶒鶘鶐鶛"],["f5a1","鶠鶔鶜鶪鶗鶡鶚鶢鶨鶞鶣鶿鶩鶖鶦鶧麙麛麚黥黤黧黦鼰鼮齛齠齞齝齙龑儺儹劘劗囃嚽嚾孈孇巋巏廱懽攛欂櫼欃櫸欀灃灄灊灈灉灅灆爝爚爙獾甗癪矐礭礱礯籔籓糲纊纇纈纋纆纍罍羻耰臝蘘蘪蘦蘟蘣蘜蘙蘧蘮蘡蘠蘩蘞蘥"],["f640","蠩蠝蠛蠠蠤蠜蠫衊襭襩襮襫觺譹譸譅譺譻贐贔趯躎躌轞轛轝酆酄酅醹鐿鐻鐶鐩鐽鐼鐰鐹鐪鐷鐬鑀鐱闥闤闣霵霺鞿韡顤飉飆飀饘饖騹騽驆驄驂驁騺"],["f6a1","騿髍鬕鬗鬘鬖鬺魒鰫鰝鰜鰬鰣鰨鰩鰤鰡鶷鶶鶼鷁鷇鷊鷏鶾鷅鷃鶻鶵鷎鶹鶺鶬鷈鶱鶭鷌鶳鷍鶲鹺麜黫黮黭鼛鼘鼚鼱齎齥齤龒亹囆囅囋奱孋孌巕巑廲攡攠攦攢欋欈欉氍灕灖灗灒爞爟犩獿瓘瓕瓙瓗癭皭礵禴穰穱籗籜籙籛籚"],["f740","糴糱纑罏羇臞艫蘴蘵蘳蘬蘲蘶蠬蠨蠦蠪蠥襱覿覾觻譾讄讂讆讅譿贕躕躔躚躒躐躖躗轠轢酇鑌鑐鑊鑋鑏鑇鑅鑈鑉鑆霿韣顪顩飋饔饛驎驓驔驌驏驈驊"],["f7a1","驉驒驐髐鬙鬫鬻魖魕鱆鱈鰿鱄鰹鰳鱁鰼鰷鰴鰲鰽鰶鷛鷒鷞鷚鷋鷐鷜鷑鷟鷩鷙鷘鷖鷵鷕鷝麶黰鼵鼳鼲齂齫龕龢儽劙壨壧奲孍巘蠯彏戁戃戄攩攥斖曫欑欒欏毊灛灚爢玂玁玃癰矔籧籦纕艬蘺虀蘹蘼蘱蘻蘾蠰蠲蠮蠳襶襴襳觾"],["f840","讌讎讋讈豅贙躘轤轣醼鑢鑕鑝鑗鑞韄韅頀驖驙鬞鬟鬠鱒鱘鱐鱊鱍鱋鱕鱙鱌鱎鷻鷷鷯鷣鷫鷸鷤鷶鷡鷮鷦鷲鷰鷢鷬鷴鷳鷨鷭黂黐黲黳鼆鼜鼸鼷鼶齃齏"],["f8a1","齱齰齮齯囓囍孎屭攭曭曮欓灟灡灝灠爣瓛瓥矕礸禷禶籪纗羉艭虃蠸蠷蠵衋讔讕躞躟躠躝醾醽釂鑫鑨鑩雥靆靃靇韇韥驞髕魙鱣鱧鱦鱢鱞鱠鸂鷾鸇鸃鸆鸅鸀鸁鸉鷿鷽鸄麠鼞齆齴齵齶囔攮斸欘欙欗欚灢爦犪矘矙礹籩籫糶纚"],["f940","纘纛纙臠臡虆虇虈襹襺襼襻觿讘讙躥躤躣鑮鑭鑯鑱鑳靉顲饟鱨鱮鱭鸋鸍鸐鸏鸒鸑麡黵鼉齇齸齻齺齹圞灦籯蠼趲躦釃鑴鑸鑶鑵驠鱴鱳鱱鱵鸔鸓黶鼊"],["f9a1","龤灨灥糷虪蠾蠽蠿讞貜躩軉靋顳顴飌饡馫驤驦驧鬤鸕鸗齈戇欞爧虌躨钂钀钁驩驨鬮鸙爩虋讟钃鱹麷癵驫鱺鸝灩灪麤齾齉龘碁銹裏墻恒粧嫺╔╦╗╠╬╣╚╩╝╒╤╕╞╪╡╘╧╛╓╥╖╟╫╢╙╨╜║═╭╮╰╯▓"]]',
      );
    },
    1532: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",127],["8ea1","｡",62],["a1a1","　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈",9,"＋－±×÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇"],["a2a1","◆□■△▲▽▼※〒→←↑↓〓"],["a2ba","∈∋⊆⊇⊂⊃∪∩"],["a2ca","∧∨￢⇒⇔∀∃"],["a2dc","∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],["a2f2","Å‰♯♭♪†‡¶"],["a2fe","◯"],["a3b0","０",9],["a3c1","Ａ",25],["a3e1","ａ",25],["a4a1","ぁ",82],["a5a1","ァ",85],["a6a1","Α",16,"Σ",6],["a6c1","α",16,"σ",6],["a7a1","А",5,"ЁЖ",25],["a7d1","а",5,"ёж",25],["a8a1","─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],["ada1","①",19,"Ⅰ",9],["adc0","㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],["addf","㍻〝〟№㏍℡㊤",4,"㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],["b0a1","亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],["b1a1","院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応"],["b2a1","押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],["b3a1","魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱"],["b4a1","粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],["b5a1","機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京"],["b6a1","供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],["b7a1","掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲"],["b8a1","検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],["b9a1","后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込"],["baa1","此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],["bba1","察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時"],["bca1","次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],["bda1","宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償"],["bea1","勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],["bfa1","拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾"],["c0a1","澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],["c1a1","繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎"],["c2a1","臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],["c3a1","叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵"],["c4a1","帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],["c5a1","邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到"],["c6a1","董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],["c7a1","如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦"],["c8a1","函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],["c9a1","鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服"],["caa1","福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],["cba1","法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満"],["cca1","漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],["cda1","諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃"],["cea1","痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],["cfa1","蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],["d0a1","弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],["d1a1","僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨"],["d2a1","辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],["d3a1","咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉"],["d4a1","圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],["d5a1","奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓"],["d6a1","屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],["d7a1","廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚"],["d8a1","悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],["d9a1","戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼"],["daa1","據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],["dba1","曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍"],["dca1","棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],["dda1","檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾"],["dea1","沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],["dfa1","漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼"],["e0a1","燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],["e1a1","瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰"],["e2a1","癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],["e3a1","磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐"],["e4a1","筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],["e5a1","紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺"],["e6a1","罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],["e7a1","隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙"],["e8a1","茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],["e9a1","蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙"],["eaa1","蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],["eba1","襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫"],["eca1","譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],["eda1","蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸"],["eea1","遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],["efa1","錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞"],["f0a1","陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],["f1a1","顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷"],["f2a1","髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],["f3a1","鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠"],["f4a1","堯槇遙瑤凜熙"],["f9a1","纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德"],["faa1","忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],["fba1","犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚"],["fca1","釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],["fcf1","ⅰ",9,"￢￤＇＂"],["8fa2af","˘ˇ¸˙˝¯˛˚～΄΅"],["8fa2c2","¡¦¿"],["8fa2eb","ºª©®™¤№"],["8fa6e1","ΆΈΉΊΪ"],["8fa6e7","Ό"],["8fa6e9","ΎΫ"],["8fa6ec","Ώ"],["8fa6f1","άέήίϊΐόςύϋΰώ"],["8fa7c2","Ђ",10,"ЎЏ"],["8fa7f2","ђ",10,"ўџ"],["8fa9a1","ÆĐ"],["8fa9a4","Ħ"],["8fa9a6","Ĳ"],["8fa9a8","ŁĿ"],["8fa9ab","ŊØŒ"],["8fa9af","ŦÞ"],["8fa9c1","æđðħıĳĸłŀŉŋøœßŧþ"],["8faaa1","ÁÀÄÂĂǍĀĄÅÃĆĈČÇĊĎÉÈËÊĚĖĒĘ"],["8faaba","ĜĞĢĠĤÍÌÏÎǏİĪĮĨĴĶĹĽĻŃŇŅÑÓÒÖÔǑŐŌÕŔŘŖŚŜŠŞŤŢÚÙÜÛŬǓŰŪŲŮŨǗǛǙǕŴÝŸŶŹŽŻ"],["8faba1","áàäâăǎāąåãćĉčçċďéèëêěėēęǵĝğ"],["8fabbd","ġĥíìïîǐ"],["8fabc5","īįĩĵķĺľļńňņñóòöôǒőōõŕřŗśŝšşťţúùüûŭǔűūųůũǘǜǚǖŵýÿŷźžż"],["8fb0a1","丂丄丅丌丒丟丣两丨丫丮丯丰丵乀乁乄乇乑乚乜乣乨乩乴乵乹乿亍亖亗亝亯亹仃仐仚仛仠仡仢仨仯仱仳仵份仾仿伀伂伃伈伋伌伒伕伖众伙伮伱你伳伵伷伹伻伾佀佂佈佉佋佌佒佔佖佘佟佣佪佬佮佱佷佸佹佺佽佾侁侂侄"],["8fb1a1","侅侉侊侌侎侐侒侓侔侗侙侚侞侟侲侷侹侻侼侽侾俀俁俅俆俈俉俋俌俍俏俒俜俠俢俰俲俼俽俿倀倁倄倇倊倌倎倐倓倗倘倛倜倝倞倢倧倮倰倲倳倵偀偁偂偅偆偊偌偎偑偒偓偗偙偟偠偢偣偦偧偪偭偰偱倻傁傃傄傆傊傎傏傐"],["8fb2a1","傒傓傔傖傛傜傞",4,"傪傯傰傹傺傽僀僃僄僇僌僎僐僓僔僘僜僝僟僢僤僦僨僩僯僱僶僺僾儃儆儇儈儋儌儍儎僲儐儗儙儛儜儝儞儣儧儨儬儭儯儱儳儴儵儸儹兂兊兏兓兕兗兘兟兤兦兾冃冄冋冎冘冝冡冣冭冸冺冼冾冿凂"],["8fb3a1","凈减凑凒凓凕凘凞凢凥凮凲凳凴凷刁刂刅划刓刕刖刘刢刨刱刲刵刼剅剉剕剗剘剚剜剟剠剡剦剮剷剸剹劀劂劅劊劌劓劕劖劗劘劚劜劤劥劦劧劯劰劶劷劸劺劻劽勀勄勆勈勌勏勑勔勖勛勜勡勥勨勩勪勬勰勱勴勶勷匀匃匊匋"],["8fb4a1","匌匑匓匘匛匜匞匟匥匧匨匩匫匬匭匰匲匵匼匽匾卂卌卋卙卛卡卣卥卬卭卲卹卾厃厇厈厎厓厔厙厝厡厤厪厫厯厲厴厵厷厸厺厽叀叅叏叒叓叕叚叝叞叠另叧叵吂吓吚吡吧吨吪启吱吴吵呃呄呇呍呏呞呢呤呦呧呩呫呭呮呴呿"],["8fb5a1","咁咃咅咈咉咍咑咕咖咜咟咡咦咧咩咪咭咮咱咷咹咺咻咿哆哊响哎哠哪哬哯哶哼哾哿唀唁唅唈唉唌唍唎唕唪唫唲唵唶唻唼唽啁啇啉啊啍啐啑啘啚啛啞啠啡啤啦啿喁喂喆喈喎喏喑喒喓喔喗喣喤喭喲喿嗁嗃嗆嗉嗋嗌嗎嗑嗒"],["8fb6a1","嗓嗗嗘嗛嗞嗢嗩嗶嗿嘅嘈嘊嘍",5,"嘙嘬嘰嘳嘵嘷嘹嘻嘼嘽嘿噀噁噃噄噆噉噋噍噏噔噞噠噡噢噣噦噩噭噯噱噲噵嚄嚅嚈嚋嚌嚕嚙嚚嚝嚞嚟嚦嚧嚨嚩嚫嚬嚭嚱嚳嚷嚾囅囉囊囋囏囐囌囍囙囜囝囟囡囤",4,"囱囫园"],["8fb7a1","囶囷圁圂圇圊圌圑圕圚圛圝圠圢圣圤圥圩圪圬圮圯圳圴圽圾圿坅坆坌坍坒坢坥坧坨坫坭",4,"坳坴坵坷坹坺坻坼坾垁垃垌垔垗垙垚垜垝垞垟垡垕垧垨垩垬垸垽埇埈埌埏埕埝埞埤埦埧埩埭埰埵埶埸埽埾埿堃堄堈堉埡"],["8fb8a1","堌堍堛堞堟堠堦堧堭堲堹堿塉塌塍塏塐塕塟塡塤塧塨塸塼塿墀墁墇墈墉墊墌墍墏墐墔墖墝墠墡墢墦墩墱墲壄墼壂壈壍壎壐壒壔壖壚壝壡壢壩壳夅夆夋夌夒夓夔虁夝夡夣夤夨夯夰夳夵夶夿奃奆奒奓奙奛奝奞奟奡奣奫奭"],["8fb9a1","奯奲奵奶她奻奼妋妌妎妒妕妗妟妤妧妭妮妯妰妳妷妺妼姁姃姄姈姊姍姒姝姞姟姣姤姧姮姯姱姲姴姷娀娄娌娍娎娒娓娞娣娤娧娨娪娭娰婄婅婇婈婌婐婕婞婣婥婧婭婷婺婻婾媋媐媓媖媙媜媞媟媠媢媧媬媱媲媳媵媸媺媻媿"],["8fbaa1","嫄嫆嫈嫏嫚嫜嫠嫥嫪嫮嫵嫶嫽嬀嬁嬈嬗嬴嬙嬛嬝嬡嬥嬭嬸孁孋孌孒孖孞孨孮孯孼孽孾孿宁宄宆宊宎宐宑宓宔宖宨宩宬宭宯宱宲宷宺宼寀寁寍寏寖",4,"寠寯寱寴寽尌尗尞尟尣尦尩尫尬尮尰尲尵尶屙屚屜屢屣屧屨屩"],["8fbba1","屭屰屴屵屺屻屼屽岇岈岊岏岒岝岟岠岢岣岦岪岲岴岵岺峉峋峒峝峗峮峱峲峴崁崆崍崒崫崣崤崦崧崱崴崹崽崿嵂嵃嵆嵈嵕嵑嵙嵊嵟嵠嵡嵢嵤嵪嵭嵰嵹嵺嵾嵿嶁嶃嶈嶊嶒嶓嶔嶕嶙嶛嶟嶠嶧嶫嶰嶴嶸嶹巃巇巋巐巎巘巙巠巤"],["8fbca1","巩巸巹帀帇帍帒帔帕帘帟帠帮帨帲帵帾幋幐幉幑幖幘幛幜幞幨幪",4,"幰庀庋庎庢庤庥庨庪庬庱庳庽庾庿廆廌廋廎廑廒廔廕廜廞廥廫异弆弇弈弎弙弜弝弡弢弣弤弨弫弬弮弰弴弶弻弽弿彀彄彅彇彍彐彔彘彛彠彣彤彧"],["8fbda1","彯彲彴彵彸彺彽彾徉徍徏徖徜徝徢徧徫徤徬徯徰徱徸忄忇忈忉忋忐",4,"忞忡忢忨忩忪忬忭忮忯忲忳忶忺忼怇怊怍怓怔怗怘怚怟怤怭怳怵恀恇恈恉恌恑恔恖恗恝恡恧恱恾恿悂悆悈悊悎悑悓悕悘悝悞悢悤悥您悰悱悷"],["8fbea1","悻悾惂惄惈惉惊惋惎惏惔惕惙惛惝惞惢惥惲惵惸惼惽愂愇愊愌愐",4,"愖愗愙愜愞愢愪愫愰愱愵愶愷愹慁慅慆慉慞慠慬慲慸慻慼慿憀憁憃憄憋憍憒憓憗憘憜憝憟憠憥憨憪憭憸憹憼懀懁懂懎懏懕懜懝懞懟懡懢懧懩懥"],["8fbfa1","懬懭懯戁戃戄戇戓戕戜戠戢戣戧戩戫戹戽扂扃扄扆扌扐扑扒扔扖扚扜扤扭扯扳扺扽抍抎抏抐抦抨抳抶抷抺抾抿拄拎拕拖拚拪拲拴拼拽挃挄挊挋挍挐挓挖挘挩挪挭挵挶挹挼捁捂捃捄捆捊捋捎捒捓捔捘捛捥捦捬捭捱捴捵"],["8fc0a1","捸捼捽捿掂掄掇掊掐掔掕掙掚掞掤掦掭掮掯掽揁揅揈揎揑揓揔揕揜揠揥揪揬揲揳揵揸揹搉搊搐搒搔搘搞搠搢搤搥搩搪搯搰搵搽搿摋摏摑摒摓摔摚摛摜摝摟摠摡摣摭摳摴摻摽撅撇撏撐撑撘撙撛撝撟撡撣撦撨撬撳撽撾撿"],["8fc1a1","擄擉擊擋擌擎擐擑擕擗擤擥擩擪擭擰擵擷擻擿攁攄攈攉攊攏攓攔攖攙攛攞攟攢攦攩攮攱攺攼攽敃敇敉敐敒敔敟敠敧敫敺敽斁斅斊斒斕斘斝斠斣斦斮斲斳斴斿旂旈旉旎旐旔旖旘旟旰旲旴旵旹旾旿昀昄昈昉昍昑昒昕昖昝"],["8fc2a1","昞昡昢昣昤昦昩昪昫昬昮昰昱昳昹昷晀晅晆晊晌晑晎晗晘晙晛晜晠晡曻晪晫晬晾晳晵晿晷晸晹晻暀晼暋暌暍暐暒暙暚暛暜暟暠暤暭暱暲暵暻暿曀曂曃曈曌曎曏曔曛曟曨曫曬曮曺朅朇朎朓朙朜朠朢朳朾杅杇杈杌杔杕杝"],["8fc3a1","杦杬杮杴杶杻极构枎枏枑枓枖枘枙枛枰枱枲枵枻枼枽柹柀柂柃柅柈柉柒柗柙柜柡柦柰柲柶柷桒栔栙栝栟栨栧栬栭栯栰栱栳栻栿桄桅桊桌桕桗桘桛桫桮",4,"桵桹桺桻桼梂梄梆梈梖梘梚梜梡梣梥梩梪梮梲梻棅棈棌棏"],["8fc4a1","棐棑棓棖棙棜棝棥棨棪棫棬棭棰棱棵棶棻棼棽椆椉椊椐椑椓椖椗椱椳椵椸椻楂楅楉楎楗楛楣楤楥楦楨楩楬楰楱楲楺楻楿榀榍榒榖榘榡榥榦榨榫榭榯榷榸榺榼槅槈槑槖槗槢槥槮槯槱槳槵槾樀樁樃樏樑樕樚樝樠樤樨樰樲"],["8fc5a1","樴樷樻樾樿橅橆橉橊橎橐橑橒橕橖橛橤橧橪橱橳橾檁檃檆檇檉檋檑檛檝檞檟檥檫檯檰檱檴檽檾檿櫆櫉櫈櫌櫐櫔櫕櫖櫜櫝櫤櫧櫬櫰櫱櫲櫼櫽欂欃欆欇欉欏欐欑欗欛欞欤欨欫欬欯欵欶欻欿歆歊歍歒歖歘歝歠歧歫歮歰歵歽"],["8fc6a1","歾殂殅殗殛殟殠殢殣殨殩殬殭殮殰殸殹殽殾毃毄毉毌毖毚毡毣毦毧毮毱毷毹毿氂氄氅氉氍氎氐氒氙氟氦氧氨氬氮氳氵氶氺氻氿汊汋汍汏汒汔汙汛汜汫汭汯汴汶汸汹汻沅沆沇沉沔沕沗沘沜沟沰沲沴泂泆泍泏泐泑泒泔泖"],["8fc7a1","泚泜泠泧泩泫泬泮泲泴洄洇洊洎洏洑洓洚洦洧洨汧洮洯洱洹洼洿浗浞浟浡浥浧浯浰浼涂涇涑涒涔涖涗涘涪涬涴涷涹涽涿淄淈淊淎淏淖淛淝淟淠淢淥淩淯淰淴淶淼渀渄渞渢渧渲渶渹渻渼湄湅湈湉湋湏湑湒湓湔湗湜湝湞"],["8fc8a1","湢湣湨湳湻湽溍溓溙溠溧溭溮溱溳溻溿滀滁滃滇滈滊滍滎滏滫滭滮滹滻滽漄漈漊漌漍漖漘漚漛漦漩漪漯漰漳漶漻漼漭潏潑潒潓潗潙潚潝潞潡潢潨潬潽潾澃澇澈澋澌澍澐澒澓澔澖澚澟澠澥澦澧澨澮澯澰澵澶澼濅濇濈濊"],["8fc9a1","濚濞濨濩濰濵濹濼濽瀀瀅瀆瀇瀍瀗瀠瀣瀯瀴瀷瀹瀼灃灄灈灉灊灋灔灕灝灞灎灤灥灬灮灵灶灾炁炅炆炔",4,"炛炤炫炰炱炴炷烊烑烓烔烕烖烘烜烤烺焃",4,"焋焌焏焞焠焫焭焯焰焱焸煁煅煆煇煊煋煐煒煗煚煜煞煠"],["8fcaa1","煨煹熀熅熇熌熒熚熛熠熢熯熰熲熳熺熿燀燁燄燋燌燓燖燙燚燜燸燾爀爇爈爉爓爗爚爝爟爤爫爯爴爸爹牁牂牃牅牎牏牐牓牕牖牚牜牞牠牣牨牫牮牯牱牷牸牻牼牿犄犉犍犎犓犛犨犭犮犱犴犾狁狇狉狌狕狖狘狟狥狳狴狺狻"],["8fcba1","狾猂猄猅猇猋猍猒猓猘猙猞猢猤猧猨猬猱猲猵猺猻猽獃獍獐獒獖獘獝獞獟獠獦獧獩獫獬獮獯獱獷獹獼玀玁玃玅玆玎玐玓玕玗玘玜玞玟玠玢玥玦玪玫玭玵玷玹玼玽玿珅珆珉珋珌珏珒珓珖珙珝珡珣珦珧珩珴珵珷珹珺珻珽"],["8fcca1","珿琀琁琄琇琊琑琚琛琤琦琨",9,"琹瑀瑃瑄瑆瑇瑋瑍瑑瑒瑗瑝瑢瑦瑧瑨瑫瑭瑮瑱瑲璀璁璅璆璇璉璏璐璑璒璘璙璚璜璟璠璡璣璦璨璩璪璫璮璯璱璲璵璹璻璿瓈瓉瓌瓐瓓瓘瓚瓛瓞瓟瓤瓨瓪瓫瓯瓴瓺瓻瓼瓿甆"],["8fcda1","甒甖甗甠甡甤甧甩甪甯甶甹甽甾甿畀畃畇畈畎畐畒畗畞畟畡畯畱畹",5,"疁疅疐疒疓疕疙疜疢疤疴疺疿痀痁痄痆痌痎痏痗痜痟痠痡痤痧痬痮痯痱痹瘀瘂瘃瘄瘇瘈瘊瘌瘏瘒瘓瘕瘖瘙瘛瘜瘝瘞瘣瘥瘦瘩瘭瘲瘳瘵瘸瘹"],["8fcea1","瘺瘼癊癀癁癃癄癅癉癋癕癙癟癤癥癭癮癯癱癴皁皅皌皍皕皛皜皝皟皠皢",6,"皪皭皽盁盅盉盋盌盎盔盙盠盦盨盬盰盱盶盹盼眀眆眊眎眒眔眕眗眙眚眜眢眨眭眮眯眴眵眶眹眽眾睂睅睆睊睍睎睏睒睖睗睜睞睟睠睢"],["8fcfa1","睤睧睪睬睰睲睳睴睺睽瞀瞄瞌瞍瞔瞕瞖瞚瞟瞢瞧瞪瞮瞯瞱瞵瞾矃矉矑矒矕矙矞矟矠矤矦矪矬矰矱矴矸矻砅砆砉砍砎砑砝砡砢砣砭砮砰砵砷硃硄硇硈硌硎硒硜硞硠硡硣硤硨硪确硺硾碊碏碔碘碡碝碞碟碤碨碬碭碰碱碲碳"],["8fd0a1","碻碽碿磇磈磉磌磎磒磓磕磖磤磛磟磠磡磦磪磲磳礀磶磷磺磻磿礆礌礐礚礜礞礟礠礥礧礩礭礱礴礵礻礽礿祄祅祆祊祋祏祑祔祘祛祜祧祩祫祲祹祻祼祾禋禌禑禓禔禕禖禘禛禜禡禨禩禫禯禱禴禸离秂秄秇秈秊秏秔秖秚秝秞"],["8fd1a1","秠秢秥秪秫秭秱秸秼稂稃稇稉稊稌稑稕稛稞稡稧稫稭稯稰稴稵稸稹稺穄穅穇穈穌穕穖穙穜穝穟穠穥穧穪穭穵穸穾窀窂窅窆窊窋窐窑窔窞窠窣窬窳窵窹窻窼竆竉竌竎竑竛竨竩竫竬竱竴竻竽竾笇笔笟笣笧笩笪笫笭笮笯笰"],["8fd2a1","笱笴笽笿筀筁筇筎筕筠筤筦筩筪筭筯筲筳筷箄箉箎箐箑箖箛箞箠箥箬箯箰箲箵箶箺箻箼箽篂篅篈篊篔篖篗篙篚篛篨篪篲篴篵篸篹篺篼篾簁簂簃簄簆簉簋簌簎簏簙簛簠簥簦簨簬簱簳簴簶簹簺籆籊籕籑籒籓籙",5],["8fd3a1","籡籣籧籩籭籮籰籲籹籼籽粆粇粏粔粞粠粦粰粶粷粺粻粼粿糄糇糈糉糍糏糓糔糕糗糙糚糝糦糩糫糵紃紇紈紉紏紑紒紓紖紝紞紣紦紪紭紱紼紽紾絀絁絇絈絍絑絓絗絙絚絜絝絥絧絪絰絸絺絻絿綁綂綃綅綆綈綋綌綍綑綖綗綝"],["8fd4a1","綞綦綧綪綳綶綷綹緂",4,"緌緍緎緗緙縀緢緥緦緪緫緭緱緵緶緹緺縈縐縑縕縗縜縝縠縧縨縬縭縯縳縶縿繄繅繇繎繐繒繘繟繡繢繥繫繮繯繳繸繾纁纆纇纊纍纑纕纘纚纝纞缼缻缽缾缿罃罄罇罏罒罓罛罜罝罡罣罤罥罦罭"],["8fd5a1","罱罽罾罿羀羋羍羏羐羑羖羗羜羡羢羦羪羭羴羼羿翀翃翈翎翏翛翟翣翥翨翬翮翯翲翺翽翾翿耇耈耊耍耎耏耑耓耔耖耝耞耟耠耤耦耬耮耰耴耵耷耹耺耼耾聀聄聠聤聦聭聱聵肁肈肎肜肞肦肧肫肸肹胈胍胏胒胔胕胗胘胠胭胮"],["8fd6a1","胰胲胳胶胹胺胾脃脋脖脗脘脜脞脠脤脧脬脰脵脺脼腅腇腊腌腒腗腠腡腧腨腩腭腯腷膁膐膄膅膆膋膎膖膘膛膞膢膮膲膴膻臋臃臅臊臎臏臕臗臛臝臞臡臤臫臬臰臱臲臵臶臸臹臽臿舀舃舏舓舔舙舚舝舡舢舨舲舴舺艃艄艅艆"],["8fd7a1","艋艎艏艑艖艜艠艣艧艭艴艻艽艿芀芁芃芄芇芉芊芎芑芔芖芘芚芛芠芡芣芤芧芨芩芪芮芰芲芴芷芺芼芾芿苆苐苕苚苠苢苤苨苪苭苯苶苷苽苾茀茁茇茈茊茋荔茛茝茞茟茡茢茬茭茮茰茳茷茺茼茽荂荃荄荇荍荎荑荕荖荗荰荸"],["8fd8a1","荽荿莀莂莄莆莍莒莔莕莘莙莛莜莝莦莧莩莬莾莿菀菇菉菏菐菑菔菝荓菨菪菶菸菹菼萁萆萊萏萑萕萙莭萯萹葅葇葈葊葍葏葑葒葖葘葙葚葜葠葤葥葧葪葰葳葴葶葸葼葽蒁蒅蒒蒓蒕蒞蒦蒨蒩蒪蒯蒱蒴蒺蒽蒾蓀蓂蓇蓈蓌蓏蓓"],["8fd9a1","蓜蓧蓪蓯蓰蓱蓲蓷蔲蓺蓻蓽蔂蔃蔇蔌蔎蔐蔜蔞蔢蔣蔤蔥蔧蔪蔫蔯蔳蔴蔶蔿蕆蕏",4,"蕖蕙蕜",6,"蕤蕫蕯蕹蕺蕻蕽蕿薁薅薆薉薋薌薏薓薘薝薟薠薢薥薧薴薶薷薸薼薽薾薿藂藇藊藋藎薭藘藚藟藠藦藨藭藳藶藼"],["8fdaa1","藿蘀蘄蘅蘍蘎蘐蘑蘒蘘蘙蘛蘞蘡蘧蘩蘶蘸蘺蘼蘽虀虂虆虒虓虖虗虘虙虝虠",4,"虩虬虯虵虶虷虺蚍蚑蚖蚘蚚蚜蚡蚦蚧蚨蚭蚱蚳蚴蚵蚷蚸蚹蚿蛀蛁蛃蛅蛑蛒蛕蛗蛚蛜蛠蛣蛥蛧蚈蛺蛼蛽蜄蜅蜇蜋蜎蜏蜐蜓蜔蜙蜞蜟蜡蜣"],["8fdba1","蜨蜮蜯蜱蜲蜹蜺蜼蜽蜾蝀蝃蝅蝍蝘蝝蝡蝤蝥蝯蝱蝲蝻螃",6,"螋螌螐螓螕螗螘螙螞螠螣螧螬螭螮螱螵螾螿蟁蟈蟉蟊蟎蟕蟖蟙蟚蟜蟟蟢蟣蟤蟪蟫蟭蟱蟳蟸蟺蟿蠁蠃蠆蠉蠊蠋蠐蠙蠒蠓蠔蠘蠚蠛蠜蠞蠟蠨蠭蠮蠰蠲蠵"],["8fdca1","蠺蠼衁衃衅衈衉衊衋衎衑衕衖衘衚衜衟衠衤衩衱衹衻袀袘袚袛袜袟袠袨袪袺袽袾裀裊",4,"裑裒裓裛裞裧裯裰裱裵裷褁褆褍褎褏褕褖褘褙褚褜褠褦褧褨褰褱褲褵褹褺褾襀襂襅襆襉襏襒襗襚襛襜襡襢襣襫襮襰襳襵襺"],["8fdda1","襻襼襽覉覍覐覔覕覛覜覟覠覥覰覴覵覶覷覼觔",4,"觥觩觫觭觱觳觶觹觽觿訄訅訇訏訑訒訔訕訞訠訢訤訦訫訬訯訵訷訽訾詀詃詅詇詉詍詎詓詖詗詘詜詝詡詥詧詵詶詷詹詺詻詾詿誀誃誆誋誏誐誒誖誗誙誟誧誩誮誯誳"],["8fdea1","誶誷誻誾諃諆諈諉諊諑諓諔諕諗諝諟諬諰諴諵諶諼諿謅謆謋謑謜謞謟謊謭謰謷謼譂",4,"譈譒譓譔譙譍譞譣譭譶譸譹譼譾讁讄讅讋讍讏讔讕讜讞讟谸谹谽谾豅豇豉豋豏豑豓豔豗豘豛豝豙豣豤豦豨豩豭豳豵豶豻豾貆"],["8fdfa1","貇貋貐貒貓貙貛貜貤貹貺賅賆賉賋賏賖賕賙賝賡賨賬賯賰賲賵賷賸賾賿贁贃贉贒贗贛赥赩赬赮赿趂趄趈趍趐趑趕趞趟趠趦趫趬趯趲趵趷趹趻跀跅跆跇跈跊跎跑跔跕跗跙跤跥跧跬跰趼跱跲跴跽踁踄踅踆踋踑踔踖踠踡踢"],["8fe0a1","踣踦踧踱踳踶踷踸踹踽蹀蹁蹋蹍蹎蹏蹔蹛蹜蹝蹞蹡蹢蹩蹬蹭蹯蹰蹱蹹蹺蹻躂躃躉躐躒躕躚躛躝躞躢躧躩躭躮躳躵躺躻軀軁軃軄軇軏軑軔軜軨軮軰軱軷軹軺軭輀輂輇輈輏輐輖輗輘輞輠輡輣輥輧輨輬輭輮輴輵輶輷輺轀轁"],["8fe1a1","轃轇轏轑",4,"轘轝轞轥辝辠辡辤辥辦辵辶辸达迀迁迆迊迋迍运迒迓迕迠迣迤迨迮迱迵迶迻迾适逄逈逌逘逛逨逩逯逪逬逭逳逴逷逿遃遄遌遛遝遢遦遧遬遰遴遹邅邈邋邌邎邐邕邗邘邙邛邠邡邢邥邰邲邳邴邶邽郌邾郃"],["8fe2a1","郄郅郇郈郕郗郘郙郜郝郟郥郒郶郫郯郰郴郾郿鄀鄄鄅鄆鄈鄍鄐鄔鄖鄗鄘鄚鄜鄞鄠鄥鄢鄣鄧鄩鄮鄯鄱鄴鄶鄷鄹鄺鄼鄽酃酇酈酏酓酗酙酚酛酡酤酧酭酴酹酺酻醁醃醅醆醊醎醑醓醔醕醘醞醡醦醨醬醭醮醰醱醲醳醶醻醼醽醿"],["8fe3a1","釂釃釅釓釔釗釙釚釞釤釥釩釪釬",5,"釷釹釻釽鈀鈁鈄鈅鈆鈇鈉鈊鈌鈐鈒鈓鈖鈘鈜鈝鈣鈤鈥鈦鈨鈮鈯鈰鈳鈵鈶鈸鈹鈺鈼鈾鉀鉂鉃鉆鉇鉊鉍鉎鉏鉑鉘鉙鉜鉝鉠鉡鉥鉧鉨鉩鉮鉯鉰鉵",4,"鉻鉼鉽鉿銈銉銊銍銎銒銗"],["8fe4a1","銙銟銠銤銥銧銨銫銯銲銶銸銺銻銼銽銿",4,"鋅鋆鋇鋈鋋鋌鋍鋎鋐鋓鋕鋗鋘鋙鋜鋝鋟鋠鋡鋣鋥鋧鋨鋬鋮鋰鋹鋻鋿錀錂錈錍錑錔錕錜錝錞錟錡錤錥錧錩錪錳錴錶錷鍇鍈鍉鍐鍑鍒鍕鍗鍘鍚鍞鍤鍥鍧鍩鍪鍭鍯鍰鍱鍳鍴鍶"],["8fe5a1","鍺鍽鍿鎀鎁鎂鎈鎊鎋鎍鎏鎒鎕鎘鎛鎞鎡鎣鎤鎦鎨鎫鎴鎵鎶鎺鎩鏁鏄鏅鏆鏇鏉",4,"鏓鏙鏜鏞鏟鏢鏦鏧鏹鏷鏸鏺鏻鏽鐁鐂鐄鐈鐉鐍鐎鐏鐕鐖鐗鐟鐮鐯鐱鐲鐳鐴鐻鐿鐽鑃鑅鑈鑊鑌鑕鑙鑜鑟鑡鑣鑨鑫鑭鑮鑯鑱鑲钄钃镸镹"],["8fe6a1","镾閄閈閌閍閎閝閞閟閡閦閩閫閬閴閶閺閽閿闆闈闉闋闐闑闒闓闙闚闝闞闟闠闤闦阝阞阢阤阥阦阬阱阳阷阸阹阺阼阽陁陒陔陖陗陘陡陮陴陻陼陾陿隁隂隃隄隉隑隖隚隝隟隤隥隦隩隮隯隳隺雊雒嶲雘雚雝雞雟雩雯雱雺霂"],["8fe7a1","霃霅霉霚霛霝霡霢霣霨霱霳靁靃靊靎靏靕靗靘靚靛靣靧靪靮靳靶靷靸靻靽靿鞀鞉鞕鞖鞗鞙鞚鞞鞟鞢鞬鞮鞱鞲鞵鞶鞸鞹鞺鞼鞾鞿韁韄韅韇韉韊韌韍韎韐韑韔韗韘韙韝韞韠韛韡韤韯韱韴韷韸韺頇頊頙頍頎頔頖頜頞頠頣頦"],["8fe8a1","頫頮頯頰頲頳頵頥頾顄顇顊顑顒顓顖顗顙顚顢顣顥顦顪顬颫颭颮颰颴颷颸颺颻颿飂飅飈飌飡飣飥飦飧飪飳飶餂餇餈餑餕餖餗餚餛餜餟餢餦餧餫餱",4,"餹餺餻餼饀饁饆饇饈饍饎饔饘饙饛饜饞饟饠馛馝馟馦馰馱馲馵"],["8fe9a1","馹馺馽馿駃駉駓駔駙駚駜駞駧駪駫駬駰駴駵駹駽駾騂騃騄騋騌騐騑騖騞騠騢騣騤騧騭騮騳騵騶騸驇驁驄驊驋驌驎驑驔驖驝骪骬骮骯骲骴骵骶骹骻骾骿髁髃髆髈髎髐髒髕髖髗髛髜髠髤髥髧髩髬髲髳髵髹髺髽髿",4],["8feaa1","鬄鬅鬈鬉鬋鬌鬍鬎鬐鬒鬖鬙鬛鬜鬠鬦鬫鬭鬳鬴鬵鬷鬹鬺鬽魈魋魌魕魖魗魛魞魡魣魥魦魨魪",4,"魳魵魷魸魹魿鮀鮄鮅鮆鮇鮉鮊鮋鮍鮏鮐鮔鮚鮝鮞鮦鮧鮩鮬鮰鮱鮲鮷鮸鮻鮼鮾鮿鯁鯇鯈鯎鯐鯗鯘鯝鯟鯥鯧鯪鯫鯯鯳鯷鯸"],["8feba1","鯹鯺鯽鯿鰀鰂鰋鰏鰑鰖鰘鰙鰚鰜鰞鰢鰣鰦",4,"鰱鰵鰶鰷鰽鱁鱃鱄鱅鱉鱊鱎鱏鱐鱓鱔鱖鱘鱛鱝鱞鱟鱣鱩鱪鱜鱫鱨鱮鱰鱲鱵鱷鱻鳦鳲鳷鳹鴋鴂鴑鴗鴘鴜鴝鴞鴯鴰鴲鴳鴴鴺鴼鵅鴽鵂鵃鵇鵊鵓鵔鵟鵣鵢鵥鵩鵪鵫鵰鵶鵷鵻"],["8feca1","鵼鵾鶃鶄鶆鶊鶍鶎鶒鶓鶕鶖鶗鶘鶡鶪鶬鶮鶱鶵鶹鶼鶿鷃鷇鷉鷊鷔鷕鷖鷗鷚鷞鷟鷠鷥鷧鷩鷫鷮鷰鷳鷴鷾鸊鸂鸇鸎鸐鸑鸒鸕鸖鸙鸜鸝鹺鹻鹼麀麂麃麄麅麇麎麏麖麘麛麞麤麨麬麮麯麰麳麴麵黆黈黋黕黟黤黧黬黭黮黰黱黲黵"],["8feda1","黸黿鼂鼃鼉鼏鼐鼑鼒鼔鼖鼗鼙鼚鼛鼟鼢鼦鼪鼫鼯鼱鼲鼴鼷鼹鼺鼼鼽鼿齁齃",4,"齓齕齖齗齘齚齝齞齨齩齭",4,"齳齵齺齽龏龐龑龒龔龖龗龞龡龢龣龥"]]',
      );
    },
    6258: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"uChars":[128,165,169,178,184,216,226,235,238,244,248,251,253,258,276,284,300,325,329,334,364,463,465,467,469,471,473,475,477,506,594,610,712,716,730,930,938,962,970,1026,1104,1106,8209,8215,8218,8222,8231,8241,8244,8246,8252,8365,8452,8454,8458,8471,8482,8556,8570,8596,8602,8713,8720,8722,8726,8731,8737,8740,8742,8748,8751,8760,8766,8777,8781,8787,8802,8808,8816,8854,8858,8870,8896,8979,9322,9372,9548,9588,9616,9622,9634,9652,9662,9672,9676,9680,9702,9735,9738,9793,9795,11906,11909,11913,11917,11928,11944,11947,11951,11956,11960,11964,11979,12284,12292,12312,12319,12330,12351,12436,12447,12535,12543,12586,12842,12850,12964,13200,13215,13218,13253,13263,13267,13270,13384,13428,13727,13839,13851,14617,14703,14801,14816,14964,15183,15471,15585,16471,16736,17208,17325,17330,17374,17623,17997,18018,18212,18218,18301,18318,18760,18811,18814,18820,18823,18844,18848,18872,19576,19620,19738,19887,40870,59244,59336,59367,59413,59417,59423,59431,59437,59443,59452,59460,59478,59493,63789,63866,63894,63976,63986,64016,64018,64021,64025,64034,64037,64042,65074,65093,65107,65112,65127,65132,65375,65510,65536],"gbChars":[0,36,38,45,50,81,89,95,96,100,103,104,105,109,126,133,148,172,175,179,208,306,307,308,309,310,311,312,313,341,428,443,544,545,558,741,742,749,750,805,819,820,7922,7924,7925,7927,7934,7943,7944,7945,7950,8062,8148,8149,8152,8164,8174,8236,8240,8262,8264,8374,8380,8381,8384,8388,8390,8392,8393,8394,8396,8401,8406,8416,8419,8424,8437,8439,8445,8482,8485,8496,8521,8603,8936,8946,9046,9050,9063,9066,9076,9092,9100,9108,9111,9113,9131,9162,9164,9218,9219,11329,11331,11334,11336,11346,11361,11363,11366,11370,11372,11375,11389,11682,11686,11687,11692,11694,11714,11716,11723,11725,11730,11736,11982,11989,12102,12336,12348,12350,12384,12393,12395,12397,12510,12553,12851,12962,12973,13738,13823,13919,13933,14080,14298,14585,14698,15583,15847,16318,16434,16438,16481,16729,17102,17122,17315,17320,17402,17418,17859,17909,17911,17915,17916,17936,17939,17961,18664,18703,18814,18962,19043,33469,33470,33471,33484,33485,33490,33497,33501,33505,33513,33520,33536,33550,37845,37921,37948,38029,38038,38064,38065,38066,38069,38075,38076,38078,39108,39109,39113,39114,39115,39116,39265,39394,189000]}',
      );
    },
    4346: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["a140","",62],["a180","",32],["a240","",62],["a280","",32],["a2ab","",5],["a2e3","€"],["a2ef",""],["a2fd",""],["a340","",62],["a380","",31,"　"],["a440","",62],["a480","",32],["a4f4","",10],["a540","",62],["a580","",32],["a5f7","",7],["a640","",62],["a680","",32],["a6b9","",7],["a6d9","",6],["a6ec",""],["a6f3",""],["a6f6","",8],["a740","",62],["a780","",32],["a7c2","",14],["a7f2","",12],["a896","",10],["a8bc","ḿ"],["a8bf","ǹ"],["a8c1",""],["a8ea","",20],["a958",""],["a95b",""],["a95d",""],["a989","〾⿰",11],["a997","",12],["a9f0","",14],["aaa1","",93],["aba1","",93],["aca1","",93],["ada1","",93],["aea1","",93],["afa1","",93],["d7fa","",4],["f8a1","",93],["f9a1","",93],["faa1","",93],["fba1","",93],["fca1","",93],["fda1","",93],["fe50","⺁⺄㑳㑇⺈⺋㖞㘚㘎⺌⺗㥮㤘㧏㧟㩳㧐㭎㱮㳠⺧⺪䁖䅟⺮䌷⺳⺶⺷䎱䎬⺻䏝䓖䙡䙌"],["fe80","䜣䜩䝼䞍⻊䥇䥺䥽䦂䦃䦅䦆䦟䦛䦷䦶䲣䲟䲠䲡䱷䲢䴓",6,"䶮",93],["8135f437",""]]',
      );
    },
    7014: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '[["0","\\u0000",128],["a1","｡",62],["8140","　、。，．・：；？！゛゜´｀¨＾￣＿ヽヾゝゞ〃仝々〆〇ー―‐／＼～∥｜…‥‘’“”（）〔〕［］｛｝〈",9,"＋－±×"],["8180","÷＝≠＜＞≦≧∞∴♂♀°′″℃￥＄￠￡％＃＆＊＠§☆★○●◎◇◆□■△▲▽▼※〒→←↑↓〓"],["81b8","∈∋⊆⊇⊂⊃∪∩"],["81c8","∧∨￢⇒⇔∀∃"],["81da","∠⊥⌒∂∇≡≒≪≫√∽∝∵∫∬"],["81f0","Å‰♯♭♪†‡¶"],["81fc","◯"],["824f","０",9],["8260","Ａ",25],["8281","ａ",25],["829f","ぁ",82],["8340","ァ",62],["8380","ム",22],["839f","Α",16,"Σ",6],["83bf","α",16,"σ",6],["8440","А",5,"ЁЖ",25],["8470","а",5,"ёж",7],["8480","о",17],["849f","─│┌┐┘└├┬┤┴┼━┃┏┓┛┗┣┳┫┻╋┠┯┨┷┿┝┰┥┸╂"],["8740","①",19,"Ⅰ",9],["875f","㍉㌔㌢㍍㌘㌧㌃㌶㍑㍗㌍㌦㌣㌫㍊㌻㎜㎝㎞㎎㎏㏄㎡"],["877e","㍻"],["8780","〝〟№㏍℡㊤",4,"㈱㈲㈹㍾㍽㍼≒≡∫∮∑√⊥∠∟⊿∵∩∪"],["889f","亜唖娃阿哀愛挨姶逢葵茜穐悪握渥旭葦芦鯵梓圧斡扱宛姐虻飴絢綾鮎或粟袷安庵按暗案闇鞍杏以伊位依偉囲夷委威尉惟意慰易椅為畏異移維緯胃萎衣謂違遺医井亥域育郁磯一壱溢逸稲茨芋鰯允印咽員因姻引飲淫胤蔭"],["8940","院陰隠韻吋右宇烏羽迂雨卯鵜窺丑碓臼渦嘘唄欝蔚鰻姥厩浦瓜閏噂云運雲荏餌叡営嬰影映曳栄永泳洩瑛盈穎頴英衛詠鋭液疫益駅悦謁越閲榎厭円"],["8980","園堰奄宴延怨掩援沿演炎焔煙燕猿縁艶苑薗遠鉛鴛塩於汚甥凹央奥往応押旺横欧殴王翁襖鴬鴎黄岡沖荻億屋憶臆桶牡乙俺卸恩温穏音下化仮何伽価佳加可嘉夏嫁家寡科暇果架歌河火珂禍禾稼箇花苛茄荷華菓蝦課嘩貨迦過霞蚊俄峨我牙画臥芽蛾賀雅餓駕介会解回塊壊廻快怪悔恢懐戒拐改"],["8a40","魁晦械海灰界皆絵芥蟹開階貝凱劾外咳害崖慨概涯碍蓋街該鎧骸浬馨蛙垣柿蛎鈎劃嚇各廓拡撹格核殻獲確穫覚角赫較郭閣隔革学岳楽額顎掛笠樫"],["8a80","橿梶鰍潟割喝恰括活渇滑葛褐轄且鰹叶椛樺鞄株兜竃蒲釜鎌噛鴨栢茅萱粥刈苅瓦乾侃冠寒刊勘勧巻喚堪姦完官寛干幹患感慣憾換敢柑桓棺款歓汗漢澗潅環甘監看竿管簡緩缶翰肝艦莞観諌貫還鑑間閑関陥韓館舘丸含岸巌玩癌眼岩翫贋雁頑顔願企伎危喜器基奇嬉寄岐希幾忌揮机旗既期棋棄"],["8b40","機帰毅気汽畿祈季稀紀徽規記貴起軌輝飢騎鬼亀偽儀妓宜戯技擬欺犠疑祇義蟻誼議掬菊鞠吉吃喫桔橘詰砧杵黍却客脚虐逆丘久仇休及吸宮弓急救"],["8b80","朽求汲泣灸球究窮笈級糾給旧牛去居巨拒拠挙渠虚許距鋸漁禦魚亨享京供侠僑兇競共凶協匡卿叫喬境峡強彊怯恐恭挟教橋況狂狭矯胸脅興蕎郷鏡響饗驚仰凝尭暁業局曲極玉桐粁僅勤均巾錦斤欣欽琴禁禽筋緊芹菌衿襟謹近金吟銀九倶句区狗玖矩苦躯駆駈駒具愚虞喰空偶寓遇隅串櫛釧屑屈"],["8c40","掘窟沓靴轡窪熊隈粂栗繰桑鍬勲君薫訓群軍郡卦袈祁係傾刑兄啓圭珪型契形径恵慶慧憩掲携敬景桂渓畦稽系経継繋罫茎荊蛍計詣警軽頚鶏芸迎鯨"],["8c80","劇戟撃激隙桁傑欠決潔穴結血訣月件倹倦健兼券剣喧圏堅嫌建憲懸拳捲検権牽犬献研硯絹県肩見謙賢軒遣鍵険顕験鹸元原厳幻弦減源玄現絃舷言諺限乎個古呼固姑孤己庫弧戸故枯湖狐糊袴股胡菰虎誇跨鈷雇顧鼓五互伍午呉吾娯後御悟梧檎瑚碁語誤護醐乞鯉交佼侯候倖光公功効勾厚口向"],["8d40","后喉坑垢好孔孝宏工巧巷幸広庚康弘恒慌抗拘控攻昂晃更杭校梗構江洪浩港溝甲皇硬稿糠紅紘絞綱耕考肯肱腔膏航荒行衡講貢購郊酵鉱砿鋼閤降"],["8d80","項香高鴻剛劫号合壕拷濠豪轟麹克刻告国穀酷鵠黒獄漉腰甑忽惚骨狛込此頃今困坤墾婚恨懇昏昆根梱混痕紺艮魂些佐叉唆嵯左差査沙瑳砂詐鎖裟坐座挫債催再最哉塞妻宰彩才採栽歳済災采犀砕砦祭斎細菜裁載際剤在材罪財冴坂阪堺榊肴咲崎埼碕鷺作削咋搾昨朔柵窄策索錯桜鮭笹匙冊刷"],["8e40","察拶撮擦札殺薩雑皐鯖捌錆鮫皿晒三傘参山惨撒散桟燦珊産算纂蚕讃賛酸餐斬暫残仕仔伺使刺司史嗣四士始姉姿子屍市師志思指支孜斯施旨枝止"],["8e80","死氏獅祉私糸紙紫肢脂至視詞詩試誌諮資賜雌飼歯事似侍児字寺慈持時次滋治爾璽痔磁示而耳自蒔辞汐鹿式識鴫竺軸宍雫七叱執失嫉室悉湿漆疾質実蔀篠偲柴芝屡蕊縞舎写射捨赦斜煮社紗者謝車遮蛇邪借勺尺杓灼爵酌釈錫若寂弱惹主取守手朱殊狩珠種腫趣酒首儒受呪寿授樹綬需囚収周"],["8f40","宗就州修愁拾洲秀秋終繍習臭舟蒐衆襲讐蹴輯週酋酬集醜什住充十従戎柔汁渋獣縦重銃叔夙宿淑祝縮粛塾熟出術述俊峻春瞬竣舜駿准循旬楯殉淳"],["8f80","準潤盾純巡遵醇順処初所暑曙渚庶緒署書薯藷諸助叙女序徐恕鋤除傷償勝匠升召哨商唱嘗奨妾娼宵将小少尚庄床廠彰承抄招掌捷昇昌昭晶松梢樟樵沼消渉湘焼焦照症省硝礁祥称章笑粧紹肖菖蒋蕉衝裳訟証詔詳象賞醤鉦鍾鐘障鞘上丈丞乗冗剰城場壌嬢常情擾条杖浄状畳穣蒸譲醸錠嘱埴飾"],["9040","拭植殖燭織職色触食蝕辱尻伸信侵唇娠寝審心慎振新晋森榛浸深申疹真神秦紳臣芯薪親診身辛進針震人仁刃塵壬尋甚尽腎訊迅陣靭笥諏須酢図厨"],["9080","逗吹垂帥推水炊睡粋翠衰遂酔錐錘随瑞髄崇嵩数枢趨雛据杉椙菅頗雀裾澄摺寸世瀬畝是凄制勢姓征性成政整星晴棲栖正清牲生盛精聖声製西誠誓請逝醒青静斉税脆隻席惜戚斥昔析石積籍績脊責赤跡蹟碩切拙接摂折設窃節説雪絶舌蝉仙先千占宣専尖川戦扇撰栓栴泉浅洗染潜煎煽旋穿箭線"],["9140","繊羨腺舛船薦詮賎践選遷銭銑閃鮮前善漸然全禅繕膳糎噌塑岨措曾曽楚狙疏疎礎祖租粗素組蘇訴阻遡鼠僧創双叢倉喪壮奏爽宋層匝惣想捜掃挿掻"],["9180","操早曹巣槍槽漕燥争痩相窓糟総綜聡草荘葬蒼藻装走送遭鎗霜騒像増憎臓蔵贈造促側則即息捉束測足速俗属賊族続卒袖其揃存孫尊損村遜他多太汰詑唾堕妥惰打柁舵楕陀駄騨体堆対耐岱帯待怠態戴替泰滞胎腿苔袋貸退逮隊黛鯛代台大第醍題鷹滝瀧卓啄宅托択拓沢濯琢託鐸濁諾茸凧蛸只"],["9240","叩但達辰奪脱巽竪辿棚谷狸鱈樽誰丹単嘆坦担探旦歎淡湛炭短端箪綻耽胆蛋誕鍛団壇弾断暖檀段男談値知地弛恥智池痴稚置致蜘遅馳築畜竹筑蓄"],["9280","逐秩窒茶嫡着中仲宙忠抽昼柱注虫衷註酎鋳駐樗瀦猪苧著貯丁兆凋喋寵帖帳庁弔張彫徴懲挑暢朝潮牒町眺聴脹腸蝶調諜超跳銚長頂鳥勅捗直朕沈珍賃鎮陳津墜椎槌追鎚痛通塚栂掴槻佃漬柘辻蔦綴鍔椿潰坪壷嬬紬爪吊釣鶴亭低停偵剃貞呈堤定帝底庭廷弟悌抵挺提梯汀碇禎程締艇訂諦蹄逓"],["9340","邸鄭釘鼎泥摘擢敵滴的笛適鏑溺哲徹撤轍迭鉄典填天展店添纏甜貼転顛点伝殿澱田電兎吐堵塗妬屠徒斗杜渡登菟賭途都鍍砥砺努度土奴怒倒党冬"],["9380","凍刀唐塔塘套宕島嶋悼投搭東桃梼棟盗淘湯涛灯燈当痘祷等答筒糖統到董蕩藤討謄豆踏逃透鐙陶頭騰闘働動同堂導憧撞洞瞳童胴萄道銅峠鴇匿得徳涜特督禿篤毒独読栃橡凸突椴届鳶苫寅酉瀞噸屯惇敦沌豚遁頓呑曇鈍奈那内乍凪薙謎灘捺鍋楢馴縄畷南楠軟難汝二尼弐迩匂賑肉虹廿日乳入"],["9440","如尿韮任妊忍認濡禰祢寧葱猫熱年念捻撚燃粘乃廼之埜嚢悩濃納能脳膿農覗蚤巴把播覇杷波派琶破婆罵芭馬俳廃拝排敗杯盃牌背肺輩配倍培媒梅"],["9480","楳煤狽買売賠陪這蝿秤矧萩伯剥博拍柏泊白箔粕舶薄迫曝漠爆縛莫駁麦函箱硲箸肇筈櫨幡肌畑畠八鉢溌発醗髪伐罰抜筏閥鳩噺塙蛤隼伴判半反叛帆搬斑板氾汎版犯班畔繁般藩販範釆煩頒飯挽晩番盤磐蕃蛮匪卑否妃庇彼悲扉批披斐比泌疲皮碑秘緋罷肥被誹費避非飛樋簸備尾微枇毘琵眉美"],["9540","鼻柊稗匹疋髭彦膝菱肘弼必畢筆逼桧姫媛紐百謬俵彪標氷漂瓢票表評豹廟描病秒苗錨鋲蒜蛭鰭品彬斌浜瀕貧賓頻敏瓶不付埠夫婦富冨布府怖扶敷"],["9580","斧普浮父符腐膚芙譜負賦赴阜附侮撫武舞葡蕪部封楓風葺蕗伏副復幅服福腹複覆淵弗払沸仏物鮒分吻噴墳憤扮焚奮粉糞紛雰文聞丙併兵塀幣平弊柄並蔽閉陛米頁僻壁癖碧別瞥蔑箆偏変片篇編辺返遍便勉娩弁鞭保舗鋪圃捕歩甫補輔穂募墓慕戊暮母簿菩倣俸包呆報奉宝峰峯崩庖抱捧放方朋"],["9640","法泡烹砲縫胞芳萌蓬蜂褒訪豊邦鋒飽鳳鵬乏亡傍剖坊妨帽忘忙房暴望某棒冒紡肪膨謀貌貿鉾防吠頬北僕卜墨撲朴牧睦穆釦勃没殆堀幌奔本翻凡盆"],["9680","摩磨魔麻埋妹昧枚毎哩槙幕膜枕鮪柾鱒桝亦俣又抹末沫迄侭繭麿万慢満漫蔓味未魅巳箕岬密蜜湊蓑稔脈妙粍民眠務夢無牟矛霧鵡椋婿娘冥名命明盟迷銘鳴姪牝滅免棉綿緬面麺摸模茂妄孟毛猛盲網耗蒙儲木黙目杢勿餅尤戻籾貰問悶紋門匁也冶夜爺耶野弥矢厄役約薬訳躍靖柳薮鑓愉愈油癒"],["9740","諭輸唯佑優勇友宥幽悠憂揖有柚湧涌猶猷由祐裕誘遊邑郵雄融夕予余与誉輿預傭幼妖容庸揚揺擁曜楊様洋溶熔用窯羊耀葉蓉要謡踊遥陽養慾抑欲"],["9780","沃浴翌翼淀羅螺裸来莱頼雷洛絡落酪乱卵嵐欄濫藍蘭覧利吏履李梨理璃痢裏裡里離陸律率立葎掠略劉流溜琉留硫粒隆竜龍侶慮旅虜了亮僚両凌寮料梁涼猟療瞭稜糧良諒遼量陵領力緑倫厘林淋燐琳臨輪隣鱗麟瑠塁涙累類令伶例冷励嶺怜玲礼苓鈴隷零霊麗齢暦歴列劣烈裂廉恋憐漣煉簾練聯"],["9840","蓮連錬呂魯櫓炉賂路露労婁廊弄朗楼榔浪漏牢狼篭老聾蝋郎六麓禄肋録論倭和話歪賄脇惑枠鷲亙亘鰐詫藁蕨椀湾碗腕"],["989f","弌丐丕个丱丶丼丿乂乖乘亂亅豫亊舒弍于亞亟亠亢亰亳亶从仍仄仆仂仗仞仭仟价伉佚估佛佝佗佇佶侈侏侘佻佩佰侑佯來侖儘俔俟俎俘俛俑俚俐俤俥倚倨倔倪倥倅伜俶倡倩倬俾俯們倆偃假會偕偐偈做偖偬偸傀傚傅傴傲"],["9940","僉僊傳僂僖僞僥僭僣僮價僵儉儁儂儖儕儔儚儡儺儷儼儻儿兀兒兌兔兢竸兩兪兮冀冂囘册冉冏冑冓冕冖冤冦冢冩冪冫决冱冲冰况冽凅凉凛几處凩凭"],["9980","凰凵凾刄刋刔刎刧刪刮刳刹剏剄剋剌剞剔剪剴剩剳剿剽劍劔劒剱劈劑辨辧劬劭劼劵勁勍勗勞勣勦飭勠勳勵勸勹匆匈甸匍匐匏匕匚匣匯匱匳匸區卆卅丗卉卍凖卞卩卮夘卻卷厂厖厠厦厥厮厰厶參簒雙叟曼燮叮叨叭叺吁吽呀听吭吼吮吶吩吝呎咏呵咎呟呱呷呰咒呻咀呶咄咐咆哇咢咸咥咬哄哈咨"],["9a40","咫哂咤咾咼哘哥哦唏唔哽哮哭哺哢唹啀啣啌售啜啅啖啗唸唳啝喙喀咯喊喟啻啾喘喞單啼喃喩喇喨嗚嗅嗟嗄嗜嗤嗔嘔嗷嘖嗾嗽嘛嗹噎噐營嘴嘶嘲嘸"],["9a80","噫噤嘯噬噪嚆嚀嚊嚠嚔嚏嚥嚮嚶嚴囂嚼囁囃囀囈囎囑囓囗囮囹圀囿圄圉圈國圍圓團圖嗇圜圦圷圸坎圻址坏坩埀垈坡坿垉垓垠垳垤垪垰埃埆埔埒埓堊埖埣堋堙堝塲堡塢塋塰毀塒堽塹墅墹墟墫墺壞墻墸墮壅壓壑壗壙壘壥壜壤壟壯壺壹壻壼壽夂夊夐夛梦夥夬夭夲夸夾竒奕奐奎奚奘奢奠奧奬奩"],["9b40","奸妁妝佞侫妣妲姆姨姜妍姙姚娥娟娑娜娉娚婀婬婉娵娶婢婪媚媼媾嫋嫂媽嫣嫗嫦嫩嫖嫺嫻嬌嬋嬖嬲嫐嬪嬶嬾孃孅孀孑孕孚孛孥孩孰孳孵學斈孺宀"],["9b80","它宦宸寃寇寉寔寐寤實寢寞寥寫寰寶寳尅將專對尓尠尢尨尸尹屁屆屎屓屐屏孱屬屮乢屶屹岌岑岔妛岫岻岶岼岷峅岾峇峙峩峽峺峭嶌峪崋崕崗嵜崟崛崑崔崢崚崙崘嵌嵒嵎嵋嵬嵳嵶嶇嶄嶂嶢嶝嶬嶮嶽嶐嶷嶼巉巍巓巒巖巛巫已巵帋帚帙帑帛帶帷幄幃幀幎幗幔幟幢幤幇幵并幺麼广庠廁廂廈廐廏"],["9c40","廖廣廝廚廛廢廡廨廩廬廱廳廰廴廸廾弃弉彝彜弋弑弖弩弭弸彁彈彌彎弯彑彖彗彙彡彭彳彷徃徂彿徊很徑徇從徙徘徠徨徭徼忖忻忤忸忱忝悳忿怡恠"],["9c80","怙怐怩怎怱怛怕怫怦怏怺恚恁恪恷恟恊恆恍恣恃恤恂恬恫恙悁悍惧悃悚悄悛悖悗悒悧悋惡悸惠惓悴忰悽惆悵惘慍愕愆惶惷愀惴惺愃愡惻惱愍愎慇愾愨愧慊愿愼愬愴愽慂慄慳慷慘慙慚慫慴慯慥慱慟慝慓慵憙憖憇憬憔憚憊憑憫憮懌懊應懷懈懃懆憺懋罹懍懦懣懶懺懴懿懽懼懾戀戈戉戍戌戔戛"],["9d40","戞戡截戮戰戲戳扁扎扞扣扛扠扨扼抂抉找抒抓抖拔抃抔拗拑抻拏拿拆擔拈拜拌拊拂拇抛拉挌拮拱挧挂挈拯拵捐挾捍搜捏掖掎掀掫捶掣掏掉掟掵捫"],["9d80","捩掾揩揀揆揣揉插揶揄搖搴搆搓搦搶攝搗搨搏摧摯摶摎攪撕撓撥撩撈撼據擒擅擇撻擘擂擱擧舉擠擡抬擣擯攬擶擴擲擺攀擽攘攜攅攤攣攫攴攵攷收攸畋效敖敕敍敘敞敝敲數斂斃變斛斟斫斷旃旆旁旄旌旒旛旙无旡旱杲昊昃旻杳昵昶昴昜晏晄晉晁晞晝晤晧晨晟晢晰暃暈暎暉暄暘暝曁暹曉暾暼"],["9e40","曄暸曖曚曠昿曦曩曰曵曷朏朖朞朦朧霸朮朿朶杁朸朷杆杞杠杙杣杤枉杰枩杼杪枌枋枦枡枅枷柯枴柬枳柩枸柤柞柝柢柮枹柎柆柧檜栞框栩桀桍栲桎"],["9e80","梳栫桙档桷桿梟梏梭梔條梛梃檮梹桴梵梠梺椏梍桾椁棊椈棘椢椦棡椌棍棔棧棕椶椒椄棗棣椥棹棠棯椨椪椚椣椡棆楹楷楜楸楫楔楾楮椹楴椽楙椰楡楞楝榁楪榲榮槐榿槁槓榾槎寨槊槝榻槃榧樮榑榠榜榕榴槞槨樂樛槿權槹槲槧樅榱樞槭樔槫樊樒櫁樣樓橄樌橲樶橸橇橢橙橦橈樸樢檐檍檠檄檢檣"],["9f40","檗蘗檻櫃櫂檸檳檬櫞櫑櫟檪櫚櫪櫻欅蘖櫺欒欖鬱欟欸欷盜欹飮歇歃歉歐歙歔歛歟歡歸歹歿殀殄殃殍殘殕殞殤殪殫殯殲殱殳殷殼毆毋毓毟毬毫毳毯"],["9f80","麾氈氓气氛氤氣汞汕汢汪沂沍沚沁沛汾汨汳沒沐泄泱泓沽泗泅泝沮沱沾沺泛泯泙泪洟衍洶洫洽洸洙洵洳洒洌浣涓浤浚浹浙涎涕濤涅淹渕渊涵淇淦涸淆淬淞淌淨淒淅淺淙淤淕淪淮渭湮渮渙湲湟渾渣湫渫湶湍渟湃渺湎渤滿渝游溂溪溘滉溷滓溽溯滄溲滔滕溏溥滂溟潁漑灌滬滸滾漿滲漱滯漲滌"],["e040","漾漓滷澆潺潸澁澀潯潛濳潭澂潼潘澎澑濂潦澳澣澡澤澹濆澪濟濕濬濔濘濱濮濛瀉瀋濺瀑瀁瀏濾瀛瀚潴瀝瀘瀟瀰瀾瀲灑灣炙炒炯烱炬炸炳炮烟烋烝"],["e080","烙焉烽焜焙煥煕熈煦煢煌煖煬熏燻熄熕熨熬燗熹熾燒燉燔燎燠燬燧燵燼燹燿爍爐爛爨爭爬爰爲爻爼爿牀牆牋牘牴牾犂犁犇犒犖犢犧犹犲狃狆狄狎狒狢狠狡狹狷倏猗猊猜猖猝猴猯猩猥猾獎獏默獗獪獨獰獸獵獻獺珈玳珎玻珀珥珮珞璢琅瑯琥珸琲琺瑕琿瑟瑙瑁瑜瑩瑰瑣瑪瑶瑾璋璞璧瓊瓏瓔珱"],["e140","瓠瓣瓧瓩瓮瓲瓰瓱瓸瓷甄甃甅甌甎甍甕甓甞甦甬甼畄畍畊畉畛畆畚畩畤畧畫畭畸當疆疇畴疊疉疂疔疚疝疥疣痂疳痃疵疽疸疼疱痍痊痒痙痣痞痾痿"],["e180","痼瘁痰痺痲痳瘋瘍瘉瘟瘧瘠瘡瘢瘤瘴瘰瘻癇癈癆癜癘癡癢癨癩癪癧癬癰癲癶癸發皀皃皈皋皎皖皓皙皚皰皴皸皹皺盂盍盖盒盞盡盥盧盪蘯盻眈眇眄眩眤眞眥眦眛眷眸睇睚睨睫睛睥睿睾睹瞎瞋瞑瞠瞞瞰瞶瞹瞿瞼瞽瞻矇矍矗矚矜矣矮矼砌砒礦砠礪硅碎硴碆硼碚碌碣碵碪碯磑磆磋磔碾碼磅磊磬"],["e240","磧磚磽磴礇礒礑礙礬礫祀祠祗祟祚祕祓祺祿禊禝禧齋禪禮禳禹禺秉秕秧秬秡秣稈稍稘稙稠稟禀稱稻稾稷穃穗穉穡穢穩龝穰穹穽窈窗窕窘窖窩竈窰"],["e280","窶竅竄窿邃竇竊竍竏竕竓站竚竝竡竢竦竭竰笂笏笊笆笳笘笙笞笵笨笶筐筺笄筍笋筌筅筵筥筴筧筰筱筬筮箝箘箟箍箜箚箋箒箏筝箙篋篁篌篏箴篆篝篩簑簔篦篥籠簀簇簓篳篷簗簍篶簣簧簪簟簷簫簽籌籃籔籏籀籐籘籟籤籖籥籬籵粃粐粤粭粢粫粡粨粳粲粱粮粹粽糀糅糂糘糒糜糢鬻糯糲糴糶糺紆"],["e340","紂紜紕紊絅絋紮紲紿紵絆絳絖絎絲絨絮絏絣經綉絛綏絽綛綺綮綣綵緇綽綫總綢綯緜綸綟綰緘緝緤緞緻緲緡縅縊縣縡縒縱縟縉縋縢繆繦縻縵縹繃縷"],["e380","縲縺繧繝繖繞繙繚繹繪繩繼繻纃緕繽辮繿纈纉續纒纐纓纔纖纎纛纜缸缺罅罌罍罎罐网罕罔罘罟罠罨罩罧罸羂羆羃羈羇羌羔羞羝羚羣羯羲羹羮羶羸譱翅翆翊翕翔翡翦翩翳翹飜耆耄耋耒耘耙耜耡耨耿耻聊聆聒聘聚聟聢聨聳聲聰聶聹聽聿肄肆肅肛肓肚肭冐肬胛胥胙胝胄胚胖脉胯胱脛脩脣脯腋"],["e440","隋腆脾腓腑胼腱腮腥腦腴膃膈膊膀膂膠膕膤膣腟膓膩膰膵膾膸膽臀臂膺臉臍臑臙臘臈臚臟臠臧臺臻臾舁舂舅與舊舍舐舖舩舫舸舳艀艙艘艝艚艟艤"],["e480","艢艨艪艫舮艱艷艸艾芍芒芫芟芻芬苡苣苟苒苴苳苺莓范苻苹苞茆苜茉苙茵茴茖茲茱荀茹荐荅茯茫茗茘莅莚莪莟莢莖茣莎莇莊荼莵荳荵莠莉莨菴萓菫菎菽萃菘萋菁菷萇菠菲萍萢萠莽萸蔆菻葭萪萼蕚蒄葷葫蒭葮蒂葩葆萬葯葹萵蓊葢蒹蒿蒟蓙蓍蒻蓚蓐蓁蓆蓖蒡蔡蓿蓴蔗蔘蔬蔟蔕蔔蓼蕀蕣蕘蕈"],["e540","蕁蘂蕋蕕薀薤薈薑薊薨蕭薔薛藪薇薜蕷蕾薐藉薺藏薹藐藕藝藥藜藹蘊蘓蘋藾藺蘆蘢蘚蘰蘿虍乕虔號虧虱蚓蚣蚩蚪蚋蚌蚶蚯蛄蛆蚰蛉蠣蚫蛔蛞蛩蛬"],["e580","蛟蛛蛯蜒蜆蜈蜀蜃蛻蜑蜉蜍蛹蜊蜴蜿蜷蜻蜥蜩蜚蝠蝟蝸蝌蝎蝴蝗蝨蝮蝙蝓蝣蝪蠅螢螟螂螯蟋螽蟀蟐雖螫蟄螳蟇蟆螻蟯蟲蟠蠏蠍蟾蟶蟷蠎蟒蠑蠖蠕蠢蠡蠱蠶蠹蠧蠻衄衂衒衙衞衢衫袁衾袞衵衽袵衲袂袗袒袮袙袢袍袤袰袿袱裃裄裔裘裙裝裹褂裼裴裨裲褄褌褊褓襃褞褥褪褫襁襄褻褶褸襌褝襠襞"],["e640","襦襤襭襪襯襴襷襾覃覈覊覓覘覡覩覦覬覯覲覺覽覿觀觚觜觝觧觴觸訃訖訐訌訛訝訥訶詁詛詒詆詈詼詭詬詢誅誂誄誨誡誑誥誦誚誣諄諍諂諚諫諳諧"],["e680","諤諱謔諠諢諷諞諛謌謇謚諡謖謐謗謠謳鞫謦謫謾謨譁譌譏譎證譖譛譚譫譟譬譯譴譽讀讌讎讒讓讖讙讚谺豁谿豈豌豎豐豕豢豬豸豺貂貉貅貊貍貎貔豼貘戝貭貪貽貲貳貮貶賈賁賤賣賚賽賺賻贄贅贊贇贏贍贐齎贓賍贔贖赧赭赱赳趁趙跂趾趺跏跚跖跌跛跋跪跫跟跣跼踈踉跿踝踞踐踟蹂踵踰踴蹊"],["e740","蹇蹉蹌蹐蹈蹙蹤蹠踪蹣蹕蹶蹲蹼躁躇躅躄躋躊躓躑躔躙躪躡躬躰軆躱躾軅軈軋軛軣軼軻軫軾輊輅輕輒輙輓輜輟輛輌輦輳輻輹轅轂輾轌轉轆轎轗轜"],["e780","轢轣轤辜辟辣辭辯辷迚迥迢迪迯邇迴逅迹迺逑逕逡逍逞逖逋逧逶逵逹迸遏遐遑遒逎遉逾遖遘遞遨遯遶隨遲邂遽邁邀邊邉邏邨邯邱邵郢郤扈郛鄂鄒鄙鄲鄰酊酖酘酣酥酩酳酲醋醉醂醢醫醯醪醵醴醺釀釁釉釋釐釖釟釡釛釼釵釶鈞釿鈔鈬鈕鈑鉞鉗鉅鉉鉤鉈銕鈿鉋鉐銜銖銓銛鉚鋏銹銷鋩錏鋺鍄錮"],["e840","錙錢錚錣錺錵錻鍜鍠鍼鍮鍖鎰鎬鎭鎔鎹鏖鏗鏨鏥鏘鏃鏝鏐鏈鏤鐚鐔鐓鐃鐇鐐鐶鐫鐵鐡鐺鑁鑒鑄鑛鑠鑢鑞鑪鈩鑰鑵鑷鑽鑚鑼鑾钁鑿閂閇閊閔閖閘閙"],["e880","閠閨閧閭閼閻閹閾闊濶闃闍闌闕闔闖關闡闥闢阡阨阮阯陂陌陏陋陷陜陞陝陟陦陲陬隍隘隕隗險隧隱隲隰隴隶隸隹雎雋雉雍襍雜霍雕雹霄霆霈霓霎霑霏霖霙霤霪霰霹霽霾靄靆靈靂靉靜靠靤靦靨勒靫靱靹鞅靼鞁靺鞆鞋鞏鞐鞜鞨鞦鞣鞳鞴韃韆韈韋韜韭齏韲竟韶韵頏頌頸頤頡頷頽顆顏顋顫顯顰"],["e940","顱顴顳颪颯颱颶飄飃飆飩飫餃餉餒餔餘餡餝餞餤餠餬餮餽餾饂饉饅饐饋饑饒饌饕馗馘馥馭馮馼駟駛駝駘駑駭駮駱駲駻駸騁騏騅駢騙騫騷驅驂驀驃"],["e980","騾驕驍驛驗驟驢驥驤驩驫驪骭骰骼髀髏髑髓體髞髟髢髣髦髯髫髮髴髱髷髻鬆鬘鬚鬟鬢鬣鬥鬧鬨鬩鬪鬮鬯鬲魄魃魏魍魎魑魘魴鮓鮃鮑鮖鮗鮟鮠鮨鮴鯀鯊鮹鯆鯏鯑鯒鯣鯢鯤鯔鯡鰺鯲鯱鯰鰕鰔鰉鰓鰌鰆鰈鰒鰊鰄鰮鰛鰥鰤鰡鰰鱇鰲鱆鰾鱚鱠鱧鱶鱸鳧鳬鳰鴉鴈鳫鴃鴆鴪鴦鶯鴣鴟鵄鴕鴒鵁鴿鴾鵆鵈"],["ea40","鵝鵞鵤鵑鵐鵙鵲鶉鶇鶫鵯鵺鶚鶤鶩鶲鷄鷁鶻鶸鶺鷆鷏鷂鷙鷓鷸鷦鷭鷯鷽鸚鸛鸞鹵鹹鹽麁麈麋麌麒麕麑麝麥麩麸麪麭靡黌黎黏黐黔黜點黝黠黥黨黯"],["ea80","黴黶黷黹黻黼黽鼇鼈皷鼕鼡鼬鼾齊齒齔齣齟齠齡齦齧齬齪齷齲齶龕龜龠堯槇遙瑤凜熙"],["ed40","纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏"],["ed80","塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱"],["ee40","犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙"],["ee80","蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"],["eeef","ⅰ",9,"￢￤＇＂"],["f040","",62],["f080","",124],["f140","",62],["f180","",124],["f240","",62],["f280","",124],["f340","",62],["f380","",124],["f440","",62],["f480","",124],["f540","",62],["f580","",124],["f640","",62],["f680","",124],["f740","",62],["f780","",124],["f840","",62],["f880","",124],["f940",""],["fa40","ⅰ",9,"Ⅰ",9,"￢￤＇＂㈱№℡∵纊褜鍈銈蓜俉炻昱棈鋹曻彅丨仡仼伀伃伹佖侒侊侚侔俍偀倢俿倞偆偰偂傔僴僘兊"],["fa80","兤冝冾凬刕劜劦勀勛匀匇匤卲厓厲叝﨎咜咊咩哿喆坙坥垬埈埇﨏塚增墲夋奓奛奝奣妤妺孖寀甯寘寬尞岦岺峵崧嵓﨑嵂嵭嶸嶹巐弡弴彧德忞恝悅悊惞惕愠惲愑愷愰憘戓抦揵摠撝擎敎昀昕昻昉昮昞昤晥晗晙晴晳暙暠暲暿曺朎朗杦枻桒柀栁桄棏﨓楨﨔榘槢樰橫橆橳橾櫢櫤毖氿汜沆汯泚洄涇浯"],["fb40","涖涬淏淸淲淼渹湜渧渼溿澈澵濵瀅瀇瀨炅炫焏焄煜煆煇凞燁燾犱犾猤猪獷玽珉珖珣珒琇珵琦琪琩琮瑢璉璟甁畯皂皜皞皛皦益睆劯砡硎硤硺礰礼神"],["fb80","祥禔福禛竑竧靖竫箞精絈絜綷綠緖繒罇羡羽茁荢荿菇菶葈蒴蕓蕙蕫﨟薰蘒﨡蠇裵訒訷詹誧誾諟諸諶譓譿賰賴贒赶﨣軏﨤逸遧郞都鄕鄧釚釗釞釭釮釤釥鈆鈐鈊鈺鉀鈼鉎鉙鉑鈹鉧銧鉷鉸鋧鋗鋙鋐﨧鋕鋠鋓錥錡鋻﨨錞鋿錝錂鍰鍗鎤鏆鏞鏸鐱鑅鑈閒隆﨩隝隯霳霻靃靍靏靑靕顗顥飯飼餧館馞驎髙"],["fc40","髜魵魲鮏鮱鮻鰀鵰鵫鶴鸙黑"]]',
      );
    },
    1947: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"topLevel":{"dependancies":"dependencies","dependecies":"dependencies","depdenencies":"dependencies","devEependencies":"devDependencies","depends":"dependencies","dev-dependencies":"devDependencies","devDependences":"devDependencies","devDepenencies":"devDependencies","devdependencies":"devDependencies","repostitory":"repository","repo":"repository","prefereGlobal":"preferGlobal","hompage":"homepage","hampage":"homepage","autohr":"author","autor":"author","contributers":"contributors","publicationConfig":"publishConfig","script":"scripts"},"bugs":{"web":"url","name":"url"},"script":{"server":"start","tests":"test"}}',
      );
    },
    6271: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '{"repositories":"\'repositories\' (plural) Not supported. Please pick one as the \'repository\' field","missingRepository":"No repository field.","brokenGitUrl":"Probably broken git url: %s","nonObjectScripts":"scripts must be an object","nonStringScript":"script values must be string commands","nonArrayFiles":"Invalid \'files\' member","invalidFilename":"Invalid filename in \'files\' list: %s","nonArrayBundleDependencies":"Invalid \'bundleDependencies\' list. Must be array of package names","nonStringBundleDependency":"Invalid bundleDependencies member: %s","nonDependencyBundleDependency":"Non-dependency in bundleDependencies: %s","nonObjectDependencies":"%s field must be an object","nonStringDependency":"Invalid dependency: %s %s","deprecatedArrayDependencies":"specifying %s as array is deprecated","deprecatedModules":"modules field is deprecated","nonArrayKeywords":"keywords should be an array of strings","nonStringKeyword":"keywords should be an array of strings","conflictingName":"%s is also the name of a node core module.","nonStringDescription":"\'description\' field should be a string","missingDescription":"No description","missingReadme":"No README data","missingLicense":"No license field.","nonEmailUrlBugsString":"Bug string field must be url, email, or {email,url}","nonUrlBugsUrlField":"bugs.url field must be a string url. Deleted.","nonEmailBugsEmailField":"bugs.email field must be a string email. Deleted.","emptyNormalizedBugs":"Normalized value of bugs field is an empty object. Deleted.","nonUrlHomepage":"homepage field must be a string url. Deleted.","invalidLicense":"license should be a valid SPDX license expression","typo":"%s should probably be %s."}',
      );
    },
    238: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '["389-exception","Asterisk-exception","Autoconf-exception-2.0","Autoconf-exception-3.0","Autoconf-exception-generic","Autoconf-exception-generic-3.0","Autoconf-exception-macro","Bison-exception-1.24","Bison-exception-2.2","Bootloader-exception","Classpath-exception-2.0","CLISP-exception-2.0","cryptsetup-OpenSSL-exception","DigiRule-FOSS-exception","eCos-exception-2.0","Fawkes-Runtime-exception","FLTK-exception","fmt-exception","Font-exception-2.0","freertos-exception-2.0","GCC-exception-2.0","GCC-exception-2.0-note","GCC-exception-3.1","Gmsh-exception","GNAT-exception","GNOME-examples-exception","GNU-compiler-exception","gnu-javamail-exception","GPL-3.0-interface-exception","GPL-3.0-linking-exception","GPL-3.0-linking-source-exception","GPL-CC-1.0","GStreamer-exception-2005","GStreamer-exception-2008","i2p-gpl-java-exception","KiCad-libraries-exception","LGPL-3.0-linking-exception","libpri-OpenH323-exception","Libtool-exception","Linux-syscall-note","LLGPL","LLVM-exception","LZMA-exception","mif-exception","OCaml-LGPL-linking-exception","OCCT-exception-1.0","OpenJDK-assembly-exception-1.0","openvpn-openssl-exception","PS-or-PDF-font-exception-20170817","QPL-1.0-INRIA-2004-exception","Qt-GPL-exception-1.0","Qt-LGPL-exception-1.1","Qwt-exception-1.0","SANE-exception","SHL-2.0","SHL-2.1","stunnel-exception","SWI-exception","Swift-exception","Texinfo-exception","u-boot-exception-2.0","UBDL-exception","Universal-FOSS-exception-1.0","vsftpd-openssl-exception","WxWindows-exception-3.1","x11vnc-openssl-exception"]',
      );
    },
    6765: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '["AGPL-1.0","AGPL-3.0","BSD-2-Clause-FreeBSD","BSD-2-Clause-NetBSD","GFDL-1.1","GFDL-1.2","GFDL-1.3","GPL-1.0","GPL-2.0","GPL-2.0-with-GCC-exception","GPL-2.0-with-autoconf-exception","GPL-2.0-with-bison-exception","GPL-2.0-with-classpath-exception","GPL-2.0-with-font-exception","GPL-3.0","GPL-3.0-with-GCC-exception","GPL-3.0-with-autoconf-exception","LGPL-2.0","LGPL-2.1","LGPL-3.0","Net-SNMP","Nunit","StandardML-NJ","bzip2-1.0.5","eCos-2.0","wxWindows"]',
      );
    },
    6033: (module) => {
      "use strict";
      module.exports = JSON.parse(
        '["0BSD","3D-Slicer-1.0","AAL","ADSL","AFL-1.1","AFL-1.2","AFL-2.0","AFL-2.1","AFL-3.0","AGPL-1.0-only","AGPL-1.0-or-later","AGPL-3.0-only","AGPL-3.0-or-later","AMD-newlib","AMDPLPA","AML","AML-glslang","AMPAS","ANTLR-PD","ANTLR-PD-fallback","APAFML","APL-1.0","APSL-1.0","APSL-1.1","APSL-1.2","APSL-2.0","ASWF-Digital-Assets-1.0","ASWF-Digital-Assets-1.1","Abstyles","AdaCore-doc","Adobe-2006","Adobe-Display-PostScript","Adobe-Glyph","Adobe-Utopia","Afmparse","Aladdin","Apache-1.0","Apache-1.1","Apache-2.0","App-s2p","Arphic-1999","Artistic-1.0","Artistic-1.0-Perl","Artistic-1.0-cl8","Artistic-2.0","BSD-1-Clause","BSD-2-Clause","BSD-2-Clause-Darwin","BSD-2-Clause-Patent","BSD-2-Clause-Views","BSD-2-Clause-first-lines","BSD-3-Clause","BSD-3-Clause-Attribution","BSD-3-Clause-Clear","BSD-3-Clause-HP","BSD-3-Clause-LBNL","BSD-3-Clause-Modification","BSD-3-Clause-No-Military-License","BSD-3-Clause-No-Nuclear-License","BSD-3-Clause-No-Nuclear-License-2014","BSD-3-Clause-No-Nuclear-Warranty","BSD-3-Clause-Open-MPI","BSD-3-Clause-Sun","BSD-3-Clause-acpica","BSD-3-Clause-flex","BSD-4-Clause","BSD-4-Clause-Shortened","BSD-4-Clause-UC","BSD-4.3RENO","BSD-4.3TAHOE","BSD-Advertising-Acknowledgement","BSD-Attribution-HPND-disclaimer","BSD-Inferno-Nettverk","BSD-Protection","BSD-Source-Code","BSD-Source-beginning-file","BSD-Systemics","BSD-Systemics-W3Works","BSL-1.0","BUSL-1.1","Baekmuk","Bahyph","Barr","Beerware","BitTorrent-1.0","BitTorrent-1.1","Bitstream-Charter","Bitstream-Vera","BlueOak-1.0.0","Boehm-GC","Borceux","Brian-Gladman-2-Clause","Brian-Gladman-3-Clause","C-UDA-1.0","CAL-1.0","CAL-1.0-Combined-Work-Exception","CATOSL-1.1","CC-BY-1.0","CC-BY-2.0","CC-BY-2.5","CC-BY-2.5-AU","CC-BY-3.0","CC-BY-3.0-AT","CC-BY-3.0-AU","CC-BY-3.0-DE","CC-BY-3.0-IGO","CC-BY-3.0-NL","CC-BY-3.0-US","CC-BY-4.0","CC-BY-NC-1.0","CC-BY-NC-2.0","CC-BY-NC-2.5","CC-BY-NC-3.0","CC-BY-NC-3.0-DE","CC-BY-NC-4.0","CC-BY-NC-ND-1.0","CC-BY-NC-ND-2.0","CC-BY-NC-ND-2.5","CC-BY-NC-ND-3.0","CC-BY-NC-ND-3.0-DE","CC-BY-NC-ND-3.0-IGO","CC-BY-NC-ND-4.0","CC-BY-NC-SA-1.0","CC-BY-NC-SA-2.0","CC-BY-NC-SA-2.0-DE","CC-BY-NC-SA-2.0-FR","CC-BY-NC-SA-2.0-UK","CC-BY-NC-SA-2.5","CC-BY-NC-SA-3.0","CC-BY-NC-SA-3.0-DE","CC-BY-NC-SA-3.0-IGO","CC-BY-NC-SA-4.0","CC-BY-ND-1.0","CC-BY-ND-2.0","CC-BY-ND-2.5","CC-BY-ND-3.0","CC-BY-ND-3.0-DE","CC-BY-ND-4.0","CC-BY-SA-1.0","CC-BY-SA-2.0","CC-BY-SA-2.0-UK","CC-BY-SA-2.1-JP","CC-BY-SA-2.5","CC-BY-SA-3.0","CC-BY-SA-3.0-AT","CC-BY-SA-3.0-DE","CC-BY-SA-3.0-IGO","CC-BY-SA-4.0","CC-PDDC","CC0-1.0","CDDL-1.0","CDDL-1.1","CDL-1.0","CDLA-Permissive-1.0","CDLA-Permissive-2.0","CDLA-Sharing-1.0","CECILL-1.0","CECILL-1.1","CECILL-2.0","CECILL-2.1","CECILL-B","CECILL-C","CERN-OHL-1.1","CERN-OHL-1.2","CERN-OHL-P-2.0","CERN-OHL-S-2.0","CERN-OHL-W-2.0","CFITSIO","CMU-Mach","CMU-Mach-nodoc","CNRI-Jython","CNRI-Python","CNRI-Python-GPL-Compatible","COIL-1.0","CPAL-1.0","CPL-1.0","CPOL-1.02","CUA-OPL-1.0","Caldera","Caldera-no-preamble","Catharon","ClArtistic","Clips","Community-Spec-1.0","Condor-1.1","Cornell-Lossless-JPEG","Cronyx","Crossword","CrystalStacker","Cube","D-FSL-1.0","DEC-3-Clause","DL-DE-BY-2.0","DL-DE-ZERO-2.0","DOC","DRL-1.0","DRL-1.1","DSDP","DocBook-Schema","DocBook-XML","Dotseqn","ECL-1.0","ECL-2.0","EFL-1.0","EFL-2.0","EPICS","EPL-1.0","EPL-2.0","EUDatagrid","EUPL-1.0","EUPL-1.1","EUPL-1.2","Elastic-2.0","Entessa","ErlPL-1.1","Eurosym","FBM","FDK-AAC","FSFAP","FSFAP-no-warranty-disclaimer","FSFUL","FSFULLR","FSFULLRWD","FTL","Fair","Ferguson-Twofish","Frameworx-1.0","FreeBSD-DOC","FreeImage","Furuseth","GCR-docs","GD","GFDL-1.1-invariants-only","GFDL-1.1-invariants-or-later","GFDL-1.1-no-invariants-only","GFDL-1.1-no-invariants-or-later","GFDL-1.1-only","GFDL-1.1-or-later","GFDL-1.2-invariants-only","GFDL-1.2-invariants-or-later","GFDL-1.2-no-invariants-only","GFDL-1.2-no-invariants-or-later","GFDL-1.2-only","GFDL-1.2-or-later","GFDL-1.3-invariants-only","GFDL-1.3-invariants-or-later","GFDL-1.3-no-invariants-only","GFDL-1.3-no-invariants-or-later","GFDL-1.3-only","GFDL-1.3-or-later","GL2PS","GLWTPL","GPL-1.0-only","GPL-1.0-or-later","GPL-2.0-only","GPL-2.0-or-later","GPL-3.0-only","GPL-3.0-or-later","Giftware","Glide","Glulxe","Graphics-Gems","Gutmann","HIDAPI","HP-1986","HP-1989","HPND","HPND-DEC","HPND-Fenneberg-Livingston","HPND-INRIA-IMAG","HPND-Intel","HPND-Kevlin-Henney","HPND-MIT-disclaimer","HPND-Markus-Kuhn","HPND-Netrek","HPND-Pbmplus","HPND-UC","HPND-UC-export-US","HPND-doc","HPND-doc-sell","HPND-export-US","HPND-export-US-acknowledgement","HPND-export-US-modify","HPND-export2-US","HPND-merchantability-variant","HPND-sell-MIT-disclaimer-xserver","HPND-sell-regexpr","HPND-sell-variant","HPND-sell-variant-MIT-disclaimer","HPND-sell-variant-MIT-disclaimer-rev","HTMLTIDY","HaskellReport","Hippocratic-2.1","IBM-pibs","ICU","IEC-Code-Components-EULA","IJG","IJG-short","IPA","IPL-1.0","ISC","ISC-Veillard","ImageMagick","Imlib2","Info-ZIP","Inner-Net-2.0","Intel","Intel-ACPI","Interbase-1.0","JPL-image","JPNIC","JSON","Jam","JasPer-2.0","Kastrup","Kazlib","Knuth-CTAN","LAL-1.2","LAL-1.3","LGPL-2.0-only","LGPL-2.0-or-later","LGPL-2.1-only","LGPL-2.1-or-later","LGPL-3.0-only","LGPL-3.0-or-later","LGPLLR","LOOP","LPD-document","LPL-1.0","LPL-1.02","LPPL-1.0","LPPL-1.1","LPPL-1.2","LPPL-1.3a","LPPL-1.3c","LZMA-SDK-9.11-to-9.20","LZMA-SDK-9.22","Latex2e","Latex2e-translated-notice","Leptonica","LiLiQ-P-1.1","LiLiQ-R-1.1","LiLiQ-Rplus-1.1","Libpng","Linux-OpenIB","Linux-man-pages-1-para","Linux-man-pages-copyleft","Linux-man-pages-copyleft-2-para","Linux-man-pages-copyleft-var","Lucida-Bitmap-Fonts","MIT","MIT-0","MIT-CMU","MIT-Festival","MIT-Khronos-old","MIT-Modern-Variant","MIT-Wu","MIT-advertising","MIT-enna","MIT-feh","MIT-open-group","MIT-testregex","MITNFA","MMIXware","MPEG-SSG","MPL-1.0","MPL-1.1","MPL-2.0","MPL-2.0-no-copyleft-exception","MS-LPL","MS-PL","MS-RL","MTLL","Mackerras-3-Clause","Mackerras-3-Clause-acknowledgment","MakeIndex","Martin-Birgmeier","McPhee-slideshow","Minpack","MirOS","Motosoto","MulanPSL-1.0","MulanPSL-2.0","Multics","Mup","NAIST-2003","NASA-1.3","NBPL-1.0","NCBI-PD","NCGL-UK-2.0","NCL","NCSA","NGPL","NICTA-1.0","NIST-PD","NIST-PD-fallback","NIST-Software","NLOD-1.0","NLOD-2.0","NLPL","NOSL","NPL-1.0","NPL-1.1","NPOSL-3.0","NRL","NTP","NTP-0","Naumen","NetCDF","Newsletr","Nokia","Noweb","O-UDA-1.0","OAR","OCCT-PL","OCLC-2.0","ODC-By-1.0","ODbL-1.0","OFFIS","OFL-1.0","OFL-1.0-RFN","OFL-1.0-no-RFN","OFL-1.1","OFL-1.1-RFN","OFL-1.1-no-RFN","OGC-1.0","OGDL-Taiwan-1.0","OGL-Canada-2.0","OGL-UK-1.0","OGL-UK-2.0","OGL-UK-3.0","OGTSL","OLDAP-1.1","OLDAP-1.2","OLDAP-1.3","OLDAP-1.4","OLDAP-2.0","OLDAP-2.0.1","OLDAP-2.1","OLDAP-2.2","OLDAP-2.2.1","OLDAP-2.2.2","OLDAP-2.3","OLDAP-2.4","OLDAP-2.5","OLDAP-2.6","OLDAP-2.7","OLDAP-2.8","OLFL-1.3","OML","OPL-1.0","OPL-UK-3.0","OPUBL-1.0","OSET-PL-2.1","OSL-1.0","OSL-1.1","OSL-2.0","OSL-2.1","OSL-3.0","OpenPBS-2.3","OpenSSL","OpenSSL-standalone","OpenVision","PADL","PDDL-1.0","PHP-3.0","PHP-3.01","PPL","PSF-2.0","Parity-6.0.0","Parity-7.0.0","Pixar","Plexus","PolyForm-Noncommercial-1.0.0","PolyForm-Small-Business-1.0.0","PostgreSQL","Python-2.0","Python-2.0.1","QPL-1.0","QPL-1.0-INRIA-2004","Qhull","RHeCos-1.1","RPL-1.1","RPL-1.5","RPSL-1.0","RSA-MD","RSCPL","Rdisc","Ruby","Ruby-pty","SAX-PD","SAX-PD-2.0","SCEA","SGI-B-1.0","SGI-B-1.1","SGI-B-2.0","SGI-OpenGL","SGP4","SHL-0.5","SHL-0.51","SISSL","SISSL-1.2","SL","SMLNJ","SMPPL","SNIA","SPL-1.0","SSH-OpenSSH","SSH-short","SSLeay-standalone","SSPL-1.0","SWL","Saxpath","SchemeReport","Sendmail","Sendmail-8.23","SimPL-2.0","Sleepycat","Soundex","Spencer-86","Spencer-94","Spencer-99","SugarCRM-1.1.3","Sun-PPP","Sun-PPP-2000","SunPro","Symlinks","TAPR-OHL-1.0","TCL","TCP-wrappers","TGPPL-1.0","TMate","TORQUE-1.1","TOSL","TPDL","TPL-1.0","TTWL","TTYP0","TU-Berlin-1.0","TU-Berlin-2.0","TermReadKey","UCAR","UCL-1.0","UMich-Merit","UPL-1.0","URT-RLE","Ubuntu-font-1.0","Unicode-3.0","Unicode-DFS-2015","Unicode-DFS-2016","Unicode-TOU","UnixCrypt","Unlicense","VOSTROM","VSL-1.0","Vim","W3C","W3C-19980720","W3C-20150513","WTFPL","Watcom-1.0","Widget-Workshop","Wsuipa","X11","X11-distribute-modifications-variant","X11-swapped","XFree86-1.1","XSkat","Xdebug-1.03","Xerox","Xfig","Xnet","YPL-1.0","YPL-1.1","ZPL-1.1","ZPL-2.0","ZPL-2.1","Zed","Zeeff","Zend-2.0","Zimbra-1.3","Zimbra-1.4","Zlib","any-OSI","bcrypt-Solar-Designer","blessing","bzip2-1.0.6","check-cvs","checkmk","copyleft-next-0.3.0","copyleft-next-0.3.1","curl","cve-tou","diffmark","dtoa","dvipdfm","eGenix","etalab-2.0","fwlw","gSOAP-1.3b","gnuplot","gtkbook","hdparm","iMatix","libpng-2.0","libselinux-1.0","libtiff","libutil-David-Nugent","lsof","magaz","mailprio","metamail","mpi-permissive","mpich2","mplus","pkgconf","pnmstitch","psfrag","psutils","python-ldap","radvd","snprintf","softSurfer","ssh-keyscan","swrule","threeparttable","ulem","w3m","xinetd","xkeyboard-config-Zinoviev","xlock","xpp","xzoom","zlib-acknowledgement"]',
      );
    },
  };
  var __webpack_module_cache__ = {};
  function __nccwpck_require__(moduleId) {
    var cachedModule = __webpack_module_cache__[moduleId];
    if (cachedModule !== undefined) {
      return cachedModule.exports;
    }
    var module = (__webpack_module_cache__[moduleId] = { exports: {} });
    var threw = true;
    try {
      __webpack_modules__[moduleId].call(
        module.exports,
        module,
        module.exports,
        __nccwpck_require__,
      );
      threw = false;
    } finally {
      if (threw) delete __webpack_module_cache__[moduleId];
    }
    return module.exports;
  }
  if (typeof __nccwpck_require__ !== "undefined")
    __nccwpck_require__.ab = __dirname + "/";
  var __webpack_exports__ = __nccwpck_require__(6763);
  module.exports = __webpack_exports__;
})();
